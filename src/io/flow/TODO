general stuff:
--------------------------

- get Walt to implement another request processing function (or another
  mode of the current function) that discards segments and lets me seek
  ahead in the stream as far as I want (maintaining state, unlike the
  CKSIZE function).  When implemented, use it in place of
  process_request_discard_regions().

- make an optional flow descriptor checker function that makes sure the
  flow descriptor fields are set to sane initial values - only use it
  during development

- make sure that reuse of flow descriptors works, or at least document
  if they don't

- probably should get rid of alloca calls, not sure if portable
  (would be faster to keep static buffers for some of that anyway if
  possible)

- contrive some test cases that would force the use of the CKSIZE
  mode of PINT_Process_request().  This would mainly require a
  data layout that causes the number of segments per flow cycle to
  exceed the maximum that I am willing to handle.

- figure out points at which zero byte messages should be sent to try
  to abort flow
  - in particular, make sure that we can handle receiving a zero
	 byte message in bmi to mem case.

- implement unpost()

- why do we need flowproto_check() or flowproto_checksome()? the top
  level flow code is not calling them.

- look into idea of hash table in place of completion queue (see
  bmi_tcp implementation in BMI)

- NOTE: we can assume that every flow will be preceded by an ack from
  the server.  This means that we already know how much can be
  transfered, and that we don't have to do any special handling of
  short cases (they are assumed to be an I/O error).  Ack will also tell
  client what current size of datafile is.

- think about how flow timeouts should be handled.  For example,
  suppose the sender experiences a BMI error and aborts.  The
  receiver may sit there indefinitely waiting for the next message
  if no one makes it time out.

flowproto bmi_trove stuff:
--------------------------

- use trove testsome() once it is implemented

- think about queue/array layout for op id's a little more.
  Is there any reason why we can't maintain an array the whole time
  rather than converting between list and array?

- NOTE: it is ok to post lots of list trove messages at once; this is a
  handy feature (on server write operation case) when there is a
  large buffer with too many discontig regions to do in one list
  from request processor

- on client read operation case, if we run into a limit on the max
  number of discontig segments, we should just do a big contiguous
  receive and memcpy out to regions.  This keeps us from having to
  handle arbitrarily large lists on bmi recv, and also may even be
  faster in cases of extremely discontiguous regions.

- signal I/O error by sending 0 byte message.  This means receiver
  should shut down because no other data is coming.

