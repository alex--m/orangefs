#!/usr/bin/perl
#
#  (C) 2001 Clemson University and The University of Chicago
#
#  See COPYING in top-level directory.
#
# generate a global pvfs2 configuration file based on user input
#
use Term::ReadLine;

sub get_user_input
{
    my($term,$OUT,$prompt,$res);

    $term = new Term::ReadLine 'pvfs2-genconfig';
    $OUT = $term->OUT || STDOUT;
    print "\n";
    $prompt = "* $_[0]";

    $_ = $term->readline($prompt);
    print "\n";
    return $_;
}

sub valid_number
{
    my($num, $len, $i, $digit);

    $num = $_[0];
    $len = length($num);

    for($i = 0; $i < $len; $i++)
    {
        $digit = substr($num,$i,1);
        if (($digit < 0) || ($digit > 9))
        {
            return 0;
        }
    }
    return (($len > 0) ? 1 : 0);
}

sub prompt_num
{
    my($prompt,$num,$default);
    $prompt = $_[0];
    $default = $_[1];
    do
    {
        $num = get_user_input($prompt);
        if (length($num) == 0)
        {
            return $default;
        }
    } while(!valid_number($num));
    return $num;
}

sub prompt_word
{
    my($prompt,$default,$val);
    $prompt = $_[0];
    $default = $_[1];
    
    $val = get_user_input($prompt);
    if (length($val) == 0)
    {
        $val = $default;
    }
    return $val;
}

sub tcp_parse_hostlist
{
    my($inputline, $port, $i, $foo, @parse, $numinodes, $arrayline);
    my($prefix, $count, @temparray, @inodes, $numinodes);
    $inputline = $_[0];
    $port = $_[1];

    # store input line in default variable 
    $_ = $inputline;
    # initialize array index counter
    $i = 0;
    # while there is still text left
    while($_)
    {
	# strip out the first matching word (delimited by comma or white sp)
	s/^[\s,]*[^\s,]+//;
	# save the matching string that was stripped out
	$foo = "$&";
	# pull leading and trailing white sp off
	$foo =~ s/[\s,]+//g;
	# stick it in the array
	$parse[$i] = $foo;
	# increment array index
	$i++;
	# loop around and continue on next word
    }

    $numinodes = 0;
    for($i=0; $parse[$i] !~ /^$/;$i++) {
	# expand parsed input that contains brackets
	if ($parse[$i] =~ /{/) {
	    @arrayline = split(/[{}, ]+/, $parse[$i]);
	    $prefix = @arrayline[0];
	    $count = @arrayline - 1;
	    for ($j = 1; $j <= $count; $j++) { 
		if (@arrayline[$j] =~ /-/) {
		    @temparray = split(/-/, $arrayline[$j]);
		    for ($k = @temparray[0]; $k <= @temparray[1]; $k++) {
			@inodes[$numinodes] = $arrayline[0].$k;
			$numinodes++;
		    }	
		} else { 
		    @inodes[$numinodes] = $arrayline[0].$arrayline[$j];
		    $numinodes++;
		}	
	    }
	}
	else {
	    @inodes[$numinodes] = $parse[$i];
	    $numinodes++;
	}
    }
    return @inodes;
}

sub emit_defaults
{
    my($target,$num_unexp,$bmi_module);
    $target = $_[0];
    $num_unexp = $_[1];
    $bmi_module = $_[2];

    # remove quotes from logfile if any
    if ($logfile =~ /\".*\"/)
    {
        $logfile =~ s/\"//g;
    }

    print $target "<Defaults>\n";
    print $target "\tUnexpectedRequests $num_unexp\n";
    print $target "\tLogFile $logfile\n";
    print $target "\tEventLogging none\n";
    print $target "\tBMIModules $bmi_module\n";
    print $target "\tFlowModules flowproto_bmi_trove\n";
    print $target "</Defaults>\n";
}

sub emit_aliases
{
    my($target);
    $target = $_[0];

    print $target "\n<Aliases>\n";
    for($i = 0; $i <= $#union_aliases; $i++)
    {
        print $target "\tAlias @union_aliases[$i] @union_bmi[$i]\n";
    }
    print $target "</Aliases>\n";
}

sub emit_filesystem
{
    my($target, $name, $fs_id, $root_handle);
    $target = $_[0];
    $name = $_[1];
    $fs_id = $_[2];
    $root_handle = $_[3];

    # divide handle range space equally among servers ((2^32)-1 for now)
    my($total_num_handles_available, $start, $end, $i, $step, $num_ranges);
    $num_ranges = $#meta_bmi + $#io_bmi + 2;
    $total_num_handles_available = 4294967295;

    # since meta and data handle ranges must be split, increment
    # num nodes for calculation purposes below
    $step = sprintf("%lu",($total_num_handles_available / $num_ranges));

    # pre-compute the single meta handle range
    $start = 2^1;
    $end = $step;

    print $target "\n<Filesystem>\n";
    print $target "\tName $name\n";
    print $target "\tCollectionID $fs_id\n";
    print $target "\tRootHandle $root_handle\n";
    print $target "\t<MetaHandleRanges>\n";
    print $target "\t\tRange $meta_aliases[0] $start-$end\n";
    print $target "\t</MetaHandleRanges>\n";
    print $target "\t<DataHandleRanges>\n";

    foreach(@io_aliases)
    {
        $start = $end + 1;
        $end += $step;
        print $target "\t\tRange $_ $start-$end\n";
    }
    print $target "\t</DataHandleRanges>\n";
    print $target "</Filesystem>\n";
}

sub emit_server_conf
{
    my($target, $node, $storage);
    $target = $_[0];
    $node = $_[1];
    $storage = $_[2];

    print $target "StorageSpace $storage\n";
    print $target "HostID \"$node\"\n";
}

sub confirm
{
    my($prompt, $char, $valid_char);
    $prompt = $_[0];
    $valid_char = 0;
    do
    {
        $char = prompt_word($prompt,"-");
        if (($char eq 'y') || ($char eq 'n'))
        {
            $valid_char = 1;
        }
    } while($valid_char == 0);

    return (($char eq 'y') ? 1 : 0);
}

# ---------------------
# entry point of script
# ---------------------

$using_stdout = 0;

if ((@ARGV == 1) && ($ARGV[0] eq "-"))
{
    $output_target = STDOUT;
    $using_stdout = 1;
}
elsif (@ARGV != 2)
{
    print "\nUsage: pvfs2-genconfig <fs.conf> <server.conf>\n\n";

    print "The two arguments specify the names of the configuration files\n";
    print " that will be written.  This utility will create one fs.conf file.\n";
    print " It will also create a seperate server.conf file for each server\n";
    print " in the file system.  Each server.conf file will be appended\n";
    print " with the host name of the server to which it belongs.\n";
   
    print "\nExample: 'perl ./pvfs2-genconfig /tmp/fs.conf /tmp/server.conf'\n";
    print " will generate a file called /tmp/fs.conf and server specific\n";
    print " files called /tmp/server.conf-host1, /tmp/server.conf-host2, etc.\n";
    print "\nNOTE: If pvfs2-genconfig is executed with a single argument of\n";
    print " \"-\", then all output is directed to stdout and no files are\n";
    print " written.\n";
    exit;
}
else
{
    $output_target = FILEOUT;
    unless (open($output_target, ">", $ARGV[0]))
    {
        print STDERR "Can't open specified file $ARGV[0]: $!\n";
        return;
    }
}

@server_addrs = undef;
@server_aliases = undef;

#$num_unexp_reqs = prompt_num("How many unexpected requests should we be prepared to receive?  ");
$num_unexp_reqs = 10;

print "**********************************************************************\n";
print "\tWelcome to the PVFS2 Configuration Generator:\n\n";
print "This interactive script will generate configuration files suitable\n";
print "for use with a new PVFS2 file system.  Please see the PVFS2 quickstart\n";
print "guide for details.\n\n";
print "**********************************************************************\n";

# get network type
print "\n";
print "You must first select the network protocol that your file system will use.\n";
print "The only currently supported options are \"tcp\" and \"gm\".\n";
$type = prompt_word("Enter protocol type [Default is tcp]: ","tcp");

if (!($type =~ /tcp/))
{
    print "Sorry.  At this time, only the tcp protocol is configured\n";
    print "for use with this configuration utility.\n";
    exit 1;
}

# TODO: this section of the script assumes tcp, break into seperate function
###################################

# get host port
print "Choose a TCP/IP port for the servers to listen on.  Note that this\n";
print "script assumes that all servers will use the same port number.\n";
$port = prompt_num("Enter port number [Default is 3334]: ","3334");

# get host names
print "Next you must list the hostnames of the machines that will act as\n";
print "I/O servers.  Acceptable syntax is \"node1, node2, ...\" or \"node{#-#,#,#}\".\n";
$ioline = prompt_word("Enter hostnames [Default is localhost]: ","localhost");

@io_aliases = tcp_parse_hostlist($ioline, $port);
@io_aliases = sort @io_aliases;

print "Now list the hostnames of the machines that will act as Metadata\n";
print "servers.  This list may or may not overlap with the I/O server list.\n";
$metaline = prompt_word("Enter hostnames [Default is localhost]: ","localhost");

@meta_aliases = tcp_parse_hostlist($metaline, $port);
@meta_aliases = sort @meta_aliases;

my %nonunion_aliases = ();
foreach(@io_aliases,@meta_aliases){
    $nonunion_aliases{$_}=1;
}
@union_aliases = keys %nonunion_aliases;
@union_aliases = sort @union_aliases;

# tack on BMI style notation
for($i=0; $i <= $#io_aliases; $i++)
{
    @io_bmi[$i] = "tcp://@io_aliases[$i]:$port";
}
for($i=0; $i <= $#meta_aliases; $i++)
{
    @meta_bmi[$i] = "tcp://@meta_aliases[$i]:$port";
}
for($i=0; $i <= $#union_aliases; $i++)
{
    @union_bmi[$i] = "tcp://@union_aliases[$i]:$port";
}

$bmi_module = "bmi_tcp";

###################################
# end of tcp specific section

print "Configured a total of ", ($#union_bmi + 1), " servers:\n";
print "", ($#io_bmi + 1), " of them are I/O servers.\n";
print "", ($#meta_bmi + 1), " of them are Metadata servers.\n";

if($#meta_aliases != 0)
{
    print "\nERROR: we only support the use of one Metadata server at this time.\n";
    exit 1;
}

$verify_svr_flag = prompt_word("Would you like to verify server list (y/n) [Default is n]? ","n");

if($verify_svr_flag eq "y" or $verify_svr_flag eq "yes")
{
    print "****** I/O servers:\n";
    foreach(@io_bmi)
    {
	print "$_\n";
    }
    print "\n****** Metadata servers:\n";
    foreach(@meta_bmi)
    {
	print "$_\n";
    }
    my $ok_flag = prompt_word("Does this look ok (y/n) [Default is y]? ","y");
    if(!($ok_flag eq "y" or $ok_flag eq "yes"))
    {
	print "Aborting...\n";
	exit 1;
    }
}

# logfile location
print "Choose a file for each server to write log messages to.\n";

$logfile = prompt_word("Enter log file location [Default is /tmp/pvfs2-server.log]: ","/tmp/pvfs2-server.log");

print "Choose a directory for each server to store data in.\n";

$storage = prompt_word("Enter directory name: [Default is /tmp/pvfs2-storage-space]: ","/tmp/pvfs2-storage-space");

# ----------------------------------------------------------
# now that we have all the info, emit the configuration data
# ----------------------------------------------------------

# NOTE: we assume that server_aliases and server_addrs
# arrays are properly populated from above

print "Writing fs config file... ";
if ($using_stdout == 1)
{
    print "\n";
}

emit_defaults($output_target, $num_unexp_reqs, $bmi_module);
emit_aliases($output_target, $num_nodes);
emit_filesystem($output_target, "pvfs2-fs", 9, 1048576);

# close fs.conf
if ($using_stdout == 0)
{
    close($output_target);
}

print "Done.\n";

print "Writing ", ($#union_aliases + 1), " server config file(s)... ";
if ($using_stdout == 1)
{
    print "\n";
}
for($i = 0; $i <= $#union_aliases; $i++)
{
    my($filename);

    # and open server.conf files
    if ($using_stdout == 0)
    {
        $output_target = FILEOUT + $i + 10;

        $filename = "$ARGV[1]-$union_aliases[$i]";
        unless (open($output_target, ">", $filename))
        {
            print STDERR "Can't open specified file $ARGV[1]: $!\n";
            return;
        }
    }
    emit_server_conf($output_target, $union_bmi[$i], $storage);

    if ($using_stdout == 0)
    {
        close($output_target);
    }
}
print "Done.\n";

print "\nConfiguration complete!\n";
