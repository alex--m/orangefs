/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_msgpairarray_sm
 *
 * The purpose of this state machine is to prepare, send, and
 * receive a collection of request/response pairs (msgpairs).
 */

#include <string.h>
#include <assert.h>

/* conditionally include different headers to get the type of the state
 * machine struct that contains the msgpair state structs we need to access;
 * this is done to allow the reuse of this nested machine on both client and
 * server side where completely different primary state machine structures
 * are used
 */
#if defined(__PVFS2_CLIENT__)
#include "client-state-machine.h"
#define PARENT_SM PINT_client_sm
#elif defined(__PVFS2_SERVER__)
#include "pvfs2-server.h"
#define PARENT_SM PINT_server_op 
#else
/* this condition is only included for dependency building step; will not
 * actually compile cleanly
 */
#include "client-state-machine.h"
#include "pvfs2-server.h"
#endif
#include "state-machine-fns.h"
#include "msgpairarray.h"
#include "pvfs2-debug.h"
#include "pint-cached-config.h"
#include "job.h"
#include "gossip.h"
#include "pint-servreq.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

enum
{
    MSGPAIRS_COMPLETE = 190,
    MSGPAIRS_RETRY = 191
};

static int msgpairarray_init(
    PARENT_SM *sm_p, job_status_s *js_p);
static int msgpairarray_post(
    PARENT_SM *sm_p, job_status_s *js_p);
static int msgpairarray_post_retry(
    PARENT_SM *sm_p, job_status_s *js_p);
static int msgpairarray_complete(
    PARENT_SM *sm_p, job_status_s *js_p);
static int msgpairarray_completion_fn(
    PARENT_SM *sm_p, job_status_s *js_p);

static int count_incomplete_msgs(
    PINT_sm_msgpair_state *msgarray, int array_count);

%%

nested machine pvfs2_client_msgpairarray_sm(init,
                                            post,
                                            post_retry,
					    complete,
					    completion_fn)
{
    state init
    {
        run msgpairarray_init;
        default => post;
    }

    state post
    {
        run msgpairarray_post;
	MSGPAIRS_COMPLETE => completion_fn;
        default => complete;
    }

    state post_retry
    {
        run msgpairarray_post_retry;
        default => post;
    }

    state complete
    {
        run msgpairarray_complete;
        MSGPAIRS_COMPLETE => completion_fn;
        default => complete;
    }

    state completion_fn
    {
        run msgpairarray_completion_fn;
        MSGPAIRS_RETRY => post_retry;
        default => return;
    }
}

%%

static int msgpairarray_init(PARENT_SM *sm_p,
                             job_status_s *js_p)
{
    int i = 0;
    PINT_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "(%p) msgpairarray state: init (%d msgpair(s))\n",
                 sm_p, sm_p->msgarray_count);

    assert(sm_p->msgarray_count > 0);

    js_p->error_code = 0;

    /*
      set number of operations that must complete.  we're using the
      comp_ct in the first msgarray entry to keep up with the count
      for the entire array.
    */
    sm_p->msgarray[0].comp_ct = (2 * sm_p->msgarray_count);

    for(i = 0; i < sm_p->msgarray_count; i++)
    {
        msg_p = &sm_p->msgarray[i];
        assert(msg_p);

        assert((msg_p->retry_flag == PVFS_MSGPAIR_RETRY) ||
               (msg_p->retry_flag == PVFS_MSGPAIR_NO_RETRY));

        msg_p->encoded_resp_p = NULL;
        msg_p->retry_count = 0;
        msg_p->complete = 0;
    }
    return 1;
}

/* msgpairarray_post()
 *
 * The following elements of the PINT_sm_msgpair_state
 * should be valid prior to this state (for each msgpair in array):
 * - req (unencoded request)
 * - srv_addr of each element in msg array
 *
 * This state performs the following operations for each msgpair,
 * one at a time:
 * (1) encodes request
 * (2) calculates maximum response size
 * (3) allocates BMI memory for response data (encoded)
 * (4) gets a session tag for the pair of messages
 * (5) posts the receive of the response
 * (6) posts the send of the request
 * (7) stores job ids for later matching
 *
 */
static int msgpairarray_post(PARENT_SM *sm_p,
			     job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0, tmp = 0;
    struct server_configuration_s *server_config = NULL;
    PVFS_msg_tag_t session_tag;
    PINT_sm_msgpair_state *msg_p = NULL;
    struct filesystem_configuration_s *cur_fs = NULL;
    int num_incomplete_msgpairs = (sm_p->msgarray[0].comp_ct / 2);

    gossip_debug(
        GOSSIP_CLIENT_DEBUG, "(%p) msgpairarray state: post "
        "(%d total message(s) with %d incomplete)\n", sm_p,
        (sm_p->msgarray_count * 2), (num_incomplete_msgpairs * 2));

    js_p->error_code = 0;

    assert(sm_p->msgarray_count > 0);
    assert(num_incomplete_msgpairs && sm_p->msgarray[0].comp_ct);

    for (i = 0; i < num_incomplete_msgpairs; i++)
    {
        msg_p = &sm_p->msgarray[i];
        assert(msg_p);

        /*
          here we skip over the msgs that have already completed in
          the case of being in the retry code path when it's ok
        */
        if (msg_p->complete)
        {
            continue;
        }

        msg_p->op_status = 0;

        if (msg_p->encoded_resp_p == NULL)
        {
            enum PVFS_encoding_type enc_type = ENCODING_DEFAULT;

            if (msg_p->fs_id != PVFS_FS_ID_NULL)
            {
                server_config = PINT_get_server_config_struct(
                    msg_p->fs_id);
                assert(server_config);

                cur_fs = PINT_config_find_fs_id(server_config,
                                                msg_p->fs_id);
                PINT_put_server_config_struct(server_config);
                assert(cur_fs);
                enc_type = cur_fs->encoding;
            }

            ret = PINT_encode(&msg_p->req, PINT_ENCODE_REQ,
                              &msg_p->encoded_req, msg_p->svr_addr,
                              enc_type);
            if (ret != 0)
            {
                gossip_lerr("msgpairarray_post: PINT_encode failed\n");
                js_p->error_code = ret;
                return 1;
            }

            /* calculate max response msg size and allocate space */
            msg_p->max_resp_sz = PINT_encode_calc_max_size(
                PINT_ENCODE_RESP, msg_p->req.op, enc_type);

            msg_p->encoded_resp_p = BMI_memalloc(
                msg_p->svr_addr, msg_p->max_resp_sz, BMI_RECV);

            if (msg_p->encoded_resp_p == NULL)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return 1;
            }
        }

	session_tag = get_next_session_tag();

        gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "(%p) msgpair %d (%p): posting recv\n",
                     sm_p, (i + 1), msg_p);

	/* post receive of response; job_id stored in recv_id */
	ret = job_bmi_recv(msg_p->svr_addr,
			   msg_p->encoded_resp_p,
			   msg_p->max_resp_sz,
			   session_tag,
			   BMI_PRE_ALLOC,
			   sm_p,
			   i,
			   &msg_p->recv_status,
			   &msg_p->recv_id,
			   pint_client_sm_context,
			   PVFS2_CLIENT_JOB_TIMEOUT);
	if (ret == 0)
	{
	    /* perform a quick test to see if the recv failed before posting
	     * the send; if it reports an error quickly then we can save the
	     * confusion of sending a request for which we can't recv a
	     * response
	     */
	    ret = job_test(msg_p->recv_id, &tmp, NULL,
			   &msg_p->recv_status, 0, pint_client_sm_context);
	}

	if ((ret < 0) || (ret == 1))
        {
	    /* it is impossible for this recv to complete at this point
	     * without errors; we haven't sent the request yet!
	     */
	    assert(ret < 0 || msg_p->recv_status.error_code != 0);
	    if (ret < 0)
            {
		PVFS_perror_gossip("Post of receive failed", ret);
            }
	    else
            {
		PVFS_perror_gossip("Receive immediately failed",
			    msg_p->recv_status.error_code);
            }

	    msg_p->recv_id = 0;
	    msg_p->send_id = 0;

	    /* mark send as bad too and don't post it */
	    msg_p->send_status.error_code = msg_p->recv_status.error_code;
	    msg_p->op_status = msg_p->recv_status.error_code;
	    sm_p->msgarray[0].comp_ct -= 2;
	    /* continue to send other array entries if possible */
	    continue;
	}

	/* if we reach here, the recv has been posted without failure, but
	 * has not completed yet
	 */
	assert(ret == 0);

        gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "(%p) msgpair %d (%p): posting send\n",
                     sm_p, (i + 1), msg_p);

	/* post send of request; job_id stored in send_id */
	ret = job_bmi_send_list(msg_p->encoded_req.dest,
				msg_p->encoded_req.buffer_list,
				msg_p->encoded_req.size_list,
				msg_p->encoded_req.list_count,
				msg_p->encoded_req.total_size,
				session_tag,
				msg_p->encoded_req.buffer_type,
				1,
				sm_p,
				sm_p->msgarray_count+i,
				&msg_p->send_status,
				&msg_p->send_id,
				pint_client_sm_context,
				PVFS2_CLIENT_JOB_TIMEOUT);

 	if ((ret < 0) ||
            ((ret == 1) && (msg_p->send_status.error_code != 0)))
	{
	    if (ret < 0)
            {
		PVFS_perror_gossip("Post of send failed", ret);
            }
	    else
            {
		PVFS_perror_gossip("Send immediately failed",
		    msg_p->recv_status.error_code);
            }

	    gossip_err("Send error: cancelling recv.\n");

	    PINT_client_bmi_cancel(msg_p->recv_id);
	    
	    /* we still have to wait for recv completion, so just decrement
	     * comp_ct by one and keep going
	     */
	    msg_p->op_status = msg_p->send_status.error_code;
	    msg_p->send_id = 0;
	    sm_p->msgarray[0].comp_ct--;
	}
	else if (ret == 1)
	{
	    /* immediate completion */
	    msg_p->send_id = 0;
	    /* decrement our count, since send is already done.
	     *
	     * we're using the comp_ct in the first array element to
	     * keep up with our count for the entire array.
	     */
	    sm_p->msgarray[0].comp_ct--;
	}
        /* else: successful post, no immediate completion */
    }

    if (sm_p->msgarray[0].comp_ct == 0)
    {
	/* everything is completed already (could happen in some failure
	 * cases); jump straight to final completion function.
	 */
	 js_p->error_code = MSGPAIRS_COMPLETE;
	 return 1;
    }

    /* we are still waiting on operations to complete, next state
     * transition will handle them
     */
    return 0;
}

static int msgpairarray_post_retry(PARENT_SM *sm_p,
                                   job_status_s *js_p)
{
    job_id_t tmp_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "(%p) msgpairarray state: post_retry\n", sm_p);

    return job_req_sched_post_timer(
        PVFS2_CLIENT_RETRY_DELAY, sm_p, 0, js_p, &tmp_id,
        pint_client_sm_context);
}

static int msgpairarray_complete(PARENT_SM *sm_p,
                                 job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "(%p) msgpairarray state: complete\n", sm_p);

    /* match operation with something in the msgpair array */
    /* the first N tags are receives, the second N are sends */
    assert(js_p->status_user_tag < sm_p->msgarray_count*2);

    if (js_p->status_user_tag < sm_p->msgarray_count)
    {
	PINT_sm_msgpair_state *msg_p = 
	    &sm_p->msgarray[js_p->status_user_tag];

	msg_p->recv_id = 0;
	msg_p->recv_status = *js_p;

	/* save error (if we don't already have one) in op_status */
	if(msg_p->op_status == 0)
	    msg_p->op_status = msg_p->recv_status.error_code;

	if(msg_p->recv_status.error_code && msg_p->send_id != 0)
	{
	    /* we got a receive error, but send is still pending.  Cancel
	     * the send
	     */
	    PINT_client_bmi_cancel(msg_p->send_id);
	}
    }
    else
    {
	PINT_sm_msgpair_state *msg_p = &sm_p->msgarray[
            js_p->status_user_tag - sm_p->msgarray_count];

	msg_p->send_id = 0;
	msg_p->send_status = *js_p;

	/* save error (if we don't already have one) in op_status */
	if(msg_p->op_status == 0)
	    msg_p->op_status = msg_p->send_status.error_code;

	if(msg_p->send_status.error_code && msg_p->recv_id != 0)
	{
	    /* we got a send error, but recv is still pending.  Cancel
	     * the recv 
	     */
	    PINT_client_bmi_cancel(msg_p->recv_id);
	}
    }

    /* decrement comp_ct until all operations have completed */
    if (--sm_p->msgarray[0].comp_ct > 0)
    {
	return 0;
    }

    assert(sm_p->msgarray[0].comp_ct == 0);
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "  msgpairarray: all operations complete\n");

    js_p->error_code = MSGPAIRS_COMPLETE;
    return 1;
}

static int msgpairarray_completion_fn(PARENT_SM *sm_p,
				      job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0;
    struct PINT_decoded_msg decoded_resp;
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) msgpairarray state: "
                 "completion_fn\n", sm_p);

    for (i = 0; i < sm_p->msgarray_count; i++)
    {
	PINT_sm_msgpair_state *msg_p = &sm_p->msgarray[i];
        assert(msg_p);

	if (msg_p->op_status != 0)
	{
            if ((msg_p->retry_flag == PVFS_MSGPAIR_RETRY) &&
                (PVFS_ERROR_CLASS(-msg_p->op_status) ==
                 PVFS_ERROR_BMI) &&
                (msg_p->retry_count < PVFS_MSGPAIR_RETRY_LIMIT))
            {
                msg_p->retry_count++;

                gossip_debug(GOSSIP_CLIENT_DEBUG, "*** msgpairarray send "
                             "failed -- retrying msgpair (count = %d)\n",
                             msg_p->retry_count);

                /*
                  NOTE: we only retry msgpairs that haven't yet been
                  completed
                */
                sm_p->msgarray[0].comp_ct = 2 * count_incomplete_msgs(
                    sm_p->msgarray, sm_p->msgarray_count);

                assert(sm_p->msgarray[0].comp_ct > 0);

                gossip_debug(GOSSIP_CLIENT_DEBUG, "*** msgpairarray is "
                             "retrying %d of %d total messages\n",
                             sm_p->msgarray[0].comp_ct,
                             (2 * sm_p->msgarray_count));

                js_p->error_code = MSGPAIRS_RETRY;
                return 1;
            }

	    PVFS_perror_gossip("*** msgpair did not complete successfully",
                        msg_p->op_status);

	    js_p->error_code = msg_p->op_status;
	    continue;
	}

	ret = PINT_serv_decode_resp(msg_p->fs_id,
				    msg_p->encoded_resp_p,
				    &decoded_resp,
				    &msg_p->svr_addr,
				    msg_p->recv_status.actual_size,
				    &resp_p);
	if (ret != 0)
        {
            PVFS_perror_gossip("msgpairarray decode error", ret);
            js_p->error_code = ret;
            return 1;
	}

	assert(resp_p->status <= 0);

	/* if we've made it this far, the server response status is
	 * meaningful, so we save it.
	 */
	msg_p->op_status = resp_p->status;

	/* NOTE: we call the function associated with each message,
	 *       not just the one from the first array element.  so
	 *       there could in theory be different functions for each
	 *       message (to handle different types of messages all in
	 *       the same array).
	 */
	if (msg_p->comp_fn != NULL)
	{
	    /* If we call the completion function, store the result on
	     * a per message pair basis.  Also store some non-zero
	     * (failure) value in js_p->error_code if we see one.
	     */
	    msg_p->op_status = msg_p->comp_fn(sm_p, resp_p, i);
	    if (msg_p->op_status != 0)
	    {
		js_p->error_code = msg_p->op_status;
	    }

	    /* even if we see a failure, continue to process with the
	     * completion function. -- RobR
	     */
	}
	else if (resp_p->status != 0)
        {
	    /* no comp_fn specified and status non-zero */
	    gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "notice: msgpairarray_complete: error %d "
                         "from server %d\n", resp_p->status, i);

	    /* save a non-zero status to return if we see one */
	    js_p->error_code = resp_p->status;

	    /* If we don't have a completion function, there is no point
	     * in continuing to process after seeing a failure.
	     */
	    if (js_p->error_code)
            {
                break;
            }
	}
	
	/* free all the resources that we used to send and receive. */
	ret = PINT_serv_free_msgpair_resources(
            &msg_p->encoded_req, msg_p->encoded_resp_p, &decoded_resp,
            &msg_p->svr_addr, msg_p->max_resp_sz);
	if (ret)
        {
            PVFS_perror_gossip("Failed to free msgpair resources", ret);
            js_p->error_code = ret;
            return 1;
	}

        msg_p->encoded_resp_p = NULL;
        msg_p->max_resp_sz = 0;

        /*
          mark that this msgpair has been completed and should not be
          retried in the case of possible future retries
        */
        msg_p->complete = 1;

        gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "(%p) msgpair %d (%p): marked complete\n",
                     sm_p, (i + 1), msg_p);
    }
    return 1;
}

static int count_incomplete_msgs(
    PINT_sm_msgpair_state *msgarray, int array_count)
{
    int count = 0, i = 0;
    PINT_sm_msgpair_state *msg = NULL;

    for(i = 0; i < array_count; i++)
    {
        msg = &msgarray[i];
        assert(msg);

        count += (msg->complete ? 0 : 1);
    }
    return count;
}
    
/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
