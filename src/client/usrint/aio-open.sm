/* 
 * (C) 2012 Clemson University
 *
 * See COPYING in top-level directory.
 */

#include "pvfs2-aio.h"
#include "client-state-machine.h"
#include "str-utils.h"
#include "openfile-util.h"
#include "pvfs2-internal.h"
#include "pvfs2-dist-simple-stripe.h"
#include "usrint.h"

extern job_context_id pint_client_sm_context;

enum
{
    OPEN_PDIR_GIVEN = 924,
    OPEN_PDIR_NULL,
    OPEN_PDIR_RESOLVE_FAIL,
    OPEN_RUN_LOOKUP_SM,
    OPEN_FIND_FILE,
    OPEN_FILE_FOUND,
    OPEN_CREATE_FILE,
    OPEN_TRUNCATE_FILE,
    OPEN_FILE_APPEND
};

/* helper function prototypes */
static int initialize_context(
    struct PINT_client_lookup_sm * lookup_sm,
    char *pathname,
    PVFS_object_ref ctx_starting_refn);

static PVFS_error split_path(
    const char *path,
    int dirflag,
    char **directory,
    char **filename);

static PINT_dist* get_default_distribution(PVFS_fs_id fs_id);

%%

machine pvfs2_client_aio_open_sm
{
    state init
    {
        run open_init;
        OPEN_PDIR_GIVEN => pdir_given;
        OPEN_PDIR_NULL => pdir_lookup;
        default => cleanup;
    }

    state pdir_given
    {
        run open_pdir_lookup_given;
        OPEN_RUN_LOOKUP_SM => pdir_ref_lookup_rel;
        OPEN_FIND_FILE => file_lookup_setup;
        default => cleanup;
    }

    state pdir_lookup
    {
        run open_pdir_lookup;
        OPEN_PDIR_RESOLVE_FAIL => resolve_fail_file_lookup_setup;
        OPEN_RUN_LOOKUP_SM => pdir_ref_lookup_abs;
        OPEN_FIND_FILE => file_lookup_setup;
        default => cleanup;
    }

    state pdir_ref_lookup_rel
    {
        jump pvfs2_client_lookup_sm;
        default => pdir_ref_lookup_rel_setup_next;
    }

    state pdir_ref_lookup_abs
    {
        jump pvfs2_client_lookup_sm;
        default => pdir_ref_lookup_abs_inspect;
    }

    state pdir_ref_lookup_rel_setup_next
    {
        run open_pdir_ref_lookup_rel_setup_next;
        OPEN_RUN_LOOKUP_SM => pdir_ref_lookup_rel;
        OPEN_FIND_FILE => file_lookup_setup;
        default => cleanup;
    }

    state pdir_ref_lookup_abs_inspect
    {
        run open_pdir_ref_lookup_abs_inspect;
        success => file_lookup_setup;
        default => cleanup;
    }

    state resolve_fail_file_lookup_setup
    {
        run open_resolve_fail_file_lookup_abs;
        OPEN_RUN_LOOKUP_SM => resolve_fail_file_lookup;
        default => file_lookup_inspect;
    }

    state resolve_fail_file_lookup
    {
        jump pvfs2_client_lookup_sm;
        default => resolve_fail_file_lookup_inspect;
    }

    state resolve_fail_file_lookup_inspect
    {
        run open_resolve_fail_file_lookup_inspect;
        default => file_lookup_inspect;
    }

    state file_lookup_setup
    {
        run open_file_lookup_setup;
        OPEN_RUN_LOOKUP_SM => file_lookup;
        default => file_lookup_inspect;
    }

    state file_lookup
    {
        jump pvfs2_client_lookup_sm;
        default => file_lookup_setup_next;
    }

    state file_lookup_setup_next
    {
        run open_file_lookup_setup_next;
        OPEN_RUN_LOOKUP_SM => file_lookup;
        default => file_lookup_inspect;
    }

    state file_lookup_inspect
    {
        run open_file_ref_lookup_inspect;
        OPEN_CREATE_FILE => create_file;
        success => setup_fildes;
	default => cleanup;
    }

    state create_file
    {
        jump pvfs2_client_create_sm;
        default => create_file_inspect;
    }

    state create_file_inspect
    {
        run open_create_file_inspect;
        OPEN_FIND_FILE => file_lookup_setup;
        success => setup_fildes;
        default => cleanup;
    }

    state setup_fildes
    {
        run open_setup_fildes;
        success => fildes_getattr;
        default => cleanup;
    }

    state fildes_getattr
    {
        jump pvfs2_client_getattr_sm;
        default => fildes_getattr_inspect;
    }

    state fildes_getattr_inspect
    {
        run open_getattr_inspect;
	OPEN_TRUNCATE_FILE => file_truncate;
        default => file_append_check;
    }

    state file_truncate
    {
        jump pvfs2_client_truncate_sm;
        default => file_append_check;
    }

    state file_append_check
    {
        run open_file_append_check;
        OPEN_FILE_APPEND => file_append_getattr;
        default => cleanup;
    }

    state file_append_getattr
    {
        jump pvfs2_client_getattr_sm;
        default => file_append_getattr_inspect;
    }

    state file_append_getattr_inspect
    {
        run open_file_append_getattr_inspect;
        OPEN_FILE_APPEND => file_append_readdir;
        default => cleanup;
    }

    state file_append_readdir
    {
        jump pvfs2_client_readdir_sm;
        default => file_append_readdir_inspect;
    }

    state file_append_readdir_inspect
    {
        run open_file_append_readdir_inspect;
        default => cleanup;
    }

    state cleanup
    {
        run open_cleanup;
        default => terminate;
    }
}

%%

static int initialize_context(
    struct PINT_client_lookup_sm * lookup_sm,
    char *pathname,
    PVFS_object_ref ctx_starting_refn)
{
    int i, ret = -PVFS_EINVAL, pathlen = 0, num_segments = 0;
    void *state = NULL;
    int cur_seg_index = 0, prev_ctx_index = 0;
    char *cur_seg_name = NULL;
    char *orig_pathname = NULL, *seg_remaining = NULL, *slash_str = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;
    int num_consecutive_prev_ctx_dot_dots = 0;
    PINT_client_lookup_sm_ctx *ctx = NULL;
    PINT_client_lookup_sm_ctx *prev_ctx = NULL;

    gossip_debug(GOSSIP_LOOKUP_DEBUG, "initialize_context called\n");

    assert(lookup_sm->current_context <= lookup_sm->context_count);

    if(lookup_sm->current_context == lookup_sm->context_count)
    {
        /* we have used the last available context */
        lookup_sm->context_count++;
        if(lookup_sm->context_count == 1)
        {
            lookup_sm->contexts = malloc(sizeof(PINT_client_lookup_sm_ctx));
            if(!lookup_sm->contexts)
            {
                return -PVFS_ENOMEM;
            }
        }
        else
        {
            /* not the first one, so realloc to get one more */
            lookup_sm->contexts = realloc(lookup_sm->contexts,
                                          sizeof(PINT_client_lookup_sm_ctx) *
                                          lookup_sm->context_count);
            if(!lookup_sm->contexts)
            {
                return -PVFS_ENOMEM;
            }
        }
    }

    if (pathname && (lookup_sm->current_context > -1))
    {
        ctx = &lookup_sm->contexts[lookup_sm->current_context];
        assert(ctx);

        prev_ctx_index = (lookup_sm->current_context - 1);

        pathlen = strlen(pathname);
        num_segments = PINT_string_count_segments(pathname);

        if ((pathlen == 0) || (num_segments == 0))
        {
            return ret;
        }

        if ((pathlen > (PVFS_REQ_LIMIT_PATH_NAME_BYTES - 1)) ||
            (num_segments > MAX_LOOKUP_SEGMENTS))
        {
            gossip_err("Filename %s is too long\n", pathname);
            return -PVFS_ENAMETOOLONG;
        }

        memset(ctx, 0, sizeof(PINT_client_lookup_sm_ctx));

        ctx->current_segment = 0;
        ctx->total_segments = 0;
        ctx->ctx_starting_refn = ctx_starting_refn;

        /* initialize all segments within the context */
        orig_pathname = strdup(pathname);
        gossip_debug(GOSSIP_LOOKUP_DEBUG, " original pathname is: %s\n",
                     orig_pathname);
        while(!PINT_string_next_segment(pathname,&cur_seg_name,&state))
        {
            /* grab the next segment in the context to fill in */
            cur_seg = &(ctx->segments[cur_seg_index]);
            assert(cur_seg);
            memset(cur_seg, 0, sizeof(PINT_client_lookup_sm_segment));

            gossip_debug(GOSSIP_LOOKUP_DEBUG, " cur_seg_name[%d]: %s\n",
                         cur_seg_index, cur_seg_name);
            gossip_debug(GOSSIP_LOOKUP_DEBUG, " pathname is: %s\n",
                         pathname);

            if (strcmp(cur_seg_name,".") == 0)
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;

                gossip_debug(GOSSIP_LOOKUP_DEBUG,
                             " ignoring useless segment\n");
                continue;
            }
            else if (strcmp(cur_seg_name,"..") == 0)
            {
                /*
                   if this isn't true, we need to
                   grab the previous context's previous segment

                   if this weren't true, we'd normally:
                   assert(cur_seg_index > 0);
                */
                if ((cur_seg_index < 1) ||
                    (num_consecutive_prev_ctx_dot_dots > 0))
                {
                    PINT_client_lookup_sm_segment *prev_ctx_prev_seg;

                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG, "  got a '..' segment that "
                        "requires attention of the previous context\n");

                  init_next_prev_segment:
                    /*
                      grab the previous context to access the segments
                      within it, assuming a previous context is
                      available
                    */
                    if (prev_ctx_index < 0)
                    {
                        gossip_debug(GOSSIP_LOOKUP_DEBUG, "there are no "
                                     "more previous contexts available: "
                                     "failing lookup\n");
                        free(orig_pathname);
                        return -PVFS_ENOENT;
                    }

                    prev_ctx = &lookup_sm->contexts[prev_ctx_index];
                    assert(prev_ctx);
                    assert(prev_ctx->current_segment > 0);

                    num_consecutive_prev_ctx_dot_dots++;
                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG, "num consecutive '..' "
                        "segments requiring the previous segment "
                        "is now %d\n", num_consecutive_prev_ctx_dot_dots);

                    /*
                      further, if we have a number of consecutive '..'
                      segments, we may need to keep backing up into
                      the previous contexts' space
                    */
                    if (prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots < 0)
                    {
                        /* skip to next previous context, if any */
                        if (prev_ctx_index > -1)
                        {
                            /*
                              bump down dot dot count since it wasn't
                              used yet if we got here
                            */
                            num_consecutive_prev_ctx_dot_dots--;
                            prev_ctx_index--;
                            goto init_next_prev_segment;
                        }
                        gossip_debug(
                            GOSSIP_LOOKUP_DEBUG, "there are no more segments "
                            "in the previous context: failing lookup\n");
                        free(orig_pathname);
                        return -PVFS_ENOENT;
                    }

                    prev_ctx_prev_seg = &prev_ctx->segments[
                        prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots];
                    assert(prev_ctx_prev_seg);

                    /*
                      instead of decrementing the seg index and
                      continuing, we need to replace the last segment
                      copied from the last context in this case.  (so
                      we drop through to segment init)
                    */
                    ctx_starting_refn =
                        prev_ctx_prev_seg->seg_starting_refn;
                    cur_seg_name = prev_ctx_prev_seg->seg_name;
                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG,
                        "using previous segment: %s\n", cur_seg_name);

                    cur_seg_index--;
                }
                else
                {
                    gossip_debug(GOSSIP_LOOKUP_DEBUG,
                                 "  got a '..' segment\n");
                    cur_seg_index--;
                    continue;
                }
            }
            else
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;
            }

            /*
              fill in the current segment now.  the first segment
              MUST have the same starting refn as the context
            */
            if (cur_seg_index == 0)
            {
                cur_seg->seg_starting_refn = ctx_starting_refn;
            }
            if (cur_seg->seg_name)
            {
                free(cur_seg->seg_name);
            }
            cur_seg->seg_name = strdup(cur_seg_name);
            assert(cur_seg->seg_name);

            slash_str = orig_pathname;
            for (i = 0; i < cur_seg_index; i++) {
                slash_str = strchr(slash_str, '/');
                if (slash_str == NULL) {
                    break;
                }
                slash_str++;
            }
            /* seg_remaining = strstr(orig_pathname, cur_seg_name); */
            seg_remaining = slash_str;
            if (seg_remaining)
            {
                gossip_debug(GOSSIP_LOOKUP_DEBUG,
                             " *seg_remaining is: %s\n", seg_remaining);

                cur_seg->seg_remaining = strdup(seg_remaining);
                assert(cur_seg->seg_remaining);
            }
            else
            {
                cur_seg->seg_remaining = NULL;
            }

            cur_seg_index++;
        }
        free(orig_pathname);

#if 0
    /* DEBUGGING ONLY */
    {
        int i = 0;
        gossip_debug(GOSSIP_LOOKUP_DEBUG, "Processed context path is:\n");
        for(i = 0; i < cur_seg_index; i++)
        {
            assert(ctx->segments[i].seg_name);
            gossip_debug(GOSSIP_LOOKUP_DEBUG, "/%s", 
                         ctx->segments[i].seg_name);
        }
        gossip_debug(GOSSIP_LOOKUP_DEBUG, "\n");
    }
#endif

        ctx->total_segments = cur_seg_index;
        assert(ctx->current_segment == 0);
        ret = 0;
    }
    return ret;
}

static PVFS_error split_path(
    const char *path,
    int dirflag,
    char **directory,
    char **filename)
{
    int i, fnlen, slashes = 0;
    int length = strlen("pvfs2");

    if (!path || !directory || !filename)
    {
        return -PVFS_EINVAL;
    }
    /* chop off pvfs2 prefix */
    if (strncmp(path, "pvfs2:", length) == 0)
    {
        path = &path[length];
    }
    /* Split path into a directory and filename */
    length = strnlen(path, PVFS_PATH_MAX);
    if (length == PVFS_PATH_MAX)
    {
        return -PVFS_ENAMETOOLONG;
    }
    i = length - 1;
    if (dirflag)
    {
        /* skip any trailing slashes */
        for(; i >= 0 && path[i] == '/'; i--)
        {
            slashes++;
        }
    }
    for (; i >= 0; i--)
    {
        if (path[i] == '/')
        {
            /* parse the directory */
            *directory = malloc(i + 1);
            if (!*directory)
            {
                return -PVFS_EIO;
            }
            strncpy(*directory, path, i);
            (*directory)[i] = '\0';
            break;
        }
    }
    if (i == -1)
    {
        /* found no '/' path is all filename */
        *directory = NULL;
    }
    i++;
    /* copy the filename */
    fnlen = length - i - slashes;
    if (fnlen == 0)
    {
        filename = NULL;
        if (!directory)
        {
            return -PVFS_EISDIR;
        }
        else
        {
            return -PVFS_ENOENT;
        }
    }
    /* check flag to see if there are slashes to skip */
    *filename = malloc(fnlen + 1);
    if (!*filename)
    {
        if (*directory)
        {
            free(*directory);
        }
        *directory = NULL;
        *filename = NULL;
        return -PVFS_EIO;
    }
    strncpy(*filename, path + i, length - i);
    (*filename)[length - i] = '\0';
    return 0;
}

/**
 * Returns the default distribution, or NULL if the distribution could not
 * be created.  The default distribution is read from the server
 * configuration if possible.  If the server config does not specify a
 * default distribution, simple_stripe will be used.
 */
static PINT_dist* get_default_distribution(PVFS_fs_id fs_id)
{
    server_configuration_s* server_config = NULL;
    PINT_dist* dist = NULL;

    /* Retrieve the server configuration (with mutex) */
    server_config = PINT_get_server_config_struct(fs_id);

    /* If a default dist is specified in the config, use that
       else just create a simple_stripe distribution */
    if (NULL != server_config &&
        NULL != server_config->default_dist_config.name)
    {
        dist = PINT_dist_create(server_config->default_dist_config.name);

        if (dist)
        {
            PINT_llist_p iter = server_config->default_dist_config.param_list;

            /* Set supplied the distribution parameters */
            while (iter)
            {
                int rc;
                distribution_param_configuration* param =PINT_llist_head(iter);

                /* If we are at the list end, break
                   else, set the distribution parameter to the given value */
                if (NULL == param)
                {
                    break;
                }
                else
                {
                    rc = dist->methods->set_param(dist->dist_name,
                                                  dist->params,
                                                  param->name,
                                                  &param->value);

                    if (0 != rc)
                    {
                        gossip_err("Error setting distribution parameter\n"
                                   "  dist: %s\n"
                                   "  param name: %s\n"
                                   "  param value: %lld\n",
                                   dist->dist_name, param->name,
                                   lld(param->value));
                    }
                }
                iter = PINT_llist_next(iter);
            }
        }
        else
        {
            gossip_err("Error creating default distribution: %s\n",
                       server_config->default_dist_config.name);
        }
    }
    else
    {
        dist = PINT_dist_create(PVFS_DIST_SIMPLE_STRIPE_NAME);
    }

    /* Release the server config mutex */
    PINT_put_server_config_struct(server_config);

    return dist;
}


/****************************************************************/

PVFS_error PVFS_iaio_open(
    pvfs_descriptor **fildes,
    const char *path,
    int flags,
    PVFS_hint file_creation_param,
    mode_t mode,
    pvfs_descriptor *pdir,
    const PVFS_credential *credential,
    PVFS_sys_op_id *op_id,
    PVFS_hint hints,
    void *user_ptr)
{
    PVFS_error ret = -PVFS_EINVAL;
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;
    char *directory = NULL;
    char *filename = NULL;
    char *newpath = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_iaio_open entered\n");

    if (fildes == NULL || path == NULL)
    {
        gossip_err("invalid (NULL) required arguments\n");
        return ret;
    }

    newpath = pvfs_qualify_path(path);
    if (!newpath)
    {
        return ret;
    }
    if (newpath == path)
    {
        newpath = malloc(strlen(path) + 1);
        if (!newpath)
        {
            return -PVFS_ENOMEM;
        }
        strcpy(newpath, path);
    }

    ret = split_path(path, 0, &directory, &filename);
    if (ret < 0)
    {
        return ret;
    }

    PINT_smcb_alloc(&smcb, PVFS_AIO_OPEN,
             sizeof(struct PINT_client_sm),
             client_op_state_get_machine,
             client_state_machine_terminate,
             pint_client_sm_context);
    if (smcb == NULL)
    {
        return -PVFS_ENOMEM;
    }
    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    PINT_init_sysint_credential(sm_p->cred_p, credential);
    sm_p->u.aio_open.path = newpath;
    sm_p->u.aio_open.directory = directory;
    sm_p->u.aio_open.filename = filename;
    sm_p->u.aio_open.flags = flags;
    sm_p->u.aio_open.pdir = pdir;
    sm_p->u.aio_open.file_creation_param = file_creation_param;
    sm_p->u.aio_open.mode = mode;
    sm_p->u.aio_open.pd = fildes;
    PVFS_hint_copy(hints, &sm_p->hints);

    return PINT_client_state_machine_post(
        smcb, op_id, user_ptr);
}

PVFS_error PVFS_aio_open(
    pvfs_descriptor **fildes,
    const char *path,
    int flags, 
    PVFS_hint file_creation_param,
    mode_t mode,
    pvfs_descriptor *pdir,
    const PVFS_credential *credential,
    PVFS_hint hints)
{
    PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_aio_open entered\n");

    ret = PVFS_iaio_open(fildes, path, flags, file_creation_param,
                         mode, pdir, credential, &op_id, hints, NULL);

    if (ret)
    {
        PVFS_perror_gossip("PVFS_iaio_open call", ret);
        error = ret;
    }
    else
    {
        ret = PVFS_sys_wait(op_id, "aio_open", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_sys_wait call", ret);
            error = ret;
        }
    }

    PINT_sys_release(op_id);
    return error;
}

/*******************************************************************/

static PINT_sm_action open_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: init\n");

    memset(&sm_p->u.aio_open.file_ref, 0, sizeof(PVFS_object_ref));
    memset(&sm_p->u.aio_open.parent_ref, 0, sizeof(PVFS_object_ref)); 
    sm_p->u.aio_open.current_seg_path = NULL;

    /* Check the flags to determine if links are followed */
    if (sm_p->u.aio_open.flags & O_NOFOLLOW)
    {
        sm_p->u.aio_open.follow_link = PVFS2_LOOKUP_LINK_NO_FOLLOW;
    }
    else
    {
        sm_p->u.aio_open.follow_link = PVFS2_LOOKUP_LINK_FOLLOW;
    }

    /* check to see if a parent directory descriptor is passed in */
    if (sm_p->u.aio_open.pdir == NULL)
    {
        js_p->error_code = OPEN_PDIR_NULL;
    }
    else
    {
        js_p->error_code = OPEN_PDIR_GIVEN;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_pdir_lookup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    PVFS_fs_id lookup_fs_id;
    char pvfs_path[PVFS_PATH_MAX];
    PVFS_object_ref parent;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: pdir_lookup\n");

    ret = PVFS_util_resolve(sm_p->u.aio_open.directory, &lookup_fs_id,
                            pvfs_path, PVFS_PATH_MAX);
    if (ret < 0)
    {
        if (ret == -PVFS_ENOENT)
        {
            js_p->error_code = OPEN_PDIR_RESOLVE_FAIL;
        }
        else
        {
            js_p->error_code = ret;
        }
        return SM_ACTION_COMPLETE;
    }

    parent.handle = 0;
    parent.fs_id = lookup_fs_id;

    ret = PINT_cached_config_get_root_handle(parent.fs_id, &parent.handle);
    if (ret < 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    if (strcmp(pvfs_path, "/") == 0)
    {
        sm_p->u.aio_open.parent_ref.handle = parent.handle;
        sm_p->u.aio_open.parent_ref.fs_id = lookup_fs_id;
        js_p->error_code = OPEN_FIND_FILE;
    }
    else
    {
        PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
        if (lookup_frame == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
        memset(lookup_frame, 0, sizeof(PINT_client_sm));

        char *path = ((pvfs_path[0] == '/') ? &pvfs_path[1] : pvfs_path);

        PINT_init_msgarray_params(lookup_frame, lookup_fs_id);
        PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
        lookup_frame->u.lookup.orig_pathname = path;
        lookup_frame->u.lookup.starting_refn = parent;
        lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_open.lookup_resp);
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;
        PVFS_hint_copy(sm_p->hints, &lookup_frame->hints);
        PVFS_hint_add(&lookup_frame->hints, PVFS_HINT_HANDLE_NAME,
                    sizeof(PVFS_handle),
                    &(parent.handle));

        ret = initialize_context(&lookup_frame->u.lookup, path,
                                 parent);
        if (ret != 0)
        {
            gossip_err("aio-open: failed to init context (path = %s)\n", path);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.parent_ref.fs_id = lookup_fs_id;
            sm_p->u.aio_open.parent_ref.handle = parent.handle;
            js_p->error_code = OPEN_FIND_FILE;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         path, llu(parent.handle));

        }
    }

    return SM_ACTION_COMPLETE;
} 

static PINT_sm_action open_pdir_lookup_given(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: pdir_given\n");

    if (sm_p->u.aio_open.directory)
    {
        sm_p->u.aio_open.cur = sm_p->u.aio_open.directory;
        sm_p->u.aio_open.last = sm_p->u.aio_open.directory;
        sm_p->u.aio_open.start = sm_p->u.aio_open.directory;
    
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_open.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_open.cur++;
                (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/');
                 sm_p->u.aio_open.cur++);
            if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
                if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
                {
                    js_p->error_code = -PVFS_ENAMETOOLONG;
                    return SM_ACTION_COMPLETE;
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
            }
        }
/*        
        char current_seg_path[PVFS_NAME_MAX];
        memset(current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(current_seg_path, sm_p->u.aio_open.start,
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
*/
        sm_p->u.aio_open.current_seg_path = (char *)malloc(PVFS_NAME_MAX);
        if (sm_p->u.aio_open.current_seg_path == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
        memset(sm_p->u.aio_open.current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(sm_p->u.aio_open.current_seg_path, sm_p->u.aio_open.start, 
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 2);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

        PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
        if (lookup_frame == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
        memset(lookup_frame, 0, sizeof(PINT_client_sm));

        PINT_init_msgarray_params(lookup_frame, sm_p->u.aio_open.pdir->s->pvfs_ref.fs_id);

        PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
        lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_open.current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.pdir->s->pvfs_ref;
        lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_open.lookup_resp);
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;
        PVFS_hint_copy(sm_p->hints, &lookup_frame->hints);
        PVFS_hint_add(&lookup_frame->hints, PVFS_HINT_HANDLE_NAME,
                    sizeof(PVFS_handle),
                    &(sm_p->u.aio_open.pdir->s->pvfs_ref.handle));

        ret = initialize_context(&lookup_frame->u.lookup,
                                 sm_p->u.aio_open.current_seg_path,
                                 sm_p->u.aio_open.pdir->s->pvfs_ref);
        if (ret != 0)
        {
            gossip_err("aio-open: failed to init context (path = %s)\n",
                       sm_p->u.aio_open.current_seg_path);
            free(lookup_frame);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.parent_ref.fs_id = sm_p->u.aio_open.pdir->s->pvfs_ref.fs_id;
            sm_p->u.aio_open.parent_ref.handle = sm_p->u.aio_open.pdir->s->pvfs_ref.handle;
            js_p->error_code = OPEN_FIND_FILE;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         sm_p->u.aio_open.current_seg_path,
                         llu(sm_p->u.aio_open.pdir->s->pvfs_ref.handle));

        }
    }    
    else
    {
        sm_p->u.aio_open.parent_ref = sm_p->u.aio_open.pdir->s->pvfs_ref;
        js_p->error_code = OPEN_FIND_FILE;
    }   

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_pdir_ref_lookup_rel_setup_next(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: pdir_ref_lookup_rel_setup_next\n");

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    js_p->error_code = lookup_frame->error_code;
    if (js_p->error_code)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    if (*(sm_p->u.aio_open.cur))
    {
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_open.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_open.cur++;
                (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/');
                 sm_p->u.aio_open.cur++);
            if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
                if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
                {
                    free(lookup_frame);
                    js_p->error_code = -PVFS_ENAMETOOLONG;
                    return SM_ACTION_COMPLETE;
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
            }
        }
/*
        char current_seg_path[PVFS_NAME_MAX];
        memset(current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(current_seg_path, sm_p->u.aio_open.start,
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
*/

        memset(sm_p->u.aio_open.current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(sm_p->u.aio_open.current_seg_path, sm_p->u.aio_open.start,
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

        lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_open.current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.lookup_resp.ref;
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;

        ret = initialize_context(&lookup_frame->u.lookup,
                                 sm_p->u.aio_open.current_seg_path,
                                 sm_p->u.aio_open.lookup_resp.ref);
        if (ret != 0)
        {
            gossip_err("aio-open: failed to init context (path = %s)\n",
                       sm_p->u.aio_open.current_seg_path);
            free(lookup_frame);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.parent_ref.fs_id = sm_p->u.aio_open.pdir->s->pvfs_ref.fs_id;
            sm_p->u.aio_open.parent_ref.handle = sm_p->u.aio_open.lookup_resp.ref.handle;
            js_p->error_code = OPEN_FIND_FILE;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         sm_p->u.aio_open.current_seg_path,
                         llu(sm_p->u.aio_open.lookup_resp.ref.handle));
        }
    }
    else
    {
        sm_p->u.aio_open.parent_ref = lookup_frame->u.lookup.lookup_resp->ref;
        free(lookup_frame);
        js_p->error_code = OPEN_FIND_FILE;
    }
                                 
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_pdir_ref_lookup_abs_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: pdir_ref_lookup_abs_inspect\n");

    if (sm_p->u.aio_open.current_seg_path)
        free(sm_p->u.aio_open.current_seg_path);

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    js_p->error_code = lookup_frame->error_code;
    if (js_p->error_code < 0)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    sm_p->u.aio_open.parent_ref = sm_p->u.aio_open.lookup_resp.ref;
    free(lookup_frame);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_resolve_fail_file_lookup_abs(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    PVFS_fs_id lookup_fs_id;
    char pvfs_path[PVFS_PATH_MAX];
    PVFS_object_ref file;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: resolve_fail_file_lookup_setup\n");

    ret = PVFS_util_resolve(sm_p->u.aio_open.path, &lookup_fs_id,
                            pvfs_path, PVFS_PATH_MAX);
    if (ret < 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    file.handle = 0;
    file.fs_id = lookup_fs_id;

    ret = PINT_cached_config_get_root_handle(file.fs_id, &file.handle);
    if (ret < 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    if (strcmp(pvfs_path, "/") == 0)
    {
        sm_p->u.aio_open.file_ref.handle = file.handle;
        sm_p->u.aio_open.file_ref.fs_id = lookup_fs_id;
        js_p->error_code = 0;
    }
    else
    {
        PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
        if (lookup_frame == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
        memset(lookup_frame, 0, sizeof(PINT_client_sm));

        char *path = ((pvfs_path[0] == '/') ? &pvfs_path[1] : pvfs_path);

        PINT_init_msgarray_params(lookup_frame, lookup_fs_id);
        PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
        lookup_frame->u.lookup.orig_pathname = path;
        lookup_frame->u.lookup.starting_refn = file;
        lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_open.lookup_resp);
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;
        PVFS_hint_copy(sm_p->hints, &lookup_frame->hints);
        PVFS_hint_add(&lookup_frame->hints, PVFS_HINT_HANDLE_NAME,
                    sizeof(PVFS_handle),
                    &(file.handle));

        ret = initialize_context(&lookup_frame->u.lookup, path,
                                 file);
        if (ret != 0)
        {
            gossip_err("aio-open: failed to init context (path = %s)\n", path);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.file_ref.fs_id = lookup_fs_id;
            sm_p->u.aio_open.file_ref.handle = file.handle;
            js_p->error_code = 0;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         path, llu(file.handle));
        }
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_resolve_fail_file_lookup_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: resolve_fail_file_lookup_inspect\n");

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    js_p->error_code = lookup_frame->error_code;
    if (!js_p->error_code)
    {
        sm_p->u.aio_open.file_ref = sm_p->u.aio_open.lookup_resp.ref;
    }

    free(lookup_frame);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_lookup_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    
    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: file_lookup_setup\n");

    sm_p->u.aio_open.cur = sm_p->u.aio_open.filename;
    sm_p->u.aio_open.last = sm_p->u.aio_open.filename;
    sm_p->u.aio_open.start = sm_p->u.aio_open.filename;

    /* loop over chars to find a complete path segment */
    /* that is no longer than PVFS_NAME_MAX chars */
    while(*(sm_p->u.aio_open.cur))
    {
        /* find next path seperator / */
        /* cur either points to a slash */
        /* or the first char of the path */
        /* there must be at least one */
        /* so n either case increment it first */
        for(sm_p->u.aio_open.cur++;
            (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/');
            sm_p->u.aio_open.cur++);
        if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
        {
            /* we over-shot the limit go back to last */
            sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
            if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
            {
                js_p->error_code = -PVFS_ENAMETOOLONG;
                return SM_ACTION_COMPLETE;
            }
            break;
        }
        else
        {
            /* set up to add the next path segment */
            sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
        }
    }

    sm_p->u.aio_open.current_seg_path = (char *)malloc(PVFS_NAME_MAX);
    if (sm_p->u.aio_open.current_seg_path == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(sm_p->u.aio_open.current_seg_path, 0, PVFS_NAME_MAX);
    strncpy(sm_p->u.aio_open.current_seg_path, sm_p->u.aio_open.start,
            sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 2);
    sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
    sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

    PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
    if (lookup_frame == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(lookup_frame, 0, sizeof(PINT_client_sm));

    PINT_init_msgarray_params(lookup_frame, sm_p->u.aio_open.parent_ref.fs_id);
    PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
    lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_open.current_seg_path;
    lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.parent_ref;
    lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_open.lookup_resp);
    lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
    lookup_frame->u.lookup.current_context = 0;
    PVFS_hint_copy(sm_p->hints, &lookup_frame->hints);
    PVFS_hint_add(&lookup_frame->hints, PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle),
                  &(sm_p->u.aio_open.parent_ref.handle));

    ret = initialize_context(&lookup_frame->u.lookup,
                             sm_p->u.aio_open.current_seg_path,
                             sm_p->u.aio_open.parent_ref);
    if (ret != 0)
    {
        gossip_err("aio-open: failed to init context (path = %s)\n",
                   sm_p->u.aio_open.current_seg_path);
        free(lookup_frame);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    if (lookup_frame->u.lookup.current_context == 0 &&
        lookup_frame->u.lookup.contexts[0].total_segments == 0)
    {
        free(lookup_frame);
        sm_p->u.aio_open.file_ref.fs_id = sm_p->u.aio_open.parent_ref.fs_id;
        sm_p->u.aio_open.file_ref.handle = sm_p->u.aio_open.parent_ref.handle;
    }
    else
    {
        js_p->error_code = OPEN_RUN_LOOKUP_SM;
        PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

        gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                     sm_p->u.aio_open.current_seg_path,
                     llu(sm_p->u.aio_open.parent_ref.handle));
    }
  
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_lookup_setup_next(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: file_lookup_setup_next\n");

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    js_p->error_code = lookup_frame->error_code;
    if (js_p->error_code)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    if (*(sm_p->u.aio_open.cur))
    {
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_open.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_open.cur++;
                (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/');
                 sm_p->u.aio_open.cur++);
            if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
                if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
                {
                    free(lookup_frame);
                    js_p->error_code = -PVFS_ENAMETOOLONG;
                    return SM_ACTION_COMPLETE;
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
            }
        }

        memset(sm_p->u.aio_open.current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(sm_p->u.aio_open.current_seg_path, sm_p->u.aio_open.start,
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

        lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_open.current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.lookup_resp.ref;
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;

        ret = initialize_context(&lookup_frame->u.lookup,
                                 sm_p->u.aio_open.current_seg_path,
                                 sm_p->u.aio_open.lookup_resp.ref);
        if (ret != 0)
        {
            gossip_err("aio-open: failed to init context (path = %s)\n",
                       sm_p->u.aio_open.current_seg_path);
            free(lookup_frame);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.file_ref.fs_id = sm_p->u.aio_open.lookup_resp.ref.fs_id;
            sm_p->u.aio_open.file_ref.handle = sm_p->u.aio_open.lookup_resp.ref.handle;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         sm_p->u.aio_open.current_seg_path,
                         llu(sm_p->u.aio_open.lookup_resp.ref.handle));
        }
    }
    else
    {
        sm_p->u.aio_open.file_ref = lookup_frame->u.lookup.lookup_resp->ref;
        free(lookup_frame);
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_ref_lookup_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: file_lookup_inspect\n");

    if (sm_p->u.aio_open.current_seg_path)
        free(sm_p->u.aio_open.current_seg_path);

    /* file found, but EXCLUSIVE so fail */
    if ((js_p->error_code == 0) && (sm_p->u.aio_open.flags & O_EXCL) &&
        (sm_p->u.aio_open.flags & O_CREAT))
    {
        js_p->error_code = -PVFS_EEXIST;
        return SM_ACTION_COMPLETE;
    }

    /* examine file ref lookup error to see if we can work around it */
    if (js_p->error_code < 0)
    {
        if ((js_p->error_code != -PVFS_ENOENT) ||
            !(sm_p->u.aio_open.flags & O_CREAT))
        {
            return SM_ACTION_COMPLETE;
        }

        /* CREATE THE FILE */
        PVFS_sys_attr attr;
        memset(&attr, 0, sizeof(attr));
        attr.owner = geteuid();
        attr.group = getegid();
        attr.atime = time(NULL);
        attr.mtime = attr.atime;
        attr.ctime = attr.atime;
        attr.mask = PVFS_ATTR_SYS_ALL_SETABLE;

        /* Extract the users umask (and restore it to the original value) */
        mode_t mode_mask = umask(0);
        umask(mode_mask);
        mode_t user_mode = sm_p->u.aio_open.mode & ~mode_mask;

        /* set the file permissions */
        if (user_mode & S_IXOTH)
        {
            attr.perms |= PVFS_O_EXECUTE;
        }
        if (user_mode & S_IWOTH)
        {
            attr.perms |= PVFS_O_WRITE;
        }
        if (user_mode & S_IROTH)
        {
            attr.perms |= PVFS_O_READ;
        }
        if (user_mode & S_IXGRP)
        {
            attr.perms |= PVFS_G_EXECUTE;
        }
        if (user_mode & S_IWGRP)
        {
            attr.perms |= PVFS_G_WRITE;
        }
        if (user_mode & S_IRGRP)
        {
            attr.perms |= PVFS_G_READ;
        }
        if (user_mode & S_IXUSR)
        {
            attr.perms |= PVFS_U_EXECUTE;
        }
        if (user_mode & S_IWUSR)
        {
            attr.perms |= PVFS_U_WRITE;
        }
        if (user_mode & S_IRUSR)
        {
            attr.perms |= PVFS_U_READ;
        }

        if ((attr.mask & PVFS_ATTR_SYS_DFILE_COUNT) &&
            ((attr.dfile_count < 1) ||
             (attr.dfile_count > PVFS_REQ_LIMIT_DFILE_COUNT)))
        {
            gossip_err("Error: invalid number of datafiles (%d) specified "
                       "for create sm.\n", (int)attr.dfile_count);
            js_p->error_code = -PVFS_EINVAL;
            return SM_ACTION_COMPLETE;
        }

        if ((strlen(sm_p->u.aio_open.filename) + 1) > PVFS_REQ_LIMIT_SEGMENT_BYTES)
        {
            js_p->error_code = -PVFS_ENAMETOOLONG;
        }

        if (attr.owner != sm_p->cred_p->userid)
        {
            gossip_debug(GOSSIP_CLIENT_DEBUG, "Replacing owner uid %d with %d "
                     "on create\n", attr.owner, sm_p->cred_p->userid);
            attr.owner = sm_p->cred_p->userid;
        }

        if (attr.group != sm_p->cred_p->group_array[0])
        {
            gossip_debug(GOSSIP_CLIENT_DEBUG, "Replacing group uid %d with %d "
                         "on create\n", attr.group, sm_p->cred_p->group_array[0]);
            attr.group = sm_p->cred_p->group_array[0];
        }

        PINT_client_sm *create_frame = (PINT_client_sm *)malloc(sizeof(PINT_client_sm));
        if (create_frame == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        PINT_init_msgarray_params(create_frame, sm_p->u.aio_open.parent_ref.fs_id);
        PINT_init_sysint_credential(create_frame->cred_p, sm_p->cred_p);
        create_frame->u.create.object_name = sm_p->u.aio_open.filename;
        create_frame->u.create.create_resp = &sm_p->u.aio_open.create_resp;
        PINT_CONVERT_ATTR(&create_frame->u.create.attr, &attr, PVFS_ATTR_META_ALL);

        /* save the original attribute passed in. since create does it's own
         * retries we need the original attribute available on retries */
        PINT_copy_object_attr(&(create_frame->u.create.store_attr), &(create_frame->u.create.attr));

        create_frame->u.create.stored_error_code = 0;
        create_frame->u.create.retry_count = 0;
        PVFS_hint_copy(sm_p->hints, &create_frame->hints);
        PVFS_hint_add(&create_frame->hints, PVFS_HINT_HANDLE_NAME,
                      sizeof(PVFS_handle), &sm_p->u.aio_open.parent_ref.handle);
        create_frame->parent_ref = sm_p->u.aio_open.parent_ref;

        if (attr.mask & PVFS_ATTR_SYS_DFILE_COUNT)
        {
            create_frame->u.create.user_requested_num_data_files = attr.dfile_count;
        }

        create_frame->u.create.layout.algorithm = PVFS_SYS_LAYOUT_ROUND_ROBIN;
        create_frame->object_ref = sm_p->u.aio_open.parent_ref;
        create_frame->u.create.dist = get_default_distribution(create_frame->parent_ref.fs_id);
        if (!create_frame->u.create.dist)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        js_p->error_code = OPEN_CREATE_FILE;
        gossip_debug(
            GOSSIP_CLIENT_DEBUG, "Creating file %s under %llu, %d\n",
            sm_p->u.aio_open.filename, llu(sm_p->u.aio_open.parent_ref.handle),
            sm_p->u.aio_open.parent_ref.fs_id);

        PINT_sm_push_frame(smcb, 0, (void *)create_frame);
        return SM_ACTION_COMPLETE;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_create_file_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: create_file_inspect\n");

    struct PINT_client_sm *create_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);
    
    js_p->error_code = create_frame->error_code;
    free(create_frame);
    if (js_p->error_code < 0)
    {
        if (js_p->error_code == -PVFS_EEXIST)
        {
            /* the file exists, so must have been created by
             * another process, so open it
             */
            js_p->error_code = OPEN_FIND_FILE;
        }
        return SM_ACTION_COMPLETE;
    }

    sm_p->u.aio_open.file_ref = sm_p->u.aio_open.create_resp.ref;

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_setup_fildes(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    pvfs_descriptor *fildes_out;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: setup_fildes\n");

    fildes_out = pvfs_alloc_descriptor(&pvfs_ops, -1,
                 &(sm_p->u.aio_open.file_ref), 0);
    if (!fildes_out)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }
    fildes_out->s->flags = sm_p->u.aio_open.flags;
    fildes_out->is_in_use = PVFS_FS;

    if ((fildes_out->s->pvfs_ref.handle == PVFS_HANDLE_NULL) ||
        (fildes_out->s->pvfs_ref.fs_id == PVFS_FS_ID_NULL))
    {   
        js_p->error_code = -PVFS_EINVAL; 
        return SM_ACTION_COMPLETE;
    }

    /* setup getattr state machine */   
    PINT_client_sm *getattr_frame = malloc(sizeof(PINT_client_sm));
    if (getattr_frame == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(getattr_frame, 0, sizeof(PINT_client_sm));

    PINT_init_msgarray_params(getattr_frame, fildes_out->s->pvfs_ref.fs_id);
    PINT_init_sysint_credential(getattr_frame->cred_p, sm_p->cred_p);
    getattr_frame->error_code = 0;
    getattr_frame->object_ref = fildes_out->s->pvfs_ref;
    getattr_frame->u.getattr.getattr_resp_p = &(sm_p->u.aio_open.getattr_resp);
    PVFS_hint_copy(sm_p->hints, &(getattr_frame->hints));
    PVFS_hint_add(&(getattr_frame->hints), PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle), &(fildes_out->s->pvfs_ref.handle));

    PINT_SM_GETATTR_STATE_FILL(
        getattr_frame->getattr,
        fildes_out->s->pvfs_ref,
        PVFS_util_sys_to_object_attr_mask(PVFS_ATTR_SYS_ALL_NOHINT),
        PVFS_TYPE_NONE,
        0);

    PINT_sm_push_frame(smcb, 0, (void *)getattr_frame);

    *(sm_p->u.aio_open.pd) = fildes_out;

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_getattr_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;
    pvfs_descriptor *fildes_out = *(sm_p->u.aio_open.pd);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: fildes_getattr_inspect\n");

    struct PINT_client_sm *getattr_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    js_p->error_code = getattr_frame->error_code;
    free(getattr_frame);
    if (js_p->error_code < 0)
    {
        return SM_ACTION_COMPLETE;
    }

    fildes_out->s->mode = sm_p->u.aio_open.getattr_resp.attr.perms;

    if (sm_p->u.aio_open.getattr_resp.attr.objtype == PVFS_TYPE_METAFILE)
    {
        fildes_out->s->mode |= S_IFREG;
    }
    if (sm_p->u.aio_open.getattr_resp.attr.objtype == PVFS_TYPE_DIRECTORY)
    {
        fildes_out->s->mode |= S_IFDIR;
        if (sm_p->u.aio_open.pdir)
        {
            fildes_out->s->dpath = (char *)malloc(strlen(sm_p->u.aio_open.pdir->s->dpath) + strlen(sm_p->u.aio_open.path) + 2);
            strcpy(fildes_out->s->dpath, sm_p->u.aio_open.pdir->s->dpath);
            strcat(fildes_out->s->dpath, "/");
            strcat(fildes_out->s->dpath, sm_p->u.aio_open.path);
        }
        else
        {
            fildes_out->s->dpath = (char *)malloc(strlen(sm_p->u.aio_open.path) + 1);
            strcpy(fildes_out->s->dpath, sm_p->u.aio_open.path);
        }
    }
    if (sm_p->u.aio_open.getattr_resp.attr.objtype == PVFS_TYPE_SYMLINK)
    {
        fildes_out->s->mode |= S_IFLNK;
    }
    gen_mutex_unlock(&fildes_out->s->lock);
    gen_mutex_unlock(&fildes_out->lock);

    if (sm_p->u.aio_open.flags & O_TRUNC)
    {
        /* truncate the file */
        PINT_client_sm *trunc_frame = (PINT_client_sm *)
                                      malloc(sizeof(PINT_client_sm));
        if (trunc_frame == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        PINT_init_msgarray_params(trunc_frame, sm_p->u.aio_open.file_ref.fs_id);
        PINT_init_sysint_credential(trunc_frame->cred_p, sm_p->cred_p);
        trunc_frame->u.truncate.size = 0;
        trunc_frame->object_ref = sm_p->u.aio_open.file_ref;
        PVFS_hint_copy(sm_p->hints, &(trunc_frame->hints));

        PINT_SM_GETATTR_STATE_FILL(
            trunc_frame->getattr,
            trunc_frame->object_ref,
            PVFS_ATTR_META_ALL|PVFS_ATTR_COMMON_TYPE|PVFS_ATTR_CAPABILITY,
            PVFS_TYPE_METAFILE,
            PINT_SM_GETATTR_BYPASS_CACHE);

        js_p->error_code = OPEN_TRUNCATE_FILE;
        PINT_sm_push_frame(smcb, 0, (void *)trunc_frame);

        gossip_debug(
            GOSSIP_CLIENT_DEBUG, "Truncating file %s under %llu, %d\n",
            sm_p->u.aio_open.filename, llu(sm_p->u.aio_open.parent_ref.handle),
            sm_p->u.aio_open.parent_ref.fs_id);

        return SM_ACTION_COMPLETE;
    }
    
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_append_check(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    pvfs_descriptor *fildes_out = *(sm_p->u.aio_open.pd);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: file_append_check\n");

    if (sm_p->u.aio_open.flags & O_TRUNC)
    {
        int frame_id, frames_remaining;

        struct PINT_client_sm *trunc_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                              smcb, &frame_id,
                                              &js_p->error_code, &frames_remaining);
        
        js_p->error_code = trunc_frame->error_code;
        free(trunc_frame);
        if (js_p->error_code < 0)
        {
            return SM_ACTION_COMPLETE;
        }
    }

    if (sm_p->u.aio_open.flags & O_APPEND)
    {
        /* append to the file */

        if (!(fildes_out) || fildes_out->is_in_use != PVFS_FS)
        {
            js_p->error_code = -PVFS_EBADF;
            return SM_ACTION_COMPLETE;
        }
        gen_mutex_lock(&(fildes_out->s->lock));
        memset(&(sm_p->u.aio_open.getattr_resp), 0, sizeof(PVFS_sysresp_getattr));
        
        if (fildes_out->s->pvfs_ref.handle == PVFS_HANDLE_NULL ||
            fildes_out->s->pvfs_ref.fs_id == PVFS_FS_ID_NULL)
        {
            js_p->error_code = -PVFS_EINVAL;
            return SM_ACTION_COMPLETE;
        }
         
        PINT_client_sm *getattr_frame = (PINT_client_sm *)malloc(
                                        sizeof(PINT_client_sm));
        if (getattr_frame == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            gen_mutex_unlock(&(fildes_out->s->lock));
            return SM_ACTION_COMPLETE;
        }
        memset(getattr_frame, 0, sizeof(PINT_client_sm));

        PINT_init_msgarray_params(getattr_frame, fildes_out->s->pvfs_ref.fs_id);
        PINT_init_sysint_credential(getattr_frame->cred_p, sm_p->cred_p);
        getattr_frame->error_code = 0;
        getattr_frame->object_ref = fildes_out->s->pvfs_ref;
        getattr_frame->u.getattr.getattr_resp_p = &(sm_p->u.aio_open.getattr_resp);
        PVFS_hint_copy(sm_p->hints, &getattr_frame->hints);
        PVFS_hint_add(&getattr_frame->hints, PVFS_HINT_HANDLE_NAME,
                      sizeof(PVFS_handle), 
                      &(fildes_out->s->pvfs_ref.handle));

        PINT_SM_GETATTR_STATE_FILL(
            getattr_frame->getattr,
            fildes_out->s->pvfs_ref,
            PVFS_util_sys_to_object_attr_mask(
                PVFS_ATTR_SYS_SIZE),
            PVFS_TYPE_NONE,
            0);

        js_p->error_code = OPEN_FILE_APPEND;
        PINT_sm_push_frame(smcb, 0, (void *)getattr_frame);
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_append_getattr_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;
    pvfs_descriptor *fildes_out = *(sm_p->u.aio_open.pd);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: file_append_getattr_inspect\n");

    struct PINT_client_sm *getattr_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    js_p->error_code = getattr_frame->error_code;
    free(getattr_frame);
    if (js_p->error_code < 0)
    {
        gen_mutex_unlock(&(fildes_out->s->lock));
        return SM_ACTION_COMPLETE;
    }

    fildes_out->s->file_pointer = sm_p->u.aio_open.getattr_resp.attr.size;

    if (S_ISDIR(fildes_out->s->mode))
    {
        int dirent_no;

        memset(&(sm_p->u.aio_open.readdir_resp), 0, sizeof(PVFS_sysresp_readdir));
        dirent_no = fildes_out->s->file_pointer / sizeof(PVFS_dirent);
        fildes_out->s->file_pointer = dirent_no * sizeof(PVFS_dirent);
        fildes_out->s->token = PVFS_READDIR_START;

        if (dirent_no)
        {        
            if (dirent_no > PVFS_REQ_LIMIT_DIRENT_COUNT)
            {
                gossip_lerr("PVFS readdir sm unable to handle request "
                            "for %d entries.\n", dirent_no);
                js_p->error_code = -PVFS_EINVAL;
                gen_mutex_unlock(&(fildes_out->s->lock));
                return SM_ACTION_COMPLETE;
            }

            PINT_client_sm *readdir_frame = (PINT_client_sm *)malloc(
                                             sizeof(PINT_client_sm));            
            if (readdir_frame == NULL)
            {
                js_p->error_code = -PVFS_ENOMEM;
                gen_mutex_unlock(&fildes_out->s->lock);
                return SM_ACTION_COMPLETE;
            }
            memset(readdir_frame, 0, sizeof(PINT_client_sm));

            PINT_init_msgarray_params(readdir_frame,fildes_out->s->pvfs_ref.fs_id);
            PINT_init_sysint_credential(readdir_frame->cred_p, sm_p->cred_p);
            readdir_frame->u.readdir.readdir_resp = &sm_p->u.aio_open.readdir_resp;
            readdir_frame->object_ref = fildes_out->s->pvfs_ref;
            PVFS_hint_copy(sm_p->hints, &readdir_frame->hints);
            PVFS_hint_add(&readdir_frame->hints, PVFS_HINT_HANDLE_NAME,
                sizeof(PVFS_handle), &fildes_out->s->pvfs_ref.handle);

            /* point the sm dirent array and outcount to the readdir response */
            readdir_frame->readdir.dirent_array = &(sm_p->u.aio_open.readdir_resp.dirent_array);
            readdir_frame->readdir.dirent_outcount = &(sm_p->u.aio_open.readdir_resp.pvfs_dirent_outcount);
            readdir_frame->readdir.token = &(sm_p->u.aio_open.readdir_resp.token);
            readdir_frame->readdir.directory_version = &(sm_p->u.aio_open.readdir_resp.directory_version);

            readdir_frame->readdir.pos_token = fildes_out->s->token;
            readdir_frame->u.readdir.pos_token = fildes_out->s->token;
            readdir_frame->readdir.dirent_limit = dirent_no;
            readdir_frame->u.readdir.dirent_limit = dirent_no;

            gossip_debug(GOSSIP_CLIENT_DEBUG, "Doing readdir on handle "
                         "%llu on fs %d\n",
                         llu(fildes_out->s->pvfs_ref.handle),
                         fildes_out->s->pvfs_ref.fs_id);

            js_p->error_code = OPEN_FILE_APPEND;
            PINT_sm_push_frame(smcb, 0, (void *)readdir_frame);
            return SM_ACTION_COMPLETE;
        }
    }

    gen_mutex_unlock(&(fildes_out->s->lock));

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_append_readdir_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;
    pvfs_descriptor *fildes_out = *(sm_p->u.aio_open.pd);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: file_append_readdir_inspect\n");

    struct PINT_client_sm *readdir_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    js_p->error_code = readdir_frame->error_code;
    free(readdir_frame);
    if (js_p->error_code < 0)
    {
        gen_mutex_unlock(&(fildes_out->s->lock));
        return SM_ACTION_COMPLETE;
    }

    fildes_out->s->token = sm_p->u.aio_open.readdir_resp.token;
    free(sm_p->u.aio_open.readdir_resp.dirent_array);
    gen_mutex_unlock(&(fildes_out->s->lock));

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: cleanup\n");

    free((char *)sm_p->u.aio_open.path);
    if (sm_p->u.aio_open.directory)
        free(sm_p->u.aio_open.directory);
    if (sm_p->u.aio_open.filename)
        free(sm_p->u.aio_open.filename);

    sm_p->error_code = js_p->error_code;
    if (js_p->error_code < 0)
    {
        *(sm_p->u.aio_open.pd) = NULL;
    }

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

