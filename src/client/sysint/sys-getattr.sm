/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_getattr_sm
 *
 * This state machine implements the getattr system interface function.
 *
 * The input parameters are held in sm_p->u.getattr.
 *
 * The sm_p->msgpair structure is used to get the attributes of the
 * object itself.  We convert the original attribute mask (in
 * sm_p->u.getattr.attrmask) to ask for datafile and distribution info
 * if the user asked for file size (PVFS_ATTR_SYS_SIZE).  This allows us
 * to obtain this information (if the object turns out to be a metafile)
 * so that we can later look up the datafile sizes and calculate the overall
 * file size.
 *
 * The datafile handles and distribution information are stored in
 * sm_p->u.getattr also, if the object turns out to be a metafile and the 
 * caller asked for the size.  These need to be freed once we are done with
 * them.
 *
 * The sm_p->msgpairarray is used to get datafile sizes, if it turns out that
 * we need them.  This space will also need to be freed, if we grab these
 * sizes.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pvfs2-util.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

enum {
    GETATTR_NEED_SIZE = 1,
    GETATTR_NEED_DATAFILE_SIZES = 2
};

/* state function prototypes */
static int getattr_check_parameters(PINT_client_sm *sm_p,
                                    job_status_s *js_p);
static int getattr_object_getattr_setup_msgpair(PINT_client_sm *sm_p,
						job_status_s *js_p);
static int getattr_object_getattr_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p);
static int getattr_datafile_getattr_setup_msgpairarray(PINT_client_sm *sm_p,
						       job_status_s *js_p);
static int getattr_datafile_getattr_failure(PINT_client_sm *sm_p,
					    job_status_s *js_p);
static int getattr_cleanup(PINT_client_sm *sm_p,
			   job_status_s *js_p);

/* completion function prototypes */
static int getattr_object_getattr_comp_fn(void *v_p,
					  struct PVFS_server_resp *resp_p,
					  int index);
static int getattr_datafile_getattr_comp_fn(void *v_p,
					    struct PVFS_server_resp *resp_p,
					    int index);

%%

machine pvfs2_client_getattr_sm(check_parameters,
				object_getattr_setup_msgpair,
				object_getattr_xfer_msgpair,
				object_getattr_failure,
				datafile_getattr_setup_msgpairarray,
				datafile_getattr_xfer_msgpairarray,
				datafile_getattr_failure,
				cleanup)
{
    state check_parameters
    {
	run getattr_check_parameters;
	success => object_getattr_setup_msgpair;
	default => cleanup;
    }

    state object_getattr_setup_msgpair
    {
	run getattr_object_getattr_setup_msgpair;
	success => object_getattr_xfer_msgpair;
	default => cleanup;
    }

    state object_getattr_xfer_msgpair
    {
	jump pvfs2_client_getattr_acache_sm;
	success => cleanup;
	GETATTR_NEED_DATAFILE_SIZES => datafile_getattr_setup_msgpairarray;
	default => object_getattr_failure;
    }

    state object_getattr_failure
    {
	run getattr_object_getattr_failure;
	default => cleanup;
    }

    state datafile_getattr_setup_msgpairarray
    {
	run getattr_datafile_getattr_setup_msgpairarray;
	success => datafile_getattr_xfer_msgpairarray;
	default => cleanup;
    }

    state datafile_getattr_xfer_msgpairarray
    {
	jump pvfs2_client_msgpairarray_sm;
	success => cleanup;
	default => datafile_getattr_failure;
    }

    state datafile_getattr_failure
    {
	run getattr_datafile_getattr_failure;
	default => cleanup;
    }

    state cleanup
    {
	run getattr_cleanup;
	default => terminate;
    }
}

%%

int PVFS_sys_getattr(PVFS_pinode_reference pinode_ref,
		     uint32_t              attrmask, 
		     PVFS_credentials      credentials,
		     PVFS_sysresp_getattr *resp_p)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_getattr entered\n");

    if (resp_p == NULL)
    {
        gossip_lerr("NULL resp pointer\n");
        return ret;
    }
    
    if (attrmask & ~(PVFS_ATTR_SYS_ALL))
    {
        gossip_lerr("invalid attrmask\n");
        return ret;
    }

    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }

    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->error_code = 0;
    sm_p->cred_p = &credentials;
    sm_p->u.getattr.object_ref     = pinode_ref;
    sm_p->u.getattr.attrmask       = attrmask;
    sm_p->u.getattr.getattr_resp_p = resp_p;

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_GETATTR);

    while (!sm_p->op_complete && ret == 0)
    {
	ret = PINT_client_state_machine_test();
    }
    assert(ret == 0);

    error = sm_p->error_code;

    free(sm_p);
    return error;
}


/*******************************************************************/

static int getattr_check_parameters(PINT_client_sm *sm_p,
				    job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "getattr state: getattr_check_parameters\n");

    assert(js_p->error_code == 0);
    return 1;
}

/* getattr_object_getattr_setup_msgpair()
 *
 * Fills in sm_p->msgpair to perform a getattr using the getattr_acache
 * state machine.
 */
static int getattr_object_getattr_setup_msgpair(PINT_client_sm *sm_p,
						job_status_s *js_p)
{
    int ret = -1;
    uint32_t attrmask;

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) getattr state: "
                 "getattr_setup_msgpair\n", sm_p);

    /*
      adjust parameters as necessary; what's happening here
      is that we're converting sys_attr masks to obj_attr masks
      before passing the getattr request to the server.
    */
    attrmask = sm_p->u.getattr.attrmask;
    if (attrmask & PVFS_ATTR_SYS_SIZE)
    {
	/* need datafile handles and distribution in order to get 
	 * datafile handles and know what function to call to get
	 * the file size.
	 */
	attrmask &= ~PVFS_ATTR_SYS_SIZE;

	attrmask |= (PVFS_ATTR_META_DFILES | PVFS_ATTR_META_DIST);
        attrmask |= PVFS_ATTR_DATA_SIZE;
    }

    if(attrmask & PVFS_ATTR_SYS_DFILE_COUNT)
    {
	attrmask |= PVFS_ATTR_META_DFILES;
    }

    if (attrmask & PVFS_ATTR_SYS_LNK_TARGET)
    {
        attrmask &= ~PVFS_ATTR_SYS_LNK_TARGET;
        attrmask |= PVFS_ATTR_SYMLNK_TARGET;
    }

    /* fill in getattr request */
    PINT_SERVREQ_GETATTR_FILL(sm_p->msgpair.req,
			      *sm_p->cred_p,
			      sm_p->u.getattr.object_ref.fs_id,
			      sm_p->u.getattr.object_ref.handle,
			      attrmask);

    /* fill in msgpair structure components */
    sm_p->msgpair.fs_id   = sm_p->u.getattr.object_ref.fs_id;
    sm_p->msgpair.handle  = sm_p->u.getattr.object_ref.handle;
    sm_p->msgpair.comp_fn = getattr_object_getattr_comp_fn;
    ret = PINT_bucket_map_to_server(&sm_p->msgpair.svr_addr,
                                    sm_p->msgpair.handle,
                                    sm_p->msgpair.fs_id);
    if(ret != 0)
    {
	gossip_err("Error: failure mapping to server.\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* TODO: real error handling */
    }

    gossip_debug(GOSSIP_CLIENT_DEBUG, "attrmask being passed to server: ");
    PINT_attrmask_print(GOSSIP_CLIENT_DEBUG, attrmask);

    /* drop through and jump to getattr_acache state machine */
    return 1;
}

/* getattr_object_getattr_comp_fn()
 *
 * Called to copy data from getattr response into the
 * getattr-specific portion of the PINT_client_sm structure,
 * so we can use the data after returning to this state
 * machine.
 *
 * Return value is returned in job status, so it affects the
 * resulting state coming back from the nested state machine.
 *
 * Returns 0 for directory, GETATTR_NEED_DATAFILE_SIZES for a
 * metafile (when appropriate).  Returns 0 for symlink.
 * Other types die right now.
 */
static int getattr_object_getattr_comp_fn(void *v_p,
					  struct PVFS_server_resp *resp_p,
					  int index)
{
    int need_datafiles = 0;
    PVFS_object_attr *attr = NULL;

    /* this is a little kludge to get around some struct definition
     * issues in the headers.  maybe fix later?
     */
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;

    assert(resp_p->op == PVFS_SERV_GETATTR); /* sanity check */

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    /*
      if we got a metafile that didn't get a cache hit *and* we
      need the size, that should be only time we're going to have
      to do a full data file fetch.  (that's expensive)
    */
    if ((resp_p->u.getattr.attr.objtype == PVFS_TYPE_METAFILE) &&
        (!sm_p->acache_hit) &&
        (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE))
    {
        need_datafiles = 1;
    }

    /*
      if we didn't get a cache hit, we're making a
      copy of the attributes here so that we can add
      a acache entry later in cleanup.
    */
    if (!sm_p->acache_hit)
    {
        PINT_acache_object_attr_deep_copy(
            &sm_p->acache_attr, &resp_p->u.getattr.attr);
    }

    /*
      if we got a cache hit, use those attributes,
      otherwise use the real server replied attrs
    */
    attr = (sm_p->acache_hit ?
            &sm_p->pinode->attr :
            &resp_p->u.getattr.attr);
    assert(attr);

    /*
      if we got a symlink target, copy it for caller; this target
      path will be handed all the way back up to the caller via
      the PVFS_sys_attr object.  caller must free it.
    */
    if (attr->objtype == PVFS_TYPE_SYMLINK)
    {
        if (attr->mask & PVFS_ATTR_SYMLNK_TARGET)
        {
            assert(attr->u.sym.target_path_len > 0);
            assert(attr->u.sym.target_path);

            sm_p->u.getattr.getattr_resp_p->attr.link_target =
                strdup(attr->u.sym.target_path);
            if (!sm_p->u.getattr.getattr_resp_p->attr.link_target)
            {
                return -PVFS_ENOMEM;
            }
        }
    }

    /* special case for when users ask for dfile count */
    if ((attr->objtype == PVFS_TYPE_METAFILE) &&
        (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_DFILE_COUNT))
    {
	sm_p->u.getattr.getattr_resp_p->attr.dfile_count = 
	    attr->u.meta.dfile_count;
    }

    /* transform the attributes from the response
     *
     * Note: the structure in sm_p is a PVFS_sys_attr, while the data returned
     * is in a PVFS_object_attr.  So some translation is necessary.
     */
    sm_p->u.getattr.getattr_resp_p->attr.owner = attr->owner;
    sm_p->u.getattr.getattr_resp_p->attr.group = attr->group;
    sm_p->u.getattr.getattr_resp_p->attr.perms = attr->perms;
    sm_p->u.getattr.getattr_resp_p->attr.atime = attr->atime;
    sm_p->u.getattr.getattr_resp_p->attr.mtime = attr->mtime;
    sm_p->u.getattr.getattr_resp_p->attr.ctime = attr->ctime;
    sm_p->u.getattr.getattr_resp_p->attr.mask  = attr->mask;
    sm_p->u.getattr.getattr_resp_p->attr.size  = 0;
    sm_p->u.getattr.getattr_resp_p->attr.objtype = attr->objtype;

    /* on cache hit, we can skip all of the copying below;  joy! */
    if (sm_p->acache_hit)
    {
        return 0;
    }

    switch (attr->objtype)
    {
	case PVFS_TYPE_METAFILE:
	    if (sm_p->msgpair.req.u.getattr.attrmask & PVFS_ATTR_META_DIST)
            {
		/* sanity checks */
		assert(attr->mask & PVFS_ATTR_META_DIST);
		assert(attr->u.meta.dist_size > 0);
		
		gossip_debug(GOSSIP_CLIENT_DEBUG,
                             "getattr_object_getattr_comp_fn: "
                             "copying %d bytes of dist.\n",
                             attr->u.meta.dist_size);

		/* here we make a copy of the distribution information. */
		sm_p->u.getattr.dist_p = PVFS_Dist_copy(attr->u.meta.dist);
		if (sm_p->u.getattr.dist_p == NULL) {
		    assert(0);
		    return -PVFS_ENOMEM;
		}
		sm_p->u.getattr.dist_size = attr->u.meta.dist_size;

		/* nothing special about our return value here */
	    }
	    if (sm_p->msgpair.req.u.getattr.attrmask & PVFS_ATTR_META_DFILES)
            {
		/* need to save datafile handles to calculate file size;
		 * redirect us to those states.
		 */
		
		/* sanity checks */
		assert(attr->mask & PVFS_ATTR_META_DFILES);
		assert(attr->u.meta.dfile_count > 0);
		
		gossip_debug(GOSSIP_CLIENT_DEBUG,
			     "getattr_object_getattr_comp_fn: %d datafiles.\n",
			     attr->u.meta.dfile_count);
		
		/* save the datafile handles prior to freeing up the
		 * buffers we used for messages.  we could keep them around
		 * i suppose, but we're not going to do that for now.  later
		 * it is likely that this stuff will be stuck in the acache
		 * anyway, so we'll be able to just reference it from there.
		 */
		sm_p->u.getattr.datafile_handles = (PVFS_handle *)
                    malloc(attr->u.meta.dfile_count * sizeof(PVFS_handle));
                assert(sm_p->u.getattr.datafile_handles);
		sm_p->u.getattr.datafile_count = attr->u.meta.dfile_count;
		memcpy(sm_p->u.getattr.datafile_handles,
		   attr->u.meta.dfile_array,
		   attr->u.meta.dfile_count * sizeof(PVFS_handle));

                if (need_datafiles == 0)
                {
                    /*
                      if we've retrieved all attributes for the datafile
                      handles from cache, skip the expensive retrieval
                    */
                    return 0;
                }
		else if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE)
                {
		    /* if caller asked for the size, AND we couldn't
                     * retrieve them from the acache, then we need to
                     * go get the datafile sizes
		     */
		    return GETATTR_NEED_DATAFILE_SIZES;
		}
	    }
	    else return 0;
	    break;
	case PVFS_TYPE_DIRECTORY:
	    return 0;
	    break;
	case PVFS_TYPE_SYMLINK:
            return 0;
            break;
	case PVFS_TYPE_DATAFILE:
	    /* fall through */
	case PVFS_TYPE_DIRDATA:
	    /* fall through */
	default:
	    gossip_err("error: getattr_object_getattr_comp_fn: "
                       "handle refers to invalid object type\n");
	    return -PVFS_EINVAL;
    } /* end of switch() */

    return -PVFS_EINVAL; /* should not get here */
} /* getattr_object_getattr_comp_fn */


static int getattr_object_getattr_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p)
{
    gossip_debug(
        GOSSIP_CLIENT_DEBUG,
        "(%p) getattr state: getattr_object_getattr_failure\n", sm_p);

    if ((js_p->error_code != -PVFS_ENOENT) &&
        (js_p->error_code != -PVFS_EINVAL))
    {
        gossip_err("getattr: Failed with unexpected error code %d\n",
                   js_p->error_code);
    }
    return 1;
}

static int getattr_datafile_getattr_setup_msgpairarray(PINT_client_sm *sm_p,
						       job_status_s *js_p)
{
    int i;
    int ret = -1;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) getattr state: "
                 "getattr_datafile_getattr_setup_msgpairarray\n", sm_p);

    /* clear error field in job */
    js_p->error_code = 0;
    
    sm_p->msgarray = (PINT_client_sm_msgpair_state *)
	malloc(sm_p->u.getattr.datafile_count *
               sizeof(PINT_client_sm_msgpair_state));
    assert(sm_p->msgarray);

    sm_p->u.getattr.size_array = (PVFS_size *)
	malloc(sm_p->u.getattr.datafile_count * sizeof(PVFS_size));
    assert(sm_p->u.getattr.size_array);

    sm_p->msgarray_count = sm_p->u.getattr.datafile_count;

    /* for each datafile, post a send/recv pair to obtain the size */
    for (i=0; i < sm_p->msgarray_count; i++)
    {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

	gossip_debug(GOSSIP_CLIENT_DEBUG,
		     "  datafile_getattr: getting size for handle %Lu\n", 
		     Lu(sm_p->u.getattr.datafile_handles[i]));

	/* fill in getattr request; all we care about is the size */
	PINT_SERVREQ_GETATTR_FILL(msg_p->req,
				  *sm_p->cred_p,
				  sm_p->u.getattr.object_ref.fs_id,
				  sm_p->u.getattr.datafile_handles[i],
				  PVFS_ATTR_DATA_SIZE);
	
	/* fill in msgpair structure components */
	msg_p->fs_id   = sm_p->u.getattr.object_ref.fs_id;
	msg_p->handle  = sm_p->u.getattr.datafile_handles[i];
	msg_p->comp_fn = getattr_datafile_getattr_comp_fn;
    }

    /* fill in address of each server to contact */
    ret = PINT_serv_msgpairarray_resolve_addrs(
        sm_p->msgarray_count, sm_p->msgarray);
    if(ret < 0)
    {
	gossip_lerr("Error: failed to resolve server addresses.\n");
	/* TODO: handle this properly */
	assert(0);
	js_p->error_code = ret;
	return 1;
    }

    /* return immediately; next state jumps to msgpairarray machine */
    return 1;
}

static int getattr_datafile_getattr_comp_fn(void *v_p,
					    struct PVFS_server_resp *resp_p,
					    int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;

    if (resp_p->status != 0) {
	return resp_p->status;
    }

    /* sanity checks:
     * - this is a getattr response
     * - the attributes indicate that this was indeed a datafile
     * - the datafile has a positive size
     */
    assert(resp_p->op == PVFS_SERV_GETATTR);
    assert(resp_p->u.getattr.attr.objtype == PVFS_TYPE_DATAFILE);
    assert(resp_p->u.getattr.attr.u.data.size >= 0);

    gossip_debug(GOSSIP_CLIENT_DEBUG,
		 "datafile_getattr: size of datafile %d is %Ld\n",
		 index,
		 Ld(resp_p->u.getattr.attr.u.data.size));
    sm_p->u.getattr.size_array[index] = resp_p->u.getattr.attr.u.data.size;

    return 0;
}

static int getattr_datafile_getattr_failure(PINT_client_sm *sm_p,
					    job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
		 "(%p) getattr state: getattr_datafile_getattr_failure\n",
		 sm_p);
    return 1;
}

static int getattr_cleanup(PINT_client_sm *sm_p,
			   job_status_s *js_p)
{
    int ret = 0;
    uint32_t amask;
    PVFS_sys_attr *s_attr_p = &sm_p->u.getattr.getattr_resp_p->attr;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "(%p) getattr state: getattr_cleanup\n", sm_p);

    sm_p->error_code = js_p->error_code;

    if (js_p->error_code == 0)
    {
	/* calculate size of file if necessary */
	assert(s_attr_p->size == 0);

	amask = s_attr_p->mask; /* from object getattr */

        if (amask & PVFS_ATTR_META_DIST)
        {
            /*
              recompute size if it's not a acache hit, or if it is
              a acache hit on an entry that no longer has a valid size
            */
            if (!sm_p->acache_hit ||
                (sm_p->acache_hit &&
                 !(sm_p->pinode->attr.mask & PVFS_ATTR_DATA_SIZE)))
            {
                ret = PINT_Dist_lookup(sm_p->u.getattr.dist_p);
                if (ret < 0)
                {
                    assert(0);
                }

                s_attr_p->size =
                    (sm_p->u.getattr.dist_p->methods->logical_file_size)
                    (sm_p->u.getattr.dist_p->params,
                     sm_p->u.getattr.datafile_count,
                     sm_p->u.getattr.size_array);
            }
            else
            {
                s_attr_p->size = sm_p->pinode->size;
            }
        }

	/* redo the mask */
	s_attr_p->mask = PVFS_util_object_to_sys_attr_mask(s_attr_p->mask);

	/* we know we grabbed the size if they asked for it */
	if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE)
        {
	    s_attr_p->mask |= PVFS_ATTR_SYS_SIZE;
	}

        /* if this is a symlink, we know we have the target */
        if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_LNK_TARGET)
        {
            s_attr_p->mask |= PVFS_ATTR_SYS_LNK_TARGET;
        }

	PINT_attrmask_print(GOSSIP_CLIENT_DEBUG, s_attr_p->mask);

	/* free all the memory we allocated, which could include:
	 * - size array
	 * - msgpair array
	 * - datafile handle array (if not from acache)
	 * - distribution description (if not from acache)
	 */
	if (sm_p->u.getattr.size_array != NULL)
        {
	    free(sm_p->u.getattr.size_array);
	}
	if (sm_p->msgarray != NULL)
        {
	    free(sm_p->msgarray);
	}

        /*
          only free dist and dfile memory if we didn't get a
          cache hit;  if we got a acache hit, we're referencing
          memory inside the acache entries, so no allocations we
          made
        */
        if (!sm_p->acache_hit)
        {
            if ((amask & PVFS_ATTR_META_DFILES) &&
                (sm_p->u.getattr.datafile_handles != NULL))
            {
                free(sm_p->u.getattr.datafile_handles);
            }
            if ((amask & PVFS_ATTR_META_DIST) &&
                (sm_p->u.getattr.dist_p != NULL))
            {
                PVFS_Dist_free(sm_p->u.getattr.dist_p);
            }
        }

        /* add entry to acache if not already present */
        if (!sm_p->acache_hit)
        {
            int release_required = 1;
            PINT_pinode *pinode =
                PINT_acache_lookup(sm_p->u.getattr.object_ref);
            if (!pinode)
            {
                pinode = PINT_acache_pinode_alloc();
                assert(pinode);
                release_required = 0;
            }
            pinode->refn = sm_p->u.getattr.object_ref;

            if (sm_p->acache_attr.objtype == PVFS_TYPE_SYMLINK)
            {
                sm_p->acache_attr.mask &=
                    (PVFS_ATTR_SYMLNK_ALL | PVFS_ATTR_COMMON_ALL);
            }
            else if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE)
            {
                /*
                  this special case size caching in metafiles does
                  not apply at all to symlinks, so special case
                  symlinks above
                */

                pinode->size = s_attr_p->size;
                /*
                  update the attr mask in the src object so that
                  we properly copy out all required fields in the
                  deep copy below to the pinode object
                */
                sm_p->acache_attr.mask |= PVFS_ATTR_DATA_SIZE;
                /*
                  if we have the size, be sure to set the
                  META_ALL related bits since we also have
                  that information at this point
                */
                sm_p->acache_attr.mask |= PVFS_ATTR_META_ALL;
            }

            PINT_acache_object_attr_deep_copy(
                &pinode->attr, &sm_p->acache_attr);
            PINT_acache_object_attr_deep_free(
                &sm_p->acache_attr);

            PINT_acache_set_valid(pinode);

            if (release_required)
            {
                PINT_acache_release(pinode);
            }
            sm_p->acache_hit = 0;
        }
    }
    else
    {
        /* in case of failure, blank out response */ 
	memset(sm_p->u.getattr.getattr_resp_p,
               0, sizeof(PVFS_sysresp_getattr));
    }

    /* mark operation as complete */
    sm_p->op_complete = 1;

    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
