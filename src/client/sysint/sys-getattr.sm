/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */
#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pvfs2-util.h"
#include "pint-servreq.h"
#include "pint-cached-config.h"
#include "PINT-reqproto-encode.h"

/* pvfs2_client_getattr_sm
 *
 * The sm_p->msgpair structure is used to get the attributes of the
 * object itself.  We convert the original attribute mask (in
 * sm_p->u.getattr.attrmask) to ask for datafile and distribution info
 * if the user asked for file size (PVFS_ATTR_SYS_SIZE).  This allows
 * us to obtain this information (if the object turns out to be a
 * metafile) so that we can later look up the datafile sizes and
 * calculate the overall file size.
 *
 * The sm_p->msgpairarray is used to get datafile sizes, if it turns
 * out that we need them.  This space will also need to be freed, if
 * we grab these sizes.
 */

extern job_context_id pint_client_sm_context;

enum
{
    GETATTR_NEED_SIZE = 1,
    GETATTR_NEED_DATAFILE_SIZES = 2
};

/* state function prototypes */
static int getattr_object_getattr_setup_msgpair(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_object_getattr_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_datafile_getattr_setup_msgpairarray(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_datafile_getattr_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_cleanup(
    PINT_client_sm *sm_p, job_status_s *js_p);

/* completion function prototypes */
static int getattr_object_getattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
static int getattr_datafile_getattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);

%%

machine pvfs2_client_getattr_sm(
    object_getattr_setup_msgpair,
    object_getattr_xfer_msgpair,
    object_getattr_failure,
    datafile_getattr_setup_msgpairarray,
    datafile_getattr_xfer_msgpairarray,
    datafile_getattr_failure,
    cleanup)
{
    state object_getattr_setup_msgpair
    {
        run getattr_object_getattr_setup_msgpair;
        success => object_getattr_xfer_msgpair;
        default => cleanup;
    }

    state object_getattr_xfer_msgpair
    {
        jump pvfs2_client_getattr_acache_sm;
        success => cleanup;
        GETATTR_NEED_DATAFILE_SIZES => datafile_getattr_setup_msgpairarray;
        default => object_getattr_failure;
    }

    state object_getattr_failure
    {
        run getattr_object_getattr_failure;
        default => cleanup;
    }

    state datafile_getattr_setup_msgpairarray
    {
        run getattr_datafile_getattr_setup_msgpairarray;
        success => datafile_getattr_xfer_msgpairarray;
        default => cleanup;
    }

    state datafile_getattr_xfer_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        success => cleanup;
        default => datafile_getattr_failure;
    }

    state datafile_getattr_failure
    {
        run getattr_datafile_getattr_failure;
        default => cleanup;
    }

    state cleanup
    {
        run getattr_cleanup;
        default => terminate;
    }
}

%%

int PVFS_isys_getattr(
    PVFS_object_ref ref,
    uint32_t attrmask, 
    PVFS_credentials *credentials,
    PVFS_sysresp_getattr *resp_p,
    PVFS_sys_op_id *op_id,
    void *user_ptr)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_isys_getattr entered\n");

    if (resp_p == NULL)
    {
        gossip_lerr("NULL resp pointer\n");
        return ret;
    }
    
    if (attrmask & ~(PVFS_ATTR_SYS_ALL))
    {
        gossip_lerr("invalid attrmask\n");
        return ret;
    }

    sm_p = (PINT_client_sm *)malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));
    /* set msgpair default parameters */
    sm_p->msgarray_params.job_context = pint_client_sm_context;
    sm_p->msgarray_params.job_timeout = PVFS2_CLIENT_JOB_TIMEOUT;
    sm_p->msgarray_params.retry_delay = PVFS2_CLIENT_RETRY_DELAY;
    sm_p->msgarray_params.retry_limit = PVFS2_CLIENT_RETRY_LIMIT;

    PINT_init_sysint_credentials(sm_p->cred_p, credentials);
    sm_p->error_code = 0;
    sm_p->u.getattr.object_ref = ref;
    sm_p->u.getattr.attrmask = attrmask;
    sm_p->u.getattr.getattr_resp_p = resp_p;

    return PINT_client_state_machine_post(
        sm_p, PVFS_SYS_GETATTR, op_id, user_ptr);
}

int PVFS_sys_getattr(
    PVFS_object_ref ref,
    uint32_t attrmask, 
    PVFS_credentials *credentials,
    PVFS_sysresp_getattr *resp_p)
{
    int ret = -PVFS_EINVAL;
    PVFS_error error;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_getattr entered\n");

    ret = PVFS_isys_getattr(ref, attrmask, credentials,
                            resp_p, &op_id, NULL);
    if (ret)
    {
        PVFS_perror_gossip("PVFS_isys_getattr call", ret);
        error = ret;
    }
    else
    {
        ret = PINT_sys_wait(op_id, "getattr", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_sys_wait call", ret);
            error = ret;
        }
    }

    PINT_sys_release(op_id);
    return error;
}


/*******************************************************************/

static int getattr_object_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;
    uint32_t attrmask;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) getattr state: "
                 "getattr_setup_msgpair\n", sm_p);

    js_p->error_code = 0;

    /*
      adjust parameters as necessary; what's happening here
      is that we're converting sys_attr masks to obj_attr masks
      before passing the getattr request to the server.
    */
    attrmask = sm_p->u.getattr.attrmask;
    if (attrmask & PVFS_ATTR_SYS_SIZE)
    {
        /* need datafile handles and distribution in order to get 
         * datafile handles and know what function to call to get
         * the file size.
         */
        attrmask &= ~PVFS_ATTR_SYS_SIZE;

        attrmask |= (PVFS_ATTR_META_DFILES | PVFS_ATTR_META_DIST);
        attrmask |= PVFS_ATTR_DATA_SIZE;
    }

    if (attrmask & PVFS_ATTR_SYS_DFILE_COUNT)
    {
        attrmask |= PVFS_ATTR_META_DFILES;
    }

    if (attrmask & PVFS_ATTR_SYS_LNK_TARGET)
    {
        attrmask &= ~PVFS_ATTR_SYS_LNK_TARGET;
        attrmask |= PVFS_ATTR_SYMLNK_TARGET;
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "attrmask being passed to server: ");
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG, attrmask);

    PINT_SERVREQ_GETATTR_FILL(
        sm_p->msgpair.req,
        *sm_p->cred_p,
        sm_p->u.getattr.object_ref.fs_id,
        sm_p->u.getattr.object_ref.handle,
        attrmask);

    sm_p->msgpair.fs_id   = sm_p->u.getattr.object_ref.fs_id;
    sm_p->msgpair.handle  = sm_p->u.getattr.object_ref.handle;
    sm_p->msgpair.retry_flag = PVFS_MSGPAIR_RETRY;
    sm_p->msgpair.comp_fn = getattr_object_getattr_comp_fn;

    ret = PINT_cached_config_map_to_server(&sm_p->msgpair.svr_addr,
                                    sm_p->msgpair.handle,
                                    sm_p->msgpair.fs_id);
    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
    return 1;
}

/*
  copies data from getattr response into the user supplied sys_attr
  structure.  returns 0 for directories and symlinks, and
  GETATTR_NEED_DATAFILE_SIZES for a metafile (when appropriate)
*/
static int getattr_object_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index)
{
    int need_datafiles = 0;
    PVFS_object_attr *attr = NULL;
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;

    assert(resp_p->op == PVFS_SERV_GETATTR);

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }

    /*
      if we got a metafile that didn't get a cache hit *and* we need
      the size, that should be only time we're going to have to do a
      full data file fetch.  (that's expensive)
    */
    if ((resp_p->u.getattr.attr.objtype == PVFS_TYPE_METAFILE) &&
        (!sm_p->acache_hit) &&
        (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE))
    {
        need_datafiles = 1;
    }

    /*
      if we didn't get a cache hit, we're making a copy of the
      attributes here so that we can add a acache entry later in
      cleanup.
    */
    if (!sm_p->acache_hit)
    {
        PINT_acache_object_attr_deep_copy(
            &sm_p->acache_attr, &resp_p->u.getattr.attr);
    }

    attr = (sm_p->acache_hit ?
            &sm_p->pinode->attr :
            &resp_p->u.getattr.attr);
    assert(attr);

    /*
      if we got a symlink target, copy it for caller; this target
      path will be handed all the way back up to the caller via
      the PVFS_sys_attr object.  caller must free it.
    */
    if (attr->objtype == PVFS_TYPE_SYMLINK)
    {
        if (attr->mask & PVFS_ATTR_SYMLNK_TARGET)
        {
            assert(attr->u.sym.target_path_len > 0);
            assert(attr->u.sym.target_path);

            sm_p->u.getattr.getattr_resp_p->attr.link_target =
                strdup(attr->u.sym.target_path);
            if (!sm_p->u.getattr.getattr_resp_p->attr.link_target)
            {
                return -PVFS_ENOMEM;
            }
        }
    }

    /* special case for when users ask for dfile count */
    if ((attr->objtype == PVFS_TYPE_METAFILE) &&
        (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_DFILE_COUNT))
    {
        sm_p->u.getattr.getattr_resp_p->attr.dfile_count = 
            attr->u.meta.dfile_count;
    }

    /* copy outgoing sys_attr fields from returned object_attr */
    sm_p->u.getattr.getattr_resp_p->attr.owner = attr->owner;
    sm_p->u.getattr.getattr_resp_p->attr.group = attr->group;
    sm_p->u.getattr.getattr_resp_p->attr.perms = attr->perms;
    sm_p->u.getattr.getattr_resp_p->attr.atime = attr->atime;
    sm_p->u.getattr.getattr_resp_p->attr.mtime = attr->mtime;
    sm_p->u.getattr.getattr_resp_p->attr.ctime = attr->ctime;
    sm_p->u.getattr.getattr_resp_p->attr.mask  = attr->mask;
    sm_p->u.getattr.getattr_resp_p->attr.size  = 0;
    sm_p->u.getattr.getattr_resp_p->attr.objtype = attr->objtype;

    /* on cache hit, we can skip all of the copying below;  joy! */
    if (sm_p->acache_hit)
    {
        return 0;
    }

    switch (attr->objtype)
    {
        case PVFS_TYPE_METAFILE:
            if (sm_p->msgpair.req.u.getattr.attrmask &
                PVFS_ATTR_META_DIST)
            {
                assert(attr->mask & PVFS_ATTR_META_DIST);
                assert(attr->u.meta.dist && (attr->u.meta.dist_size > 0));
            }

            if (sm_p->msgpair.req.u.getattr.attrmask &
                PVFS_ATTR_META_DFILES)
            {
                assert(attr->mask & PVFS_ATTR_META_DFILES);
                assert(attr->u.meta.dfile_array &&
                       (attr->u.meta.dfile_count > 0));

                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             "getattr_object_getattr_comp_fn: "
                             "%d datafiles.\n", attr->u.meta.dfile_count);

                if (need_datafiles == 0)
                {
                    /*
                      if we've retrieved all attributes for the datafile
                      handles from cache, skip the expensive retrieval
                    */
                    return 0;
                }
                else if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE)
                {
                    /* if caller asked for the size, AND we couldn't
                     * retrieve them from the acache, then we need to
                     * retrieve the datafile sizes
                     */
                    return GETATTR_NEED_DATAFILE_SIZES;
                }
            }
            return 0;
        case PVFS_TYPE_DIRECTORY:
            return 0;
        case PVFS_TYPE_SYMLINK:
            return 0;
        case PVFS_TYPE_DATAFILE:
            /* fall through */
        case PVFS_TYPE_DIRDATA:
            /* fall through */
        default:
            gossip_err("error: getattr_object_getattr_comp_fn: "
                       "handle refers to invalid object type\n");
    }
    return -PVFS_EINVAL;
}


static int getattr_object_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p)
{
    gossip_debug(
        GOSSIP_CLIENT_DEBUG,
        "(%p) getattr state: getattr_object_getattr_failure\n", sm_p);

    if ((js_p->error_code != -PVFS_ENOENT) &&
        (js_p->error_code != -PVFS_EINVAL))
    {
        PVFS_perror_gossip("getattr_object_getattr_failure ",
                           js_p->error_code);
    }
    return 1;
}

static int getattr_datafile_getattr_setup_msgpairarray(
    PINT_client_sm *sm_p, job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0;
    PVFS_object_attr *attr = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) getattr state: "
                 "getattr_datafile_getattr_setup_msgpairarray\n", sm_p);

    js_p->error_code = 0;

    attr = (sm_p->acache_hit ?
            &sm_p->pinode->attr :
            &sm_p->acache_attr);
    assert(attr);

    sm_p->msgarray = (PINT_sm_msgpair_state *)malloc(
        attr->u.meta.dfile_count * sizeof(PINT_sm_msgpair_state));
    if (!sm_p->msgarray)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return 1;
    }

    sm_p->u.getattr.size_array = (PVFS_size *)malloc(
        attr->u.meta.dfile_count * sizeof(PVFS_size));
    if (!sm_p->u.getattr.size_array)
    {
        free(sm_p->msgarray);
        sm_p->msgarray = NULL;

        js_p->error_code = -PVFS_ENOMEM;
        return 1;
    }

    sm_p->msgarray_count = attr->u.meta.dfile_count;

    /* for each datafile, post a send/recv pair to obtain the size */
    for (i=0; i < sm_p->msgarray_count; i++)
    {
        PINT_sm_msgpair_state *msg_p = &sm_p->msgarray[i];
        assert(msg_p);

        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  datafile_getattr: getting size for handle %Lu\n", 
                     Lu(attr->u.meta.dfile_array[i]));

        PINT_SERVREQ_GETATTR_FILL(
            msg_p->req,
            *sm_p->cred_p,
            sm_p->u.getattr.object_ref.fs_id,
            attr->u.meta.dfile_array[i],
            PVFS_ATTR_DATA_SIZE);

        msg_p->fs_id = sm_p->u.getattr.object_ref.fs_id;
        msg_p->handle = attr->u.meta.dfile_array[i];
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = getattr_datafile_getattr_comp_fn;
    }

    ret = PINT_serv_msgpairarray_resolve_addrs(
        sm_p->msgarray_count, sm_p->msgarray);
    if (ret < 0)
    {
        gossip_lerr("Error: failed to resolve meta server addresses.\n");
        js_p->error_code = ret;
    }
    return 1;
}

static int getattr_datafile_getattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *)v_p;

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }

    assert(resp_p->op == PVFS_SERV_GETATTR);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "datafile_getattr: size of datafile %d is %Ld\n",
                 index, Ld(resp_p->u.getattr.attr.u.data.size));

    sm_p->u.getattr.size_array[index] =
        resp_p->u.getattr.attr.u.data.size;

    return 0;
}

static int getattr_datafile_getattr_failure(PINT_client_sm *sm_p,
                                            job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) getattr state: "
                 "getattr_datafile_getattr_failure\n", sm_p);
    return 1;
}

static int getattr_cleanup(PINT_client_sm *sm_p,
                           job_status_s *js_p)
{
    int ret = 0;
    uint32_t amask;
    PVFS_sys_attr *s_attr_p = &sm_p->u.getattr.getattr_resp_p->attr;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "(%p) getattr state: getattr_cleanup\n", sm_p);

    sm_p->error_code = js_p->error_code;

    if (js_p->error_code == 0)
    {
        /* calculate size of file if necessary */
        assert(s_attr_p->size == 0);

        amask = s_attr_p->mask; /* from object getattr */

        if (amask & PVFS_ATTR_META_DIST)
        {
            /*
              recompute size if it's not a acache hit, or if it is a
              acache hit on an entry that no longer has a valid size
            */
            if (!sm_p->acache_hit ||
                (sm_p->acache_hit &&
                 !(sm_p->pinode->attr.mask & PVFS_ATTR_DATA_SIZE)))
            {
                PINT_dist *dist = NULL;
                PVFS_object_attr *attr = (sm_p->acache_hit ?
                                          &sm_p->pinode->attr :
                                          &sm_p->acache_attr);
                assert(attr && attr->u.meta.dist);

                dist = attr->u.meta.dist;
                assert(dist->methods);

                ret = PINT_dist_lookup(dist);
                assert(ret == 0);

                s_attr_p->size = (dist->methods->logical_file_size)(
                    dist->params, attr->u.meta.dfile_count,
                    sm_p->u.getattr.size_array);
            }
            else
            {
                s_attr_p->size = sm_p->pinode->size;
            }
        }

        /* convert outgoing attribute mask based on what we got */
        s_attr_p->mask = PVFS_util_object_to_sys_attr_mask(
            s_attr_p->mask);

        /* and add the size if they asked for it */
        if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE)
        {
            s_attr_p->mask |= PVFS_ATTR_SYS_SIZE;
        }

        /* if this is a symlink, add the link target */
        if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_LNK_TARGET)
        {
            s_attr_p->mask |= PVFS_ATTR_SYS_LNK_TARGET;
        }

        if (sm_p->u.getattr.size_array)
        {
            free(sm_p->u.getattr.size_array);
            sm_p->u.getattr.size_array = NULL;
        }

        if (sm_p->msgarray && (sm_p->msgarray != &(sm_p->msgpair)))
        {
            free(sm_p->msgarray);
        }
        sm_p->msgarray = NULL;

        /* add entry to acache if not already present */
        if (!sm_p->acache_hit)
        {
            int release_required = 1;
            PINT_pinode *pinode =
                PINT_acache_lookup(sm_p->u.getattr.object_ref);
            if (!pinode)
            {
                pinode = PINT_acache_pinode_alloc();
                assert(pinode);
                release_required = 0;
            }

            gossip_debug(GOSSIP_CLIENT_DEBUG, "trying to add object "
                         "reference to acache (%s present)\n",
                         (release_required ? "already" : "not"));
            pinode->refn = sm_p->u.getattr.object_ref;

            if (sm_p->acache_attr.objtype == PVFS_TYPE_SYMLINK)
            {
                sm_p->acache_attr.mask &=
                    (PVFS_ATTR_SYMLNK_ALL | PVFS_ATTR_COMMON_ALL);
            }
            else if (sm_p->u.getattr.attrmask & PVFS_ATTR_SYS_SIZE)
            {
                /*
                  this special case size caching in metafiles does
                  not apply at all to symlinks, so special case
                  symlinks above
                */
                pinode->size = s_attr_p->size;
                /*
                  update the attr mask in the src object so that
                  we properly copy out all required fields in the
                  deep copy below to the pinode object
                */
                sm_p->acache_attr.mask |= PVFS_ATTR_DATA_SIZE;
                /*
                  if we have the size, be sure to set the
                  META_ALL related bits since we also have
                  that information at this point
                */
                sm_p->acache_attr.mask |= PVFS_ATTR_META_ALL;
            }

            PINT_acache_object_attr_deep_copy(
                &pinode->attr, &sm_p->acache_attr);
            PINT_acache_object_attr_deep_free(
                &sm_p->acache_attr);

            PINT_acache_set_valid(pinode);

            if (release_required)
            {
                PINT_acache_release(pinode);
            }
        }
    }
    else
    {
        /* in case of failure, blank out response */ 
        memset(sm_p->u.getattr.getattr_resp_p,
               0, sizeof(PVFS_sysresp_getattr));
    }

    sm_p->op_complete = 1;
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
