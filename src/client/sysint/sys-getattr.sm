/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for obtaining attributes of an object
 *  (file or directory).
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-util.h"
#include "pvfs2-util.h"
#include "pint-servreq.h"
#include "pint-cached-config.h"
#include "PINT-reqproto-encode.h"
#include "pvfs2-internal.h"

/* pvfs2_client_getattr_sm
 *
 * The sm_p->msgpair structure is used to get the attributes of the
 * object itself.  We convert the original attribute mask (in
 * sm_p->u.getattr.attrmask) to ask for datafile and distribution info
 * if the user asked for file size (PVFS_ATTR_SYS_SIZE).  This allows
 * us to obtain this information (if the object turns out to be a
 * metafile) so that we can later look up the datafile sizes and
 * calculate the overall file size.
 *
 * The sm_p->msgpairarray is used to get datafile sizes, if it turns
 * out that we need them.  This space will also need to be freed, if
 * we grab these sizes.
 */

extern job_context_id pint_client_sm_context;

enum
{
    GETATTR_ACACHE_MISS = 1,
    GETATTR_NEED_DATAFILE_SIZES = 2
};

/* state function prototypes for getattr nested machine */
static int getattr_acache_lookup(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_acache_insert(PINT_client_sm *sm_p,
                                 job_status_s *js_p);
static int getattr_object_getattr_setup_msgpair(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_object_getattr_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_datafile_getattr_setup_msgpairarray(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_datafile_getattr_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_datafile_getattr_cleanup(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int getattr_cleanup(
    PINT_client_sm *sm_p, job_status_s *js_p);

/* state function prototypes for the system interface getattr state machine */
static int getattr_set_sys_response(
    PINT_client_sm *sm_p, job_status_s *js_p);

/* completion function prototypes */
static int getattr_object_getattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
static int getattr_datafile_getattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);

%%

nested machine pvfs2_client_datafile_getattr_sizes_sm(
    datafile_getattr_setup_msgpairarray,
    datafile_getattr_xfer_msgpairarray,
    datafile_getattr_failure,
    datafile_getattr_cleanup)
{
    state datafile_getattr_setup_msgpairarray
    {
        run getattr_datafile_getattr_setup_msgpairarray;
        success => datafile_getattr_xfer_msgpairarray;
        default => datafile_getattr_failure;
    }
    
    state datafile_getattr_xfer_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        success => datafile_getattr_cleanup;
        default => datafile_getattr_failure;
    }

    state datafile_getattr_failure
    {
        run getattr_datafile_getattr_failure;
        default => datafile_getattr_cleanup;
    }

    state datafile_getattr_cleanup
    {
	run getattr_datafile_getattr_cleanup;
        default => return;
    }
}


nested machine pvfs2_client_getattr_sm(
    acache_lookup,
    object_getattr_setup_msgpair,
    object_getattr_xfer_msgpair,
    object_getattr_failure,
    datafile_get_sizes,
    acache_insert,
    cleanup)
{
    state acache_lookup
    {
        run getattr_acache_lookup;
        GETATTR_ACACHE_MISS => object_getattr_setup_msgpair;
        GETATTR_NEED_DATAFILE_SIZES => datafile_get_sizes;
        default => cleanup;
    }

    state object_getattr_setup_msgpair
    {
        run getattr_object_getattr_setup_msgpair;
        success => object_getattr_xfer_msgpair;
        default => cleanup;
    }

    state object_getattr_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => acache_insert;
        GETATTR_NEED_DATAFILE_SIZES => datafile_get_sizes;
        default => object_getattr_failure;
    }

    state acache_insert
    {
        run getattr_acache_insert;
        default => cleanup;
    }

    state object_getattr_failure
    {
        run getattr_object_getattr_failure;
        default => cleanup;
    }

    state datafile_get_sizes
    {
	jump pvfs2_client_datafile_getattr_sizes_sm;
	success => acache_insert;
        default => cleanup;
    }

    state cleanup
    {
        run getattr_cleanup;
        default => return;
    }
}

machine pvfs2_client_sysint_getattr_sm(
    dowork,
    set_sys_response)
{
    state dowork
    {
        jump pvfs2_client_getattr_sm;
        default => set_sys_response; 
    }

    state set_sys_response
    {
        run getattr_set_sys_response;
        default => terminate;
    }
}
    
%%


/** Initiate retrieval of object attributes.
 */
PVFS_error PVFS_isys_getattr(
    PVFS_object_ref ref,
    uint32_t attrmask, 
    PVFS_credentials *credentials,
    PVFS_sysresp_getattr *resp_p,
    PVFS_sys_op_id *op_id,
    void *user_ptr)
{
    PVFS_error ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_isys_getattr entered\n");

    if ((ref.handle == PVFS_HANDLE_NULL) ||
        (ref.fs_id == PVFS_FS_ID_NULL) || (resp_p == NULL))
    {
        gossip_err("invalid (NULL) required argument\n");
        return ret;
    }
    
    if (attrmask & ~(PVFS_ATTR_SYS_ALL))
    {
        gossip_err("invalid attrmask\n");
        return ret;
    }

    sm_p = (PINT_client_sm *)malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));

    PINT_init_msgarray_params(&sm_p->msgarray_params, ref.fs_id);
    PINT_init_sysint_credentials(sm_p->cred_p, credentials);
    sm_p->error_code = 0;
    sm_p->object_ref = ref;
    sm_p->u.getattr.getattr_resp_p = resp_p;
    
    PINT_SM_GETATTR_STATE_FILL(
        sm_p->getattr,
        ref,
        PVFS_util_sys_to_object_attr_mask(
            attrmask), 
        PVFS_TYPE_NONE);

    return PINT_client_state_machine_post(
        sm_p, PVFS_SYS_GETATTR, op_id, user_ptr);
}

/** Retrieve object attributes.
 */
PVFS_error PVFS_sys_getattr(
    PVFS_object_ref ref,
    uint32_t attrmask, 
    PVFS_credentials *credentials,
    PVFS_sysresp_getattr *resp_p)
{
    PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_getattr entered\n");

    ret = PVFS_isys_getattr(ref, attrmask, credentials,
                            resp_p, &op_id, NULL);
    if (ret)
    {
        PVFS_perror_gossip("PVFS_isys_getattr call", ret);
        error = ret;
    }
    else
    {
        ret = PINT_sys_wait(op_id, "getattr", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_sys_wait call", ret);
            error = ret;
        }
    }

    PINT_sys_release(op_id);
    return error;
}


/**
 * getattr_acache_lookup
 * @ingroup client_sm_getattr
 * 
 * This function is invoked as the first state action of the
 * getattr-dowork state machine.  It performs a lookup into the
 * attribute cache for the attribute in question, and returns
 * result codes for a hit or a miss.  
 * 
 * @param sm_p This must be a valid client state machine handle, with
 * the @ref getattr field containing valid values for the
 * fsid/handle of the desired attribute (in object_ref), as well as the 
 * requested attribute mask (req_attrmask).
 *
 * @param js_p Contains the return code to be set by this function in the
 * @ref error_code field.  This determines the next state action to jump
 * to in the getattr-dowork state machine.  Possible values for js_p->error_code
 * are:
 * <ul>
 * <li><b>GETATTR_ACACHE_MISS</b> - The requested attribute was not found
 * in the attribute cache, or the attribute was found, but the attribute's
 * mask did not include values required by the requested mask (req_attrmask).
 * </li>
 * <li><b>GETATTR_NEED_DATAFILE_SIZES</b> - The requested attribute was found
 * in the attribute cache and the mask was sufficient, but the data file size
 * was requested for this handle, so we need to get that next.
 * </li>
 * <li><b>default</b> - The requested attribute was found in the attribute
 * cache and its mask values were sufficient.
 * </li>
 *
 * @return This function should always return 1 unless an error occurred
 * within the internals of the state machine.
 */
static int getattr_acache_lookup(PINT_client_sm *sm_p,
				 job_status_s *js_p)
{
    uint32_t trimmed_mask = 0;
    int status = 0;
    int unexpired_masks, missing_attrs;
    PVFS_object_ref object_ref;
    PINT_pinode * pinode;

    js_p->error_code = 0;

    object_ref = sm_p->getattr.object_ref;

    assert(object_ref.handle != PVFS_HANDLE_NULL);
    assert(object_ref.fs_id != PVFS_FS_ID_NULL);

    gossip_debug(GOSSIP_ACACHE_DEBUG, "%s: handle %llu fsid %d\n",
      __func__, llu(object_ref.handle), object_ref.fs_id);

   
    /* The sys attr mask request is converted to object
     * attr mask values for comparison with the cached
     */
    if(sm_p->getattr.req_attrmask & PVFS_ATTR_DATA_SIZE)
    {
	sm_p->getattr.req_attrmask |= PVFS_ATTR_META_ALL;
    }

    pinode = PINT_acache_lookup(object_ref, &status, &unexpired_masks);
    if (pinode)
    {
        /*
          make sure pinode is not expired, and that it has all
          attribute info fields requested;
        */
        if (status == PINODE_STATUS_VALID)
        {
            /*
             * The sys attr mask request is converted to object
             * attr mask values for comparison with the cached
             * entry
             */
            trimmed_mask = sm_p->getattr.req_attrmask;
            
            /*
               the trimmed mask is used for making sure that we're only
               checking attr bits that make sense for the object type
               since the caller may have requested all attributes in
               the case where it doesn't know what type of object we're
               doing the getattr against.
               */

            if (pinode->attr.objtype == PVFS_TYPE_METAFILE)
            {
                trimmed_mask &= (PVFS_ATTR_META_ALL |
                                 PVFS_ATTR_DATA_SIZE |
                                 PVFS_ATTR_COMMON_ALL);

                /* if the DATA_SIZE is requested but not META_ALL, we need to
                 * add META_ALL since we can't compute DATA_SIZE without it
                 */
                if(trimmed_mask & PVFS_ATTR_DATA_SIZE)
                {
                    trimmed_mask |= PVFS_ATTR_META_ALL;
                }
            }
            else if (pinode->attr.objtype == PVFS_TYPE_SYMLINK)
            {
                trimmed_mask &= (PVFS_ATTR_SYMLNK_ALL | PVFS_ATTR_COMMON_ALL);
            }
            else if (pinode->attr.objtype == PVFS_TYPE_DIRECTORY)
            {
                trimmed_mask &= (PVFS_ATTR_COMMON_ALL | PVFS_ATTR_DIR_ALL);
            }

            /* trimmed_mask contains the list of attributes
             * requested for a particular object, 
             * while sm_p->pinode->attr.mask contains
             * the list of attributes cached for that object.
             * The cached attributes can be used if requested
             * is less than cached, i.e. all the attributes
             * we need are already cached.  So we need to do
             * a bitwise comparison of requested <= cached.
             *
             * xor of the two masks gives us the bits that are different,
             * and-ing that result with the requested mask gives us the
             * bits in the requested mask but not in the cached mask.
             */
            missing_attrs = ((trimmed_mask ^ unexpired_masks) &
                             trimmed_mask);
            if (missing_attrs == 0)
            {
                /* nothing's missing, a hit! */
                goto cache_hit;
            }

            /* check if the only thing missing is the file size, then
             * we don't need to do the object getattr operation, we only
             * need to do the datafile getattr operation, so we return
             * the GETATTR_NEED_DATAFILE_SIZES error code which will make
             * the getattr-dowork state machine jump to the datafile getattr
             * operation state. 
             */
            if(missing_attrs == PVFS_ATTR_DATA_SIZE)
            {
                /* if the file size is requested but the distribution info
                 * isn't and it hasn't been cached, then we need to
                 * get that first.
                 */
                PINT_SM_DATAFILE_SIZE_ARRAY_INIT(
                    &sm_p->getattr.size_array,
                    pinode->attr.u.meta.dfile_count);

                js_p->error_code = GETATTR_NEED_DATAFILE_SIZES;
                goto cache_hit;
            }
                
            /*
              normally, if we get here, we've got a cache miss.
              setattr is an exception as it now does write-through
              acache updates.  (i.e. it's a hit in invalid cases
              because it'll be updated properly on success; flushed on
              failure)
            */
            if (sm_p->op != PVFS_SYS_SETATTR)
            {
                gossip_debug(GOSSIP_ACACHE_DEBUG, "acache: sm_p->op is: %d "
                        "[%llu]\n", sm_p->op, llu(object_ref.handle));

                goto cache_miss;
            }

          cache_hit:
      
            PINT_copy_object_attr(&sm_p->getattr.attr, &pinode->attr);
            
            if(trimmed_mask & PVFS_ATTR_DATA_SIZE)
            {
                sm_p->getattr.size = pinode->size;
            }

            PINT_acache_release(pinode);

            gossip_debug(GOSSIP_ACACHE_DEBUG, "acache: acache hit "
                         "[%llu]\n", llu(object_ref.handle));
            return 1;
        }
      cache_miss:
        /*
          to avoid having an entry in the cache that doesn't exactly
          match what the caller asked for, in this case invalidate the
          entry; note invalidate implies an internal acache release.
          The entry gets added back into the cache with
        */
        gossip_debug(GOSSIP_ACACHE_DEBUG, "acache: invalid acache "
                     "miss [%llu]\n", 
                     llu(object_ref.handle));

        PINT_acache_release(pinode);
    }
    gossip_debug(GOSSIP_ACACHE_DEBUG, "acache: clean acache miss: "
                " [%llu]\n",
                  llu(object_ref.handle));

    js_p->error_code = GETATTR_ACACHE_MISS;
    return 1;
}


static int getattr_object_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;
    PVFS_object_ref object_ref;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) "
                 "getattr_setup_msgpair\n", sm_p);

    js_p->error_code = 0;

    memset(&sm_p->msgpair, 0, sizeof(PINT_sm_msgpair_state));

    object_ref = sm_p->getattr.object_ref;

    assert(object_ref.fs_id != PVFS_FS_ID_NULL);
    assert(object_ref.handle != PVFS_HANDLE_NULL);

    /* setup the msgpair to do a getattr operation */
    PINT_SERVREQ_GETATTR_FILL(
        sm_p->msgpair.req,
        *sm_p->cred_p,
        object_ref.fs_id,
        object_ref.handle,
        sm_p->getattr.req_attrmask);
    
    sm_p->msgpair.fs_id = object_ref.fs_id;
    sm_p->msgpair.handle = object_ref.handle;
    sm_p->msgpair.retry_flag = PVFS_MSGPAIR_RETRY;
    sm_p->msgpair.comp_fn = getattr_object_getattr_comp_fn;

    ret = PINT_cached_config_map_to_server(
        &sm_p->msgpair.svr_addr, sm_p->msgpair.handle,
        sm_p->msgpair.fs_id);
    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }

    /* point msgarray to the statically allocated msgpair */
    if (sm_p->msgarray != &(sm_p->msgpair))
    {
	    free(sm_p->msgarray);
    }
    sm_p->msgarray = &(sm_p->msgpair);
    sm_p->msgarray_count = 1;
    return 1;
}

/*
  copies data from getattr response into the user supplied sys_attr
  structure.  returns 0 for directories and symlinks, and
  GETATTR_NEED_DATAFILE_SIZES for a metafile (when appropriate)
*/
static int getattr_object_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index)
{
    PVFS_object_attr *attr = NULL;
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;

    assert(resp_p->op == PVFS_SERV_GETATTR);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "getattr_object_getattr_comp_fn called\n");

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }

    /*
     * If we've reached the callback for the getattr msgpair tranfer,
     * then we can make a copy of the retrieved attribute for later
     * caching.
     */
    PINT_copy_object_attr(&sm_p->getattr.attr,
                          &resp_p->u.getattr.attr);

    attr =  &sm_p->getattr.attr;
    assert(attr);

    /* if the ref_type mask is set to a non-zero value (!PVFS_TYPE_NONE)
     * a -PVFS_error will be triggered if the
     * attributes received are not one of the the types specified.
     * This is useful so that the client can know (in some cases) that it
     * can avoid issuing an operation to the server since the server will 
     * just pass an error back anyway.
     */
    if(sm_p->getattr.ref_type &&
       sm_p->getattr.ref_type != attr->objtype)
    {
        int ret;
        gossip_debug(GOSSIP_CLIENT_DEBUG, "*** "
                     "getattr_comp_fn: Object type mismatch.\n Possibly "
                     "saving network roundtrip by returning an error\n");

        if (sm_p->getattr.ref_type == PVFS_TYPE_DIRECTORY)
        {
            ret = -PVFS_ENOTDIR;
        }
        else
        {
            assert(sm_p->getattr.ref_type == PVFS_TYPE_METAFILE);
            ret = ((attr->objtype == PVFS_TYPE_DIRECTORY) ?
                   -PVFS_EISDIR : -PVFS_EBADF);
        }
        PVFS_perror_gossip("Object Type mismatch error", ret);
        return ret;
    }

    /* do assertion checking of getattr response values, and
     * check if file sizes are needed.  With NDEBUG defined, this block
     * only checks if file sizes are needed.
     */
    switch (attr->objtype)
    {
        case PVFS_TYPE_METAFILE:
            if (sm_p->msgpair.req.u.getattr.attrmask &
                PVFS_ATTR_META_DIST)
            {
                /* if we requested distribution attrs, did the distribution 
                 * get set and is the size valid?
                 */
                assert(attr->mask & PVFS_ATTR_META_DIST);
                assert(attr->u.meta.dist && (attr->u.meta.dist_size > 0));
            }

            if (sm_p->msgpair.req.u.getattr.attrmask &
                PVFS_ATTR_META_DFILES)
            {
                /* if we requested the datafile handles for the file, did
                 * the datafile array get populated?
                 */
                assert(attr->u.meta.dfile_array &&
                       (attr->u.meta.dfile_count > 0));

                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             "getattr_object_getattr_comp_fn: "
                             "%d datafiles.\n", attr->u.meta.dfile_count);
                
                /* if we need the size, that should be the only time we're 
                 * going to have to do a full data file fetch. 
                 * (that's expensive)
                 */
                if (sm_p->getattr.req_attrmask & PVFS_ATTR_DATA_SIZE)
                {
                    /* if caller asked for the size, then we need
                     * to jump to the datafile_getattr state, which
                     * will retrieve the datafile sizes for us.
                     */
                    PINT_SM_DATAFILE_SIZE_ARRAY_INIT(
                        &sm_p->getattr.size_array,
                        attr->u.meta.dfile_count);
                    return GETATTR_NEED_DATAFILE_SIZES;
                }
            }
            return 0;
        case PVFS_TYPE_DIRECTORY:
            return 0;
        case PVFS_TYPE_SYMLINK:
            return 0;
        case PVFS_TYPE_DATAFILE:
	    return 0;
        case PVFS_TYPE_DIRDATA:
	    return 0;
        default:
            gossip_err("error: getattr_object_getattr_comp_fn: "
                       "handle refers to invalid object type\n");
    }
    return -PVFS_EINVAL;
}


static int getattr_object_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p)
{
    gossip_debug(
        GOSSIP_CLIENT_DEBUG,
        "(%p) getattr state: getattr_object_getattr_failure\n", sm_p);

    if ((js_p->error_code != -PVFS_ENOENT) &&
        (js_p->error_code != -PVFS_EINVAL))
    {
        PVFS_perror_gossip("getattr_object_getattr_failure ",
                           js_p->error_code);
    }

    return 1;
}

static int getattr_datafile_getattr_setup_msgpairarray(
    PINT_client_sm *sm_p, job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0;
    PVFS_object_attr *attr = NULL;

    js_p->error_code = 0;

    attr = &sm_p->getattr.attr;
    assert(attr);

    sm_p->msgarray = (PINT_sm_msgpair_state *)malloc(
        attr->u.meta.dfile_count * sizeof(PINT_sm_msgpair_state));
    if (!sm_p->msgarray)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return 1;
    }

    sm_p->msgarray_count = attr->u.meta.dfile_count;

    /* for each datafile, post a send/recv pair to obtain the size */
    for(i = 0; i < sm_p->msgarray_count; i++)
    {
        PINT_sm_msgpair_state *msg_p = &sm_p->msgarray[i];
        assert(msg_p);

        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  datafile_getattr: getting size for handle %llu\n",
                     llu(attr->u.meta.dfile_array[i]));

        PINT_SERVREQ_GETATTR_FILL(
            msg_p->req,
            *sm_p->cred_p,
            sm_p->getattr.object_ref.fs_id,
            attr->u.meta.dfile_array[i],
            PVFS_ATTR_DATA_SIZE);

        msg_p->fs_id = sm_p->getattr.object_ref.fs_id;
        msg_p->handle = attr->u.meta.dfile_array[i];
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = getattr_datafile_getattr_comp_fn;
    }

    ret = PINT_serv_msgpairarray_resolve_addrs(
        sm_p->msgarray_count, sm_p->msgarray);
    if (ret < 0)
    {
        gossip_lerr("Error: failed to resolve meta server addresses.\n");
        js_p->error_code = ret;
    }
    return 1;
}

static int getattr_datafile_getattr_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *)v_p;

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }

    assert(resp_p->op == PVFS_SERV_GETATTR);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "datafile_getattr: size of datafile %d is %lld\n",
                 index, lld(resp_p->u.getattr.attr.u.data.size));

    sm_p->getattr.size_array[index] =
        resp_p->u.getattr.attr.u.data.size;

    return 0;
}

static int getattr_datafile_getattr_failure(PINT_client_sm *sm_p,
                                            job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) getattr state: "
                 "getattr_datafile_getattr_failure\n", sm_p);
    return 1;
}

static int getattr_datafile_getattr_cleanup(PINT_client_sm *sm_p,
                                            job_status_s *js_p)
{
    if(js_p->error_code == 0)
    {
        if (sm_p->msgarray)
        {
            free(sm_p->msgarray);
        }
        sm_p->msgarray = NULL;
    }

    return 1;
}

static int getattr_acache_insert(PINT_client_sm *sm_p,
                                 job_status_s *js_p)
{
    PVFS_object_attr *attr = NULL;
    int release_required = 1;
    PINT_pinode *pinode = PINT_acache_lookup(
        sm_p->getattr.object_ref, NULL, NULL);
    if (!pinode)
    {
        pinode = PINT_acache_pinode_alloc();
        if(!pinode)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return 1;
        }

        release_required = 0;
    }

    attr = &sm_p->getattr.attr;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "trying to add object "
                 "reference to acache (%s present)\n",
                 (release_required ? "already" : "not"));
    pinode->refn = sm_p->getattr.object_ref;

    if (attr->objtype == PVFS_TYPE_METAFILE &&
        sm_p->getattr.req_attrmask & PVFS_ATTR_DATA_SIZE)
    {
        ;
        /* compute size as requested */
        PINT_dist *dist = NULL;
        assert(attr->u.meta.dist);
        dist = attr->u.meta.dist;

        /* XXX - decode_PINT_dist calls PINT_dist_lookup, so there's
         * no need to do it again.  -slang
         *
         * ret = PINT_dist_lookup(attr->u.meta.dist);
         */
        assert(dist->methods &&
               dist->methods->logical_file_size);
        
        sm_p->getattr.size = (dist->methods->logical_file_size)(
            dist->params, attr->u.meta.dfile_count,
            sm_p->getattr.size_array);

        pinode->size = sm_p->getattr.size;

        /*
           update the attr mask in the src object so that
           we properly copy out all required fields in the
           deep copy below to the pinode object
           */
        sm_p->getattr.attr.mask |= PVFS_ATTR_DATA_SIZE;
    }

    PINT_copy_object_attr(&pinode->attr, &sm_p->getattr.attr);

    PINT_acache_set_valid(pinode);

    if (release_required)
    {
        PINT_acache_release(pinode);
    }

    return 1;
}

static int getattr_cleanup(PINT_client_sm *sm_p,
                           job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "(%p) getattr state: getattr_cleanup\n", sm_p);

    sm_p->error_code = js_p->error_code;

    PINT_SM_DATAFILE_SIZE_ARRAY_DESTROY(&sm_p->getattr.size_array);

    return 1;
}

static int getattr_set_sys_response(PINT_client_sm *sm_p,
                                    job_status_s *js_p)
{
    PVFS_sysresp_getattr * sysresp = NULL;
    PVFS_object_attr *attr = NULL;

    if(js_p->error_code != 0)
    {
        sm_p->op_complete = 1;
        return 0;
    }

    attr = &sm_p->getattr.attr;
    assert(attr);
    
    /* If we get to this state action, 
     * the getattr state machine was invoked, so
     * we can assume that one of the PVFS_[i]sys_getattr functions
     * was called, and the response field must be filled in for the
     * user.
     */

    sysresp = sm_p->u.getattr.getattr_resp_p;
    
    /*
     * if we retrieved a symlink target, copy it for the caller; this
     * target path will be handed all the way back up to the caller via
     * the PVFS_sys_attr object.  The caller of PVFS_[i]sys_getattr
     * must free it.
     */
    if(attr->objtype == PVFS_TYPE_SYMLINK &&
       attr->mask & PVFS_ATTR_SYMLNK_TARGET)
    {
        assert(attr->u.sym.target_path_len > 0);
        assert(attr->u.sym.target_path);

        sysresp->attr.link_target = strdup(attr->u.sym.target_path);
        if(!sysresp->attr.link_target)
        {
           js_p->error_code = -PVFS_ENOMEM;
           return 0;
        }
    }

    /* special case for when users ask for dfile count */
    if(attr->objtype == PVFS_TYPE_METAFILE &&
       sm_p->getattr.req_attrmask & PVFS_ATTR_SYS_DFILE_COUNT)
    {
        sysresp->attr.dfile_count = attr->u.meta.dfile_count;
    }

    /* copy outgoing sys_attr fields from returned object_attr */
    sysresp->attr.owner = attr->owner;
    sysresp->attr.group = attr->group;
    sysresp->attr.perms = attr->perms;
    sysresp->attr.atime = attr->atime;
    sysresp->attr.mtime = attr->mtime;
    sysresp->attr.ctime = attr->ctime;
    sysresp->attr.mask  = PVFS_util_object_to_sys_attr_mask(attr->mask);
    sysresp->attr.size  = 0;
    sysresp->attr.objtype = attr->objtype;

    if (js_p->error_code == 0)
    {
 
        /* convert outgoing attribute mask based on what we got */
        sysresp->attr.mask = PVFS_util_object_to_sys_attr_mask(
            sm_p->getattr.attr.mask);

       if (sm_p->getattr.req_attrmask & PVFS_ATTR_DATA_SIZE)
        {
            sysresp->attr.size = sm_p->getattr.size;
            sysresp->attr.mask |= PVFS_ATTR_SYS_SIZE;
        }

        /* if this is a symlink, add the link target */
        if (sm_p->getattr.req_attrmask & PVFS_ATTR_SYMLNK_TARGET)
        {
            sysresp->attr.mask |= PVFS_ATTR_SYS_LNK_TARGET;
        }
    }
    else
    {
        /* in case of failure, blank out response */ 
        memset(sm_p->u.getattr.getattr_resp_p,
               0, sizeof(PVFS_sysresp_getattr));
    }

    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);
    sm_p->op_complete = 1;
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
