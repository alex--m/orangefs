/* 
 * (C) 2012 Clemson University
 *
 * See COPYING in top-level directory.
 */

enum
{
    OPEN_PDIR_GIVEN = 924;
    OPEN_PDIR_NULL,
    OPEN_RUN_LOOKUP_SM,
    OPEN_FIND_FILE,
    OPEN_FILE_FOUND  
};

/* helper function prototypes */
static int initialize_context(
    struct PINT_client_lookup_sm * lookup_sm,
    char *pathname,
    PVFS_object_ref ctx_starting_refn);

static void finalize_context(
    PINT_client_lookup_sm_ctx *ctx);

%%

machine pvfs2_client_aio_open_sm
{
    state init
    {
        run open_init;
        OPEN_PDIR_GIVEN => pdir_given;
        OPEN_PDIR_NULL => pdir_lookup;
        default => ****ERROR**** /* TODO: */
    }

    state pdir_given
    {
        run open_pdir_lookup_given;
        OPEN_RUN_LOOKUP_SM => pdir_ref_lookup_rel;
        OPEN_FIND_FILE => file_lookup_setup;
        default => /* TODO: WHAT ????? */
    }

    state pdir_lookup
    {
        run open_pdir_lookup;
        OPEN_RUN_LOOKUP_SM => pdir_ref_lookup_abs;
        OPEN_FIND_FILE => file_lookup_setup;
        default => /* TODO: */ 
    }

    state pdir_ref_lookup_rel
    {
        jump pvfs2_client_lookup_sm;
        success => pdir_ref_lookup_rel_setup_next;
        default => /* TODO: HANDE ERR */ 
    }

    state pdir_ref_lookup_abs
    {
        jump pvfs2_client_lookup_sm;
        success => pdir_ref_lookup_abs_inspect;
        default => /* TODO: ERROR */
    }

    state pdir_ref_lookup_rel_setup_next
    {
        run open_setup_next_rel_lookup;
        OPEN_RUN_LOOKUP_SM => pdir_ref_lookup_rel;
        OPEN_FIND_FILE => file_lookup_setup;
        default => /* TODO:HANDLE ERR */
    }

    state pdir_ref_lookup_abs_inspect
    {
        run open_pdir_ref_lookup_abs_inspect;
        success => file_lookup_setup;
        default => /* TODO: error */
    }

    state file_lookup_setup
    {
        run open_file_lookup_setup;
        OPEN_RUN_LOOKUP_SM => file_lookup;
        OPEN_FILE_FOUND => file_found;
        default => /* TODO: Err */ 
    }

    state file_lookup
    {
        jump pvfs2_client_lookup_sm;
        success => file_lookup_setup_next;
        default => /* TODO: ERROR */
    }

    state file_lookup_setup_next
    {
        run open_file_lookup_setup_next;
        OPEN_RUN_LOOKUP_SM => file_lookup;
        OPEN_FILE_FOUND => file_found;
        default => /* TODO: ERROR */
    }

    state file_found
    {

    }
}

%%

static int initialize_context(
    struct PINT_client_lookup_sm * lookup_sm,
    char *pathname,
    PVFS_object_ref ctx_starting_refn)
{
    int i, ret = -PVFS_EINVAL, pathlen = 0, num_segments = 0;
    void *state = NULL;
    int cur_seg_index = 0, prev_ctx_index = 0;
    char *cur_seg_name = NULL;
    char *orig_pathname = NULL, *seg_remaining = NULL, *slash_str = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;
    int num_consecutive_prev_ctx_dot_dots = 0;
    PINT_client_lookup_sm_ctx *ctx = NULL;
    PINT_client_lookup_sm_ctx *prev_ctx = NULL;

    gossip_debug(GOSSIP_LOOKUP_DEBUG, "initialize_context called\n");

    assert(lookup_sm->current_context <= lookup_sm->context_count);

    if(lookup_sm->current_context == lookup_sm->context_count)
    {
        /* we have used the last available context */
        lookup_sm->context_count++;
        if(lookup_sm->context_count == 1)
        {
            lookup_sm->contexts = malloc(sizeof(PINT_client_lookup_sm_ctx));
            if(!lookup_sm->contexts)
            {
                return -PVFS_ENOMEM;
            }
        }
        else
        {
            /* not the first one, so realloc to get one more */
            lookup_sm->contexts = realloc(lookup_sm->contexts,
                                          sizeof(PINT_client_lookup_sm_ctx) *
                                          lookup_sm->context_count);
            if(!lookup_sm->contexts)
            {
                return -PVFS_ENOMEM;
            }
        }
    }

    if (pathname && (lookup_sm->current_context > -1))
    {
        ctx = &lookup_sm->contexts[lookup_sm->current_context];
        assert(ctx);

        prev_ctx_index = (lookup_sm->current_context - 1);

        pathlen = strlen(pathname);
        num_segments = PINT_string_count_segments(pathname);

        if ((pathlen == 0) || (num_segments == 0))
        {
            return ret;
        }

        if ((pathlen > (PVFS_REQ_LIMIT_PATH_NAME_BYTES - 1)) ||
            (num_segments > MAX_LOOKUP_SEGMENTS))
        {
            gossip_err("Filename %s is too long\n", pathname);
            return -PVFS_ENAMETOOLONG;
        }

        memset(ctx, 0, sizeof(PINT_client_lookup_sm_ctx));

        ctx->current_segment = 0;
        ctx->total_segments = 0;
        ctx->ctx_starting_refn = ctx_starting_refn;

        /* initialize all segments within the context */
        orig_pathname = strdup(pathname);
        gossip_debug(GOSSIP_LOOKUP_DEBUG, " original pathname is: %s\n",
                     orig_pathname);
        while(!PINT_string_next_segment(pathname,&cur_seg_name,&state))
        {
            /* grab the next segment in the context to fill in */
            cur_seg = &(ctx->segments[cur_seg_index]);
            assert(cur_seg);
            memset(cur_seg, 0, sizeof(PINT_client_lookup_sm_segment));

            gossip_debug(GOSSIP_LOOKUP_DEBUG, " cur_seg_name[%d]: %s\n",
                         cur_seg_index, cur_seg_name);
            gossip_debug(GOSSIP_LOOKUP_DEBUG, " pathname is: %s\n",
                         pathname);

            if (strcmp(cur_seg_name,".") == 0)
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;

                gossip_debug(GOSSIP_LOOKUP_DEBUG,
                             " ignoring useless segment\n");
                continue;
            }
            else if (strcmp(cur_seg_name,"..") == 0)
            {
                /*
                   if this isn't true, we need to
                   grab the previous context's previous segment

                   if this weren't true, we'd normally:
                   assert(cur_seg_index > 0);
                */
                if ((cur_seg_index < 1) ||
                    (num_consecutive_prev_ctx_dot_dots > 0))
                {
                    PINT_client_lookup_sm_segment *prev_ctx_prev_seg;

                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG, "  got a '..' segment that "
                        "requires attention of the previous context\n");

                  init_next_prev_segment:
                    /*
                      grab the previous context to access the segments
                      within it, assuming a previous context is
                      available
                    */
                    if (prev_ctx_index < 0)
                    {
                        gossip_debug(GOSSIP_LOOKUP_DEBUG, "there are no "
                                     "more previous contexts available: "
                                     "failing lookup\n");
                        free(orig_pathname);
                        return -PVFS_ENOENT;
                    }

                    prev_ctx = &lookup_sm->contexts[prev_ctx_index];
                    assert(prev_ctx);
                    assert(prev_ctx->current_segment > 0);

                    num_consecutive_prev_ctx_dot_dots++;
                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG, "num consecutive '..' "
                        "segments requiring the previous segment "
                        "is now %d\n", num_consecutive_prev_ctx_dot_dots);

                    /*
                      further, if we have a number of consecutive '..'
                      segments, we may need to keep backing up into
                      the previous contexts' space
                    */
                    if (prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots < 0)
                    {
                        /* skip to next previous context, if any */
                        if (prev_ctx_index > -1)
                        {
                            /*
                              bump down dot dot count since it wasn't
                              used yet if we got here
                            */
                            num_consecutive_prev_ctx_dot_dots--;
                            prev_ctx_index--;
                            goto init_next_prev_segment;
                        }
                        gossip_debug(
                            GOSSIP_LOOKUP_DEBUG, "there are no more segments "
                            "in the previous context: failing lookup\n");
                        free(orig_pathname);
                        return -PVFS_ENOENT;
                    }

                    prev_ctx_prev_seg = &prev_ctx->segments[
                        prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots];
                    assert(prev_ctx_prev_seg);

                    /*
                      instead of decrementing the seg index and
                      continuing, we need to replace the last segment
                      copied from the last context in this case.  (so
                      we drop through to segment init)
                    */
                    ctx_starting_refn =
                        prev_ctx_prev_seg->seg_starting_refn;
                    cur_seg_name = prev_ctx_prev_seg->seg_name;
                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG,
                        "using previous segment: %s\n", cur_seg_name);

                    cur_seg_index--;
                }
                else
                {
                    gossip_debug(GOSSIP_LOOKUP_DEBUG,
                                 "  got a '..' segment\n");
                    cur_seg_index--;
                    continue;
                }
            }
            else
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;
            }

            /*
              fill in the current segment now.  the first segment
              MUST have the same starting refn as the context
            */
            if (cur_seg_index == 0)
            {
                cur_seg->seg_starting_refn = ctx_starting_refn;
            }
            if (cur_seg->seg_name)
            {
                free(cur_seg->seg_name);
            }
            cur_seg->seg_name = strdup(cur_seg_name);
            assert(cur_seg->seg_name);

            slash_str = orig_pathname;
            for (i = 0; i < cur_seg_index; i++) {
                slash_str = strchr(slash_str, '/');
                if (slash_str == NULL) {
                    break;
                }
                slash_str++;
            }
            /* seg_remaining = strstr(orig_pathname, cur_seg_name); */
            seg_remaining = slash_str;
            if (seg_remaining)
            {
                gossip_debug(GOSSIP_LOOKUP_DEBUG,
                             " *seg_remaining is: %s\n", seg_remaining);

                cur_seg->seg_remaining = strdup(seg_remaining);
                assert(cur_seg->seg_remaining);
            }
            else
            {
                cur_seg->seg_remaining = NULL;
            }

            cur_seg_index++;
        }
        free(orig_pathname);

#if 0
    /* DEBUGGING ONLY */
    {
        int i = 0;
        gossip_debug(GOSSIP_LOOKUP_DEBUG, "Processed context path is:\n");
        for(i = 0; i < cur_seg_index; i++)
        {
            assert(ctx->segments[i].seg_name);
            gossip_debug(GOSSIP_LOOKUP_DEBUG, "/%s", 
                         ctx->segments[i].seg_name);
        }
        gossip_debug(GOSSIP_LOOKUP_DEBUG, "\n");
    }
#endif

        ctx->total_segments = cur_seg_index;
        assert(ctx->current_segment == 0);
        ret = 0;
    }
    return ret;
}

static void finalize_context(
    PINT_client_lookup_sm_ctx *ctx)
{
    int i = 0;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    for(i = 0; i < MAX_LOOKUP_SEGMENTS; i++)
    {
        cur_seg = &ctx->segments[i];
        assert(cur_seg);

        if (cur_seg->seg_name)
        {
            gossip_debug(GOSSIP_LOOKUP_DEBUG, "Freeing segment %s\n",
                         cur_seg->seg_name);
            free(cur_seg->seg_name);
            cur_seg->seg_name = NULL;
        }

        if (cur_seg->seg_remaining)
        {
            gossip_debug(GOSSIP_LOOKUP_DEBUG, "Freeing remaining "
                         "segment %s\n", cur_seg->seg_remaining);
            free(cur_seg->seg_remaining);
            cur_seg->seg_remaining = NULL;
        }
        PINT_free_object_attr(&(cur_seg->seg_attr));
    }
}

/****************************************************************/

PVFS_error PVFS_iaio_open(
    const char *path,
    int flags,
    PVFS_hint file_creation_param,
    mode_t mode,
    pvfs_descriptor *pdir,
    const PVFS_credential *credential,
    PVFS_sys_op_id *op_id,
    PVFS_hint hints,
    void *user_ptr)
{
    PVFS_error ret = -PVFS_EINVAL;
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_iaio_open entered\n");

    /* TODO:CHECK ARGUMENTS FOR ERRORS */


    PINT_smcb_alloc(&smcb, PVFS_CLIENT_AIO_OPEN,
             sizeof(struct PINT_client_sm),
             client_op_state_get_machine,
             client_state_machine_terminate,
             pint_client_sm_context);
    if (smcb == NULL)
    {
        return -PVFS_ENOMEM;
    }
    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    PINT_init_sysint_credential(sm_p->cred_p, credential);
    sm_p->u.aio_open.path = path;
    sm_p->u.aio_open.flags = flags;
    sm_p->u.aio_open.pdir = pdir;
    sm_p->u.aio_open.file_creation_param = file_creation_param;
    sm_p->u.aio_open.mode = mode;
    memset(sm_p->u.aio_open.parent_ref, 0, sizeof(PVFS_object_ref));

    return PINT_client_state_machine_post(
        smcb, op_id, user_ptr);
}

PVFS_error PVFS_aio_open(
    const char *path,
    int flags, 
    PVFS_hint file_creation_param,
    mode_t mode,
    pvfs_descriptor *pdir,
    const PVFS_credential *credential,
    PVFS_hint hints)
{
    PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_aio_open entered\n");

    ret = PVFS_iaio_open(path, flags, file_creation_param, mode, pdir,
                   credential, &op_id, hints, NULL);

    if (ret)
    {
        PVFS_perror_gossip("PVFS_iaio_open call", ret);
        error = ret;
    }
    else
    {
        ret = PVFS_sys_wait(op_id, "aio_open", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_sys_wait call", ret);
            error = ret;
        }
    }

    PINT_sys_release(op_id);
    return error;
}

/*******************************************************************/

static PINT_sm_action open_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_open state: init\n");

    /* TODO: MEMSETS? */
    pvfs_sys_init();

    ret = split_pathname(sm_p->u.aio_open.path, 0,
                &(sm_p->u.aio_open.directory),
                &(sm_p->u.aio_open.filename));
    /* TODO: CHECK ERROR HERE */

    /* Check the flags to determine if links are followed */
    if (sm_p->u.aio_open.flags & O_NOFOLLOW)
    {
        sm_p->u.aio_open.follow_link = PVFS2_LOOKUP_LINK_NO_FOLLOW;
    }
    else
    {
        sm_p->u.aio_open.follow_link = PVFS2_LOOKUP_LINK_FOLLOW;
    }

    /* check to see if a parent directory descriptor is passed in */
    if (sm_p->u.aio_open.pdir == NULL)
    {
        js_p->error_code = OPEN_PDIR_NULL;
    }
    else
    {
        js_p->error_code = OPEN_PDIR_GIVEN;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_pdir_lookup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;a
    PVFS_fs_id lookup_fs_id;
    char pvfs_path[PVFS_PATH_MAX];
    PVFS_object_ref parent;

    ret = PVFS_util_resolve(sm_p->u.aio_open.directory, &lookup_fs_id,
                            pvfs_path, PVFS_PATH_MAX);
    if (ret < 0)
    {
        /* TODO: HANDLE ERR */
    }

    parent.handle = 0;
    parent.fs_id = lookup_fs_id;

    ret = PINT_cached_config_get_root_handle(parent.fs_id, &parent.handle);
    if (ret < 0)
    {
        /* TODO: handle */
    }

    if (strcmp(pvfs_path, "/") == 0)
    {
        sm_p->u.aio_open.parent_ref.handle = parent.handle;
        sm_p->u.aio_open.parent_ref.fs_id = lookup_fs_id;
        js_p->error_code = OPEN_FIND_FILE;
    }
    else
    {
        PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
        if (lookup_frame == NULL)
        {
            /* TODO: ERROR */
        }

        char *path = ((pvfs_path[0] == '/') ? &pvfs_path[1] : pvfs_path);

        PINT_init_msgarray_params(lookup_frame, lookup_fs_id);
        PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
        lookup_frame->u.lookup.orig_pathname = path;
        lookup_frame->u.lookup.starting_refn = parent;
        lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_open.lookup_resp);
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;
        PVFS_hint_copy(sm_p->hints, &lookup_frame->hints);
        PVFS_hint_add(&lookup_frame->hints, PVFS_HINT_HANDLE_NAME,
                    sizeof(PVFS_handle),
                    &(parent.handle));

        ret = initialize_context(&lookup_frame->u.lookup, path,
                                 sm_p->u.aio_open.parent_ref);
        if (ret != 0)
        {
            /*TODO: HANDLE THIS ERR */
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.parent_ref.fs_id = lookup_fs_id;
            sm_p->u.aio_open.parent_ref.handle = parent.handle;
            js_p->error_code = OPEN_FIND_FILE;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);
        }
    }

    return SM_ACTION_COMPLETE;
} 

static PINT_sm_action open_pdir_lookup_given(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;

    if (sm_p->u.aio_open.directory)
    {
        sm_p->u.aio_open.cur = sm_p->u.aio_open.directory;
        sm_p->u.aio_open.last = sm_p->u.aio_open.directory;
        sm_p->u.aio_open.start = sm_p->u.aio_open.directory;
    
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_open.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_open.cur++;
                (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/')
                 sm_p->u.aio_open.cur++);
            if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
                if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
                {
                    /*TODO: HANDLE ERR */
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
            }
        }
        
        char current_seg_path[PVFS_NAME_MAX];
        memset(current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(current_seg_path, sm_p->u.aio_open.start,
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

        if (current_seg_path == NULL)
        {
            /*TODO: ERROR */
        }
        
        PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
        if (lookup_frame == NULL)
        {
            /* TODO: ERROR */
        }

        PINT_init_msgarray_params(lookup_frame, sm_p->u.aio_open.pdir->s->pvfs_ref.fs_id);
        PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
        lookup_frame->u.lookup.orig_pathname = current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.pdir->s->pvfs_ref;
        lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_open.lookup_resp);
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;
        PVFS_hint_copy(sm_p->hints, &lookup_frame->hints);
        PVFS_hint_add(&lookup_frame->hints, PVFS_HINT_HANDLE_NAME,
                    sizeof(PVFS_handle),
                    &(sm_p->u.aio_open.pdir->s->pvfs_ref.handle));

        ret = initialize_context(&lookup_frame->u.lookup, current_seg_path,
                                 sm_p->u.aio_open.pdir->s->pvfs_ref);
        if (ret != 0)
        {
            /*TODO: HANDLE THIS ERR */
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.parent_ref.fs_id = sm_p->u.aio_open.pdir->s->pvfs_ref.fs_id;
            sm_p->u.aio_open.parent_ref.handle = sm_p->u.aio_open.pdir->s->pvfs_ref.handle;
            js_p->error_code = OPEN_FIND_FILE;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);
        }
    }    
    else
    {
        sm_p->u.aio_open.parent_ref = sm_p->u.aio_open.pdir->s->pvfs_ref;
        js_p->error_code = OPEN_FIND_FILE;
    }   

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_setup_next_rel_lookup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    int frame_id, frames_remaining;

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    if (js_p->error_code)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    if (*(sm_p->u.aio_open.cur))
    {
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_open.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_open.cur++;
                (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/')
                 sm_p->u.aio_open.cur++);
            if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
                if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
                {
                    /*TODO: HANDLE ERR */
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
            }
        }
        char current_seg_path[PVFS_NAME_MAX];
        memset(current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(current_seg_path, sm_p->u.aio_open.start,
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

        if (current_seg_path == NULL)
        {
            /*TODO: ERROR */
        }

        lookup_frame->u.lookup.orig_pathname = current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.lookup_resp.ref;
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;

        ret = initialize_context(&lookup_frame->u.lookup, current_seg_path,
                                 sm_p->u.aio_open.lookup_resp.ref);
        if (ret != 0)
        {
            /*TODO: HANDLE THIS ERR */
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.parent_ref.fs_id = sm_p->u.aio_open.pdir->s->pvfs_ref.fs_id;
            sm_p->u.aio_open.parent_ref.handle = sm_p->u.aio_open.pdir->s->pvfs_ref.handle;
            js_p->error_code = OPEN_FIND_FILE;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);
        }
    }
    else
    {
        sm_p->u.aio_open.parent_ref = lookup_frame.u.lookup.lookup_resp.ref;
        free(lookup_frame);
        js_p->error_code = OPEN_FIND_FILE;
    }
                                 
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_pdir_ref_lookup_abs_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    int frame_id, frames_remaining;

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    if (js_p->error_code)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    /* TODO: is it a waste of mem to have parent ref and loookup_resp in u */
    sm_p->u.aio_open.parent_ref = sm_p->u.aio_open.lookup_resp.ref;
    free(lookup_frame);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_lookup_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;

    sm_p->u.aio_open.cur = sm_p->u.aio_open.filename;
    sm_p->u.aio_open.last = sm_p->u.aio_open.filename;
    sm_p->u.aio_open.start = sm_p->u.aio_open.filename;

    /* loop over chars to find a complete path segment */
    /* that is no longer than PVFS_NAME_MAX chars */
    while(*(sm_p->u.aio_open.cur))
    {
        /* find next path seperator / */
        /* cur either points to a slash */
        /* or the first char of the path */
        /* there must be at least one */
        /* so n either case increment it first */
        for(sm_p->u.aio_open.cur++;
            (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/')
            sm_p->u.aio_open.cur++);
        if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
        {
            /* we over-shot the limit go back to last */
            sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
            if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
            {
                /*TODO: HANDLE ERR */
            }
            break;
        }
        else
        {
            /* set up to add the next path segment */
            sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
        }
    }

    char current_seg_path[PVFS_NAME_MAX];
    memset(current_seg_path, 0, PVFS_NAME_MAX);
    strncpy(current_seg_path, sm_p->u.aio_open.start,
            sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
    sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
    sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

    if (current_seg_path == NULL)
    {
        /*TODO: ERROR */
    }

    PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
    if (lookup_frame == NULL)
    {
        /* TODO: ERROR */
    }

    PINT_init_msgarray_params(lookup_frame, sm_p->u.aio_open.pdir->s->pvfs_ref.fs_id);
    PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
    lookup_frame->u.lookup.orig_pathname = current_seg_path;
    lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.parent_ref;
    lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_open.lookup_resp);
    lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
    lookup_frame->u.lookup.current_context = 0;
    PVFS_hint_copy(sm_p->hints, &lookup_frame->hints);
    PVFS_hint_add(&lookup_frame->hints, PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle),
                  &(sm_p->u.aio_open.parent_ref.handle));

    ret = initialize_context(&lookup_frame->u.lookup, current_seg_path,
                                 sm_p->u.aio_open.parent_ref);
    if (ret != 0)
    {
        /*TODO: HANDLE THIS ERR */
    }

    if (lookup_frame->u.lookup.current_context == 0 &&
        lookup_frame->u.lookup.contexts[0].total_segments == 0)
    {
        free(lookup_frame);
        sm_p->u.aio_open.file_ref.fs_id = sm_p->u.aio_open.parent_ref.fs_id;
        sm_p->u.aio_open.file_ref.handle = sm_p->u.aio_open.parent_ref.handle;
        js_p->error_code = OPEN_FILE_FOUND;
    }
    else
    {
        js_p->error_code = OPEN_RUN_LOOKUP_SM;
        PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);
    }
  
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action open_file_lookup_setup_next(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    int frame_id, frames_remaining;

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id,
                                 &js_p->error_code, &frames_remaining);

    if (js_p->error_code)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    if (*(sm_p->u.aio_open.cur))
    {
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_open.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_open.cur++;
                (*sm_p->u.aio_open.cur && *sm_p->u.aio_open.cur != '/')
                 sm_p->u.aio_open.cur++);
            if (sm_p->u.aio_open.cur - sm_p->u.aio_open.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_open.cur = sm_p->u.aio_open.last;
                if (sm_p->u.aio_open.cur == sm_p->u.aio_open.start)
                {
                    /*TODO: HANDLE ERR */
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_open.last = sm_p->u.aio_open.cur;
            }
        }
        char current_seg_path[PVFS_NAME_MAX];
        memset(current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(current_seg_path, sm_p->u.aio_open.start,
                sm_p->u.aio_open.cur - sm_p->u.aio_open.start + 1);
        sm_p->u.aio_open.start = sm_p->u.aio_open.cur;
        sm_p->u.aio_open.last = sm_p->u.aio_open.cur;

        if (current_seg_path == NULL)
        {
            /*TODO: ERROR */
        }

        lookup_frame->u.lookup.orig_pathname = current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_open.lookup_resp.ref;
        lookup_frame->u.lookup.follow_link = sm_p->u.aio_open.follow_link;
        lookup_frame->u.lookup.current_context = 0;

        ret = initialize_context(&lookup_frame->u.lookup, current_seg_path,
                                 sm_p->u.aio_open.lookup_resp.ref);
        if (ret != 0)
        {
            /*TODO: HANDLE THIS ERR */
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_open.file_ref.fs_id = sm_p->u.aio_open.lookup_resp.ref.fs_id;
            sm_p->u.aio_open.file_ref.handle = sm_p->u.aio_open.lookup_resp.ref.handle;
            js_p->error_code = OPEN_FILE_FOUND;
        }
        else
        {
            js_p->error_code = OPEN_RUN_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);
        }
    }
    else
    {
        sm_p->u.aio_open.file_ref = lookup_frame.u.lookup.lookup_resp.ref;
        free(lookup_frame);
        js_p->error_code = OPEN_FILE_FOUND;
    }

    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

