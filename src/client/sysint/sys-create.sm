/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"

#include "pinode-helper.h"
#include "pint-dcache.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "acache.h"
#include "PINT-reqproto-encode.h"
#include "shared-state-methods.h"

extern job_context_id pint_client_sm_context;

/* state function prototypes */
static int create_init(PINT_client_sm *sm_p,
		       job_status_s *js_p);
static int create_dspace_create_setup_msgpair(PINT_client_sm *sm_p,
                                              job_status_s *js_p);
static int create_dspace_create_failure(PINT_client_sm *sm_p,
					job_status_s *js_p);
static int create_datafiles_setup_msgpair_array(PINT_client_sm *sm_p,
                                                job_status_s *js_p);
static int create_datafiles_failure(PINT_client_sm *sm_p,
                                    job_status_s *js_p);
static int create_setattr_setup_msgpair(PINT_client_sm *sm_p,
                                        job_status_s *js_p);
static int create_setattr_failure(PINT_client_sm *sm_p,
                                  job_status_s *js_p);
static int create_crdirent_setup_msgpair(PINT_client_sm *sm_p,
					 job_status_s *js_p);
static int create_crdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p);
static int create_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p);

/* completion function prototypes */
static int create_create_comp_fn(void *v_p,
                                 struct PVFS_server_resp *resp_p,
                                 int index);
static int create_datafiles_comp_fn(void *v_p,
                                    struct PVFS_server_resp *resp_p,
                                    int index);
static int create_setattr_comp_fn(void *v_p,
                                  struct PVFS_server_resp *resp_p,
                                  int index);
static int create_crdirent_comp_fn(void *v_p,
                                   struct PVFS_server_resp *resp_p,
                                   int index);

%%

machine pvfs2_client_create_sm(init,
			       create_parent_getattr_setup_msgpair,
			       create_parent_getattr_xfer_msgpair,
			       create_parent_getattr_failure,
			       dspace_create_setup_msgpair,
			       dspace_create_xfer_msgpair,
			       dspace_create_failure,
                               datafiles_setup_msgpair_array,
                               datafiles_xfer_msgpair_array,
                               datafiles_failure,
                               create_setattr_setup_msgpair,
                               create_setattr_xfer_msgpair,
                               create_setattr_failure,
			       crdirent_setup_msgpair,
			       crdirent_xfer_msgpair,
			       crdirent_failure,
			       cleanup)
{
    state init {
	run create_init;
	default => create_parent_getattr_setup_msgpair;
    }

    state create_parent_getattr_setup_msgpair {
	run PINT_sm_common_parent_getattr_setup_msgpair;
        success => create_parent_getattr_xfer_msgpair;
	default => create_parent_getattr_failure;
    }

    state create_parent_getattr_xfer_msgpair {
	jump pvfs2_client_getattr_acache_sm;
        success => dspace_create_setup_msgpair;
	default => create_parent_getattr_failure;
    }

    state create_parent_getattr_failure {
	run PINT_sm_common_parent_getattr_failure;
	default => cleanup;
    }

    state dspace_create_setup_msgpair {
	run create_dspace_create_setup_msgpair;
	success => dspace_create_xfer_msgpair;
        default => dspace_create_failure;
    }

    state dspace_create_xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
        success => datafiles_setup_msgpair_array;
	default => dspace_create_failure;
    }

    state dspace_create_failure {
	run create_dspace_create_failure;
	default => cleanup;
    }

    state datafiles_setup_msgpair_array {
        run create_datafiles_setup_msgpair_array;
        success => datafiles_xfer_msgpair_array;
        default => cleanup;
    }

    state datafiles_xfer_msgpair_array {
	jump pvfs2_client_msgpairarray_sm;
        success => create_setattr_setup_msgpair;
        default => datafiles_failure;
    }

    state datafiles_failure {
        run create_datafiles_failure;
        default => cleanup;
    }

    state create_setattr_setup_msgpair {
        run create_setattr_setup_msgpair;
        success => create_setattr_xfer_msgpair;
        default => cleanup;
    }

    state create_setattr_xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
        success => crdirent_setup_msgpair;
        default => create_setattr_failure;
    }

    state create_setattr_failure {
        run create_setattr_failure;
        default => cleanup;
    }

    state crdirent_setup_msgpair {
	run create_crdirent_setup_msgpair;
        success => crdirent_xfer_msgpair;
	default => crdirent_failure;
    }

    state crdirent_xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
        success => cleanup;
        default => crdirent_failure;
    }

    state crdirent_failure {
	run create_crdirent_failure;
	default => cleanup;
    }

    state cleanup {
        run create_cleanup;
        default => init;
    }
}

%%

int PVFS_sys_create(
    char *object_name,
    PVFS_pinode_reference parent_refn,
    PVFS_sys_attr attr,
    PVFS_credentials credentials,
    PVFS_sysresp_create *resp)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_create entered\n");

    /* parameter checking goes here.  assume everything from the user
     * is ok past this point.
     */
    if ((object_name == NULL) || (resp == NULL))
    {
        return ret;
    }

    if ((strlen(object_name) + 1) > PVFS_REQ_LIMIT_SEGMENT_BYTES)
    {
        return -PVFS_ENAMETOOLONG;
    }

    if ((attr.mask & PVFS_ATTR_SYS_ALL_SETABLE) != PVFS_ATTR_SYS_ALL_SETABLE)
    {
        gossip_lerr("Error: Attribute sanity check failed\n");
        return ret;
    }

    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.create.object_name = object_name;
    sm_p->parent_ref = parent_refn;
    sm_p->u.create.create_resp = resp;
    sm_p->u.create.sys_attr = &attr;
    if(attr.mask & PVFS_ATTR_SYS_DFILE_COUNT)
    {
	sm_p->u.create.num_data_files = attr.dfile_count;
    }
    else
    {
	ret = PINT_bucket_get_num_io(sm_p->parent_ref.fs_id,
				     &sm_p->u.create.num_data_files);
	if (ret < 0)
	{
	    gossip_err("Failed to get number of data servers\n");
	    free(sm_p);
	    return(ret);
	}
    }

    gossip_debug(CLIENT_DEBUG, "Creating file named %s under parent handle "
                 "%Lu on fs %d\n", object_name, Lu(parent_refn.handle),
                 parent_refn.fs_id);

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_CREATE);
    assert(ret == 0);

    /* while !done call progress function */
    while (!sm_p->op_complete && ret == 0)
    {
	gossip_debug(CLIENT_DEBUG, "PVFS_sys_create calling "
                     "PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }

    assert(ret == 0);

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_create completed\n");

    /* save our return value */
    error = sm_p->error_code;

    /* clean up after ourselves */
    free(sm_p);
    return error;
}

/****************************************************************/

static int create_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "create state: init\n");

    assert(js_p->error_code == 0);

    /*
      grab a pointer to the server configuration object.
      we need this later for mapping handles to servers
      during meta/data handle creation
    */
    sm_p->server_config = PINT_get_server_config_struct();
    assert(sm_p->server_config);

    /* do the request scheduler thing, if necessary */

    return 1;
}

static int create_create_comp_fn(void *v_p,
                                 struct PVFS_server_resp *resp_p,
                                 int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;
    
    gossip_debug(CLIENT_DEBUG, "create_create_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CREATE);

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    /* otherwise, just stash the newly created meta handle */
    sm_p->u.create.metafile_handle = resp_p->u.create.handle;

    gossip_debug(CLIENT_DEBUG, "*** Got newly created handle %Lu\n",
                 Lu(sm_p->u.create.metafile_handle));

    return 0;
}

static int create_datafiles_comp_fn(void *v_p,
                                    struct PVFS_server_resp *resp_p,
                                    int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;
    
    gossip_debug(CLIENT_DEBUG, "create_datafiles_comp_fn[%d]\n",index);

    assert(resp_p->op == PVFS_SERV_CREATE);

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    /* allocate memory for the data handles if we haven't already */
    if (index == 0)
    {
        sm_p->u.create.datafile_handles = (PVFS_handle *)
            malloc(sm_p->u.create.num_data_files * sizeof(PVFS_handle));
        if (sm_p->u.create.datafile_handles == NULL)
        {
            gossip_err("create: Failed to allocate data handle array\n");
            return -PVFS_ENOMEM;
        }
        memset(sm_p->u.create.datafile_handles, 0,
               sm_p->u.create.num_data_files * sizeof(PVFS_handle));
    }

    assert(sm_p->u.create.datafile_handles);

    /* otherwise, just stash the newly created data file handle */
    sm_p->u.create.datafile_handles[index] = resp_p->u.create.handle;

    gossip_debug(CLIENT_DEBUG, "Datafile handle %d is %Lu\n",
                 index, Lu(sm_p->u.create.datafile_handles[index]));

    return 0;
}

/* 
   NOTE: this function only does a sanity check and doesn't
   need to be called.  Set the completion function to NULL
   when setting up the setattr msgpair to avoid this
*/
static int create_setattr_comp_fn(void *v_p,
                                  struct PVFS_server_resp *resp_p,
                                  int index)
{
/*     PINT_client_sm *sm_p = (PINT_client_sm *) v_p; */
    
    gossip_debug(CLIENT_DEBUG, "create_setattr_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_SETATTR);

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    return 0;
}

/* 
   NOTE: this function only does a sanity check and doesn't
   need to be called.  Set the completion function to NULL
   when setting up the crdirent msgpair to avoid this
*/
static int create_crdirent_comp_fn(void *v_p,
                                   struct PVFS_server_resp *resp_p,
                                   int index)
{
/*     PINT_client_sm *sm_p = (PINT_client_sm *) v_p; */
    
    gossip_debug(CLIENT_DEBUG, "create_crdirent_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CRDIRENT);

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    return 0;
}

static int create_dspace_create_setup_msgpair(PINT_client_sm *sm_p,
                                              job_status_s *js_p)
{
    int ret = -1;
    PVFS_handle_extent_array meta_handle_extent_array;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(CLIENT_DEBUG, "create state: "
                 "dspace_create_setup_msgpair\n");

    /* clear error field in job */
    js_p->error_code = 0;

    if (sm_p->u.create.num_data_files > PVFS_REQ_LIMIT_DFILE_COUNT)
    {
        sm_p->u.create.num_data_files = PVFS_REQ_LIMIT_DFILE_COUNT;
        gossip_err("Warning: reducing number of data "
                     "files to PVFS_REQ_LIMIT_DFILE_COUNT\n");
    }

    gossip_ldebug(CLIENT_DEBUG, "Number of data files to create "
                  "is %d\n", sm_p->u.create.num_data_files);

    gossip_debug(CLIENT_DEBUG," create: posting create req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    ret = PINT_bucket_get_next_meta(
        sm_p->server_config, sm_p->parent_ref.fs_id,
        &msg_p->svr_addr, &meta_handle_extent_array);
    if (ret < 0)
    {
        gossip_err("Failed to get meta server information\n");
        assert(0);
    }

    PINT_SERVREQ_CREATE_FILL(msg_p->req,
                             *sm_p->cred_p,
                             sm_p->parent_ref.fs_id,
                             PVFS_TYPE_METAFILE,
                             meta_handle_extent_array);

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle = meta_handle_extent_array.extent_array[0].first;
    msg_p->comp_fn = create_create_comp_fn;

    return 1;
}

static int create_dspace_create_failure(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "create state: dspace_create_failure\n");
    return 1;
}

static int create_datafiles_setup_msgpair_array(PINT_client_sm *sm_p,
                                                job_status_s *js_p)
{
    int ret = -1, i = 0;

    gossip_debug(CLIENT_DEBUG, "create state: "
                 "datafiles_setup_msgpair_array\n");

    /* clear error field in job */
    js_p->error_code = 0;

    memset(&sm_p->msgpair, 0, sizeof(PINT_client_sm_msgpair_state));

    /* allocate msgarray and set msgarray_count */
    sm_p->msgarray = (PINT_client_sm_msgpair_state *)
        malloc(sm_p->u.create.num_data_files *
               sizeof(PINT_client_sm_msgpair_state));
    if (sm_p->msgarray == NULL)
    {
        gossip_err("create: failed to allocate msgarray\n"); 
        return -PVFS_ENOMEM;
    }
    sm_p->msgarray_count = sm_p->u.create.num_data_files;

    /* allocate handle extent array objects */
    sm_p->u.create.io_handle_extent_array = (PVFS_handle_extent_array *)
        malloc(sm_p->u.create.num_data_files *
               sizeof(PVFS_handle_extent_array));
    if (!sm_p->u.create.io_handle_extent_array)
    {
        gossip_err("create: failed to allocate handle_extent_array\n"); 
        return -PVFS_ENOMEM;
    }

    /* allocate data server bmi address array */
    sm_p->u.create.data_server_addrs = (bmi_addr_t *)
        malloc(sm_p->u.create.num_data_files * sizeof(bmi_addr_t));
    if (!sm_p->u.create.data_server_addrs)
    {
        gossip_err("create: failed to allocate data server addrs\n"); 
        return -PVFS_ENOMEM;
    }

    ret = PINT_bucket_get_next_io(sm_p->server_config,
                                  sm_p->parent_ref.fs_id,
                                  sm_p->u.create.num_data_files,
                                  sm_p->u.create.data_server_addrs,
                                  sm_p->u.create.io_handle_extent_array);
    if (ret < 0)
    {
	gossip_err("Error: failure retrieving io server information.\n");
	assert(0); /* TODO: real error handling */
    }
    
    /* for each datafile, prepare to post a create send/recv pair */
    for(i = 0; i < sm_p->u.create.num_data_files; i++)
    {
        PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

        gossip_debug(CLIENT_DEBUG,
                     "create: posting data file create req %d\n",i);

        PINT_SERVREQ_CREATE_FILL(msg_p->req,
                                 *sm_p->cred_p,
                                 sm_p->parent_ref.fs_id,
                                 PVFS_TYPE_DATAFILE,
                                 sm_p->u.create.io_handle_extent_array[i]);

        /* fill in msgpair structure components */
        msg_p->fs_id = sm_p->parent_ref.fs_id;
        msg_p->handle =
            sm_p->u.create.io_handle_extent_array[i].extent_array[0].first;
        msg_p->comp_fn = create_datafiles_comp_fn;
        msg_p->svr_addr = sm_p->u.create.data_server_addrs[i];
    }
    return 1;
}

static int create_datafiles_failure(PINT_client_sm *sm_p,
                                    job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "create state: datafiles_failure\n");
    return 1;
}

static int create_setattr_setup_msgpair(PINT_client_sm *sm_p,
                                        job_status_s *js_p)
{
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(CLIENT_DEBUG, "create state: setattr_setup_msgpair\n");

    /* clear error field in job */
    js_p->error_code = 0;

    gossip_debug(CLIENT_DEBUG," create: posting setattr req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    /* FIXME: do we have a slicker way to do this at runtime? */
    sm_p->u.create.dist = PVFS_Dist_create("simple_stripe");
    assert(sm_p->u.create.dist);

    PINT_SERVREQ_SETATTR_FILL(msg_p->req,
                              *sm_p->cred_p,
                              sm_p->parent_ref.fs_id,
                              sm_p->u.create.metafile_handle,
                              PVFS_TYPE_METAFILE,
                              *sm_p->u.create.sys_attr,
                              (PVFS_ATTR_COMMON_TYPE | PVFS_ATTR_META_ALL));

    /* fill in meta file specific attributes */
    msg_p->req.u.setattr.attr.u.meta.dfile_array =
        sm_p->u.create.datafile_handles;
    msg_p->req.u.setattr.attr.u.meta.dfile_count =
        sm_p->u.create.num_data_files;
    msg_p->req.u.setattr.attr.u.meta.dist =
        sm_p->u.create.dist;

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle = sm_p->u.create.metafile_handle;
    msg_p->comp_fn = create_setattr_comp_fn;

    if (PINT_bucket_map_to_server(&msg_p->svr_addr,
                                  msg_p->handle,
                                  msg_p->fs_id) < 0)
    {
        gossip_err("Failed to get meta server information\n");
        assert(0);
    }
    return 1;
}

static int create_setattr_failure(PINT_client_sm *sm_p,
                                  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "create state: setattr_failure\n");
    return 1;
}

static int create_crdirent_setup_msgpair(PINT_client_sm *sm_p,
					 job_status_s *js_p)
{
    int ret = -1;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(CLIENT_DEBUG, "create state: crdirent_setup_msgpair\n");

    /* clear error field in job */
    js_p->error_code = 0;

    gossip_debug(CLIENT_DEBUG," create: posting crdirent req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    PINT_SERVREQ_CRDIRENT_FILL(msg_p->req,
                               *sm_p->cred_p,
                               sm_p->u.create.object_name,
                               sm_p->u.create.metafile_handle,
                               sm_p->parent_ref.handle,
                               sm_p->parent_ref.fs_id);

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle = sm_p->u.create.metafile_handle;
    msg_p->comp_fn = create_crdirent_comp_fn;

    ret = PINT_bucket_map_to_server(&msg_p->svr_addr,
                                    sm_p->parent_ref.handle,
                                    sm_p->parent_ref.fs_id);
    if (ret < 0)
    {
        gossip_err("Failed to get meta server information\n");
        assert(0);
    }
    return 1;
}

static int create_crdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "create state: crdirent_failure\n");

    if (js_p->error_code == -PVFS_EEXIST)
    {
        gossip_debug(CLIENT_DEBUG, "crdirent failed: "
                     "dirent already exists!\n");
    }
    return 1;
}

static int create_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p)
{
    PVFS_pinode_reference metafile_ref;

    gossip_debug(CLIENT_DEBUG, "create state: cleanup\n");

    sm_p->error_code = js_p->error_code;

    metafile_ref.handle = sm_p->u.create.metafile_handle;
    metafile_ref.fs_id = sm_p->parent_ref.fs_id;

    /* fill in outgoing response fields */
    sm_p->u.create.create_resp->pinode_refn = metafile_ref;

    if (sm_p->u.create.io_handle_extent_array)
    {
        free(sm_p->u.create.io_handle_extent_array);
    }

    if (sm_p->u.create.data_server_addrs)
    {
        free(sm_p->u.create.data_server_addrs);
    }

    if (sm_p->u.create.datafile_handles)
    {
        free(sm_p->u.create.datafile_handles);
    }

    if (sm_p->u.create.dist)
    {
        PVFS_Dist_free(sm_p->u.create.dist);
    }

    if (sm_p->msgarray)
    {
        free(sm_p->msgarray);
    }

    /* mark operation as complete */
    sm_p->op_complete = 1;

    return 0;
}


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
