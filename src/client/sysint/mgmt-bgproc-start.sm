/*
 * Copyright 2014 Omnibond Systems, L.L.C.
 *
 * See COPYING in top-level directory.
 */

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "pvfs2-mgmt.h"

extern job_context_id pint_client_sm_context;

static int bgproc_start_comp_fn(void* v_p, struct PVFS_server_resp *resp_p,
    int i);

%%

machine pvfs2_client_mgmt_bgproc_start_sm
{
    state setup_msgpair
    {
        run mgmt_bgproc_start_setup_msgpair;
        success => xfer_msgpair;
        default => cleanup;
    }

    state xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        default => cleanup;
    }

    state cleanup
    {
        run mgmt_bgproc_start_cleanup;
        default => terminate;
    }
}

%%

PVFS_error PVFS_imgmt_bgproc_start(
    PVFS_fs_id fs_id,
    int server_count,
    PVFS_BMI_addr_t *addr_array,
    unsigned long *statuses,
    unsigned long *ids,
    char *name,
    PVFS_mgmt_op_id *op_id,
    void *user_ptr)
{
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;
    int ret = 0;

    if ((server_count < 1) || (!addr_array) || (!statuses) || (!ids) || (!name))
    {
        return -PVFS_EINVAL;
    }

    PINT_smcb_alloc(&smcb, PVFS_MGMT_BGPROC_START,
             sizeof(struct PINT_client_sm),
             client_op_state_get_machine,
             client_state_machine_terminate,
             pint_client_sm_context);
    if (!smcb)
    {
        return -PVFS_ENOMEM;
    }

    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    PINT_init_msgarray_params(sm_p, fs_id);
    sm_p->u.mgmt_bgproc_start.fs_id = fs_id;
    sm_p->u.mgmt_bgproc_start.server_count = server_count;
    sm_p->u.mgmt_bgproc_start.addr_array = addr_array;
    sm_p->u.mgmt_bgproc_start.statuses = statuses;
    sm_p->u.mgmt_bgproc_start.ids = ids;
    sm_p->u.mgmt_bgproc_start.name = name;

    ret = PINT_msgpairarray_init(&sm_p->msgarray_op, server_count);
    if (ret != 0)
    {
       PINT_smcb_free(smcb);
       return ret;
    }

    return PINT_client_state_machine_post(
        smcb, op_id, user_ptr);
}

PVFS_error PVFS_mgmt_bgproc_start(
    PVFS_fs_id fs_id,
    int server_count,
    PVFS_BMI_addr_t *addr_array,
    unsigned long *statuses,
    unsigned long *ids,
    char *name)
{
    PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_mgmt_op_id op_id;

    ret = PVFS_imgmt_bgproc_start(fs_id, server_count, addr_array, statuses,
        ids, name, &op_id, NULL);
    if (ret)
    {
        PVFS_perror_gossip("PVFS_imgmt_bgproc_start call", ret);
        error = ret;
    }
    else
    {
        ret = PVFS_mgmt_wait(op_id, "mgmt_bgproc_start", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_mgmt_wait call", ret);
            error = ret;
        }
    }

    PINT_mgmt_release(op_id);
    return error;
}

static PINT_sm_action mgmt_bgproc_start_setup_msgpair(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_msgpair_state *msg_p = NULL;
    PVFS_capability capability;
    int i;

    PINT_null_capability(&capability);

    foreach_msgpair(&sm_p->msgarray_op, msg_p, i)
    {
        PINT_SERVREQ_MGMT_BGPROC_START_FILL(
            msg_p->req,
            capability,
            sm_p->u.mgmt_bgproc_start.name);

        msg_p->fs_id = sm_p->u.mgmt_bgproc_start.fs_id;
        msg_p->handle = PVFS_HANDLE_NULL;
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = bgproc_start_comp_fn;
        msg_p->svr_addr = sm_p->u.mgmt_bgproc_start.addr_array[i];
    }

    PINT_cleanup_capability(&capability);

    /* immediate return: next state jumps to msgpairarray machine */
    js_p->error_code = 0;

    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action mgmt_bgproc_start_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* XXX: free ? */
    PINT_msgpairarray_destroy(&sm_p->msgarray_op);

    sm_p->error_code  = js_p->error_code;

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
	
}

static int bgproc_start_comp_fn(void* v_p, struct PVFS_server_resp *resp_p,
    int i)
{
    PINT_smcb *smcb = v_p;
    PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    /* XXX: alloc ? */
    sm_p->u.mgmt_bgproc_start.statuses[i] = resp_p->u.mgmt_bgproc_start.status;
    sm_p->u.mgmt_bgproc_start.ids[i] = resp_p->u.mgmt_bgproc_start.id;
    return 0;
}
