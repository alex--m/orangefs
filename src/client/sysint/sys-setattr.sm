/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"
#include "shared-state-methods.h"

extern job_context_id pint_client_sm_context;

static int setattr_init(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int setattr_msg_setup_msgpair(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int setattr_msg_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int setattr_cleanup(
    PINT_client_sm *sm_p, job_status_s *js_p);

/* completion function prototypes */
static int setattr_msg_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);

%%

machine pvfs2_client_setattr_sm(init,
                                setattr_getattr_setup_msgpair,
                                setattr_getattr_xfer_msgpair,
                                setattr_getattr_failure,
                                setattr_msg_setup_msgpair,
                                setattr_msg_xfer_msgpair,
                                setattr_msg_failure,
                                cleanup)
{
    state init
    {
        run setattr_init;
        default => setattr_getattr_setup_msgpair;
    }

    state setattr_getattr_setup_msgpair
    {
        run PINT_sm_common_object_getattr_setup_msgpair;
        success => setattr_getattr_xfer_msgpair;
        default => setattr_getattr_failure;
    }

    state setattr_getattr_xfer_msgpair
    {
        jump pvfs2_client_getattr_acache_sm;
        success => setattr_msg_setup_msgpair;
        default => setattr_getattr_failure;
    }

    state setattr_getattr_failure
    {
        run PINT_sm_common_object_getattr_failure;
        default => cleanup;
    }

    state setattr_msg_setup_msgpair
    {
        run setattr_msg_setup_msgpair;
        success => setattr_msg_xfer_msgpair;
        default => cleanup;
    }

    state setattr_msg_xfer_msgpair
    {
        jump pvfs2_client_msgpair_sm;
        success => cleanup;
        default => setattr_msg_failure;
    }

    state setattr_msg_failure
    {
        run setattr_msg_failure;
        default => cleanup;
    }

    state cleanup
    {
        run setattr_cleanup;
        default => terminate;
    }
}

%%

int PVFS_sys_setattr(
    PVFS_pinode_reference pinode_refn,
    PVFS_sys_attr attr,
    PVFS_credentials credentials)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_setattr entered\n");

    /*
      make sure the caller didn't set invalid mask bits;
      in particular, note that you can't set size here
    */
    if ((attr.mask & ~PVFS_ATTR_SYS_ALL_SETABLE) != 0)
    {
        gossip_lerr("Error: PVFS_sys_setattr(): attempted to set "
                    "invalid attributes.\n");
        return ret;
    }

    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->object_ref = pinode_refn;
    sm_p->u.setattr.refn = pinode_refn;
    sm_p->u.setattr.sys_attr = &attr;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "Doing setattr on handle %Lu "
                 "on fs %d\n", Lu(pinode_refn.handle),
                 pinode_refn.fs_id);

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_SETATTR);
    if (ret)
    {
	gossip_lerr("Error: PINT_client_state_machine_post() failure.\n");
        free(sm_p);
        return ret;
    }

    while (!sm_p->op_complete && (ret == 0))
    {
	gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_setattr calling "
                     "PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }

    if (ret)
    {
	gossip_lerr("Error: PINT_client_state_machine_test() failure.\n");
	free(sm_p);
	return(ret);
    }

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_setattr completed\n");

    error = sm_p->error_code;

    free(sm_p);
    return error;
}

/****************************************************************/

static int setattr_init(PINT_client_sm *sm_p,
                        job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "setattr state: init\n");

    assert(js_p->error_code == 0);

    return 1;
}

static int setattr_msg_comp_fn(void *v_p,
                               struct PVFS_server_resp *resp_p,
                               int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "setattr_msg_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_SETATTR);

    if (resp_p->status != 0)
    {
	return resp_p->status;
    }
    return 0;
}

static int setattr_msg_setup_msgpair(PINT_client_sm *sm_p,
                                     job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;
    PVFS_object_attr *attr = NULL;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "setattr state: "
                 "setattr_msg_setup_msgpair\n");

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG," setattr: posting setattr req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    /*
      if this lookup wasn't a acache hit, we must have a local
      copy stored in the sm object for later acache insertion
    */
    attr = (sm_p->acache_hit ?
            &sm_p->pinode->attr :
            &sm_p->acache_attr);
    assert(attr);

    PINT_SERVREQ_SETATTR_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->u.setattr.refn.fs_id,
        sm_p->u.setattr.refn.handle,
        attr->objtype,
        *sm_p->u.setattr.sys_attr,
        PVFS_ATTR_COMMON_TYPE);

    if (attr->objtype == PVFS_TYPE_METAFILE)
    {
        if (attr->mask & PVFS_ATTR_META_DFILES)
        {
            /* fill in meta file specific attributes */
            msg_p->req.u.setattr.attr.u.meta.dfile_array =
                attr->u.meta.dfile_array;
            msg_p->req.u.setattr.attr.u.meta.dfile_count =
                attr->u.meta.dfile_count;
            msg_p->req.u.setattr.attr.mask |= PVFS_ATTR_META_DFILES;
        }
        if (attr->mask & PVFS_ATTR_META_DIST)
        {
            msg_p->req.u.setattr.attr.u.meta.dist =
                attr->u.meta.dist;
            msg_p->req.u.setattr.attr.u.meta.dist_size =
                attr->u.meta.dist_size;
            msg_p->req.u.setattr.attr.mask |= PVFS_ATTR_META_DIST;
        }
    }

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->u.setattr.refn.fs_id;
    msg_p->handle = sm_p->u.setattr.refn.handle;
    msg_p->comp_fn = setattr_msg_comp_fn;

    ret = PINT_bucket_map_to_server(&msg_p->svr_addr,
                                    msg_p->handle,
                                    msg_p->fs_id);
    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
    return 1;
}

static int setattr_msg_failure(PINT_client_sm *sm_p,
                               job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "setattr state: setattr_msg_failure\n");
    return 1;
}

static int setattr_cleanup(PINT_client_sm *sm_p,
                           job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "setattr state: cleanup\n");

    sm_p->error_code = js_p->error_code;

    if (!sm_p->acache_hit)
    {
        int release_required = 1;
        PINT_pinode *pinode =
            PINT_acache_lookup(sm_p->u.setattr.refn);
        if (!pinode)
        {
            pinode = PINT_acache_pinode_alloc();
            assert(pinode);
            release_required = 0;
        }
        pinode->refn = sm_p->u.setattr.refn;
        pinode->size = ((sm_p->acache_attr.mask & PVFS_ATTR_DATA_ALL) ?
                        sm_p->acache_attr.u.data.size : 0);

        PINT_acache_object_attr_deep_copy(
            &pinode->attr, &sm_p->acache_attr);
        PINT_acache_object_attr_deep_free(&sm_p->acache_attr);

        PINT_acache_set_valid(pinode);

        if (release_required)
        {
            PINT_acache_release(pinode);
        }
    }

    sm_p->op_complete = 1;
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
