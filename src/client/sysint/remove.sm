/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "client-capcache.h"

/*
 * Now included from client-state-machine.h
 */
#if 0
extern job_context_id pint_client_sm_context;
#endif

enum
{
    REMOVE_MUST_REMOVE_DATAFILES = 1,
    SECURITY_RETRY_REMOVE = 2,
};

#define HANDLE_REMOVE_ERROR(state)                                     \
do {                                                                   \
    char buf[64] = {0};                                                \
    gossip_debug(GOSSIP_CLIENT_DEBUG, "remove state: %s\n", state);    \
    PVFS_strerror_r(js_p->error_code, buf, 64);                        \
    gossip_err("WARNING: PVFS_sys_remove() encountered an error which "\
               "may lead\n  to inconsistent state: %s\n", buf);        \
    gossip_err("WARNING: PVFS2 fsck (if available) may be needed.\n"); \
    sm_p->u.remove.stored_error_code = js_p->error_code;               \
    js_p->error_code = 0;                                              \
} while(0)

/* function prototypes */
static int remove_datafiles_comp_fn(void *v_p,
                                    struct PVFS_server_resp *resp_p,
                                    int index);


%%

nested machine pvfs2_client_remove_helper_sm
{
    state remove_helper_init
    {
        run remove_helper_init;
        default => getattr;
    }

    state getattr
    {
        jump pvfs2_client_getattr_sm;
        success => getattr_analyze_results;
        default => remove_helper_cleanup;
    }

    state getattr_analyze_results
    {
        run remove_getattr_analyze_results;
        success => object_remove_setup_msgpair;
        REMOVE_MUST_REMOVE_DATAFILES => datafile_remove_setup_msgpair;
        default => remove_helper_cleanup;
    }

    state datafile_remove_setup_msgpair
    {
        run remove_datafile_remove_setup_msgpair;
        success => datafile_remove_xfer_msgpair;
        default => datafile_remove_failure;
    }

    state datafile_remove_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => object_remove_setup_msgpair;
        default => datafile_remove_failure;
    }

    state datafile_remove_failure
    {
        run remove_datafile_remove_failure;
        SECURITY_RETRY_REMOVE => parent_init;
        success => object_remove_setup_msgpair;
        default => remove_helper_cleanup;
    }

    state parent_init
    {
        run remove_parent_init;
        default => getattr;
    }

    state object_remove_setup_msgpair
    {
        run remove_object_remove_setup_msgpair;
        success => object_remove_xfer_msgpair;
        default => object_remove_failure;
    }

    state object_remove_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => remove_helper_cleanup;
        default => object_remove_failure;
    }

    state object_remove_failure
    {
        run remove_object_remove_failure;
        SECURITY_RETRY_REMOVE => parent_init;
        default => remove_helper_cleanup;
    }

    state remove_helper_cleanup
    {
        run remove_helper_cleanup;
        default => return;
    }
}

%%

static PINT_sm_action remove_helper_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_err("%s:sm_p->object_ref.handle(%llu)\n",__func__,llu(sm_p->object_ref.handle));
    gossip_err("%s:sm_p->parent_ref.handle(%llu)\n",__func__,llu(sm_p->parent_ref.handle));

    /* initialize attr structures */
    PINT_free_object_attr(&sm_p->u.remove.parent_attr);
    PINT_free_object_attr(&sm_p->u.remove.object_attr);
    memset(&sm_p->u.remove.parent_attr,0,sizeof(sm_p->u.remove.parent_attr));
    memset(&sm_p->u.remove.object_attr,0,sizeof(sm_p->u.remove.object_attr));

    /* store parent capability */
    PINT_copy_capability(&sm_p->parent_capability,&sm_p->u.remove.parent_attr.capability);
    sm_p->u.remove.parent_attr.mask = PVFS_ATTR_CAPABILITY;

    /* prepare to call getattr */
    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);

    PINT_SM_GETATTR_STATE_FILL(
        sm_p->getattr,
        sm_p->object_ref,
        PVFS_ATTR_META_ALL|PVFS_ATTR_COMMON_TYPE,
        PVFS_TYPE_NONE,
        0);

    js_p->error_code = 0;

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_parent_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_err("%s:sm_p->parent_ref.handle(%llu)\n",__func__,llu(sm_p->parent_ref.handle));

    js_p->error_code = 0;

    /* cleanup a capability that may have been requested by this state machine in an earlier retry. */
    //PINT_cleanup_capability(&sm_p->u.remove.parent_getattr.capability);

    /* 
     * todo:  see if capability is released
     */
    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);

    /* call getattr using the parent_getattr structure */
    PINT_SM_GETATTR_STATE_FILL(
         sm_p->getattr,
         sm_p->parent_ref,
         PVFS_ATTR_CAPABILITY|PVFS_ATTR_COMMON_TYPE,
         PVFS_TYPE_NONE,
         0);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_getattr_analyze_results(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    if ( js_p->error_code != 0 )
    {
       /* do something */
       return SM_ACTION_COMPLETE;
    }

    if ( sm_p->object_ref.handle == sm_p->getattr.object_ref.handle )
    {
       /* we just issued a getattr against the object we are removing */
       gossip_err("%s:Getattr for object ref\n",__func__);

       /* initialize destination structure */
       PINT_free_object_attr(&sm_p->u.remove.object_attr);
       memset(&sm_p->u.remove.object_attr,0,sizeof(sm_p->u.remove.object_attr));

       /* copy attributes from getattr structure */
       PINT_copy_object_attr(&sm_p->u.remove.object_attr,&sm_p->getattr.attr);
    }
    else if (sm_p->parent_ref.handle == sm_p->getattr.object_ref.handle)
    {
         /* we just issued a getattr against the parent object to regen capability */
         gossip_err("%s:Getattr for parent ref\n",__func__);

         /* initialize destination structure */
         PINT_free_object_attr(&sm_p->u.remove.parent_attr);
         memset(&sm_p->u.remove.parent_attr,0,sizeof(sm_p->u.remove.parent_attr));

         /* copy attributes from getattr structure */
         PINT_copy_object_attr(&sm_p->u.remove.parent_attr,&sm_p->getattr.attr);
    }

    /* checking object's attrs */
    switch(sm_p->u.remove.object_attr.objtype)
    {
	case PVFS_TYPE_METAFILE:

	    js_p->error_code = REMOVE_MUST_REMOVE_DATAFILES;
            break;
	case PVFS_TYPE_DIRECTORY:
#if 0
/* NOTE: this check is not safe because it relies on cached attributes on the
 * parent, which may be out of date.  The server will perform this check
 * locally when we attempt to remove the directory itself.
 */
            if(attr->u.dir.dirent_count != 0)
            {
                js_p->error_code = -PVFS_ENOTEMPTY;
                break;
            }
#endif
	case PVFS_TYPE_SYMLINK:
            js_p->error_code = 0;
            break;
	case PVFS_TYPE_DATAFILE:
	case PVFS_TYPE_DIRDATA:
	default:
	    gossip_err("%s: unhandled object type (%x)\n", __func__,
                       sm_p->u.remove.object_attr.objtype);
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_datafile_remove_setup_msgpair(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *attr = NULL;
    int ret = -PVFS_EINVAL;
    PINT_sm_msgpair_state *msg_p = NULL;

//turn this on to test timeout
#if 1 
    unsigned int uret;
    static unsigned int sleep_count = 0;
#endif

   /*
    * NOTE: it's easier to clean up from a metafile with no datafiles
    * than the other way around!  so we remove datafiles first.
    */
    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "remove state: datafile_remove_setup_msgpair\n");

    attr = &sm_p->u.remove.object_attr;
    assert(attr);

    /* post a send/recv pair for the remove to the
       first server in the list of datafiles */
    PINT_msgpair_init(&sm_p->msgarray_op);
    msg_p = &sm_p->msgarray_op.msgpair;

    PINT_SERVREQ_TREE_REMOVE_FILL(
        msg_p->req,
        sm_p->u.remove.parent_attr.capability,
        *sm_p->cred_p,
        sm_p->object_ref.fs_id,
        0,
        attr->u.meta.dfile_count,
        attr->u.meta.dfile_array,
        sm_p->hints);
    
    msg_p->fs_id = sm_p->object_ref.fs_id;
    msg_p->handle = attr->u.meta.dfile_array[0];
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;     /* TODO: Do we want retry? */
    msg_p->comp_fn = remove_datafiles_comp_fn;

    ret = PINT_cached_config_map_to_server(
        &msg_p->svr_addr, msg_p->handle, msg_p->fs_id);

    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }


#if 1
    if ( sleep_count == 0 )
    {
       sleep_count++;
       gossip_err("%s: waiting for 35 seconds before sending request to remove datafile handles\n",
                 __func__);
       uret=sleep(35);
       if (uret)
       {
          gossip_err("%s:sleep failed(%u)\n"
                    ,__func__,uret);
       }
    }
#endif


    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_object_remove_setup_msgpair(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    PINT_sm_msgpair_state *msg_p = NULL;

//turn this on to test timeout
#if 0
    unsigned int uret;
    static unsigned int sleep_count = 0;
#endif

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "remove state: object_remove_setup_msgpair\n");

    js_p->error_code = 0;

    PINT_msgpair_init(&sm_p->msgarray_op);
    msg_p = &sm_p->msgarray_op.msgpair;

    gossip_err("%s:handle(%llu) to remove.\n",__func__,llu(sm_p->object_ref.handle));
    //PINT_debug_capability(&sm_p->getattr.attr.capability,"Remove metafile object");
    PINT_debug_capability(&sm_p->u.remove.parent_attr.capability,"Parent capability");

    PINT_SERVREQ_REMOVE_FILL(
        msg_p->req,
        sm_p->u.remove.parent_attr.capability,
        //sm_p->getattr.attr.capability,
        *sm_p->cred_p,
        sm_p->object_ref.fs_id,
        sm_p->object_ref.handle,
        sm_p->hints);

    msg_p->fs_id = sm_p->object_ref.fs_id;
    msg_p->handle = sm_p->object_ref.handle;
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = NULL;

    ret = PINT_cached_config_map_to_server(
        &msg_p->svr_addr, msg_p->handle, msg_p->fs_id);

    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
	js_p->error_code = ret;
    }

    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);


#if 0
    if ( sleep_count == 0 )
    {
       sleep_count++;
       gossip_err("%s: waiting for 35 seconds before sending request to remove object handle\n",
                 __func__);
       uret=sleep(35);
       if (uret)
       {
          gossip_err("%s:sleep failed(%u)\n"
                    ,__func__,uret);
       }
    }
#endif

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_datafile_remove_failure(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* if any of the datafiles were not removed due to a capability timeout, then we must
     * regenerate a capability and retry the datafile removes.  To accomplish this, all we
     * need to do is rerun getattr to regen the capability and retry the datafile removes.
     */

    switch(js_p->error_code)
    {
       case -PVFS_TIMEOUT_CAP:
       case -PVFS_TIMEOUT_CRED:
       {
           js_p->error_code=SECURITY_RETRY_REMOVE;
           break;
       }
       default:
       {
          HANDLE_REMOVE_ERROR("datafile_remove_failure");
          break;
       }
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_object_remove_failure(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    gossip_debug(GOSSIP_CLIENT_DEBUG, "remove state: "
                 "object_remove_failure\n");
    /*
      catch and return acceptable errors here to avoid generic
      post-remove-failure cleanup
    */
    if (js_p->error_code == -PVFS_ENOTEMPTY)
    {
        gossip_debug(GOSSIP_CLIENT_DEBUG, " directory not empty -- "
                     "returning error\n");
    }
    else if (js_p->error_code == -PVFS_TIMEOUT_CAP)
    {
       /* regenerate the capability and retry object remove */
       js_p->error_code = SECURITY_RETRY_REMOVE;
       return SM_ACTION_COMPLETE;
    }
    else
    {
        gossip_err("Error: failed removing handle %llu\n", llu(sm_p->object_ref.handle));
        HANDLE_REMOVE_ERROR("object_remove_failure");
    }
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_helper_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_uid local_uid;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "remove state: helper cleanup\n");

    /* cleanup allocations made for getattr operations 
     * todo: check to see if capability is deallocated
     */
    PINT_free_object_attr(&sm_p->u.remove.parent_attr);
    PINT_free_object_attr(&sm_p->u.remove.object_attr);
    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);

    /* invalidates metafile object, directory object, or symlink object */
    PINT_acache_invalidate(sm_p->object_ref);

    /* invalidate the capcache entry as well */
    local_uid = PINT_HINT_GET_LOCAL_UID(sm_p->hints);
    if ( local_uid == (PVFS_uid) -1 )
    {
       local_uid = PINT_util_getuid();
       PVFS_hint_add(&sm_p->hints, PVFS_HINT_LOCAL_UID_NAME, sizeof(PVFS_uid), &local_uid);
    }
    PINT_client_capcache_invalidate(sm_p->object_ref, local_uid);

    PINT_msgpairarray_destroy(&sm_p->msgarray_op);

    if (js_p->error_code)
    {
        char buf[64] = {0};
        PVFS_strerror_r(js_p->error_code, buf, 64);
        gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "remove_helper_cleanup error: %s\n", buf);
    }
    return SM_ACTION_COMPLETE;
}


static int remove_datafiles_comp_fn(void *v_p,
                                    struct PVFS_server_resp *resp_p,
                                    int index)
{
    //PINT_smcb *smcb = v_p;
    //PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int resp_status = resp_p->status;
    int i;


    assert(resp_p->op == PVFS_SERV_TREE_REMOVE);

    if (resp_status != 0)
    {
       return (resp_status);
    }

    gossip_err("%s:resp_status(%d)\n",__func__,resp_status);

    for (i=0; i<resp_p->u.tree_remove.handle_count; i++)
    {
       gossip_err("%s:handle(%d)\tstatus(%d)\n",
                  __func__,
                  i,
                  resp_p->u.tree_remove.status[i]);
       if ( resp_p->u.tree_remove.status[i] == -PVFS_TIMEOUT_CAP )
       {
          /* if there was a failure deleting a datafile, then ignore it and let
           * fsck or some other process clean up orphaned datafiles.  However, if
           * the delete failed due to a timeout, regenerate the capability and try
           * again.  Because we are retrying, some of the datafiles may have already 
           * been removed, so we can ignore those errors as well.
           */
          resp_status = -PVFS_TIMEOUT_CAP;
       }
               
    }

    return (resp_status);
}/*end function remove_datafiles_comp_fn*/

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
