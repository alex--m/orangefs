/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_msgpairarray_sm
 *
 * The purpose of this state machine is to prepare, send, and
 * receive a collection of request/response pairs (msgpairs).
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "pint-bucket.h"
#include "job.h"
#include "gossip.h"
#include "pint-servreq.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

enum
{
    MSGPAIRS_COMPLETE = 190,
    MSGPAIRS_RETRY = 191
};

static int msgpairarray_init(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_post(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_post_retry(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_complete(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_completion_fn(
    PINT_client_sm *sm_p, job_status_s *js_p);

%%

nested machine pvfs2_client_msgpairarray_sm(init,
                                            post,
                                            post_retry,
					    complete,
					    completion_fn)
{
    state init
    {
        run msgpairarray_init;
        default => post;
    }

    state post
    {
        run msgpairarray_post;
	MSGPAIRS_COMPLETE => completion_fn;
        default => complete;
    }

    state post_retry
    {
        run msgpairarray_post_retry;
        default => post;
    }

    state complete
    {
        run msgpairarray_complete;
        MSGPAIRS_COMPLETE => completion_fn;
        default => complete;
    }

    state completion_fn
    {
        run msgpairarray_completion_fn;
        MSGPAIRS_RETRY => post_retry;
        default => return;
    }
}

%%

static int msgpairarray_init(PINT_client_sm *sm_p,
                             job_status_s *js_p)
{
    int i = 0;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "msgpairarray state: init (%d message(s))\n",
                 sm_p->msgarray_count);

    assert(sm_p->msgarray_count > 0);

    js_p->error_code = 0;

    /*
      set number of operations that must complete.  we're using the
      comp_ct in the first msgarray entry to keep up with the count
      for the entire array.
    */
    sm_p->msgarray[0].comp_ct = 2 * sm_p->msgarray_count;

    for(i = 0; i < sm_p->msgarray_count; i++)
    {
        msg_p = &sm_p->msgarray[i];
        assert(msg_p);

        msg_p->encoded_resp_p = NULL;
        msg_p->retry_count = 0;
    }
    return 1;
}

/* msgpairarray_post()
 *
 * The following elements of the PINT_client_sm_msgpair_state
 * should be valid prior to this state (for each msgpair in array):
 * - req (unencoded request)
 * - srv_addr of each element in msg array
 *
 * This state performs the following operations for each msgpair,
 * one at a time:
 * (1) encodes request
 * (2) calculates maximum response size
 * (3) allocates BMI memory for response data (encoded)
 * (4) gets a session tag for the pair of messages
 * (5) posts the receive of the response
 * (6) posts the send of the request
 * (7) stores job ids for later matching
 *
 */
static int msgpairarray_post(PINT_client_sm *sm_p,
			     job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0, tmp = 0;
    struct server_configuration_s *server_config = NULL;
    PVFS_msg_tag_t session_tag;
    PINT_client_sm_msgpair_state *msg_p = NULL;
    struct filesystem_configuration_s *cur_fs = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "msgpairarray state: post (%d message(s))\n",
		 sm_p->msgarray_count);

    assert(sm_p->msgarray_count > 0);

    js_p->error_code = 0;

    for (i = 0; i < sm_p->msgarray_count; i++)
    {
        msg_p = &sm_p->msgarray[i];
        assert(msg_p);

        assert((msg_p->retry_flag == PVFS_MSGPAIR_RETRY) ||
               (msg_p->retry_flag == PVFS_MSGPAIR_NO_RETRY));

        msg_p->op_status = 0;

        if (msg_p->encoded_resp_p == NULL)
        {
            enum PVFS_encoding_type enc_type = ENCODING_DEFAULT;

            if (msg_p->fs_id != PVFS_FS_ID_NULL)
            {
                server_config = PINT_get_server_config_struct(
                    msg_p->fs_id);
                assert(server_config);

                cur_fs = PINT_config_find_fs_id(server_config,
                                                msg_p->fs_id);
                PINT_put_server_config_struct(server_config);
                assert(cur_fs);
                enc_type = cur_fs->encoding;
            }

            ret = PINT_encode(&msg_p->req, PINT_ENCODE_REQ,
                              &msg_p->encoded_req, msg_p->svr_addr,
                              enc_type);
            if (ret != 0)
            {
                gossip_lerr("msgpairarray_post: PINT_encode failed\n");
                js_p->error_code = ret;
                return 1;
            }

            /* calculate maximum response message size and allocate space */
            msg_p->max_resp_sz = PINT_encode_calc_max_size(
                PINT_ENCODE_RESP, msg_p->req.op, enc_type);

            msg_p->encoded_resp_p = BMI_memalloc(
                msg_p->svr_addr, msg_p->max_resp_sz, BMI_RECV);

            if (msg_p->encoded_resp_p == NULL)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return 1;
            }
        }

      post_msg_receive:
	session_tag = get_next_session_tag();

	/* post receive of response; job_id stored in recv_id */
	ret = job_bmi_recv(msg_p->svr_addr,
			   msg_p->encoded_resp_p,
			   msg_p->max_resp_sz,
			   session_tag,
			   BMI_PRE_ALLOC,
			   sm_p,
			   i,
			   &msg_p->recv_status,
			   &msg_p->recv_id,
			   pint_client_sm_context,
			   PVFS2_CLIENT_JOB_TIMEOUT);
	if(ret == 0)
	{
	    /* perform a quick test to see if the recv failed before posting
	     * the send; if it reports an error quickly then we can save the
	     * confusion of sending a request for which we can't recv a
	     * response
	     */
	    ret = job_test(msg_p->recv_id, &tmp, NULL,
			   &msg_p->recv_status, 0, pint_client_sm_context);
	}

	if (ret < 0 || ret == 1)
        {
	    /* it is impossible for this recv to complete at this point
	     * without errors; we haven't sent the request yet!
	     */
	    assert(ret < 0 || msg_p->recv_status.error_code != 0);
	    if(ret < 0)
		PVFS_perror_gossip("Post of receive failed", ret);
	    else
		PVFS_perror_gossip("Receive immediately failed",
			    msg_p->recv_status.error_code);

	    msg_p->recv_id = 0;
	    msg_p->send_id = 0;

	    /* mark send as bad too and don't post it */
	    msg_p->send_status.error_code = msg_p->recv_status.error_code;
	    msg_p->op_status = msg_p->recv_status.error_code;
	    sm_p->msgarray[0].comp_ct -= 2;
	    /* continue to send other array entries if possible */
	    continue;
	}

	/* if we reach here, the recv has been posted without failure, but
	 * has not completed yet
	 */
	assert(ret == 0);

	/* post send of request; job_id stored in send_id */
	ret = job_bmi_send_list(msg_p->encoded_req.dest,
				msg_p->encoded_req.buffer_list,
				msg_p->encoded_req.size_list,
				msg_p->encoded_req.list_count,
				msg_p->encoded_req.total_size,
				session_tag,
				msg_p->encoded_req.buffer_type,
				1,
				sm_p,
				sm_p->msgarray_count+i,
				&msg_p->send_status,
				&msg_p->send_id,
				pint_client_sm_context,
				PVFS2_CLIENT_JOB_TIMEOUT);
	if (ret < 0)
        {
	    PVFS_perror_gossip("Post of send failed; should cancel recv", ret);

	    assert(msg_p->send_status.error_code != 0);

	    msg_p->op_status = msg_p->send_status.error_code;
	    sm_p->msgarray[0].comp_ct--;
	}
	else if (ret == 1)
        {
	    /*
              send completed immediately; decrement the completion
              counter
            */
	    gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "  msgpairarray: send completed immediately.\n");

	    /* 0 is the valid "completed job id" value */
	    msg_p->send_id = 0;

	    if (msg_p->send_status.error_code != 0)
            {
                PVFS_perror_gossip("Canceling recv due to send failure:",
                            msg_p->send_status.error_code);

                ret = PINT_client_bmi_cancel(msg_p->recv_id);
		/* this should not fail */
		assert(ret == 0);

                if ((msg_p->retry_flag == PVFS_MSGPAIR_RETRY) &&
                    (PVFS_ERROR_CLASS(-msg_p->send_status.error_code) ==
                     PVFS_ERROR_BMI) &&
                    (msg_p->retry_count < PVFS_MSGPAIR_RETRY_LIMIT))
                {
                    gossip_debug(GOSSIP_CLIENT_DEBUG, "*** msgpair "
                                 "restarting due to send failure\n");

                    msg_p->retry_count++;
                    goto post_msg_receive;
                }
	    }

	    /* decrement our count, since send is already done.
	     *
	     * we're using the comp_ct in the first array element to
	     * keep up with our count for the entire array.
	     */
	    sm_p->msgarray[0].comp_ct--;
	}
	assert(ret == 0 || ret == 1);
    }

    if(sm_p->msgarray[0].comp_ct == 0)
    {
	/* everything is completed already (could happen in some failure
	 * cases); jump straight to final completion function.
	 */
	 gossip_err("HEY, LOOK AT ME!\n");
	 js_p->error_code = MSGPAIRS_COMPLETE;
	 return 1;
    }
    else
    {
	/* we are still waiting on operations to complete, next state
	 * transition will handle them
	 */
	return 0;

    }
}

static int msgpairarray_post_retry(PINT_client_sm *sm_p,
                                   job_status_s *js_p)
{
    job_id_t tmp_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "msgpairarray state: post_retry\n");

    return job_req_sched_post_timer(
        PVFS2_CLIENT_RETRY_DELAY, sm_p, 0, js_p, &tmp_id,
        pint_client_sm_context);
}

static int msgpairarray_complete(PINT_client_sm *sm_p,
                                 job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "msgpairarray state: complete\n");

    /* match operation with something in the msgpair array */
    /* the first N tags are receives, the second N are sends */
    assert(js_p->status_user_tag < sm_p->msgarray_count*2);

    if (js_p->status_user_tag < sm_p->msgarray_count)
    {
	PINT_client_sm_msgpair_state *msg_p = 
	    &sm_p->msgarray[js_p->status_user_tag];

	msg_p->recv_id = 0;
	msg_p->recv_status = *js_p;

	/* save error, if any, in op_status */
	msg_p->op_status = msg_p->recv_status.error_code;
    }
    else
    {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[
            js_p->status_user_tag - sm_p->msgarray_count];

	msg_p->send_id = 0;
	msg_p->send_status = *js_p;

	/* save error, if any, in op_status */
	msg_p->op_status = msg_p->send_status.error_code;
    }

    /* decrement comp_ct until all operations have completed */
    if (--sm_p->msgarray[0].comp_ct > 0)
    {
	return 0;
    }

    assert(sm_p->msgarray[0].comp_ct == 0);
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "  msgpairarray: all operations complete\n");

    js_p->error_code = MSGPAIRS_COMPLETE;
    return 1;
}

static int msgpairarray_completion_fn(PINT_client_sm *sm_p,
				      job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "msgpairarray state: "
                 "completion_fn\n");

    for (i = 0; i < sm_p->msgarray_count; i++)
    {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];
        assert(msg_p);

	if (msg_p->op_status != 0)
	{
            if ((msg_p->retry_flag == PVFS_MSGPAIR_RETRY) &&
                (PVFS_ERROR_CLASS(-msg_p->op_status) ==
                 PVFS_ERROR_BMI) &&
                (msg_p->retry_count < PVFS_MSGPAIR_RETRY_LIMIT))
            {
                msg_p->retry_count++;

                gossip_debug(GOSSIP_CLIENT_DEBUG, "*** msgarray send "
                             "failed -- retrying msgpair "
                             "(count = %d)\n", msg_p->retry_count);

                /* FIXME: only redo the failed ones, not all */
                sm_p->msgarray[0].comp_ct = 2 * sm_p->msgarray_count;

                js_p->error_code = MSGPAIRS_RETRY;
                return 1;
            }

	    PVFS_perror_gossip("*** msgpair did not complete successfully",
                        msg_p->op_status);

	    js_p->error_code = msg_p->op_status;
	    continue;
	}

	ret = PINT_serv_decode_resp(msg_p->fs_id,
				    msg_p->encoded_resp_p,
				    &decoded_resp,
				    &msg_p->svr_addr,
				    msg_p->recv_status.actual_size,
				    &resp_p);
	if (ret != 0)
        {
            PVFS_perror_gossip("msgpairarray decode error", ret);
            js_p->error_code = ret;
            return 1;
	}

	assert(resp_p->status <= 0);

	/* if we've made it this far, the server response status is
	 * meaningful, so we save it.
	 */
	msg_p->op_status = resp_p->status;
	
	/* NOTE: we call the function associated with each message,
	 *       not just the one from the first array element.  so
	 *       there could in theory be different functions for each
	 *       message (to handle different types of messages all in
	 *       the same array).
	 */
	if (msg_p->comp_fn != NULL)
	{
	    /* If we call the completion function, store the result on
	     * a per message pair basis.  Also store some non-zero
	     * (failure) value in js_p->error_code if we see one.
	     */
	    msg_p->op_status = msg_p->comp_fn(sm_p, resp_p, i);
	    if (msg_p->op_status != 0)
	    {
		js_p->error_code = msg_p->op_status;
	    }

	    /* even if we see a failure, continue to process with the
	     * completion function. -- RobR
	     */
	}
	else if (resp_p->status != 0)
        {
	    /* no comp_fn specified and status non-zero */
	    gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "notice: msgpairarray_complete: error %d "
                         "from server %d\n", resp_p->status, i);

	    /* save a non-zero status to return if we see one */
	    js_p->error_code = resp_p->status;

	    /* If we don't have a completion function, there is no point
	     * in continuing to process after seeing a failure.
	     */
	    if (js_p->error_code)
            {
                break;
            }
	}
	
	/* free all the resources that we used to send and receive. */
	ret = PINT_serv_free_msgpair_resources(&msg_p->encoded_req,
					       msg_p->encoded_resp_p,
					       &decoded_resp,
					       &msg_p->svr_addr,
					       msg_p->max_resp_sz);
	if (ret != 0)
        {
            PVFS_perror_gossip("Failed to free msgpair resources", ret);
            js_p->error_code = ret;
            return 1;
	}
    }
    return 1;
}
    
/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
