/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_msgpairarray_sm
 *
 * The purpose of this state machine is to prepare, send, and
 * receive a collection of request/response pairs (msgpairs).
 *
 * The following elements of the PINT_client_sm_msgpair_state
 * must be valid prior to entering this state machine:
 * - req (unencoded request)
 * - fs_id
 * - handle
 * - comp_fn
 *
 * When this state machine returns, ...
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "pint-bucket.h"
#include "job.h"
#include "gossip.h"
#include "pint-servreq.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

enum
{
    MSGPAIRS_COMPLETE = 1
};

static int msgpairarray_post(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_complete(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_completion_fn(
    PINT_client_sm *sm_p, job_status_s *js_p);

%%

nested machine pvfs2_client_msgpairarray_sm(post,
					    complete,
					    completion_fn)
{
    state post
    {
        run msgpairarray_post;
        default => complete;
    }

    state complete
    {
        run msgpairarray_complete;
        success => complete;
        MSGPAIRS_COMPLETE => completion_fn;
        default => return;
    }

    state completion_fn
    {
        run msgpairarray_completion_fn;
        default => return;
    }
}

%%

/* msgpairarray_post()
 *
 * The following elements of the PINT_client_sm_msgpair_state
 * should be valid prior to this state (for each msgpair in array):
 * - req (unencoded request)
 * - srv_addr of each element in msg array
 *
 * This state performs the following operations for each msgpair,
 * one at a time:
 * (1) encodes request
 * (2) calculates maximum response size
 * (3) allocates BMI memory for response data (encoded)
 * (4) gets a session tag for the pair of messages
 * (5) posts the receive of the response
 * (6) posts the send of the request
 * (7) stores job ids for later matching
 *
 */
static int msgpairarray_post(PINT_client_sm *sm_p,
			     job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0, tmp = 0;
    job_status_s status;
    struct server_configuration_s *server_config = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "msgpairarray state: post (%d message(s))\n",
		 sm_p->msgarray_count);

    assert(sm_p->msgarray_count > 0);

    js_p->error_code = 0;

    /* set number of operations that must complete.
     *
     * NOTE: we're using the comp_ct in the first msgarray
     * entry to keep up with the count for the entire array.
     */
    sm_p->msgarray[0].comp_ct = 2 * sm_p->msgarray_count;

    for (i = 0; i < sm_p->msgarray_count; i++)
    {
	PVFS_msg_tag_t session_tag;
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];
	struct filesystem_configuration_s *cur_fs = NULL;

        server_config = PINT_get_server_config_struct(msg_p->fs_id);
	cur_fs = PINT_config_find_fs_id(server_config, msg_p->fs_id);
        PINT_put_server_config_struct(server_config);
	assert(cur_fs);

        assert((msg_p->retry_flag == PVFS_MSGPAIR_RETRY) ||
               (msg_p->retry_flag == PVFS_MSGPAIR_NO_RETRY));

	ret = PINT_encode(&msg_p->req, PINT_ENCODE_REQ,
                          &msg_p->encoded_req, msg_p->svr_addr,
			  cur_fs->encoding);
	if (ret != 0)
        {
	    gossip_lerr("msgpairarray_post: PINT_encode failed\n");
            js_p->error_code = ret;
            return 1;
	}

	/* calculate maximum response message size and allocate space */
	msg_p->max_resp_sz = PINT_encode_calc_max_size(
            PINT_ENCODE_RESP, msg_p->req.op, cur_fs->encoding);

	msg_p->encoded_resp_p = BMI_memalloc(
            msg_p->svr_addr, msg_p->max_resp_sz, BMI_RECV);

	if (msg_p->encoded_resp_p == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return 1;
	}

      post_msg_receive:
	session_tag = get_next_session_tag();

	/* post receive of response; job_id stored in recv_id */
	ret = job_bmi_recv(msg_p->svr_addr,
			   msg_p->encoded_resp_p,
			   msg_p->max_resp_sz,
			   session_tag,
			   BMI_PRE_ALLOC,
			   sm_p,
			   i,
			   &msg_p->recv_status,
			   &msg_p->recv_id,
			   pint_client_sm_context,
			   PVFS2_CLIENT_JOB_TIMEOUT);
	if (ret < 0)
        {
	    gossip_lerr("post of receive failed\n");
            js_p->error_code = ret;
            return 1;
	}
	else if (ret == 1)
        {
	    /* we can get this if we have lost connectivity to this server */
	    assert(msg_p->recv_status.error_code != 0);

	    msg_p->recv_id = 0;
	    msg_p->send_id = 0;

	    /* mark send as bad too and don't post it */
	    /* TODO: what should this error be?  copy of recv? */
	    msg_p->send_status.error_code = -PVFS_EIO;

	    msg_p->op_status = msg_p->recv_status.error_code;

	    sm_p->msgarray[0].comp_ct -= 2;
	    continue;
	}
	assert(ret == 0);

        /*
          before posting the send, we need to be sure the recv did not
          fail.  if it failed, we may be able to retry the operation
          depending on the retry flag which can cause an underlying
          reconnect
        */
        memset(&status, 0, sizeof(job_status_s));
        ret = job_test(msg_p->recv_id, &tmp, NULL,
                       &status, 0, pint_client_sm_context);
        if (ret != 0)
        {
            if ((msg_p->retry_flag == PVFS_MSGPAIR_RETRY) &&
                (PVFS_ERROR_CLASS(status.error_code) == PVFS_ERROR_BMI))
            {
                gossip_debug(GOSSIP_CLIENT_DEBUG,
                             "*** Reposting receive due to failure (%d)\n",
                             ret);
                goto post_msg_receive;
            }
        }

	/* post send of request; job_id stored in send_id */
	ret = job_bmi_send_list(msg_p->encoded_req.dest,
				msg_p->encoded_req.buffer_list,
				msg_p->encoded_req.size_list,
				msg_p->encoded_req.list_count,
				msg_p->encoded_req.total_size,
				session_tag,
				msg_p->encoded_req.buffer_type,
				1,
				sm_p,
				sm_p->msgarray_count+i,
				&msg_p->send_status,
				&msg_p->send_id,
				pint_client_sm_context,
				PVFS2_CLIENT_JOB_TIMEOUT);
	if (ret < 0)
        {
	    gossip_lerr("post of send failed; should cancel recv\n");

	    assert(msg_p->send_status.error_code != 0);

	    msg_p->op_status = msg_p->send_status.error_code;
	    sm_p->msgarray[0].comp_ct--;
	}
	else if (ret == 1)
        {
	    /*
              send completed immediately; decrement the completion
              counter
            */
	    gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "  msgpairarray: send completed immediately.\n");

	    /* 0 is the valid "completed job id" value */
	    msg_p->send_id = 0;

	    if (msg_p->send_status.error_code != 0)
            {
		gossip_err("msgarray send post failed; "
                           "should cancel recv\n");
	    }

	    /* decrement our count, since send is already done.
	     *
	     * we're using the comp_ct in the first array element to
	     * keep up with our count for the entire array.
	     */
	    sm_p->msgarray[0].comp_ct--;
	}
	assert(ret == 0 || ret == 1);
    }
    return 0;
}

static int msgpairarray_complete(PINT_client_sm *sm_p,
                                 job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "msgpairarray state: complete\n");

    /* match operation with something in the msgpair array */
    /* the first N tags are receives, the second N are sends */
    assert(js_p->status_user_tag < sm_p->msgarray_count*2);

    if (js_p->status_user_tag < sm_p->msgarray_count)
    {
	PINT_client_sm_msgpair_state *msg_p = 
	    &sm_p->msgarray[js_p->status_user_tag];

	msg_p->recv_id = 0;
	msg_p->recv_status = *js_p;

	/* save error, if any, in op_status */
	msg_p->op_status = msg_p->recv_status.error_code;
    }
    else
    {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[
            js_p->status_user_tag - sm_p->msgarray_count];

	msg_p->send_id = 0;
	msg_p->send_status = *js_p;

	if (msg_p->send_status.error_code != 0)
        {
	    gossip_err("msgarray bad send; should cancel recv\n");
	}

	/* save error, if any, in op_status */
	msg_p->op_status = msg_p->send_status.error_code;
    }

    /* decrement comp_ct until all operations have completed */
    if (--sm_p->msgarray[0].comp_ct > 0)
    {
	return 0;
    }

    assert(sm_p->msgarray[0].comp_ct == 0);
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "  msgpairarray: all operations complete\n");

    js_p->error_code = MSGPAIRS_COMPLETE;
    return 1;
}

static int msgpairarray_completion_fn(PINT_client_sm *sm_p,
				      job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    js_p->error_code = 0;

    for (i = 0; i < sm_p->msgarray_count; i++)
    {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];
        assert(msg_p);

	if (msg_p->op_status != 0)
	{
	    PVFS_perror("msg pair did not complete; skipping comp_fn\n",
                        msg_p->op_status);
	    js_p->error_code = msg_p->op_status;
	    continue;
	}

	ret = PINT_serv_decode_resp(msg_p->encoded_resp_p,
				    &decoded_resp,
				    &msg_p->svr_addr,
				    msg_p->recv_status.actual_size,
				    &resp_p);
	if (ret != 0)
        {
            PVFS_perror("msgpairarray decode error", ret);
            js_p->error_code = ret;
            return 1;
	}

	assert(resp_p->status <= 0);

	/* if we've made it this far, the server response status is
	 * meaningful, so we save it.
	 */
	msg_p->op_status = resp_p->status;
	
	/* NOTE: we call the function associated with each message,
	 *       not just the one from the first array element.  so
	 *       there could in theory be different functions for each
	 *       message (to handle different types of messages all in
	 *       the same array).
	 */
	if (msg_p->comp_fn != NULL)
	{
	    /* If we call the completion function, store the result on
	     * a per message pair basis.  Also store some non-zero
	     * (failure) value in js_p->error_code if we see one.
	     */
	    msg_p->op_status = msg_p->comp_fn(sm_p, resp_p, i);
	    if (msg_p->op_status != 0)
	    {
		js_p->error_code = msg_p->op_status;
	    }

	    /* even if we see a failure, continue to process with the
	     * completion function. -- RobR
	     */
	}
	else if (resp_p->status != 0)
        {
	    /* no comp_fn specified and status non-zero */
	    gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "notice: msgpairarray_complete: error %d "
                         "from server %d\n", resp_p->status, i);

	    /* save a non-zero status to return if we see one */
	    js_p->error_code = resp_p->status;

	    /* If we don't have a completion function, there is no point
	     * in continuing to process after seeing a failure.
	     */
	    if (js_p->error_code)
            {
                break;
            }
	}
	
	/* free all the resources that we used to send and receive. */
	ret = PINT_serv_free_msgpair_resources(&msg_p->encoded_req,
					       msg_p->encoded_resp_p,
					       &decoded_resp,
					       &msg_p->svr_addr,
					       msg_p->max_resp_sz);
	if (ret != 0)
        {
            PVFS_perror("Failed to free msgpair resources", ret);
            js_p->error_code = ret;
            return 1;
	}
    }
    return 1;
}
    
/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
