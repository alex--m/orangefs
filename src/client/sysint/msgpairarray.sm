/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_msgpairarray_sm
 *
 * The purpose of this state machine is to prepare, send, and
 * receive a collection of request/response pairs (msgpairs).
 *
 * The following elements of the PINT_client_sm_msgpair_state
 * must be valid prior to entering this state machine:
 * - req (unencoded request)
 * - fs_id
 * - handle
 * - comp_fn
 *
 * When this state machine returns, ...
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "pint-bucket.h"
#include "job.h"
#include "gossip.h"
#include "pint-servreq.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

enum {
    MSGPAIRS_COMPLETE = 1
};

static int msgpairarray_post(PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_complete(PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpairarray_completion_fn(PINT_client_sm *sm_p,
				      job_status_s *js_p);

%%

nested machine pvfs2_client_msgpairarray_sm(post,
					    complete,
					    completion_fn)
{
    state post {
	run msgpairarray_post;
	default => complete;
    }

    state complete {
	run msgpairarray_complete;
	success => complete;
	MSGPAIRS_COMPLETE => completion_fn;
	default => return;
    }
    state completion_fn {
	run msgpairarray_completion_fn;
	default => return;
    }
}

%%


/* msgpairarray_post()
 *
 * The following elements of the PINT_client_sm_msgpair_state
 * should be valid prior to this state (for each msgpair in array):
 * - req (unencoded request)
 * - srv_addr of each element in msg array
 *
 * This state performs the following operations for each msgpair,
 * one at a time:
 * (1) encodes request
 * (2) calculates maximum response size
 * (3) allocates BMI memory for response data (encoded)
 * (4) gets a session tag for the pair of messages
 * (5) posts the receive of the response
 * (6) posts the send of the request
 * (7) stores job ids for later matching
 *
 */
static int msgpairarray_post(PINT_client_sm *sm_p,
			     job_status_s *js_p)
{
    int ret, i;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "msgpairarray state: post (%d message(s))\n",
		 sm_p->msgarray_count);

    assert(sm_p->msgarray_count > 0); /* sanity check */

    /* we don't know what this is set to prior to this function,
     * so we reset it here.
     */
    js_p->error_code = 0;

    /* set number of operations that must complete.
     *
     * NOTE: we're using the comp_ct in the first msgarray
     * entry to keep up with the count for the entire array.
     */
    sm_p->msgarray[0].comp_ct = 2 * sm_p->msgarray_count;

    /* run through array of msgpairarray to kick off */
    for (i=0; i < sm_p->msgarray_count; i++) {
	PVFS_msg_tag_t session_tag;
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];
	struct filesystem_configuration_s *cur_fs;

	/* encode request. fills in encoded_req.
	 */
	cur_fs = PINT_config_find_fs_id(PINT_get_server_config_struct(),
	  msg_p->fs_id);
	assert(cur_fs);

	ret = PINT_encode(&msg_p->req,
			  PINT_ENCODE_REQ,
			  &msg_p->encoded_req,
			  msg_p->svr_addr,
			  cur_fs->encoding);
	if (ret != 0) {
	    gossip_lerr("pint_encode failed\n");
	    assert(ret < 0); /* return value range check */
	    assert(0); /* placeholder until we have real error handling */
	}

	/* calculate maximum response message size and allocate space.
	 * fills in max_resp_sz, encoded_resp_p
	 */
	msg_p->max_resp_sz = PINT_encode_calc_max_size(PINT_ENCODE_RESP,
						       msg_p->req.op,
						       cur_fs->encoding);
	msg_p->encoded_resp_p = BMI_memalloc(msg_p->svr_addr,
					     msg_p->max_resp_sz,
					     BMI_RECV);
	if (msg_p->encoded_resp_p == NULL) {
	    assert(0);
	}

	/* get session tag to associate with send and receive.
	 * session tag is kept as a local variable.
	 */
	session_tag = get_next_session_tag();

	/* post receive of response; job_id stored in recv_id */
	ret = job_bmi_recv(msg_p->svr_addr,
			   msg_p->encoded_resp_p,
			   msg_p->max_resp_sz,
			   session_tag,
			   BMI_PRE_ALLOC,
			   sm_p,
			   i,
			   &msg_p->recv_status,
			   &msg_p->recv_id,
			   pint_client_sm_context);
	if (ret < 0) {
	    gossip_lerr("post of receive failed\n");
	    assert(0);
	}
	else if (ret == 1) {
	    /* we can get this if we have lost connectivity to this server */
	    sm_p->msgarray[0].comp_ct -= 2;

	    assert(msg_p->recv_status.error_code != 0); /* sanity check */

	    msg_p->recv_id = 0;
	    msg_p->send_id = 0;

	    /* mark send as bad too and don't post it */
	    msg_p->send_status.error_code = PVFS_EIO; /* ??? */
	    continue;
	}
	assert(ret == 0); /* return value range check */

	/* post send of request; job_id stored in send_id */
	ret = job_bmi_send_list(msg_p->encoded_req.dest,
				msg_p->encoded_req.buffer_list,
				msg_p->encoded_req.size_list,
				msg_p->encoded_req.list_count,
				msg_p->encoded_req.total_size,
				session_tag,
				msg_p->encoded_req.buffer_type,
				1,
				sm_p,
				sm_p->msgarray_count+i,
				&msg_p->send_status,
				&msg_p->send_id,
				pint_client_sm_context);
	if (ret < 0) {
	    gossip_lerr("post of send failed; should cancel recv\n");

	    sm_p->msgarray[0].comp_ct--;

	}
	else if (ret == 1) {
	    /* send completed immediately; decrement the completion counter */
	    gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "  msgpairarray: send completed immediately.\n");

	    /* 0 is the valid "completed job id" value, according to Phil */
	    msg_p->send_id = 0;

	    if (msg_p->send_status.error_code != 0) {
		gossip_err("msgarray bad send; should cancel recv\n");
	    }

	    /* decrement our count, since send is already done.
	     *
	     * recall we're using the comp_ct in the first array
	     * element to keep up with our count for the entire
	     * array.
	     */
	    sm_p->msgarray[0].comp_ct--;
	}
	assert(ret == 0 || ret == 1); /* return value range check */
    }

    return 0;
}

/* msgpairarray_complete()
 *
 */     
static int msgpairarray_complete(PINT_client_sm *sm_p,
				 job_status_s *js_p)
{

    gossip_debug(GOSSIP_CLIENT_DEBUG, "msgpairarray state: complete\n");

    /* match operation with something in the msgpair array */
    /* the first N tags are receives, the second N are sends */
    assert(js_p->status_user_tag < sm_p->msgarray_count*2); /* sanity check */

    if(js_p->status_user_tag < sm_p->msgarray_count)
    {
	PINT_client_sm_msgpair_state *msg_p = 
	    &sm_p->msgarray[js_p->status_user_tag];

	msg_p->recv_id     = 0;
	msg_p->recv_status = *js_p;
    }
    else
    {
	PINT_client_sm_msgpair_state *msg_p = 
	    &sm_p->msgarray[js_p->status_user_tag - sm_p->msgarray_count];

	msg_p->send_id     = 0;
	msg_p->send_status = *js_p;

	if (msg_p->send_status.error_code != 0) {
	    gossip_err("msgarray bad send; should cancel recv\n");
	}
    }

    /* decrement comp_ct until all operations have completed.
     *
     * recall we're using the comp_ct in the first array element...
     */
    if (--sm_p->msgarray[0].comp_ct > 0) {
	return 0;
    }
    else {
	assert(sm_p->msgarray[0].comp_ct == 0); /* sanity check */
	js_p->error_code = MSGPAIRS_COMPLETE;
	gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "  msgpairarray: all operations complete\n");

	return 1;
    }
}

static int msgpairarray_completion_fn(PINT_client_sm *sm_p,
				      job_status_s *js_p)
{
    int ret, i;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    /* clear error code; we explicitly set it to non-zero to get to state  */
    js_p->error_code = 0;

    for (i=0; i < sm_p->msgarray_count; i++) {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

	if (msg_p->send_status.error_code != 0 ||
	    msg_p->recv_status.error_code != 0)
	{
	    js_p->error_code = msg_p->send_status.error_code;

	    /* don't call comp fn on these -- RobR */
	    gossip_err("msg pair did not complete; skipping comp_fn\n");
	    continue;
	}

	/* decode; resp_p will point to response */
	ret = PINT_serv_decode_resp(msg_p->encoded_resp_p,
				    &decoded_resp,
				    &msg_p->svr_addr,
				    msg_p->recv_status.actual_size,
				    &resp_p);
	if (ret != 0) {
	    gossip_err("error: msgpairarray_complete: decode error\n");
	    assert(ret < 0); /* return value range check */
	    assert(0); /* placeholder */
	}

	assert(resp_p->status <= 0); /* parameter range checking */
	msg_p->op_status = resp_p->status; /* save status value */
	
	/* call completion function to perform operation-specific
	 * functions.  this call must not block!!!
	 *
	 * NOTE: we call the function associated with each message,
	 *       not just the one from the first array element.  so
	 *       there could in theory be different functions for
	 *       each message (to handle different types of messages
	 *       all in the same array).
	 */
	if (msg_p->comp_fn != NULL) {
	    /* NOTE: this will result in only the last value being
	     * returned.  this is fine; the comp_fn can do whatever
	     * necessary to return the value that they're interested
	     * in I think? -- Rob
	     *
	     */
	    js_p->error_code = msg_p->comp_fn(sm_p, resp_p, i);

            /*
              break out if a completion function fails;
              caller will have to do manual cleanup in the
              next state (presumably a failure or cleanup state)
              -- Neill
            */
            if (js_p->error_code)
            {
                gossip_debug(GOSSIP_CLIENT_DEBUG, "Completion function %d "
                             "failed; aborting\n", i);
                break;
            }
	}
	else if (resp_p->status != 0) {
	    /* no comp_fn specified and status non-zero */
	    gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "notice: msgpairarray_complete: error %s (%d) "
                         "from server %d\n",
                         strerror(PVFS_ERROR_TO_ERRNO(-resp_p->status)),
                         resp_p->status,
			 i);
	    /* save a non-zero status to return if we see one */
	    js_p->error_code = resp_p->status;
	}
	
	/* free all the resources that we used to send and receive. */
	ret = PINT_serv_free_msgpair_resources(&msg_p->encoded_req,
					       msg_p->encoded_resp_p,
					       &decoded_resp,
					       &msg_p->svr_addr,
					       msg_p->max_resp_sz);
	if (ret != 0) {
	    assert(ret < 0); /* return value range check */
	    assert(0); /* placeholder */
	}
    }

    return 1;
}
    
/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
