/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "shared-state-methods.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"

/* pvfs2_client_flush-sm
 *
 * implementes the flush system interface function
 *
 * the input parameters are held in sm_p->u.flush
 *
 * we getattr on the passed-in handle.  if we are acting on a metafile
 * object, we will flush that metafile object and its associated
 * datafiles, making use of the sm_p->msgpairarray
 *
 *
 */

extern job_context_id pint_client_sm_context;

static int flush_datafile_flush_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int flush_datafile_setup_msgpairarray(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int flush_cleanup(
    PINT_client_sm *sm_p, job_status_s *js_p);

%%

machine pvfs2_client_flush_sm(flush_getattr_setup_msgpair,
                              flush_getattr_xfer_msgpair,
                              flush_getattr_failure,
                              flush_datafile_setup_msgpairarray,
                              flush_datafile_xfer_msgpairarray,
                              flush_datafile_flush_failure,
                              cleanup)
{
    state flush_getattr_setup_msgpair
    {
        run PINT_sm_common_object_getattr_setup_msgpair;
        success => flush_getattr_xfer_msgpair;
        default => flush_getattr_failure;
    }

    state flush_getattr_xfer_msgpair
    {
        jump pvfs2_client_getattr_acache_sm;
        success => flush_datafile_setup_msgpairarray;
        default => flush_getattr_failure;
    }

    state flush_getattr_failure
    {
        run PINT_sm_common_object_getattr_failure;
        default => cleanup;
    }

    state flush_datafile_setup_msgpairarray
    {
        run flush_datafile_setup_msgpairarray;
        success => flush_datafile_xfer_msgpairarray;
        default => cleanup;
    }

    state flush_datafile_xfer_msgpairarray
    {
        jump pvfs2_client_msgpairarray_sm;
        success => cleanup;
        default => flush_datafile_flush_failure;
    }

    state flush_datafile_flush_failure
    {
        run flush_datafile_flush_failure;
        default => cleanup;
    }
    
    state cleanup
    {
        run flush_cleanup;
        default => terminate;
    }
}

%%

/*
  PVFS_sys_flush()
  returns 0 on success; -errno otherwise
*/
int PVFS_sys_flush(PVFS_pinode_reference refn,
                   PVFS_credentials credentials)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_flush entered\n");

    if ((refn.fs_id == 0) || (refn.handle == 0))
    {
	gossip_err("Invalid handle/fs_id specified\n");
	return ret;
    }

    sm_p = (PINT_client_sm *)malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }

    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->object_ref = refn;

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_FLUSH);
    assert(ret == 0);

    while (!sm_p->op_complete && (ret == 0))
    {
	ret = PINT_client_state_machine_test();
    }
    assert(ret == 0);

    error = sm_p->error_code;

    free(sm_p);
    return error;
}

static int flush_datafile_setup_msgpairarray(PINT_client_sm *sm_p,
					    job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0;
    PVFS_object_attr *attr = NULL;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) flush state: "
                 "datafile_setup_msgpairarray\n", sm_p);

    js_p->error_code = 0;

    attr = (sm_p->acache_hit ?
            &sm_p->pinode->attr :
            &sm_p->acache_attr);

    assert(attr);
    assert(attr->objtype == PVFS_TYPE_METAFILE);
    assert(attr->mask & PVFS_ATTR_META_DFILES);
    assert(attr->u.meta.dfile_count > 0);

    /* datafile count + 1 metafile */
    sm_p->msgarray_count = (attr->u.meta.dfile_count + 1);

    /* allocate memory for datafile message pairs and the metafile */
    sm_p->msgarray = (PINT_client_sm_msgpair_state *)
	malloc(sm_p->msgarray_count *
               sizeof(PINT_client_sm_msgpair_state));
    if (!sm_p->msgarray)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return 1;
    }

    for(i = 0; i < sm_p->msgarray_count; i++)
    {
	msg_p = &sm_p->msgarray[i];

        if (i < attr->u.meta.dfile_count)
        {
            gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "  datafile_flush: flushing handle %Lu\n",
                         Lu(attr->u.meta.dfile_array[i]));

            PINT_SERVREQ_FLUSH_FILL(msg_p->req,
                                    *sm_p->cred_p,
                                    sm_p->object_ref.fs_id,
                                    attr->u.meta.dfile_array[i]);

            msg_p->fs_id = sm_p->object_ref.fs_id;
            msg_p->handle = attr->u.meta.dfile_array[i];
            msg_p->comp_fn = NULL;
        }
        else
        {
            assert(i == (sm_p->msgarray_count - 1));

            gossip_debug(GOSSIP_CLIENT_DEBUG,
                         "  metafile_flush: flushing handle %Lu\n",
                         Lu(sm_p->object_ref.handle));

            PINT_SERVREQ_FLUSH_FILL(msg_p->req,
                                    *sm_p->cred_p,
                                    sm_p->object_ref.fs_id,
                                    sm_p->object_ref.handle);

            msg_p->fs_id = sm_p->object_ref.fs_id;
            msg_p->handle = sm_p->object_ref.handle;
            msg_p->comp_fn = NULL;
        }
    }

    /* fill in address of each server to contact */
    ret = PINT_serv_msgpairarray_resolve_addrs(
        sm_p->msgarray_count, sm_p->msgarray);
    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
    return 1;
}

static int flush_datafile_flush_failure(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
		 "(%p) flush state: datafile_flush_failure\n",
		 sm_p);
    return 1;
}

static int flush_cleanup(PINT_client_sm *sm_p,
			job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "(%p) flush state: flush_cleanup\n", sm_p);

    if (sm_p->msgarray)
    {
        free(sm_p->msgarray);
    }

    sm_p->op_complete = 1;
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
