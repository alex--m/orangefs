/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_msgpair_sm
 *
 * The purpose of this state machine is to prepare, send, and
 * receive a request/response pair (msgpair).
 *
 * The following elements of the PINT_client_sm_msgpair_state
 * must be valid prior to entering this state machine:
 * - req (unencoded request of some type)
 * - srv_addr
 * - fs_id
 * - handle
 * - comp_fn
 *
 * When this state machine returns, ...
 *
 * TODO: augment this (and msgpairarray) so that they automatically have a
 *       look at responses and update the pcache and dcache appropriately,
 *       so we don't have to worry about them in other places.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "pint-bucket.h"
#include "job.h"
#include "gossip.h"
#include "pint-servreq.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

enum {
    MSGPAIR_COMPLETE = 9999
};

static int msgpair_post(PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpair_complete(PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpair_completion_fn(PINT_client_sm *sm_p, job_status_s *js_p);
static int msgpair_error(PINT_client_sm *sm_p, job_status_s *js_p);

%%

nested machine pvfs2_client_msgpair_sm(post,
				       complete,
				       completion_fn,
				       error)
{
    state post {
	run msgpair_post;
	success => complete;
	default => error;
    }

    state complete {
	run msgpair_complete;
	success => complete;
	MSGPAIR_COMPLETE => completion_fn;
	default => error;
    }

    state completion_fn {
	run msgpair_completion_fn;
	default => return;
    }
    
    state error {
	run msgpair_error;
	default => return;
    }
}

%%

/* msgpair_post()
 *
 * The following elements of the PINT_client_sm_msgpair_state
 * should be valid prior to this state:
 * - req (unencoded request)
 * - fs_id
 * - handle
 * - srv_addr
 *
 * This state performs the following operations:
 * (1) encodes request
 * (2) calculates maximum response size
 * (3) allocates BMI memory for response data (encoded)
 * (4) gets a session tag for the pair of messages
 * (5) posts the receive of the response
 * (6) posts the send of the request
 * (7) stores job ids for later matching
 *
 */
static int msgpair_post(PINT_client_sm *sm_p,
			job_status_s *js_p)
{
    int ret;
    PVFS_msg_tag_t session_tag;

    PINT_client_sm_msgpair_state *msg_p; /* for convenience */

    gossip_debug(CLIENT_DEBUG, "msgpair state: post\n");

    /* we don't know what this is set to prior to this function,
     * so we reset it here.
     */
    js_p->error_code = 0;

    msg_p = &sm_p->msgpair;

    /* NOTE: THIS IS REPLICATED IN PINT_SERV_PREPARE_MSGPAIR();
     * WE SHOULD GET RID OF ONE OF THEM OR SOMETHING...
     */

    /* encode request. fills in encoded_req.
     */
    ret = PINT_encode(&msg_p->req,
		      PINT_ENCODE_REQ,
		      &msg_p->encoded_req,
		      msg_p->svr_addr,
		      PINT_CLIENT_ENC_TYPE);
    if (ret != 0) {
	gossip_err("msgpair_post: failure encoding request\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* placeholder until we have real error handling */
    }

    /* calculate maximum response message size and allocate space.
     * fills in max_resp_sz, encoded_resp_p
     */
    msg_p->max_resp_sz = PINT_encode_calc_max_size(PINT_ENCODE_RESP,
						   msg_p->req.op,
						   PINT_CLIENT_ENC_TYPE);
    msg_p->encoded_resp_p = BMI_memalloc(msg_p->svr_addr,
					 msg_p->max_resp_sz,
					 BMI_RECV);
    if (msg_p->encoded_resp_p == NULL) {
	gossip_err("msgpair_post: failure in BMI_memalloc\n");
	assert(0);
    }

    /* get session tag to associate with send and receive.
     * session tag is kept as a local variable.
     */
    session_tag = get_next_session_tag();

    /* mark that we have two operations to complete. */
    msg_p->comp_ct = 2;

    /* post receive of response; job_id stored in recv_id */
    ret = job_bmi_recv(msg_p->svr_addr,
		       msg_p->encoded_resp_p,
		       msg_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p,
		       0,
		       &msg_p->recv_status,
		       &msg_p->recv_id,
		       pint_client_sm_context);
    if (ret < 0) {
	gossip_err("msgpair_post: failure in job_bmi_recv\n");
	assert(0);
    }
    else if (ret == 1) {
	/* it shouldn't be possible for the receive to complete before
	 * we send the request.
	 */
	assert(0);
    }
    assert(ret == 0); /* return value range check */

    /* post send of request; job_id stored in send_id */
    ret = job_bmi_send_list(msg_p->encoded_req.dest,
			    msg_p->encoded_req.buffer_list,
			    msg_p->encoded_req.size_list,
			    msg_p->encoded_req.list_count,
			    msg_p->encoded_req.total_size,
			    session_tag,
			    msg_p->encoded_req.buffer_type,
			    1,
			    sm_p,
			    0,
			    &msg_p->send_status,
			    &msg_p->send_id,
			    pint_client_sm_context);
    if (ret < 0) {
	gossip_err("msgpair_post: failure in job_bmi_send_list\n");
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "  msgpair: send completed immediately.\n");

	/* 0 is the valid "completed job id" value, according to Phil */
	msg_p->send_id = 0;

	/* TODO: CHECK THE STATUS!!! */
	assert(msg_p->send_status.error_code == 0);

	/* decrement our count, since send is already done */
	msg_p->comp_ct--;
	assert(msg_p->comp_ct == 1);
    }
    assert(ret == 0 || ret == 1); /* return value range check */

    return 0;
}

/* msgpair_complete()
 *
 * NOTE: the comp_fn can set the error_code of this to be non-zero.
 * we need to be sure to happily propagate this back up the path!
 *
 */     
static int msgpair_complete(PINT_client_sm *sm_p,
			    job_status_s *js_p)
{
    PINT_client_sm_msgpair_state *msg_p = &sm_p->msgpair; /* for convenience */

    gossip_debug(CLIENT_DEBUG, "msgpair state: complete\n");

    /* we know status of operation is 0, or we wouldn't be in this state. */

    /* decrement until both operations have completed */
    if (--msg_p->comp_ct > 0) {
	/* if this the first completion, then it is the send.  save
	 * the status.
	 *
	 * we will be woken up again by the next completion.
	 */
	msg_p->send_status = *js_p;
	return 0;
    }
    else {
	/* this is the second completion, which is the recv. */

	assert(msg_p->comp_ct == 0); /* sanity check */
	msg_p->recv_status = *js_p; /* save recv status */
	gossip_debug(CLIENT_DEBUG, "  msgpair: all operations complete\n");

	js_p->error_code = MSGPAIR_COMPLETE;
	return 1;
    }
}

static int msgpair_completion_fn(PINT_client_sm *sm_p,
				 job_status_s *js_p)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    PINT_client_sm_msgpair_state *msg_p = &sm_p->msgpair; /* for convenience */

    gossip_debug(CLIENT_DEBUG, "msgpair state: completion_fn\n");

    /* clear error code; was explicitly set to MSGPAIR_COMPLETE to get here. */
    js_p->error_code = 0;

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(msg_p->encoded_resp_p,
				&decoded_resp,
				&msg_p->svr_addr,
				msg_p->recv_status.actual_size,
				&resp_p);
    if (ret != 0) {
	gossip_err("error: msgpair_completion_fn: decode error\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* placeholder */
    }

    /* check status of response -- let errors pass though. */
    if (resp_p->status != 0)
    {
	gossip_debug(CLIENT_DEBUG, "notice: msgpair_completion_fn: "
                   "response status non-zero (%d)\n", resp_p->status);
#if 0
	PVFS_perror_gossip("msgpair_completion_fn", resp_p->status);
#endif
    }

    assert(resp_p->status <= 0); /* parameter range checking */
    msg_p->op_status = resp_p->status; /* save status value */

    /* call completion function to perform operation-specific
     * functions.  this call must not block!!!
     */
    if (msg_p->comp_fn != NULL) {
	/* Q: IS THERE ANY CONSTRAINT ON comp_fn OUTPUT? */
	js_p->error_code = msg_p->comp_fn(sm_p, resp_p, 0);
    }
    else if (resp_p->status != 0) {
	js_p->error_code = resp_p->status;
    }
    else if (ret != 0) {
	/* return error code in job status */
	/* TODO: SAVE THE ERROR CODE SOMEWHERE ELSE ALSO? */
	js_p->error_code = ret;
    }

    /* free all the resources that we used to send and receive. */
    ret = PINT_serv_free_msgpair_resources(&msg_p->encoded_req,
					   msg_p->encoded_resp_p,
					   &decoded_resp,
					   &msg_p->svr_addr,
					   msg_p->max_resp_sz);
    if (ret != 0) {
	assert(ret < 0); /* return value range check */
	assert(0); /* placeholder */
    }

    return 1;
}

/* msgpair_error()
 */
static int msgpair_error(PINT_client_sm *sm_p,
			 job_status_s *js_p)
{
    assert(0); /* placeholder */
    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
