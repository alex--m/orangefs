/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_getattr_pcache_sm
 *
 * The purpose of this state machine is to obtain simple attributes for an
 * object.  These attributes could come from a local cache (the pcache)
 * or be obtained from a remote server.
 *
 * This state machine is *not* appropriate for use, in itself, as a getattr
 * replacement.  This is mostly because it doesn't handle returning datafile
 * handles or grabbing sizes of objects.  That's ok; we only need that stuff
 * in a couple of specific cases, and those will be handled elsewhere.
 *
 * This state machine uses the msgpair structure in the PINT_client_sm
 * structure in order to perform the message passing.  It assumes that this
 * has been previously set up by the state machine above this one.  In
 * particular the following fields of the msgpair structure must be filled in:
 * - req (unencoded getattr request)
 * - fs_id
 * - handle
 * - comp_fn - called to pull attributes out of decoded response and store
 *   them in the appropriate place for the state machine jumping to this one
 *   (e.g. copies datafile handles out in the remove case)
 *
 * This state machine in turns jumps to the pvfs2_client_msgpair_sm to perform
 * messaging, if necessary.
 *
 * NOTE: the comp_fn can cause a non-zero error_code to be passed back up from
 *       the msgpair state machine and through this state machine back to the
 *       one that jumped to here.  so be aware!
 *
 * TODO: if we fail to get attributes on something, we should try to ensure
 *       that the dcache is cleared of any entries pertaining to that object.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "pvfs2-util.h"

#include "pint-servreq.h"
#include "pcache.h"
#include "PINT-reqproto-encode.h"

enum {
    GETATTR_PCACHE_MISS = 1
};

static int getattr_pcache_lookup(PINT_client_sm *sm_p,
				 job_status_s *js_p);

%%

nested machine pvfs2_client_getattr_pcache_sm(lookup,
					      xfer_msgpair)
{
    state lookup {
	run getattr_pcache_lookup;
	success => return;
	GETATTR_PCACHE_MISS => xfer_msgpair;
	default => return;
    }

    state xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
	default => return;
    }
}

%%

static int getattr_pcache_lookup(PINT_client_sm *sm_p,
				 job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "getattr_pcache state: lookup\n");

    /* we don't know what this is set to prior to this function,
     * so we reset it here.
     */
    js_p->error_code = 0;

    /* check input parameters */

    /* The idea is to check pcache to see if we have an entry.  if so, set
     * up a fake, decoded response structure with the results so that
     * we can then call the comp_fn to copy data out of the response
     * and into the PINT_client_sm structure.
     *
     * This is a little inefficient I suppose, but it's the most general
     * way to accomplish this.  We can optimize later if it seems
     * necessary.  Or we can tailor the pcache to store in response
     * format all the time...
     */
    assert(sm_p->pinode == NULL);
    sm_p->pinode = PINT_pcache_lookup(sm_p->u.getattr.object_ref);
    if (sm_p->pinode)
    {
        /*
          make sure pinode is not expired, and that it
          has all attribute info fields requested
        */
        if (PINT_pcache_pinode_status(sm_p->pinode) == PINODE_STATUS_VALID)
        {
            if (((sm_p->pinode->attr.objtype == PVFS_TYPE_METAFILE) &&
                 (sm_p->pinode->attr.mask ==
                  sm_p->msgpair.req.u.getattr.attrmask)) ||
                (sm_p->pinode->attr.objtype == PVFS_TYPE_DIRECTORY))
            {
                /* build a fake response for completion */
                struct PVFS_server_resp fake_resp;
                fake_resp.op = PVFS_SERV_GETATTR;
                fake_resp.status = 0;

                /*
                  skip the deep fill (i.e. copy) of attributes
                  on cache hit.  by setting the pcache_hit flag,
                  getattr won't try to read those attributes out
                */
                sm_p->pcache_hit = 1;
                sm_p->msgpair.comp_fn(sm_p, &fake_resp, 0);
                PINT_pcache_release(sm_p->pinode);
                return 1;
            }
        }
        PINT_pcache_release(sm_p->pinode);
    }

    js_p->error_code = GETATTR_PCACHE_MISS;
    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
