/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "shared-state-methods.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

static int truncate_datafile_setup_msgpairarray(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int truncate_datafile_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int truncate_cleanup(
    PINT_client_sm *sm_p, job_status_s *js_p);

%% 

machine pvfs2_client_truncate_sm(truncate_getattr_setup_msgpair,
                                 truncate_getattr_xfer_msgpair,
                                 truncate_getattr_failure,
                                 truncate_datafile_setup_msgpairarray,
                                 truncate_datafile_xfer_msgpairarray,
                                 truncate_datafile_failure,
                                 cleanup)
{
    state truncate_getattr_setup_msgpair
    {
        run PINT_sm_common_object_getattr_setup_msgpair;
        success => truncate_getattr_xfer_msgpair;
        default => truncate_getattr_failure;
    }

    state truncate_getattr_xfer_msgpair
    {
        jump pvfs2_client_getattr_acache_sm;
        success => truncate_datafile_setup_msgpairarray;
        default => truncate_getattr_failure;
    }

    state truncate_getattr_failure
    {
        run PINT_sm_common_object_getattr_failure;
        default => cleanup;
    }

    state truncate_datafile_setup_msgpairarray
    {
        run truncate_datafile_setup_msgpairarray;
        success => truncate_datafile_xfer_msgpairarray;
        default => cleanup;
    }

    state truncate_datafile_xfer_msgpairarray
    {
        jump pvfs2_client_msgpairarray_sm;
        success => cleanup;
        default => truncate_datafile_failure;
    }

    state truncate_datafile_failure
    {
        run truncate_datafile_failure;
        default => cleanup;
    }

    state cleanup
    {
        run truncate_cleanup;
        default => terminate;
    }
}

%%

int PVFS_sys_truncate(PVFS_object_ref ref,
                      PVFS_size size,
                      PVFS_credentials credentials)
{
    int ret = PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "PVFS_sys_truncate entered with %Ld\n", Ld(size));

    if ((ref.fs_id == PVFS_FS_ID_NULL) ||
        (ref.handle == PVFS_HANDLE_NULL))
    {
	gossip_lerr("Invalid pinode reference\n");
	return ret;
    }

    sm_p = (PINT_client_sm *)malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->object_ref = ref;
    sm_p->u.truncate.size = size;

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_TRUNCATE);
    if (ret)
    {
	gossip_lerr("Error: PINT_client_state_machine_post() failure.\n");
        free(sm_p);
        return ret;
    }

    while (!sm_p->op_complete && (ret == 0))
    {
	gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_truncate calling "
                     "PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }

    if (ret)
    {
	gossip_lerr("Error: PINT_client_state_machine_test() failure.\n");
	free(sm_p);
	return(ret);
    }

    error = sm_p->error_code;

    free(sm_p);
    return error;
}

static int truncate_datafile_setup_msgpairarray(PINT_client_sm *sm_p,
						job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, i = 0;
    PVFS_object_attr *attr = NULL;
    PINT_client_sm_msgpair_state *msg_p = NULL;
    PVFS_size new_dfile_size = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
	    "(%p) truncate state: datafile_setup_msgpairarray\n", sm_p);

    js_p->error_code = 0;

    attr = (sm_p->acache_hit ?
            &sm_p->pinode->attr :
            &sm_p->acache_attr);

    assert(attr);
    assert(attr->objtype == PVFS_TYPE_METAFILE);
    assert(attr->mask & PVFS_ATTR_META_DFILES);
    assert(attr->mask & PVFS_ATTR_META_DIST);
    assert(attr->u.meta.dfile_count > 0);
    assert(attr->u.meta.dist_size > 0);

    sm_p->msgarray_count = attr->u.meta.dfile_count;

    sm_p->msgarray = (PINT_client_sm_msgpair_state *)malloc(
        sm_p->msgarray_count * sizeof(PINT_client_sm_msgpair_state));
    if (!sm_p->msgarray)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return 1;
    }

    for (i = 0; i < attr->u.meta.dfile_count; i++)
    {
	msg_p = &sm_p->msgarray[i];

	gossip_debug(
            GOSSIP_CLIENT_DEBUG,
            "  datafile_truncate: client requests %Ld: resizing %Ld",
            Ld(sm_p->u.truncate.size),
            Lu(attr->u.meta.dfile_array[i]));

	new_dfile_size = 
            attr->u.meta.dist->methods->logical_to_physical_offset(
                attr->u.meta.dist->params, i, attr->u.meta.dfile_count,
                sm_p->u.truncate.size);

	gossip_debug(GOSSIP_CLIENT_DEBUG,
		" to %Ld bytes\n", Ld(new_dfile_size));

        PINT_SERVREQ_TRUNCATE_FILL(
            msg_p->req,
            *sm_p->cred_p,
            sm_p->object_ref.fs_id,
            new_dfile_size,
            attr->u.meta.dfile_array[i]);

	/*
          no callback. the status will be in the generic response
          structure
        */
	msg_p->fs_id = sm_p->object_ref.fs_id;
	msg_p->handle = attr->u.meta.dfile_array[i];
	msg_p->comp_fn = NULL;
    }

    /* fill in address of each server to contact */
    ret = PINT_serv_msgpairarray_resolve_addrs(
        sm_p->msgarray_count, sm_p->msgarray);
    if (ret)
    {
	gossip_err("Error: failed to resolve server addresses.\n");
        js_p->error_code = ret;
    }
    return 1;
}

static int truncate_datafile_failure(PINT_client_sm *sm_p,
                                     job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
	    "(%p) truncate state: datafile_failure\n", sm_p);
    return 1;
}

static int truncate_cleanup(PINT_client_sm *sm_p,
			    job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "(%p) truncate state: "
                 "truncate_cleanup\n", sm_p);

    if (sm_p->msgarray)
    {
        free(sm_p->msgarray);
    }

    /* add entry to acache if not already present */
    if (!sm_p->acache_hit)
    {
        int release_required = 1;
        PINT_pinode *pinode =
            PINT_acache_lookup(sm_p->object_ref);
        if (!pinode)
        {
            pinode = PINT_acache_pinode_alloc();
            assert(pinode);
            release_required = 0;
        }
        pinode->size = sm_p->u.truncate.size;
        pinode->refn = sm_p->object_ref;

        PINT_acache_object_attr_deep_copy(
            &pinode->attr, &sm_p->acache_attr);
        PINT_acache_object_attr_deep_free(
            &sm_p->acache_attr);

        PINT_acache_set_valid(pinode);

        if (release_required)
        {
            PINT_acache_release(pinode);
        }
        sm_p->acache_hit = 0;
    }
    sm_p->op_complete = 1;
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
