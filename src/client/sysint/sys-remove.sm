/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "pvfs2-client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"

/* from original remove.c */
#include "pinode-helper.h"
#include "pvfs2-sysint.h"
#include "pint-sysint.h"
#include "pint-dcache.h"
#include "pint-servreq.h"
#include "pint-dcache.h"
#include "pint-bucket.h"
#include "pcache.h"
#include "PINT-reqproto-encode.h"

static job_context_id pint_client_sm_context;

/* values greater than zero are usable here */
enum {
    REMOVE_DCACHE_HIT = 1,
    REMOVE_PCACHE_HIT = 2,
    REMOVE_MUST_REMOVE_DATAFILES = 3
};

static int remove_init(PINT_client_sm *sm_p,
		       job_status_s *js_p);

static int remove_post_lookup_sendrecv(PINT_client_sm *sm_p,
				       job_status_s *js_p);
static int remove_lookup_failure(PINT_client_sm *sm_p,
				 job_status_s *js_p);
static int remove_recv_lookup_resp(PINT_client_sm *sm_p,
				   job_status_s *js_p);

static int remove_post_getattr_sendrecv(PINT_client_sm *sm_p,
					job_status_s *js_p);
static int remove_getattr_failure(PINT_client_sm *sm_p,
				  job_status_s *js_p);
static int remove_recv_getattr_resp(PINT_client_sm *sm_p,
				    job_status_s *js_p);

static int remove_post_datafile_remove_sendrecv(PINT_client_sm *sm_p,
						job_status_s *js_p);
static int remove_datafile_remove_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p);
static int remove_recv_datafile_remove_resp(PINT_client_sm *sm_p,
					    job_status_s *js_p);

static int remove_post_rmdirent_sendrecv(PINT_client_sm *sm_p,
					 job_status_s *js_p);
static int remove_rmdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p);
static int remove_recv_rmdirent_resp(PINT_client_sm *sm_p,
				     job_status_s *js_p);

static int remove_post_object_remove_sendrecv(PINT_client_sm *sm_p,
					      job_status_s *js_p);
static int remove_object_remove_failure(PINT_client_sm *sm_p,
					job_status_s *js_p);
static int remove_recv_object_remove_resp(PINT_client_sm *sm_p,
					  job_status_s *js_p);

static int remove_cleanup(PINT_client_sm *sm_p,
			  job_status_s *js_p);

/* all stuff used in test function */
enum {
    MAX_RETURNED_JOBS = 32
};
static job_id_t job_id_array[MAX_RETURNED_JOBS];
static void *client_sm_p_array[MAX_RETURNED_JOBS];
static job_status_s job_status_array[MAX_RETURNED_JOBS];

%%

machine pvfs2_client_remove_sm(init,
			       cleanup,
			       post_lookup_sendrecv,
			       lookup_failure,
			       recv_lookup_resp,
			       post_getattr_sendrecv,
			       getattr_failure,
			       recv_getattr_resp,
			       post_datafile_remove_sendrecv,
			       datafile_remove_failure,
			       recv_datafile_remove_resp,
			       post_rmdirent_sendrecv,
			       rmdirent_failure,
			       recv_rmdirent_resp,
			       post_object_remove_sendrecv,
			       object_remove_failure,
			       recv_object_remove_resp)
{
    state init
	{
	    run remove_init;
	    default => post_lookup_sendrecv;
	}

    state post_lookup_sendrecv
	{
	    run remove_post_lookup_sendrecv;
	    success => recv_lookup_resp;
	    REMOVE_DCACHE_HIT => post_getattr_sendrecv;
	    REMOVE_PCACHE_HIT => cleanup;
	    default => lookup_failure;
	}

    state lookup_failure
	{
	    run remove_lookup_failure;
	    default => cleanup;
	}

    state recv_lookup_resp
	{
	    run remove_recv_lookup_resp;
	    success => post_rmdirent_sendrecv;
	    default => cleanup;
	}

    state post_getattr_sendrecv
	{
	    run remove_post_getattr_sendrecv;
	    success => recv_getattr_resp;
	    default => getattr_failure;
	}

    state getattr_failure
	{
	    run remove_getattr_failure;
	    default => cleanup;
	}

    state recv_getattr_resp
	{
	    run remove_recv_getattr_resp;
	    REMOVE_MUST_REMOVE_DATAFILES => post_datafile_remove_sendrecv;
	    success => post_object_remove_sendrecv;
	    default => cleanup;
	}

    state post_rmdirent_sendrecv
	{
	    run remove_post_rmdirent_sendrecv;
	    success => recv_rmdirent_resp;
	    default => rmdirent_failure;
	}

    state rmdirent_failure
	{
	    run remove_rmdirent_failure;
	    default => cleanup;
	}

    state recv_rmdirent_resp
	{
	    run remove_recv_rmdirent_resp;
	    default => post_getattr_sendrecv;
	}

    state post_datafile_remove_sendrecv
	{
	    run remove_post_datafile_remove_sendrecv;
	    success => recv_datafile_remove_resp;
	    default => datafile_remove_failure;
	}

    state datafile_remove_failure
	{
	    run remove_datafile_remove_failure;
	    default => cleanup;
	}

    state recv_datafile_remove_resp
	{
	    run remove_recv_datafile_remove_resp;
	    default => post_object_remove_sendrecv;
	}

    state post_object_remove_sendrecv
	{
	    run remove_post_object_remove_sendrecv;
	    success => recv_object_remove_resp;
	    default => object_remove_failure;
	}

    state object_remove_failure
	{
	    run remove_object_remove_failure;
	    default => cleanup;
	}

    state recv_object_remove_resp
	{
	    run remove_recv_object_remove_resp;
	    default => cleanup;
	}

    state cleanup
	{
	    run remove_cleanup;
	    default => init;
	}
}

%%


static int PINT_client_state_machine_post(PINT_client_sm *sm_p)
{
    int ret;
    job_status_s js;

    static int got_context = 0;

    /* TODO: MOVE THIS INTO THE INITIALIZE OR SOMETHING. */
    if (got_context == 0) {
	/* get a context for our state machine operations */
	job_open_context(&pint_client_sm_context);
	got_context = 1;
    }

    /* mark operation as unfinished */
    sm_p->op_complete = 0;

    /* figure out what function needs to be called first */
    sm_p->current_state = pvfs2_client_remove_sm.state_machine + 1;

    /* clear job status structure */
    memset(&js, 0, sizeof(js));

    /* call function, continue calling as long as we get immediate
     * success.
     */
    ret = sm_p->current_state->state_action(sm_p, &js);
    while (ret == 1) {
	/* PINT_state_machine_next() calls next function and
	 * returns the result.
	 */
	ret = PINT_state_machine_next(sm_p, &js);
    }

    /* note: job_status_s pointed to by js_p is ok to use after
     * we return regardless of whether or not we finished.
     */
    return ret;
}

static int PINT_client_state_machine_test(void)
{
    int ret, i;
    int job_count = MAX_RETURNED_JOBS;

    PINT_client_sm *sm_p;

    /* discover what jobs have completed */
    ret = job_testcontext(job_id_array,
			  &job_count, /* in/out parameter */
			  client_sm_p_array,
			  job_status_array,
			  100, /* timeout? */
			  pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }

    /* do as much as we can on every job that has completed */
    for (i=0; i < job_count; i++) {
	sm_p = (PINT_client_sm *) client_sm_p_array[i];

	ret = PINT_state_machine_next(sm_p,
				      &job_status_array[i]);
	while (ret == 1) {
	    /* PINT_state_machine_next() calls next function and
	     * returns the result.
	     */
	    ret = PINT_state_machine_next(sm_p,
					  &job_status_array[i]);
	}
	if (ret < 0) {
	    /* (ret < 0) indicates a problem from the job system
	     * itself; the return value of the underlying operation
	     * is kept in the job status structure.
	     */
	}
    }

    return 0;
}

int PVFS_sys_remove2(char *object_name,
		     PVFS_pinode_reference parent_ref, 
		     PVFS_credentials credentials)
{
    int ret;
    PINT_client_sm *sm_p;


    gossip_debug(CLIENT_DEBUG, "PVFS_sys_remove entered\n");

    /* do parameter checking here, then assume things are ok below.
     * assert()s are still ok of course :).
     */
    if (object_name == NULL) return -PVFS_EINVAL;

    /* build PINT_client_sm structure */
    /* TODO: KEEP A CACHE OF THESE AROUND SO WE'RE NOT ALWAYS MALLOC'ING? */
    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL) return -PVFS_ENOMEM;

    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.remove.object_name = object_name;
    sm_p->u.remove.parent_ref  = parent_ref;

    gossip_debug(CLIENT_DEBUG,
		 "PVFS_sys_remove calling PINT_client_state_machine_post()\n");

    /* do something to kick off processing */
    ret = PINT_client_state_machine_post(sm_p);
    assert(ret == 0);

    /* while !done call progress function */
    while (!sm_p->op_complete && ret == 0) {
	gossip_debug(CLIENT_DEBUG,
		     "PVFS_sys_remove calling PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }

    assert(ret == 0);

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_remove completed\n");

    /* clean up after ourselves */
    free(sm_p);
    return 0;
}

/* PINT_serv_prepare_msgpair()
 *
 * TODO: cache some values locally and assign at the end.
 */
static int PINT_serv_prepare_msgpair(PVFS_pinode_reference object_ref,
				     struct PVFS_server_req *req_p,
				     struct PINT_encoded_msg *encoded_req_out_p,
				     void **encoded_resp_out_pp,
				     bmi_addr_t *svr_addr_p,
				     int *max_resp_sz_out_p,
				     PVFS_msg_tag_t *session_tag_out_p)
{
    int ret;

    /* must determine destination server before we can encode;
     * this fills in sm_p->svr_addr.
     */
    ret = PINT_bucket_map_to_server(svr_addr_p,
				    object_ref.handle,
				    object_ref.fs_id);
    if (ret < 0) {
	assert(0);
    }

    /* encode request */
    ret = PINT_encode(req_p,
		      PINT_ENCODE_REQ,
		      encoded_req_out_p,
		      *svr_addr_p,
		      PINT_CLIENT_ENC_TYPE);
    if (ret < 0) {
	assert(0);
    }

    /* calculate maximum response message size and allocate space */
    *max_resp_sz_out_p = PINT_encode_calc_max_size(PINT_ENCODE_RESP,
						  req_p->op,
						  PINT_CLIENT_ENC_TYPE);

    *encoded_resp_out_pp = BMI_memalloc(*svr_addr_p,
					*max_resp_sz_out_p,
					BMI_RECV);
    if (*encoded_resp_out_pp == NULL) {
	assert(0);
    }

    /* get session tag to associate with send and receive */
    *session_tag_out_p = get_next_session_tag();

    return 0;
}

static int PINT_serv_decode_resp(void *encoded_resp_p,
				 struct PINT_decoded_msg *decoded_resp_p,
				 bmi_addr_t *svr_addr_p,
				 int actual_resp_sz,
				 struct PVFS_server_resp **resp_out_pp)
{
    int ret;

    /* decode response */
    ret = PINT_decode(encoded_resp_p,
		      PINT_DECODE_RESP,
		      decoded_resp_p, /* holds data on decoded resp */
		      *svr_addr_p,
		      actual_resp_sz);
    if (ret < 0) {
	assert(0);
    }

    /* point a reasonably typed pointer at the response data */
    *resp_out_pp = (struct PVFS_server_resp *) decoded_resp_p->buffer;

    return 0;
}

static int PINT_serv_free_msgpair_resources(struct PINT_encoded_msg *encoded_req_p,
					    void *encoded_resp_p,
					    struct PINT_decoded_msg *decoded_resp_p,
					    bmi_addr_t *svr_addr_p,
					    int max_resp_sz)
{
    PINT_encode_release(encoded_req_p,
			PINT_ENCODE_REQ);

    /* sm_p->req doesn't go anywhere; we'll use it again. */

    PINT_decode_release(decoded_resp_p,
			PINT_DECODE_RESP);

    BMI_memfree(*svr_addr_p,
		encoded_resp_p,
		max_resp_sz,
		BMI_RECV);

    return 0;
}

/****************************************************************/

/* remove_init()
 */
static int remove_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: init\n");

    /* do the request scheduler thing, if necessary */

    return 1;
}

/* remove_post_lookup_sendrecv()
 */
static int remove_post_lookup_sendrecv(PINT_client_sm *sm_p,
				       job_status_s *js_p)
{
    int ret;

    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_lookup_sendrecv\n");

    /* check and see if we have the handle for the object in
     * our directory cache already.
     *
     * dcache doesn't have a concept of a lock on an entry; maybe
     * it should though?
     */
    ret = PINT_dcache_lookup(sm_p->u.remove.object_name,
			     sm_p->u.remove.parent_ref,
			     &sm_p->u.remove.object_ref);
    if (ret < 0 && ret != -PVFS_ENOENT) {
	/* fatal error */
	return -1;
    }
    else if (ret == 0) {
	PINT_pinode *pinode_p;

	/* match in dcache; no need for lookup */
	gossip_debug(CLIENT_DEBUG, "remove: dcache hit\n");

	/* check to see if we have attributes for the object in
	 * our pinode cache already.
	 */
	/* TODO: MAKE PINT_PCACHE_LOOKUP RETURNS MORE STANDARD */
	/* TODO: MOVE THIS DOWN INTO THE GETATTR STATE!!! */
	ret = PINT_pcache_lookup(sm_p->u.remove.object_ref,
				 &pinode_p);
	if (ret == PCACHE_LOOKUP_SUCCESS) {
	    /* got our attributes; let's get to work */
	    gossip_debug(CLIENT_DEBUG, "remove: pcache hit\n");

	    sm_p->pcache_lock = 1;
	    sm_p->object_pinode_p = pinode_p;

	    js_p->error_code = REMOVE_PCACHE_HIT;
	    return 1;
	}				 
	else {
	    /* did hit dcache, but need to get attributes */
	    js_p->error_code = REMOVE_DCACHE_HIT;
	    return 1;
	}
    }

    /* otherwise we need to perform the lookup */

    /* post the receive of the response, then the send of the
     * lookup request.  pre-posting the receive can make a
     * performance difference for some network types.
     *
     * We're going to end up popping into the next state twice
     * because of these two posted operations.  We keep a counter
     * to keep up with how many operations have completed.  We'll
     * use the sm->comp_ct for this purpose.  We set to 2 (# of jobs)
     * and then decrement as they complete in the next state.
     */
    sm_p->comp_ct = 2;

    /* Steps:
     * (1) fill in request
     * (2) determine destination server
     * (3) encode request
     * (4) calculate max. size for response
     * (5) allocate BMI memory region for response
     * (6) get next session tag
     * (7) call job fn. to post receive
     * (8) call job fn. to post send
     */

    /* do parameter checking */
    if ((strlen(sm_p->u.remove.object_name) + 1 >
	 PVFS_REQ_LIMIT_PATH_NAME_BYTES) ||
	(PINT_string_count_segments(sm_p->u.remove.object_name) >
	 PVFS_REQ_LIMIT_PATH_SEGMENT_COUNT))
    {
	/* TODO: CLEAN UP... */
	assert(0);
	return -PVFS_ENAMETOOLONG;
    }

    /* fill in lookup request (macro in pvfs2-req-proto.h) */
    PINT_SERVREQ_LOOKUP_PATH_FILL(sm_p->req,
				  *sm_p->cred_p,
				  sm_p->u.remove.object_name,
				  sm_p->u.remove.parent_ref.fs_id,
				  sm_p->u.remove.parent_ref.handle,
				  PVFS_ATTR_COMMON_ALL);

    /* This function:
     * - maps object to server
     * - encodes the request
     * - calculates the max. response size
     * - allocates memory for that response
     * - gets a session tag
     */
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p, /* user pointer -- used to get to next state */
		       &recv_status, /* only for immediate completion */
		       &recv_id, /* could theoretically be used to unpost */
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0); /* just to see that we don't get odd values */

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p, /* user pointer, used to get to next state */
			    &send_status, /* only for immediate completion */
			    &send_id, /* could in theory be used to unpost */
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: lookup send completed immediately.\n");
	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);
	sm_p->comp_ct--;
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

/* remove_recv_lookup_resp()
 */
static int remove_recv_lookup_resp(PINT_client_sm *sm_p,
				   job_status_s *js_p)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_lookup_resp\n");

    /* we may or may not have previously completed either operation.
     * here we check to see if there are additional operations that
     * must complete successfully before we can continue.  if the
     * counter hits zero, we know we've gotten our data and can
     * continue.
     *
     * otherwise we return 0; we will get called again when the next
     * bmi job completes.
     */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }

    /* check status of response */
    if (resp_p->status != 0) {
	assert(0);
    }

    assert(resp_p->u.lookup_path.handle_count == 1);

    /* pull out the data that we wanted */
    sm_p->u.remove.object_ref.handle = resp_p->u.lookup_path.handle_array[0];
    sm_p->u.remove.object_ref.fs_id  = sm_p->u.remove.parent_ref.fs_id;

    gossip_debug(CLIENT_DEBUG, "lookup completed (handle = 0x%08Lx)\n",
		 sm_p->u.remove.object_ref.handle);

    /* free all the resources that we used to send and receive. */
    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    /* check permissions */

    /* Q: what do we do with directories?
     * Q: should we check that they are empty?
     */

    /* TODO: check that we have necessary metadata from lookup */

    return 1;
}

/* remove_post_getattr_sendrecv()
 *
 * Q: DO WE WANT TO REMOVE THE DIRECTORY ENTRY BEFORE THIS???
 */
static int remove_post_getattr_sendrecv(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    int ret;
    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_getattr_sendrecv\n");

    /* do parameter checking */

    /* mark that we have two messages to receive */
    sm_p->comp_ct = 2;

    /* fill in getattr request */
    PINT_SERVREQ_GETATTR_FILL(sm_p->req,
			      *sm_p->cred_p,
			      sm_p->u.remove.object_ref.fs_id,
			      sm_p->u.remove.object_ref.handle,
			      PVFS_ATTR_COMMON_ALL|PVFS_ATTR_META_DFILES);
    
    /* This function:
     * - maps object to server
     * - encodes the request
     * - calculates the max. response size
     * - allocates memory for that response
     * - gets a session tag
     */
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p, /* user pointer -- used to get to next state */
		       &recv_status, /* only for immediate completion */
		       &recv_id, /* could theoretically be used to unpost */
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0); /* just to see that we don't get odd values */

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p, /* user pointer, used to get to next state */
			    &send_status, /* only for immediate completion */
			    &send_id, /* could in theory be used to unpost */
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: getattr send completed immediately.\n");
	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);
	sm_p->comp_ct--;
	assert(sm_p->comp_ct == 1);
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

/* remove_recv_getattr_resp()
 */
static int remove_recv_getattr_resp(PINT_client_sm *sm_p,
				    job_status_s *js_p)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_getattr_resp\n");

    /* we may or may not have previously completed either operation.
     * here we check to see if there are additional operations that
     * must complete successfully before we can continue.  if the
     * counter hits zero, we know we've gotten our data and can
     * continue.
     *
     * otherwise we return 0; we will get called again when the next
     * bmi job completes.
     */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }


    /* check status of response */
    if (resp_p->status != 0) {
	gossip_err("error: remove sm: status = %d on getattr msg\n",
		   resp_p->status);
	assert(0);
    }

    gossip_debug(CLIENT_DEBUG, "getattr completed (handle = 0x%08Lx)\n",
		 sm_p->u.remove.object_ref.handle);

    /* pull out the data that we wanted */
    switch (resp_p->u.getattr.attr.objtype) {
	case PVFS_TYPE_METAFILE:
	    /* need to save datafile handles and remove them;
	     * redirect us to those states.
	     */
	    js_p->error_code = REMOVE_MUST_REMOVE_DATAFILES;
	    assert(resp_p->u.getattr.attr.mask & PVFS_ATTR_META_DFILES);
	    assert(resp_p->u.getattr.attr.u.meta.dfile_count > 0);

	    gossip_debug(CLIENT_DEBUG,
			 "remove sm: %d datafiles to remove too.\n",
			 resp_p->u.getattr.attr.u.meta.dfile_count);

	    /* save the datafile handles prior to freeing up the
	     * buffers we used for messages.  we could keep them around
	     * i suppose, but we're not going to do that for now.  later
	     * it is likely that this stuff will be stuck in the pcache
	     * anyway, so we'll be able to just reference it from there.
	     */
	    sm_p->u.remove.datafile_handles = (PVFS_handle *) malloc(resp_p->u.getattr.attr.u.meta.dfile_count * sizeof(PVFS_handle));
	    if (sm_p->u.remove.datafile_handles == NULL) {
		assert(0);
	    }
	    sm_p->u.remove.datafile_count = resp_p->u.getattr.attr.u.meta.dfile_count;
	    memcpy(sm_p->u.remove.datafile_handles,
		   resp_p->u.getattr.attr.u.meta.dfile_array,
		   resp_p->u.getattr.attr.u.meta.dfile_count * sizeof(PVFS_handle));

	    break;
	case PVFS_TYPE_DIRECTORY:
	    break;
	case PVFS_TYPE_SYMLINK:
	    /* fall through */
	case PVFS_TYPE_DATAFILE:
	    /* fall through */
	case PVFS_TYPE_DIRDATA:
	    /* fall through */
	default:
	    gossip_err("error: remove sm: unhandled object type\n");
	    assert(0);
    }

    /* TODO: POPULATE THE PCACHE? */

    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    /* check permissions */

    /* Q: what do we do with directories?
     * Q: should we check that they are empty?
     */

    /* TODO: check that we have necessary metadata from lookup */

    return 1;
}



/* remove_post_rmdirent_sendrecv()
 */
static int remove_post_rmdirent_sendrecv(PINT_client_sm *sm_p,
					 job_status_s *js_p)
{
    int ret;
    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    /* NOTE:  we remove the dirent first because this gets the
     * object out of the system fastest.
     */

    gossip_debug(CLIENT_DEBUG, "remove state: post_rmdirent_sendrecv\n");

    /* do parameter checking */

    /* mark that we have two messages to receive */
    sm_p->comp_ct = 2;

    /* fill in getattr request */
    PINT_SERVREQ_RMDIRENT_FILL(sm_p->req,
			       *sm_p->cred_p,
			       sm_p->u.remove.parent_ref.fs_id,
			       sm_p->u.remove.parent_ref.handle,
			       sm_p->u.remove.object_name);
    
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p,
		       &recv_status,
		       &recv_id,
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0);

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p,
			    &send_status,
			    &send_id,
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: rmdirent send completed immediately.\n");

	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);

	sm_p->comp_ct--;
	assert(sm_p->comp_ct == 1);
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

/* remove_recv_rmdirent_resp()
 */
static int remove_recv_rmdirent_resp(PINT_client_sm *sm_p,
				     job_status_s *js_p)
{
    /* receive rmdirent response from the server */
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_rmdirent_resp\n");

    /* decrement until both operations have completed */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.  we get the actual size of the received message
     * from the job status structure.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }

    /* check status of response */
    if (resp_p->status != 0) {
	assert(0);
    }

    /* pull out the data that we wanted */
    assert(sm_p->u.remove.object_ref.handle == resp_p->u.rmdirent.entry_handle);

    /* free all the resources that we used to send and receive. */
    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    return 1;
}

/* remove_post_datafile_remove_sendrecv()
 */
static int remove_post_datafile_remove_sendrecv(PINT_client_sm *sm_p,
						job_status_s *js_p)
{
    int ret, i;

   /* post all datafile remove requests and responses simultaneously.
     *
     * NOTE: it's easier to clean up from a metafile with no datafiles
     * than the other way around!  so we remove datafiles first.
     */

    gossip_debug(CLIENT_DEBUG, "remove state: post_getattr_sendrecv\n");

    /* do parameter checking */

    sm_p->u.remove.msgpair = (PINT_client_sm_msgpair_state *)
	malloc(sm_p->u.remove.datafile_count * sizeof(PINT_client_sm_msgpair_state));
    if (sm_p->u.remove.msgpair == NULL) {
	assert(0);
    }

    /* mark that we have two jobs per datafile */
    sm_p->comp_ct = 2 * sm_p->u.remove.datafile_count;

    /* for each datafile, post a send/recv pair for the remove */
    for (i=0; i < sm_p->u.remove.datafile_count; i++) {
	PVFS_msg_tag_t session_tag;
	job_status_s send_status;
	job_status_s recv_status;
	job_id_t send_id, recv_id;

	PINT_SERVREQ_REMOVE_FILL(sm_p->u.remove.msgpair[i].req,
				 *sm_p->cred_p,
				  sm_p->u.remove.object_ref.fs_id,
				 sm_p->u.remove.datafile_handles[i]);
    
	ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
					&sm_p->u.remove.msgpair[i].req,
					&sm_p->u.remove.msgpair[i].encoded_req,
					&sm_p->u.remove.msgpair[i].encoded_resp_p,
					&sm_p->u.remove.msgpair[i].svr_addr,
					&sm_p->u.remove.msgpair[i].max_resp_sz,
					&session_tag);
	if (ret != 0) {
	    assert(0);
	}

	/* post receive of response */
	ret = job_bmi_recv(sm_p->u.remove.msgpair[i].svr_addr,
			   sm_p->u.remove.msgpair[i].encoded_resp_p,
			   sm_p->u.remove.msgpair[i].max_resp_sz,
			   session_tag,
			   BMI_PRE_ALLOC,
			   sm_p,
			   &recv_status,
			   &recv_id,
			   pint_client_sm_context);
	if (ret < 0) {
	    assert(0);
	}
	else if (ret == 1) {
	    assert(0);
	}

	assert(ret == 0);

	/* save the job id for reference later */
	sm_p->u.remove.msgpair[i].recv_id = recv_id;

	/* post send of request */
	ret = job_bmi_send_list(sm_p->u.remove.msgpair[i].encoded_req.dest,
				sm_p->u.remove.msgpair[i].encoded_req.buffer_list,
				sm_p->u.remove.msgpair[i].encoded_req.size_list,
				sm_p->u.remove.msgpair[i].encoded_req.list_count,
				sm_p->u.remove.msgpair[i].encoded_req.total_size,
				session_tag,
				sm_p->u.remove.msgpair[i].encoded_req.buffer_type,
				1,
				sm_p,
				&send_status,
				&send_id,
				pint_client_sm_context);
	if (ret < 0) {
	    assert(0);
	}
	else if (ret == 1) {
	    /* send completed immediately; decrement the completion counter */
	    gossip_debug(CLIENT_DEBUG, "remove: datafile remove send completed immediately.\n");
	    /* TODO: CHECK THE STATUS!!! */
	    assert(send_status.error_code == 0);

	    sm_p->u.remove.msgpair[i].send_id = 0; /* mark as done */
	    sm_p->comp_ct--;
	}
    }

    gossip_debug(CLIENT_DEBUG, "remove sm: post_datafile_remove_sendrecv: count = %d\n",
		 sm_p->comp_ct);

    return 0;
}

static int remove_recv_datafile_remove_resp(PINT_client_sm *sm_p,
					    job_status_s *js_p)
{
    int ret, i;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_datafile_remove_resp\n");

    /* keep decrementing comp_ct until we're done */
    /* TODO: MARK THE ONES THAT WE RECEIVED ALREADY, SO WE COULD CLEAN
     * UP NICELY.
     */

    gossip_debug(CLIENT_DEBUG, "remove sm: recv_datafile_remove_resp: count = %d\n",
		 sm_p->comp_ct);

    if (--sm_p->comp_ct > 0) {
	int matched_job = 0;

	for (i=0; i < sm_p->u.remove.datafile_count; i++)
	{
	    if (sm_p->u.remove.msgpair[i].recv_id == js_p->id)
	    {
		sm_p->u.remove.msgpair[i].recv_id = 0;
		sm_p->u.remove.msgpair[i].actual_resp_sz = js_p->actual_size;
		matched_job = 1;
		break;
	    }
	    else if (sm_p->u.remove.msgpair[i].send_id == js_p->id)
	    {
		sm_p->u.remove.msgpair[i].send_id = 0;
		/* don't need actual size for sends, only receives */
		matched_job = 1;
		break;
	    }
	}
	assert(matched_job == 1);

	return 0;
    }
    assert(sm_p->comp_ct == 0);

    /* we have received all the responses successfully */

    /* HACK!!!!!!  WE'RE ASSUMING THAT THE ACTUAL SIZE OF ALL THE
     * MESSAGES ARE THE SAME!  WE NEED TO MATCH TAGS AND DO THE RIGHT
     * THING HERE...
     */

    /* for each remove message, decode, check status, and free resources */
    for (i=0; i < sm_p->u.remove.datafile_count; i++) {
	/* decode; resp_p will point to response */
	ret = PINT_serv_decode_resp(sm_p->u.remove.msgpair[i].encoded_resp_p,
				    &decoded_resp,
				    &sm_p->u.remove.msgpair[i].svr_addr,
				    js_p->actual_size,
				    &resp_p);
	if (ret < 0) {
	    assert(0);
	}

	/* check status of response */
	if (resp_p->status != 0) {
	    gossip_err("error: remove sm: status = %d on datafile remove msg\n",
		       resp_p->status);
	    assert(0);
	}

	/* free resources */
	ret = PINT_serv_free_msgpair_resources(&sm_p->u.remove.msgpair[i].encoded_req,
					       sm_p->u.remove.msgpair[i].encoded_resp_p,
					       &decoded_resp,
					       &sm_p->u.remove.msgpair[i].svr_addr,
					       sm_p->u.remove.msgpair[i].max_resp_sz);
	if (ret != 0) {
	    assert(0);
	}
    }

    return 1;
}

static int remove_post_object_remove_sendrecv(PINT_client_sm *sm_p,
					      job_status_s *js_p)
{
    int ret;
    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_object_remove_sendrecv\n");

    /* mark that we have two messages to receive */
    sm_p->comp_ct = 2;

    /* fill in getattr request */
    PINT_SERVREQ_REMOVE_FILL(sm_p->req,
			     *sm_p->cred_p,
			     sm_p->u.remove.object_ref.fs_id,
			     sm_p->u.remove.object_ref.handle);
    
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p,
		       &recv_status,
		       &recv_id,
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0);

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p,
			    &send_status,
			    &send_id,
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: object remove send completed immediately.\n");

	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);

	sm_p->comp_ct--;
	assert(sm_p->comp_ct == 1);
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

static int remove_recv_object_remove_resp(PINT_client_sm *sm_p,
					  job_status_s *js_p)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_object_remove_resp\n");

    /* decrement until both operations have completed */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.  we get the actual size of the received message
     * from the job status structure.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }

    /* check status of response */
    if (resp_p->status != 0) {
	assert(0);
    }

    /* free all the resources that we used to send and receive. */
    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    return 1;
}

/* remove_cleanup()
 */
static int remove_cleanup(PINT_client_sm *sm_p,
			  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: cleanup\n");

    /* store enough information in the sm structure that the caller
     * can tell what happened.
     */
    sm_p->status = *js_p;

    /* if we have a locked pcache entry, release it */
    if (sm_p->pcache_lock) {
	assert(sm_p->pcache_lock == 1);

	PINT_pcache_lookup_rls(sm_p->object_pinode_p);
    }

    /* mark operation as complete */
    sm_p->op_complete = 1;

    return 0;
}

/* remove_lookup_failure()
 */
static int remove_lookup_failure(PINT_client_sm *sm_p,
				 job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: lookup_failure\n");

    /* TODO: unpost operations that are still in progress, once we can. */

    /* ISSUE: can't tell which thing completed (with an error).
     *
     * SOLUTION: add job_id to the job_status structure, keep up with
     * them in the PINT_client_sm structure so we can tell the
     * difference.
     */

    return 1;
}

/* remove_getattr_failure()
 */
static int remove_getattr_failure(PINT_client_sm *sm_p,
				  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: getattr_failure\n");

    /* TODO: unpost operations that are still in progress, once we can. */

    /* ISSUE: can't tell which thing completed (with an error).
     *
     * SOLUTION: add job_id to the job_status structure, keep up with
     * them in the PINT_client_sm structure so we can tell the
     * difference.
     */

    /* Q: CAN WE HANDLE ALL THE SEND/RECV PAIRS FAILURE CASES WITH ONE
     * STATE?
     */

    return 1;
}

static int remove_datafile_remove_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: datafile_remove_failure\n");

    return 1;
}

static int remove_rmdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: rmdirent_failure\n");

    return 1;
}

static int remove_object_remove_failure(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: object_remove_failure\n");

    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 noexpandtab
 */
