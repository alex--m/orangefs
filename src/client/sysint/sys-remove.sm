/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"

#include "pinode-helper.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

/* values greater than zero are usable here */
/* TODO: this is a hack, duplicated in msgpair.sm, sort out later... */
enum {
    REMOVE_MUST_REMOVE_DATAFILES = 1,
    MSGPAIR_RETURN_SUCCESS = 2
};

/* state function prototypes */
static int remove_init(PINT_client_sm *sm_p,
		       job_status_s *js_p);

static int remove_getattr_setup_msgpair(PINT_client_sm *sm_p,
					job_status_s *js_p);
static int remove_getattr_failure(PINT_client_sm *sm_p,
				  job_status_s *js_p);

static int remove_datafile_remove_setup_msgpair(PINT_client_sm *sm_p,
						job_status_s *js_p);
static int remove_datafile_remove_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p);

static int remove_rmdirent_setup_msgpair(PINT_client_sm *sm_p,
				     job_status_s *js_p);
static int remove_rmdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p);

static int remove_object_remove_setup_msgpair(PINT_client_sm *sm_p,
					      job_status_s *js_p);
static int remove_object_remove_failure(PINT_client_sm *sm_p,
					job_status_s *js_p);

static int remove_cleanup(PINT_client_sm *sm_p,
			  job_status_s *js_p);

/* completion function prototypes */
static int remove_getattr_comp_fn(void *v_p,
				  struct PVFS_server_resp *resp_p,
				  int i);
static int remove_rmdirent_comp_fn(void *v_p,
				   struct PVFS_server_resp *resp_p,
				   int i);

%%

machine pvfs2_client_remove_sm(init,
			       cleanup,
			       getattr_setup_msgpair,
			       getattr_xfer_msgpair,
			       getattr_failure,
			       datafile_remove_setup_msgpair,
			       datafile_remove_xfer_msgpair,
			       datafile_remove_failure,
			       rmdirent_setup_msgpair,
			       rmdirent_xfer_msgpair,
			       rmdirent_failure,
			       object_remove_setup_msgpair,
			       object_remove_xfer_msgpair,
			       object_remove_failure)
{
    state init {
	run remove_init;
	default => rmdirent_setup_msgpair;
    }

    state rmdirent_setup_msgpair {
	run remove_rmdirent_setup_msgpair;
	success => rmdirent_xfer_msgpair;
	default => rmdirent_failure;
    }
    state rmdirent_xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
	success => getattr_setup_msgpair;
	MSGPAIR_RETURN_SUCCESS => getattr_setup_msgpair;
	default => rmdirent_failure;
    }
    state rmdirent_failure {
	run remove_rmdirent_failure;
	default => cleanup;
    }

    state getattr_setup_msgpair {
	run remove_getattr_setup_msgpair;
	success => getattr_xfer_msgpair;
	default => getattr_failure;
    }
    state getattr_xfer_msgpair {
	jump pvfs2_client_getattr_acache_sm;
	success => object_remove_setup_msgpair;
	MSGPAIR_RETURN_SUCCESS => object_remove_setup_msgpair;
	REMOVE_MUST_REMOVE_DATAFILES => datafile_remove_setup_msgpair;
	default => getattr_failure;
    }
    state getattr_failure {
	run remove_getattr_failure;
	default => cleanup;
    }

    state datafile_remove_setup_msgpair {
	run remove_datafile_remove_setup_msgpair;
	success => datafile_remove_xfer_msgpair;
	default => datafile_remove_failure;
    }
    state datafile_remove_xfer_msgpair {
	jump pvfs2_client_msgpairarray_sm;
	success => object_remove_setup_msgpair;
	default => datafile_remove_failure;
    }
    state datafile_remove_failure {
	run remove_datafile_remove_failure;
	default => cleanup;
    }
    
    state object_remove_setup_msgpair {
	run remove_object_remove_setup_msgpair;
	success => object_remove_xfer_msgpair;
	default => object_remove_failure;
    }
    state object_remove_xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
	success => cleanup;
	MSGPAIR_RETURN_SUCCESS => cleanup;
	default => object_remove_failure;
    }
    state object_remove_failure {
	run remove_object_remove_failure;
	default => cleanup;
    }

    state cleanup {
	run remove_cleanup;
	default => init;
    }
}

%%

int PVFS_sys_remove(char *object_name,
		    PVFS_pinode_reference parent_ref, 
		    PVFS_credentials credentials)
{
    int ret;
    PINT_client_sm *sm_p;
    PVFS_error error;

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_remove entered\n");

    /* do parameter checking here, then assume things are ok below.
     * assert()s are still ok of course :).
     */
    if (object_name == NULL) return -PVFS_EINVAL;

    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL) return -PVFS_ENOMEM;

    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.remove.object_name = object_name;
    sm_p->u.remove.parent_ref  = parent_ref;

    gossip_debug(CLIENT_DEBUG,
		 "PVFS_sys_remove calling PINT_client_state_machine_post()\n");

    /* do something to kick off processing */
    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_REMOVE);
    assert(ret == 0);

    /* while !done call progress function */
    while (!sm_p->op_complete && ret == 0) {
	gossip_debug(CLIENT_DEBUG,
		     "PVFS_sys_remove calling PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }

    assert(ret == 0);

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_remove completed\n");

    /* save our return value */
    error = sm_p->error_code;

    /* flush any matching pinode entries (if any) */
    if (sm_p->acache_hit)
    {
        PINT_acache_invalidate(sm_p->u.remove.object_ref);
    }

    /* clean up after ourselves */
    free(sm_p);
    return error;
}


/****************************************************************/

/* remove_init()
 */
static int remove_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: init\n");

    assert(js_p->error_code == 0); /* sanity check */

    /* do the request scheduler thing, if necessary */

    return 1;
}

/* remove_getattr_post_msgpair()
 *
 */
static int remove_getattr_setup_msgpair(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    int ret = -1;

    gossip_debug(CLIENT_DEBUG, "remove state: getattr_setup_msgpair\n");

    /* parameter range checks */
    assert(sm_p->u.remove.object_ref.fs_id != 0);
    assert(sm_p->u.remove.object_ref.handle != 0);

    /* fill in getattr request */
    PINT_SERVREQ_GETATTR_FILL(sm_p->msgpair.req,
			      *sm_p->cred_p,
			      sm_p->u.remove.object_ref.fs_id,
			      sm_p->u.remove.object_ref.handle,
			      PVFS_ATTR_COMMON_ALL|PVFS_ATTR_META_DFILES);
    
    /* fill in msgpair structure components */
    sm_p->msgpair.fs_id   = sm_p->u.remove.object_ref.fs_id;
    sm_p->msgpair.handle  = sm_p->u.remove.object_ref.handle;
    sm_p->msgpair.comp_fn = remove_getattr_comp_fn;
    ret = PINT_bucket_map_to_server(&sm_p->msgpair.svr_addr,
	sm_p->msgpair.handle,
	sm_p->msgpair.fs_id);
    if(ret != 0)
    {
	gossip_err("Error: failure mapping to server.\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* TODO: real error handling */
    }

    js_p->error_code = 0;
    return 1;
}

/* remove_getattr_comp_fn()
 *
 * Called to copy data from getattr response into the
 * remove-specific portion of the PINT_client_sm structure,
 * so we can use the data after returning to this state
 * machine.
 *
 * Return value is returned in job status, so it affects the
 * resulting state coming back from the nested state machine.
 *
 * Returns 0 for directory, REMOVE_MUST_REMOVE_DATAFILES for a
 * metafile.
 */
static int remove_getattr_comp_fn(void *v_p,
				  struct PVFS_server_resp *resp_p,
				  int index)
{
    /* this is a little kludge to get around some struct definition
     * issues in the headers.  maybe fix later?
     */
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;
    
    assert(resp_p->op == PVFS_SERV_GETATTR); /* sanity check */

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0) {
	return resp_p->status;
    }

    switch (resp_p->u.getattr.attr.objtype)
    {
	case PVFS_TYPE_METAFILE:
	    /* need to save datafile handles and remove them;
	     * redirect us to those states.
	     */

	    /* sanity checks */
	    assert(resp_p->u.getattr.attr.mask & PVFS_ATTR_META_DFILES);
	    assert(resp_p->u.getattr.attr.u.meta.dfile_count > 0);
	    
	    gossip_debug(CLIENT_DEBUG,
			 "remove_getattr_comp_fn: %d datafiles to remove too.\n",
			 resp_p->u.getattr.attr.u.meta.dfile_count);

	    /* save the datafile handles prior to freeing up the
	     * buffers we used for messages.  we could keep them around
	     * i suppose, but we're not going to do that for now.  later
	     * it is likely that this stuff will be stuck in the acache
	     * anyway, so we'll be able to just reference it from there.
	     */
	    sm_p->u.remove.datafile_handles = (PVFS_handle *) malloc(resp_p->u.getattr.attr.u.meta.dfile_count * sizeof(PVFS_handle));
	    if (sm_p->u.remove.datafile_handles == NULL) {
		assert(0);
	    }
	    sm_p->u.remove.datafile_count = resp_p->u.getattr.attr.u.meta.dfile_count;
	    memcpy(sm_p->u.remove.datafile_handles,
		   resp_p->u.getattr.attr.u.meta.dfile_array,
		   resp_p->u.getattr.attr.u.meta.dfile_count * sizeof(PVFS_handle));

	    return REMOVE_MUST_REMOVE_DATAFILES;
	case PVFS_TYPE_DIRECTORY:
	    return 0;
	case PVFS_TYPE_SYMLINK:
            return 0;
	case PVFS_TYPE_DATAFILE:
	    /* fall through */
	case PVFS_TYPE_DIRDATA:
	    /* fall through */
	default:
	    gossip_err("error: remove_getattr_comp_fn: unhandled object type\n");
	    assert(0);
    } /* end of switch() */

    return -PVFS_EINVAL; /* should not get here */
}

/* remove_rmdirent_setup_msgpair()
 */
static int remove_rmdirent_setup_msgpair(PINT_client_sm *sm_p,
					 job_status_s *js_p)
{
    int ret = -1;

    /* NOTE:  we remove the dirent first because this gets the
     * object out of the system fastest.
     */

    gossip_debug(CLIENT_DEBUG, "remove state: rmdirent_setup_msgpair\n");

    /* fill in rmdirent request */
    PINT_SERVREQ_RMDIRENT_FILL(sm_p->msgpair.req,
			       *sm_p->cred_p,
			       sm_p->u.remove.parent_ref.fs_id,
			       sm_p->u.remove.parent_ref.handle,
			       sm_p->u.remove.object_name);

    /* fill in msgpair structure components */
    sm_p->msgpair.fs_id   = sm_p->u.remove.parent_ref.fs_id;
    sm_p->msgpair.handle  = sm_p->u.remove.parent_ref.handle;
    sm_p->msgpair.comp_fn = remove_rmdirent_comp_fn;
    ret = PINT_bucket_map_to_server(&sm_p->msgpair.svr_addr,
	sm_p->msgpair.handle,
	sm_p->msgpair.fs_id);
    if(ret != 0)
    {
	gossip_err("Error: failure mapping to server.\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* TODO: real error handling */
    }

    return 1;
}

/* remove_rmdirent_comp_fn()
 */
static int remove_rmdirent_comp_fn(void *v_p,
				   struct PVFS_server_resp *resp_p,
				   int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;

    assert(resp_p->op == PVFS_SERV_RMDIRENT); /* sanity check */

    /* don't attempt to parse the response if there was an error */
    if (resp_p->status != 0) {
	assert(resp_p->status < 0); /* parameter range check */
	return resp_p->status;
    }

    /* parameter range checks */
    assert(resp_p->u.rmdirent.entry_handle != 0);
    assert(sm_p->u.remove.parent_ref.fs_id != 0);

    /* pull handle out of response, also copy in fs_id from before */
    sm_p->u.remove.object_ref.handle = resp_p->u.rmdirent.entry_handle;
    sm_p->u.remove.object_ref.fs_id  = sm_p->u.remove.parent_ref.fs_id;

    gossip_debug(CLIENT_DEBUG,
		 "  remove_rmdirent_comp_fn: metafile handle = 0x%08Lx\n",
		 Lu(sm_p->u.remove.object_ref.handle));

    return 0;
}


/* remove_datafile_remove_setup_msgpair()
 */
static int remove_datafile_remove_setup_msgpair(PINT_client_sm *sm_p,
						job_status_s *js_p)
{
    int i;
    int ret = -1;

   /* post all datafile remove requests and responses simultaneously.
     *
     * NOTE: it's easier to clean up from a metafile with no datafiles
     * than the other way around!  so we remove datafiles first.
     */

    /* clear error field in job */
    js_p->error_code = 0;

    gossip_debug(CLIENT_DEBUG,
                 "remove state: datafile_remove_setup_msgpair\n");

    /* do parameter checking */

    /* allocate msgarray and set msgarray_count */
    sm_p->msgarray = (PINT_client_sm_msgpair_state *)
	malloc(sm_p->u.remove.datafile_count *
               sizeof(PINT_client_sm_msgpair_state));
    assert(sm_p->msgarray);

    sm_p->msgarray_count = sm_p->u.remove.datafile_count;
    
    /* for each datafile, post a send/recv pair for the remove */
    for (i = 0; i < sm_p->u.remove.datafile_count; i++)
    {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

	gossip_debug(CLIENT_DEBUG,
		     "  datafile_remove: removing handle 0x%08Lx\n",
		     Lu(sm_p->u.remove.datafile_handles[i]));

	PINT_SERVREQ_REMOVE_FILL(msg_p->req,
				 *sm_p->cred_p,
				 sm_p->u.remove.object_ref.fs_id,
				 sm_p->u.remove.datafile_handles[i]);

	/* fill in msgpair structure components */
	msg_p->fs_id   = sm_p->u.remove.object_ref.fs_id;
	msg_p->handle  = sm_p->u.remove.datafile_handles[i];
	msg_p->comp_fn = NULL;
    }

    /* fill in address of each server to contact */
    ret =  PINT_serv_msgpairarray_resolve_addrs(
        sm_p->msgarray_count, sm_p->msgarray);
    if (ret < 0)
    {
	gossip_lerr("Error: failed to resolve server addresses.\n");
	js_p->error_code = ret;
	return 1;
    }
    return 1;
}

/* remove_object_remove_setup_msgpair()
 */
static int remove_object_remove_setup_msgpair(PINT_client_sm *sm_p,
					      job_status_s *js_p)
{
    int ret = -1;

    gossip_debug(CLIENT_DEBUG, "remove state: object_remove_setup_msgpair\n");

    /* fill in remove request */
    PINT_SERVREQ_REMOVE_FILL(sm_p->msgpair.req,
			     *sm_p->cred_p,
			     sm_p->u.remove.object_ref.fs_id,
			     sm_p->u.remove.object_ref.handle);

    /* fill in msgpair structure components */
    sm_p->msgpair.fs_id   = sm_p->u.remove.object_ref.fs_id;
    sm_p->msgpair.handle  = sm_p->u.remove.object_ref.handle;
    sm_p->msgpair.comp_fn = NULL;
    ret = PINT_bucket_map_to_server(&sm_p->msgpair.svr_addr,
	sm_p->msgpair.handle,
	sm_p->msgpair.fs_id);
    if(ret != 0)
    {
	gossip_err("Error: failure mapping to server.\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* TODO: real error handling */
    }

    return 1;    
}


/* remove_cleanup()
 */
static int remove_cleanup(PINT_client_sm *sm_p,
			  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: cleanup\n");

    /* store enough information in the sm structure that the caller
     * can tell what happened.
     */
    sm_p->error_code = js_p->error_code;

    /* if we acache entry, release it */
    if (sm_p->acache_hit)
    {
	PINT_acache_release(sm_p->pinode);
    }

    /* free dynamically allocated resouces */
    free(sm_p->msgarray);
    free(sm_p->u.remove.datafile_handles);

    /* mark operation as complete */
    sm_p->op_complete = 1;

    return 0;
}

/* remove_getattr_failure()
 */
static int remove_getattr_failure(PINT_client_sm *sm_p,
				  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: getattr_failure\n");

    /* TODO: unpost operations that are still in progress, once we can. */

    /* ISSUE: can't tell which thing completed (with an error).
     *
     * SOLUTION: add job_id to the job_status structure, keep up with
     * them in the PINT_client_sm structure so we can tell the
     * difference.
     */

    /* Q: CAN WE HANDLE ALL THE SEND/RECV PAIRS FAILURE CASES WITH ONE
     * STATE?
     */

    return 1;
}

static int remove_datafile_remove_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: datafile_remove_failure\n");

    return 1;
}

static int remove_rmdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: rmdirent_failure\n");

    return 1;
}

static int remove_object_remove_failure(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: object_remove_failure\n");

    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
