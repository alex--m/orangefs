/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "pvfs2-client-state-machine.h"
#include "pvfs2-debug.h"
#include "gossip.h"

/* from original remove.c */
#include "pinode-helper.h"
#include "pvfs2-sysint.h"
#include "pint-sysint.h"
#include "pint-dcache.h"
#include "pint-servreq.h"
#include "pint-dcache.h"
#include "pint-bucket.h"
#include "pcache.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

/* values greater than zero are usable here */
enum {
    REMOVE_DCACHE_HIT = 1
};

static int remove_init(PINT_client_sm *sm, job_status_s *js);
static int remove_post_lookup_sendrecv(PINT_client_sm *sm, job_status_s *js);
static int remove_lookup_failure(PINT_client_sm *sm, job_status_s *js);
static int remove_recv_lookup_resp(PINT_client_sm *sm, job_status_s *js);
static int remove_cleanup(PINT_client_sm *sm, job_status_s *js);

%%

machine pvfs2_remove_sm(init,
			cleanup,
			post_lookup_sendrecv,
			lookup_failure,
			recv_lookup_resp)
{
    state init
	{
	    run remove_init;
	    default => post_lookup_sendrecv;
	}

    state post_lookup_sendrecv
	{
	    run remove_post_lookup_sendrecv;
	    success => recv_lookup_resp;
	    REMOVE_DCACHE_HIT => cleanup;
	    default => lookup_failure;
	}

    state lookup_failure
	{
	    run remove_lookup_failure;
	    default => cleanup;
	}

    state recv_lookup_resp
	{
	    run remove_recv_lookup_resp;
	    default => cleanup;
	}

    state cleanup
	{
	    run remove_cleanup;
	    default => init;
	}
}

%%

int PVFS_sys_remove2(char *object_name,
		     PVFS_pinode_reference parent_ref, 
		     PVFS_credentials credentials)
{
    PINT_client_sm *sm;

    /* do parameter checking here, then assume things are ok below.
     * assert()s are still ok of course :).
     */
    if (object_name == NULL) return -PVFS_EINVAL;

    /* build PINT_client_sm structure */
    /* TODO: KEEP A CACHE OF THESE AROUND SO WE'RE NOT ALWAYS MALLOC'ING? */
    sm = (PINT_client_sm *) malloc(sizeof(*sm));
    if (sm == NULL) return -PVFS_ENOMEM;

    memset(sm, 0, sizeof(*sm));

    sm->cred_p = &credentials;
    sm->u.remove.object_name = object_name;
    sm->u.remove.parent_ref  = parent_ref;

    /* do something to kick off processing */

    /* while !done call progress function */

    /* clean up after ourselves */
    free(sm);
    return 0;
}

static int remove_init(PINT_client_sm *sm,
		       job_status_s *js)
{
    gossip_debug(CLIENT_DEBUG, "remove state: init\n");

    /* do the request scheduler thing, if necessary */

    return 1;
}

/* remove_post_lookup_sendrecv()
 */
static int remove_post_lookup_sendrecv(PINT_client_sm *sm,
				       job_status_s *js)
{
    int ret;

    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_lookup_sendrecv\n");

    /* check and see if we have the pinode for the object in
     * our pinode cache already.
     */
    ret = PINT_dcache_lookup(sm->u.remove.object_name,
			     sm->u.remove.parent_ref,
			     &sm->u.remove.object_ref);
    if (ret < 0 && ret != -PVFS_ENOENT) {
	/* fatal error */
	return -1;
    }
    else if (ret == 0) {
	/* match in dcache; no need for lookup */
	js->error_code = REMOVE_DCACHE_HIT;
	return 1;
    }

    /* otherwise we need to perform the lookup */

    /* post the receive of the response, then the send of the
     * lookup request.  pre-posting the receive can make a
     * performance difference for some network types.
     *
     * We're going to end up popping into the next state twice
     * because of these two posted operations.  We keep a counter
     * to keep up with how many operations have completed.  We'll
     * use the sm->comp_ct for this purpose.  We set to 2 (# of jobs)
     * and then decrement as they complete in the next state.
     */
    sm->comp_ct = 2;

    /* Steps:
     * (1) fill in request
     * (2) determine destination server
     * (3) encode request
     * (4) calculate max. size for response
     * (5) allocate BMI memory region for response
     * (6) get next session tag
     * (7) call job fn. to post receive
     * (8) call job fn. to post send
     */

    if ((strlen(sm->u.remove.object_name) + 1 >
	 PVFS_REQ_LIMIT_PATH_NAME_BYTES) ||
	(PINT_string_count_segments(sm->u.remove.object_name) >
	 PVFS_REQ_LIMIT_PATH_SEGMENT_COUNT))
    {
	/* TODO: CLEAN UP... */
	assert(0);
	return -PVFS_ENAMETOOLONG;
    }

    memset(&sm->req, 0, sizeof(sm->req));
    sm->req.op          = PVFS_SERV_LOOKUP_PATH;
    sm->req.credentials = *sm->cred_p;
    sm->req.u.lookup_path.path            = sm->u.remove.object_name;
    sm->req.u.lookup_path.fs_id           = sm->u.remove.parent_ref.fs_id;
    sm->req.u.lookup_path.starting_handle = sm->u.remove.parent_ref.handle;
    sm->req.u.lookup_path.attrmask        = PVFS_ATTR_COMMON_ALL;

    /* must determine destination server before we can encode;
     * this fills in sm->svr_addr.
     */
    ret = PINT_bucket_map_to_server(&sm->svr_addr,
				    sm->u.remove.parent_ref.handle,
				    sm->u.remove.parent_ref.fs_id);
    if (ret < 0) {
	assert(0);
    }

    /* encode request */
    ret = PINT_encode(&sm->req,
		      PINT_ENCODE_REQ,
		      &sm->encoded_req,
		      sm->svr_addr,
		      PINT_CLIENT_ENC_TYPE);
    if (ret < 0) {
	assert(0);
    }

    /* calculate maximum response message size and allocate space */
    sm->max_msg_sz = PINT_encode_calc_max_size(PINT_ENCODE_RESP,
					       sm->req.op,
					       PINT_CLIENT_ENC_TYPE);

    sm->encoded_resp_p = BMI_memalloc(sm->svr_addr,
				      sm->max_msg_sz,
				      BMI_RECV);
    if (sm->encoded_resp_p == NULL) {
	assert(0);
    }

    /* get session tag to associate with send and receive */
    session_tag = get_next_session_tag();

    /* post receive of response */
    ret = job_bmi_recv(sm->svr_addr,
		       sm->encoded_resp_p,
		       sm->max_msg_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm, /* user pointer -- used to get to next state */
		       &recv_status, /* only for immediate completion */
		       &recv_id, /* could theoretically be used to unpost */
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0); /* just to see that we don't get odd values */

    /* post send of request */
    ret = job_bmi_send_list(sm->encoded_req.dest,
			    sm->encoded_req.buffer_list,
			    sm->encoded_req.size_list,
			    sm->encoded_req.list_count,
			    sm->encoded_req.total_size,
			    session_tag,
			    sm->encoded_req.buffer_type,
			    1,
			    sm, /* user pointer -- used to get to next state */
			    &send_status, /* only for immediate completion */
			    &send_id, /* could in theory be used to unpost */
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	
	/* TODO: CHECK THE STATUS!!! */
	sm->comp_ct--;
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 1;
}

/* remove_recv_lookup_resp()
 */
static int remove_recv_lookup_resp(PINT_client_sm *sm,
				   job_status_s *js)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_lookup_resp\n");

    /* we may or may not have previously completed either operation.
     * here we check to see if there are additional operations that
     * must complete successfully before we can continue.  if the
     * counter hits zero, we know we've gotten our data and can
     * continue.
     *
     * otherwise we return 0; we will get called again when the next
     * bmi job completes.
     */
    if (--sm->comp_ct > 0) return 0;
    assert(sm->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.
     */

    /* decode response */
    ret = PINT_decode(sm->encoded_resp_p,
		      PINT_DECODE_RESP,
		      &decoded_resp, /* holds data on decoded resp */
		      sm->svr_addr,
		      js->actual_size);
    if (ret < 0) {
	assert(0);
    }

    /* point a reasonably typed pointer at the response data */
    resp_p = (struct PVFS_server_resp *) decoded_resp.buffer;

    /* check status of response */
    if (resp_p->status != 0) {
	assert(0);
    }

    assert(resp_p->u.lookup_path.handle_count == 1);

    /* pull out the data that we wanted */
    sm->u.remove.object_ref.handle = resp_p->u.lookup_path.handle_array[0];
    sm->u.remove.object_ref.fs_id  = sm->u.remove.parent_ref.fs_id;

    gossip_debug(CLIENT_DEBUG, "lookup completed (handle = 0x%08Lx)\n",
		 0);

    /* free resources */
    /* TODO: CHECK RETURN VALUES IN HERE */
    PINT_encode_release(&sm->encoded_req,
			PINT_ENCODE_REQ);

    /* sm->req doesn't go anywhere; we'll use it again. */

    PINT_decode_release(&decoded_resp,
			PINT_DECODE_RESP);

    BMI_memfree(sm->svr_addr,
		sm->encoded_resp_p,
		sm->max_msg_sz,
		BMI_RECV);


    /* check permissions */

    /* Q: what do we do with directories?
     * Q: should we check that they are empty?
     */

    /* check that we have necessary metadata -- maybe do getattr? */

    return 1;
}

static int remove_post_rmdirent_sendrecv(PINT_client_sm *sm,
					 job_status_s *js)
{
    /* post rmdirent send and receive */

    /* NOTE: same issue with posting as in lookup case. */

    /* NOTE:  we remove the dirent first because this gets the
     * object out of the system fastest.
     */

    return 1;
}

static int remove_recv_rmdirent_resp(PINT_client_sm *sm,
				     job_status_s *js)
{
    /* receive rmdirent response from the server */

    return 1;
}

static int remove_post_datafile_remove_sendrecv(PINT_client_sm *sm,
						job_status_s *js)
{
    /* post all datafile remove requests and responses simultaneously.
     *
     * NOTE: it's easier to clean up from a metafile with no datafiles
     * than the other way around!  so we remove datafiles first.
     */

    return 1;
}

static int remove_recv_datafile_remove_resp(PINT_client_sm *sm,
					    job_status_s *js)
{
    /* receive responses from servers.
     *
     * tally up any failures so that we can report them in the FT
     * case.
     *
     * return 0 if we're not done; we'll get called again.
     */

    return 1;
}

static int remove_post_remove_sendrecv(PINT_client_sm *sm,
				       job_status_s *js)
{
    /* post remove request and response; this would catch
     * metafiles or directories as appropriate.
     */

    return 1;
}

static int remove_recv_remove_resp(PINT_client_sm *sm,
				   job_status_s *js)
{
    /* receive response from server.
     */

    return 1;
}

/* remove_cleanup()
 */
static int remove_cleanup(PINT_client_sm *sm,
			  job_status_s *js)
{
    gossip_debug(CLIENT_DEBUG, "remove state: cleanup\n");

    sm->op_complete = 1;

    return 0;
}

/* remove_lookup_failure()
 */
static int remove_lookup_failure(PINT_client_sm *sm,
				 job_status_s *js)
{
    gossip_debug(CLIENT_DEBUG, "remove state: lookup_failure\n");

    /* TODO: unpost operations that are still in progress, once we can. */

    /* ISSUE: can't tell which thing completed (with an error).
     *
     * SOLUTION: add job_id to the job_status structure, keep up with
     * them in the PINT_client_sm structure so we can tell the
     * difference.
     */

    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 noexpandtab
 */
