/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "pvfs2-client-state-machine.h"
#include "pvfs2-debug.h"
#include "gossip.h"

/* from original remove.c */
#include "pinode-helper.h"
#include "pvfs2-sysint.h"
#include "pint-sysint.h"
#include "pint-dcache.h"
#include "pint-servreq.h"
#include "pint-dcache.h"
#include "pint-bucket.h"
#include "pcache.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

/* values greater than zero are usable here */
enum {
    REMOVE_DCACHE_HIT = 1
};

static int remove_init(PINT_client_sm *sm, job_status_s *js);
static int remove_cleanup(PINT_client_sm *sm, job_status_s *js);

%%

machine pvfs2_remove_sm(init,
			cleanup)
{
    state init
	{
	    run remove_init;
	    default => cleanup;
	}

    state cleanup
	{
	    run remove_cleanup;
	    default => init;
	}
}

%%

int PVFS_sys_remove2(char *object_name,
		     PVFS_pinode_reference parent_ref, 
		     PVFS_credentials credentials)
{
    PINT_client_sm *sm;

    /* do parameter checking here, then assume things are ok below.
     * assert()s are still ok of course :).
     */
    if (object_name == NULL) return -PVFS_EINVAL;

    /* build PINT_client_sm structure */
    /* TODO: KEEP A CACHE OF THESE AROUND SO WE'RE NOT ALWAYS MALLOC'ING? */
    sm = (PINT_client_sm *) malloc(sizeof(*sm));
    if (sm == NULL) return -PVFS_ENOMEM;

    memset(sm, 0, sizeof(*sm));

    sm->cred_p = &credentials;
    sm->u.remove.object_name = object_name;
    sm->u.remove.parent_ref  = parent_ref;

    /* do something to kick off processing */

    /* while !done call progress function */

    /* clean up after ourselves */
    free(sm);
    return 0;
}

static int remove_init(PINT_client_sm *sm,
		       job_status_s *js)
{
    gossip_debug(CLIENT_DEBUG, "remove state: init\n");

    /* do the request scheduler thing, if necessary */

    return 1;
}

/* remove_post_lookup_sendrecv()
 */
static int remove_post_lookup_sendrecv(PINT_client_sm *sm,
				       job_status_s *js)
{
    int ret;

    int max_msg_sz;
    bmi_addr_t svr_addr;
    PVFS_msg_tag_t session_tag;
    struct PINT_encoded_msg encoded_req;
    void *encoded_resp_p;

    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_lookup_sendrecv\n");

    /* check and see if we have the pinode for the object in
     * our pinode cache already.
     */
    ret = PINT_dcache_lookup(sm->u.remove.object_name,
			     sm->u.remove.parent_ref,
			     &sm->u.remove.object_ref);
    if (ret < 0 && ret != -PVFS_ENOENT) {
	/* fatal error */
	return -1;
    }
    else if (ret == 0) {
	/* match in dcache; no need for lookup */
	js->error_code = REMOVE_DCACHE_HIT;
	return 1;
    }

    /* otherwise we need to perform the lookup */

    /* post the receive of the response, then the send of the
     * lookup request.  pre-posting the receive can make a
     * performance difference for some network types.
     *
     * We're going to end up popping into the next state twice
     * because of these two posted operations.  We keep a counter
     * to keep up with how many operations have completed.  We'll
     * use the sm->comp_ct for this purpose.  We set to 2 (# of jobs)
     * and then decrement as they complete in the next state.
     */
    sm->comp_ct = 2;

    /* Steps:
     * (1) fill in request
     * (2) determine destination server
     * (3) encode request
     * (4) calculate max. size for response
     * (5) allocate BMI memory region for response
     * (6) get next session tag
     * (7) call job fn. to post receive
     * (8) call job fn. to post send
     */

    if ((sm->u.remove.object_name > PVFS_REQ_LIMIT_PATH_NAME_BYTES) ||
	(PINT_string_count_segments(sm->u.remove.object_name) >
	PVFS_REQ_LIMIT_PATH_SEGMENT_COUNT))
    {
	/* TODO: CLEAN UP... */
	assert(0);
	return -PVFS_ENAMETOOLONG;
    }

    sm->req.op          = PVFS_SERV_LOOKUP_PATH;
    sm->req.credentials = *sm->cred_p;
    sm->req.u.lookup_path.path            = sm->u.remove.object_name;
    sm->req.u.lookup_path.fs_id           = sm->u.remove.parent_ref.fs_id;
    sm->req.u.lookup_path.starting_handle = sm->u.remove.parent_ref.handle;
    sm->req.u.lookup_path.attrmask        = PVFS_ATTR_COMMON_ALL;

    /* must determine destination server before we can encode */
    ret = PINT_bucket_map_to_server(&svr_addr,
				    sm->u.remove.parent_ref.handle,
				    sm->u.remove.parent_ref.fs_id);
    if (ret < 0) {
	assert(0);
    }

    /* encode request */
    ret = PINT_encode(&sm->req,
		      PINT_ENCODE_REQ,
		      &encoded_req,
		      svr_addr,
		      PINT_CLIENT_ENC_TYPE);
    if (ret < 0) {
	assert(0);
    }

    /* calculate maximum response message size and allocate space */
    max_msg_sz = PINT_encode_calc_max_size(PINT_ENCODE_RESP,
					   sm->req.op,
					   PINT_CLIENT_ENC_TYPE);

    encoded_resp_p = BMI_memalloc(svr_addr,
				  max_msg_sz,
				  BMI_RECV);
    if (encoded_resp_p == NULL) {
	assert(0);
    }

    /* get session tag to associate with send and receive */
    session_tag = get_next_session_tag();

    /* post receive of response */
    ret = job_bmi_recv_list(svr_addr,
			    encoded_resp_p,
			    max_msg_sz,
			    session_tag,
			    BMI_PRE_ALLOC,
			    NULL, /* USER PTR */
			    &recv_status,
			    &recv_id,
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0); /* just to see that we don't get odd values */

    /* post send of request */
    ret = job_bmi_send_list(encoded_req.dest,
			    encoded_req.buffer_list,
			    encoded_req.size_list,
			    encoded_req.list_count,
			    encoded_req.total_size,
			    session_tag,
			    encoded_req.buffer_type,
			    1,
			    NULL, /* USER PTR */
			    &send_status,
			    &send_id,
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send has already completed! decrement the completion counter */
	sm->comp_ct--;
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 1;
}

static int remove_recv_lookup_resp(PINT_client_sm *sm,
				   job_status_s *js)
{
    /* if we call something on reception of send completion,
     * it will be this function.  decrement a counter or set
     * a bit or something and return 0; we'll get called again.
     */

    /* ISSUE: can't tell which thing completed.
     *
     * SOLUTION: add job_id to the job_status structure, keep up with
     * them in the PINT_client_sm structure so we can tell the
     * difference.
     */

    /* receive lookup response from server */

    /* check permissions */

    /* Q: what do we do with directories?
     * Q: should we check that they are empty?
     */

    /* check that we have necessary metadata -- maybe do getattr? */

    return 1;
}

static int remove_post_rmdirent_sendrecv(PINT_client_sm *sm,
					 job_status_s *js)
{
    /* post rmdirent send and receive */

    /* NOTE: same issue with posting as in lookup case. */

    /* NOTE:  we remove the dirent first because this gets the
     * object out of the system fastest.
     */

    return 1;
}

static int remove_recv_rmdirent_resp(PINT_client_sm *sm,
				     job_status_s *js)
{
    /* receive rmdirent response from the server */

    return 1;
}

static int remove_post_datafile_remove_sendrecv(PINT_client_sm *sm,
						job_status_s *js)
{
    /* post all datafile remove requests and responses simultaneously.
     *
     * NOTE: it's easier to clean up from a metafile with no datafiles
     * than the other way around!  so we remove datafiles first.
     */

    return 1;
}

static int remove_recv_datafile_remove_resp(PINT_client_sm *sm,
					    job_status_s *js)
{
    /* receive responses from servers.
     *
     * tally up any failures so that we can report them in the FT
     * case.
     *
     * return 0 if we're not done; we'll get called again.
     */

    return 1;
}

static int remove_post_remove_sendrecv(PINT_client_sm *sm,
				       job_status_s *js)
{
    /* post remove request and response; this would catch
     * metafiles or directories as appropriate.
     */

    return 1;
}

static int remove_recv_remove_resp(PINT_client_sm *sm,
				   job_status_s *js)
{
    /* receive response from server.
     */

    return 1;
}

static int remove_cleanup(PINT_client_sm *sm,
			  job_status_s *js)
{
    gossip_debug(CLIENT_DEBUG, "remove state: cleanup\n");

    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 noexpandtab
 */
