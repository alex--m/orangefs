/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"

/* from original remove.c */
#include "pinode-helper.h"
#include "pvfs2-sysint.h"
#include "pint-sysint.h"
#include "pint-dcache.h"
#include "pint-servreq.h"
#include "pint-dcache.h"
#include "pint-bucket.h"
#include "pcache.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

/* values greater than zero are usable here */
enum {
    REMOVE_DCACHE_HIT = 1,
    REMOVE_PCACHE_HIT = 2,
    REMOVE_MUST_REMOVE_DATAFILES = 3
};

static int remove_init(PINT_client_sm *sm_p,
		       job_status_s *js_p);

static int remove_lookup_post_msgpair(PINT_client_sm *sm_p,
				       job_status_s *js_p);
static int remove_lookup_failure(PINT_client_sm *sm_p,
				 job_status_s *js_p);
static int remove_lookup_complete_msgpair(PINT_client_sm *sm_p,
				   job_status_s *js_p);

static int remove_getattr_post_msgpair(PINT_client_sm *sm_p,
					job_status_s *js_p);
static int remove_getattr_failure(PINT_client_sm *sm_p,
				  job_status_s *js_p);
static int remove_getattr_complete_msgpair(PINT_client_sm *sm_p,
				    job_status_s *js_p);

static int remove_datafile_remove_post_msgpair(PINT_client_sm *sm_p,
						job_status_s *js_p);
static int remove_datafile_remove_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p);
static int remove_datafile_complete_msgpair(PINT_client_sm *sm_p,
					    job_status_s *js_p);

static int remove_rmdirent_post_msgpair(PINT_client_sm *sm_p,
					 job_status_s *js_p);
static int remove_rmdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p);
static int remove_rmdirent_complete_msgpair(PINT_client_sm *sm_p,
				     job_status_s *js_p);

static int remove_object_remove_post_msgpair(PINT_client_sm *sm_p,
					      job_status_s *js_p);
static int remove_object_remove_failure(PINT_client_sm *sm_p,
					job_status_s *js_p);
static int remove_object_remove_complete_msgpair(PINT_client_sm *sm_p,
					  job_status_s *js_p);

static int remove_cleanup(PINT_client_sm *sm_p,
			  job_status_s *js_p);

%%

machine pvfs2_client_remove_sm(init,
			       cleanup,
			       lookup_post_msgpair,
			       lookup_failure,
			       lookup_complete_msgpair,
			       getattr_post_msgpair,
			       getattr_failure,
			       getattr_complete_msgpair,
			       datafile_remove_post_msgpair,
			       datafile_remove_failure,
			       datafile_complete_msgpair,
			       rmdirent_post_msgpair,
			       rmdirent_failure,
			       rmdirent_complete_msgpair,
			       object_remove_post_msgpair,
			       object_remove_failure,
			       object_remove_complete_msgpair)
{
    state init
	{
	    run remove_init;
	    default => lookup_post_msgpair;
	}

    state lookup_post_msgpair
	{
	    jump pvfs2_client_msgpair_sm;
	    success => lookup_complete_msgpair;
	    REMOVE_DCACHE_HIT => getattr_post_msgpair;
	    REMOVE_PCACHE_HIT => cleanup;
	    default => lookup_failure;
	}

    state lookup_failure
	{
	    run remove_lookup_failure;
	    default => cleanup;
	}

    state lookup_complete_msgpair
	{
	    run remove_lookup_complete_msgpair;
	    success => rmdirent_post_msgpair;
	    default => cleanup;
	}

    state getattr_post_msgpair
	{
	    run remove_getattr_post_msgpair;
	    success => getattr_complete_msgpair;
	    default => getattr_failure;
	}

    state getattr_failure
	{
	    run remove_getattr_failure;
	    default => cleanup;
	}

    state getattr_complete_msgpair
	{
	    run remove_getattr_complete_msgpair;
	    REMOVE_MUST_REMOVE_DATAFILES => datafile_remove_post_msgpair;
	    success => object_remove_post_msgpair;
	    default => cleanup;
	}

    state rmdirent_post_msgpair
	{
	    run remove_rmdirent_post_msgpair;
	    success => rmdirent_complete_msgpair;
	    default => rmdirent_failure;
	}

    state rmdirent_failure
	{
	    run remove_rmdirent_failure;
	    default => cleanup;
	}

    state rmdirent_complete_msgpair
	{
	    run remove_rmdirent_complete_msgpair;
	    default => getattr_post_msgpair;
	}

    state datafile_remove_post_msgpair
	{
	    run remove_datafile_remove_post_msgpair;
	    success => datafile_complete_msgpair;
	    default => datafile_remove_failure;
	}

    state datafile_remove_failure
	{
	    run remove_datafile_remove_failure;
	    default => cleanup;
	}

    state datafile_complete_msgpair
	{
	    run remove_datafile_complete_msgpair;
	    default => object_remove_post_msgpair;
	}

    state object_remove_post_msgpair
	{
	    run remove_object_remove_post_msgpair;
	    success => object_remove_complete_msgpair;
	    default => object_remove_failure;
	}

    state object_remove_failure
	{
	    run remove_object_remove_failure;
	    default => cleanup;
	}

    state object_remove_complete_msgpair
	{
	    run remove_object_remove_complete_msgpair;
	    default => cleanup;
	}

    state cleanup
	{
	    run remove_cleanup;
	    default => init;
	}
}

%%



int PVFS_sys_remove2(char *object_name,
		     PVFS_pinode_reference parent_ref, 
		     PVFS_credentials credentials)
{
    int ret;
    PINT_client_sm *sm_p;


    gossip_debug(CLIENT_DEBUG, "PVFS_sys_remove entered\n");

    /* do parameter checking here, then assume things are ok below.
     * assert()s are still ok of course :).
     */
    if (object_name == NULL) return -PVFS_EINVAL;

    /* build PINT_client_sm structure */
    /* TODO: KEEP A CACHE OF THESE AROUND SO WE'RE NOT ALWAYS MALLOC'ING? */
    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL) return -PVFS_ENOMEM;

    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.remove.object_name = object_name;
    sm_p->u.remove.parent_ref  = parent_ref;

    gossip_debug(CLIENT_DEBUG,
		 "PVFS_sys_remove calling PINT_client_state_machine_post()\n");

    /* do something to kick off processing */
    ret = PINT_client_state_machine_post(sm_p);
    assert(ret == 0);

    /* while !done call progress function */
    while (!sm_p->op_complete && ret == 0) {
	gossip_debug(CLIENT_DEBUG,
		     "PVFS_sys_remove calling PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }

    assert(ret == 0);

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_remove completed\n");

    /* clean up after ourselves */
    free(sm_p);
    return 0;
}


/****************************************************************/

/* remove_init()
 */
static int remove_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: init\n");

    /* do the request scheduler thing, if necessary */

    return 1;
}

/* remove_lookup_post_msgpair()
 */
static int remove_lookup_post_msgpair(PINT_client_sm *sm_p,
				       job_status_s *js_p)
{
    int ret;

    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_lookup_post_msgpair\n");

    /* check and see if we have the handle for the object in
     * our directory cache already.
     *
     * dcache doesn't have a concept of a lock on an entry; maybe
     * it should though?
     */
    ret = PINT_dcache_lookup(sm_p->u.remove.object_name,
			     sm_p->u.remove.parent_ref,
			     &sm_p->u.remove.object_ref);
    if (ret < 0 && ret != -PVFS_ENOENT) {
	/* fatal error */
	return -1;
    }
    else if (ret == 0) {
	PINT_pinode *pinode_p;

	/* match in dcache; no need for lookup */
	gossip_debug(CLIENT_DEBUG, "remove: dcache hit\n");

	/* check to see if we have attributes for the object in
	 * our pinode cache already.
	 */
	/* TODO: MAKE PINT_PCACHE_LOOKUP RETURNS MORE STANDARD */
	/* TODO: MOVE THIS DOWN INTO THE GETATTR STATE!!! */
	ret = PINT_pcache_lookup(sm_p->u.remove.object_ref,
				 &pinode_p);
	if (ret == PCACHE_LOOKUP_SUCCESS) {
	    /* got our attributes; let's get to work */
	    gossip_debug(CLIENT_DEBUG, "remove: pcache hit\n");

	    sm_p->pcache_lock = 1;
	    sm_p->object_pinode_p = pinode_p;

	    js_p->error_code = REMOVE_PCACHE_HIT;
	    return 1;
	}				 
	else {
	    /* did hit dcache, but need to get attributes */
	    js_p->error_code = REMOVE_DCACHE_HIT;
	    return 1;
	}
    }

    /* otherwise we need to perform the lookup */

    /* post the receive of the response, then the send of the
     * lookup request.  pre-posting the receive can make a
     * performance difference for some network types.
     *
     * We're going to end up popping into the next state twice
     * because of these two posted operations.  We keep a counter
     * to keep up with how many operations have completed.  We'll
     * use the sm->comp_ct for this purpose.  We set to 2 (# of jobs)
     * and then decrement as they complete in the next state.
     */
    sm_p->comp_ct = 2;

    /* Steps:
     * (1) fill in request
     * (2) determine destination server
     * (3) encode request
     * (4) calculate max. size for response
     * (5) allocate BMI memory region for response
     * (6) get next session tag
     * (7) call job fn. to post receive
     * (8) call job fn. to post send
     */

    /* do parameter checking */
    if ((strlen(sm_p->u.remove.object_name) + 1 >
	 PVFS_REQ_LIMIT_PATH_NAME_BYTES) ||
	(PINT_string_count_segments(sm_p->u.remove.object_name) >
	 PVFS_REQ_LIMIT_PATH_SEGMENT_COUNT))
    {
	/* TODO: CLEAN UP... */
	assert(0);
	return -PVFS_ENAMETOOLONG;
    }

    /* fill in lookup request (macro in pvfs2-req-proto.h) */
    PINT_SERVREQ_LOOKUP_PATH_FILL(sm_p->req,
				  *sm_p->cred_p,
				  sm_p->u.remove.object_name,
				  sm_p->u.remove.parent_ref.fs_id,
				  sm_p->u.remove.parent_ref.handle,
				  PVFS_ATTR_COMMON_ALL);

    /* This function:
     * - maps object to server
     * - encodes the request
     * - calculates the max. response size
     * - allocates memory for that response
     * - gets a session tag
     */
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p, /* user pointer -- used to get to next state */
		       &recv_status, /* only for immediate completion */
		       &recv_id, /* could theoretically be used to unpost */
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0); /* just to see that we don't get odd values */

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p, /* user pointer, used to get to next state */
			    &send_status, /* only for immediate completion */
			    &send_id, /* could in theory be used to unpost */
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: lookup send completed immediately.\n");
	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);
	sm_p->comp_ct--;
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

/* remove_lookup_complete_msgpair()
 */
static int remove_lookup_complete_msgpair(PINT_client_sm *sm_p,
				   job_status_s *js_p)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_lookup_resp\n");

    /* we may or may not have previously completed either operation.
     * here we check to see if there are additional operations that
     * must complete successfully before we can continue.  if the
     * counter hits zero, we know we've gotten our data and can
     * continue.
     *
     * otherwise we return 0; we will get called again when the next
     * bmi job completes.
     */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }

    /* check status of response */
    if (resp_p->status != 0) {
	assert(0);
    }

    assert(resp_p->u.lookup_path.handle_count == 1);

    /* pull out the data that we wanted */
    sm_p->u.remove.object_ref.handle = resp_p->u.lookup_path.handle_array[0];
    sm_p->u.remove.object_ref.fs_id  = sm_p->u.remove.parent_ref.fs_id;

    gossip_debug(CLIENT_DEBUG, "lookup completed (handle = 0x%08Lx)\n",
		 sm_p->u.remove.object_ref.handle);

    /* free all the resources that we used to send and receive. */
    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    /* check permissions */

    /* Q: what do we do with directories?
     * Q: should we check that they are empty?
     */

    /* TODO: check that we have necessary metadata from lookup */

    return 1;
}

/* remove_getattr_post_msgpair()
 *
 * Q: DO WE WANT TO REMOVE THE DIRECTORY ENTRY BEFORE THIS???
 */
static int remove_getattr_post_msgpair(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    int ret;
    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_getattr_post_msgpair\n");

    /* do parameter checking */

    /* mark that we have two messages to receive */
    sm_p->comp_ct = 2;

    /* fill in getattr request */
    PINT_SERVREQ_GETATTR_FILL(sm_p->req,
			      *sm_p->cred_p,
			      sm_p->u.remove.object_ref.fs_id,
			      sm_p->u.remove.object_ref.handle,
			      PVFS_ATTR_COMMON_ALL|PVFS_ATTR_META_DFILES);
    
    /* This function:
     * - maps object to server
     * - encodes the request
     * - calculates the max. response size
     * - allocates memory for that response
     * - gets a session tag
     */
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p, /* user pointer -- used to get to next state */
		       &recv_status, /* only for immediate completion */
		       &recv_id, /* could theoretically be used to unpost */
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0); /* just to see that we don't get odd values */

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p, /* user pointer, used to get to next state */
			    &send_status, /* only for immediate completion */
			    &send_id, /* could in theory be used to unpost */
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: getattr send completed immediately.\n");
	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);
	sm_p->comp_ct--;
	assert(sm_p->comp_ct == 1);
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

/* remove_getattr_complete_msgpair()
 */
static int remove_getattr_complete_msgpair(PINT_client_sm *sm_p,
				    job_status_s *js_p)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_getattr_resp\n");

    /* we may or may not have previously completed either operation.
     * here we check to see if there are additional operations that
     * must complete successfully before we can continue.  if the
     * counter hits zero, we know we've gotten our data and can
     * continue.
     *
     * otherwise we return 0; we will get called again when the next
     * bmi job completes.
     */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }


    /* check status of response */
    if (resp_p->status != 0) {
	gossip_err("error: remove sm: status = %d on getattr msg\n",
		   resp_p->status);
	assert(0);
    }

    gossip_debug(CLIENT_DEBUG, "getattr completed (handle = 0x%08Lx)\n",
		 sm_p->u.remove.object_ref.handle);

    /* pull out the data that we wanted */
    switch (resp_p->u.getattr.attr.objtype) {
	case PVFS_TYPE_METAFILE:
	    /* need to save datafile handles and remove them;
	     * redirect us to those states.
	     */
	    js_p->error_code = REMOVE_MUST_REMOVE_DATAFILES;
	    assert(resp_p->u.getattr.attr.mask & PVFS_ATTR_META_DFILES);
	    assert(resp_p->u.getattr.attr.u.meta.dfile_count > 0);

	    gossip_debug(CLIENT_DEBUG,
			 "remove sm: %d datafiles to remove too.\n",
			 resp_p->u.getattr.attr.u.meta.dfile_count);

	    /* save the datafile handles prior to freeing up the
	     * buffers we used for messages.  we could keep them around
	     * i suppose, but we're not going to do that for now.  later
	     * it is likely that this stuff will be stuck in the pcache
	     * anyway, so we'll be able to just reference it from there.
	     */
	    sm_p->u.remove.datafile_handles = (PVFS_handle *) malloc(resp_p->u.getattr.attr.u.meta.dfile_count * sizeof(PVFS_handle));
	    if (sm_p->u.remove.datafile_handles == NULL) {
		assert(0);
	    }
	    sm_p->u.remove.datafile_count = resp_p->u.getattr.attr.u.meta.dfile_count;
	    memcpy(sm_p->u.remove.datafile_handles,
		   resp_p->u.getattr.attr.u.meta.dfile_array,
		   resp_p->u.getattr.attr.u.meta.dfile_count * sizeof(PVFS_handle));

	    break;
	case PVFS_TYPE_DIRECTORY:
	    break;
	case PVFS_TYPE_SYMLINK:
	    /* fall through */
	case PVFS_TYPE_DATAFILE:
	    /* fall through */
	case PVFS_TYPE_DIRDATA:
	    /* fall through */
	default:
	    gossip_err("error: remove sm: unhandled object type\n");
	    assert(0);
    }

    /* TODO: POPULATE THE PCACHE? */

    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    /* check permissions */

    /* Q: what do we do with directories?
     * Q: should we check that they are empty?
     */

    /* TODO: check that we have necessary metadata from lookup */

    return 1;
}



/* remove_rmdirent_post_msgpair()
 */
static int remove_rmdirent_post_msgpair(PINT_client_sm *sm_p,
					 job_status_s *js_p)
{
    int ret;
    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    /* NOTE:  we remove the dirent first because this gets the
     * object out of the system fastest.
     */

    gossip_debug(CLIENT_DEBUG, "remove state: post_rmdirent_post_msgpair\n");

    /* do parameter checking */

    /* mark that we have two messages to receive */
    sm_p->comp_ct = 2;

    /* fill in getattr request */
    PINT_SERVREQ_RMDIRENT_FILL(sm_p->req,
			       *sm_p->cred_p,
			       sm_p->u.remove.parent_ref.fs_id,
			       sm_p->u.remove.parent_ref.handle,
			       sm_p->u.remove.object_name);
    
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p,
		       &recv_status,
		       &recv_id,
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0);

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p,
			    &send_status,
			    &send_id,
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: rmdirent send completed immediately.\n");

	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);

	sm_p->comp_ct--;
	assert(sm_p->comp_ct == 1);
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

/* remove_rmdirent_complete_msgpair()
 */
static int remove_rmdirent_complete_msgpair(PINT_client_sm *sm_p,
				     job_status_s *js_p)
{
    /* receive rmdirent response from the server */
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_rmdirent_complete_msgpair\n");

    /* decrement until both operations have completed */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.  we get the actual size of the received message
     * from the job status structure.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }

    /* check status of response */
    if (resp_p->status != 0) {
	assert(0);
    }

    /* pull out the data that we wanted */
    assert(sm_p->u.remove.object_ref.handle == resp_p->u.rmdirent.entry_handle);

    /* free all the resources that we used to send and receive. */
    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    return 1;
}

/* remove_datafile_remove_post_msgpair()
 */
static int remove_datafile_remove_post_msgpair(PINT_client_sm *sm_p,
						job_status_s *js_p)
{
    int ret, i;

   /* post all datafile remove requests and responses simultaneously.
     *
     * NOTE: it's easier to clean up from a metafile with no datafiles
     * than the other way around!  so we remove datafiles first.
     */

    gossip_debug(CLIENT_DEBUG, "remove state: post_getattr_post_msgpair\n");

    /* do parameter checking */

    sm_p->u.remove.msgpair = (PINT_client_sm_msgpair_state *)
	malloc(sm_p->u.remove.datafile_count * sizeof(PINT_client_sm_msgpair_state));
    if (sm_p->u.remove.msgpair == NULL) {
	assert(0);
    }

    /* mark that we have two jobs per datafile */
    sm_p->comp_ct = 2 * sm_p->u.remove.datafile_count;

    /* for each datafile, post a send/recv pair for the remove */
    for (i=0; i < sm_p->u.remove.datafile_count; i++) {
	PVFS_msg_tag_t session_tag;
	job_status_s send_status;
	job_status_s recv_status;
	job_id_t send_id, recv_id;

	PINT_SERVREQ_REMOVE_FILL(sm_p->u.remove.msgpair[i].req,
				 *sm_p->cred_p,
				  sm_p->u.remove.object_ref.fs_id,
				 sm_p->u.remove.datafile_handles[i]);
    
	ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
					&sm_p->u.remove.msgpair[i].req,
					&sm_p->u.remove.msgpair[i].encoded_req,
					&sm_p->u.remove.msgpair[i].encoded_resp_p,
					&sm_p->u.remove.msgpair[i].svr_addr,
					&sm_p->u.remove.msgpair[i].max_resp_sz,
					&session_tag);
	if (ret != 0) {
	    assert(0);
	}

	/* post receive of response */
	ret = job_bmi_recv(sm_p->u.remove.msgpair[i].svr_addr,
			   sm_p->u.remove.msgpair[i].encoded_resp_p,
			   sm_p->u.remove.msgpair[i].max_resp_sz,
			   session_tag,
			   BMI_PRE_ALLOC,
			   sm_p,
			   &recv_status,
			   &recv_id,
			   pint_client_sm_context);
	if (ret < 0) {
	    assert(0);
	}
	else if (ret == 1) {
	    assert(0);
	}

	assert(ret == 0);

	/* save the job id for reference later */
	sm_p->u.remove.msgpair[i].recv_id = recv_id;

	/* post send of request */
	ret = job_bmi_send_list(sm_p->u.remove.msgpair[i].encoded_req.dest,
				sm_p->u.remove.msgpair[i].encoded_req.buffer_list,
				sm_p->u.remove.msgpair[i].encoded_req.size_list,
				sm_p->u.remove.msgpair[i].encoded_req.list_count,
				sm_p->u.remove.msgpair[i].encoded_req.total_size,
				session_tag,
				sm_p->u.remove.msgpair[i].encoded_req.buffer_type,
				1,
				sm_p,
				&send_status,
				&send_id,
				pint_client_sm_context);
	if (ret < 0) {
	    assert(0);
	}
	else if (ret == 1) {
	    /* send completed immediately; decrement the completion counter */
	    gossip_debug(CLIENT_DEBUG, "remove: datafile remove send completed immediately.\n");
	    /* TODO: CHECK THE STATUS!!! */
	    assert(send_status.error_code == 0);

	    sm_p->u.remove.msgpair[i].send_id = 0; /* mark as done */
	    sm_p->comp_ct--;
	}
    }

    gossip_debug(CLIENT_DEBUG, "remove sm: post_datafile_remove_post_msgpair: count = %d\n",
		 sm_p->comp_ct);

    return 0;
}

static int remove_datafile_complete_msgpair(PINT_client_sm *sm_p,
					    job_status_s *js_p)
{
    int ret, i;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_datafile_complete_msgpair\n");

    /* keep decrementing comp_ct until we're done */
    /* TODO: MARK THE ONES THAT WE RECEIVED ALREADY, SO WE COULD CLEAN
     * UP NICELY.
     */

    gossip_debug(CLIENT_DEBUG, "remove sm: recv_datafile_complete_msgpair: count = %d\n",
		 sm_p->comp_ct);

    if (--sm_p->comp_ct > 0) {
	int matched_job = 0;

	for (i=0; i < sm_p->u.remove.datafile_count; i++)
	{
	    if (sm_p->u.remove.msgpair[i].recv_id == js_p->id)
	    {
		sm_p->u.remove.msgpair[i].recv_id = 0;
		sm_p->u.remove.msgpair[i].actual_resp_sz = js_p->actual_size;
		matched_job = 1;
		break;
	    }
	    else if (sm_p->u.remove.msgpair[i].send_id == js_p->id)
	    {
		sm_p->u.remove.msgpair[i].send_id = 0;
		/* don't need actual size for sends, only receives */
		matched_job = 1;
		break;
	    }
	}
	assert(matched_job == 1);

	return 0;
    }
    assert(sm_p->comp_ct == 0);

    /* we have received all the responses successfully */

    /* HACK!!!!!!  WE'RE ASSUMING THAT THE ACTUAL SIZE OF ALL THE
     * MESSAGES ARE THE SAME!  WE NEED TO MATCH TAGS AND DO THE RIGHT
     * THING HERE...
     */

    /* for each remove message, decode, check status, and free resources */
    for (i=0; i < sm_p->u.remove.datafile_count; i++) {
	/* decode; resp_p will point to response */
	ret = PINT_serv_decode_resp(sm_p->u.remove.msgpair[i].encoded_resp_p,
				    &decoded_resp,
				    &sm_p->u.remove.msgpair[i].svr_addr,
				    js_p->actual_size,
				    &resp_p);
	if (ret < 0) {
	    assert(0);
	}

	/* check status of response */
	if (resp_p->status != 0) {
	    gossip_err("error: remove sm: status = %d on datafile remove msg\n",
		       resp_p->status);
	    assert(0);
	}

	/* free resources */
	ret = PINT_serv_free_msgpair_resources(&sm_p->u.remove.msgpair[i].encoded_req,
					       sm_p->u.remove.msgpair[i].encoded_resp_p,
					       &decoded_resp,
					       &sm_p->u.remove.msgpair[i].svr_addr,
					       sm_p->u.remove.msgpair[i].max_resp_sz);
	if (ret != 0) {
	    assert(0);
	}
    }

    return 1;
}

static int remove_object_remove_post_msgpair(PINT_client_sm *sm_p,
					      job_status_s *js_p)
{
    int ret;
    PVFS_msg_tag_t session_tag;
    job_status_s send_status, recv_status;
    job_id_t send_id, recv_id;

    gossip_debug(CLIENT_DEBUG, "remove state: post_object_remove_post_msgpair\n");

    /* mark that we have two messages to receive */
    sm_p->comp_ct = 2;

    /* fill in getattr request */
    PINT_SERVREQ_REMOVE_FILL(sm_p->req,
			     *sm_p->cred_p,
			     sm_p->u.remove.object_ref.fs_id,
			     sm_p->u.remove.object_ref.handle);
    
    ret = PINT_serv_prepare_msgpair(sm_p->u.remove.parent_ref,
				    &sm_p->req,
				    &sm_p->encoded_req,
				    &sm_p->encoded_resp_p,
				    &sm_p->svr_addr,
				    &sm_p->max_resp_sz,
				    &session_tag);
    if (ret != 0) {
	assert(0);
    }

    /* post receive of response */
    ret = job_bmi_recv(sm_p->svr_addr,
		       sm_p->encoded_resp_p,
		       sm_p->max_resp_sz,
		       session_tag,
		       BMI_PRE_ALLOC,
		       sm_p,
		       &recv_status,
		       &recv_id,
		       pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	assert(0);
    }
    assert(ret == 0);

    /* post send of request */
    ret = job_bmi_send_list(sm_p->encoded_req.dest,
			    sm_p->encoded_req.buffer_list,
			    sm_p->encoded_req.size_list,
			    sm_p->encoded_req.list_count,
			    sm_p->encoded_req.total_size,
			    session_tag,
			    sm_p->encoded_req.buffer_type,
			    1,
			    sm_p,
			    &send_status,
			    &send_id,
			    pint_client_sm_context);
    if (ret < 0) {
	assert(0);
    }
    else if (ret == 1) {
	/* send completed immediately; decrement the completion counter */
	gossip_debug(CLIENT_DEBUG, "remove: object remove send completed immediately.\n");

	/* TODO: CHECK THE STATUS!!! */
	assert(send_status.error_code == 0);

	sm_p->comp_ct--;
	assert(sm_p->comp_ct == 1);
    }

    /* TODO: keep up with job ids, so we can match later. */

    return 0;
}

static int remove_object_remove_complete_msgpair(PINT_client_sm *sm_p,
					  job_status_s *js_p)
{
    int ret;
    struct PINT_decoded_msg decoded_resp; /* data about decoded resp */
    struct PVFS_server_resp *resp_p; /* response structure (decoded) */

    gossip_debug(CLIENT_DEBUG, "remove state: recv_object_remove_complete_msgpair\n");

    /* decrement until both operations have completed */
    if (--sm_p->comp_ct > 0) return 0;
    assert(sm_p->comp_ct == 0);

    /* in the success case we can assume that the last thing we received
     * was the response.  we get the actual size of the received message
     * from the job status structure.
     */

    /* decode; resp_p will point to response */
    ret = PINT_serv_decode_resp(sm_p->encoded_resp_p,
				&decoded_resp,
				&sm_p->svr_addr,
				js_p->actual_size,
				&resp_p);
    if (ret < 0) {
	assert(0);
    }

    /* check status of response */
    if (resp_p->status != 0) {
	assert(0);
    }

    /* free all the resources that we used to send and receive. */
    ret = PINT_serv_free_msgpair_resources(&sm_p->encoded_req,
					   sm_p->encoded_resp_p,
					   &decoded_resp,
					   &sm_p->svr_addr,
					   sm_p->max_resp_sz);
    if (ret != 0) {
	assert(0);
    }

    return 1;
}

/* remove_cleanup()
 */
static int remove_cleanup(PINT_client_sm *sm_p,
			  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: cleanup\n");

    /* store enough information in the sm structure that the caller
     * can tell what happened.
     */
    sm_p->status = *js_p;

    /* if we have a locked pcache entry, release it */
    if (sm_p->pcache_lock) {
	assert(sm_p->pcache_lock == 1);

	PINT_pcache_lookup_rls(sm_p->object_pinode_p);
    }

    /* mark operation as complete */
    sm_p->op_complete = 1;

    return 0;
}

/* remove_lookup_failure()
 */
static int remove_lookup_failure(PINT_client_sm *sm_p,
				 job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: lookup_failure\n");

    /* TODO: unpost operations that are still in progress, once we can. */

    /* ISSUE: can't tell which thing completed (with an error).
     *
     * SOLUTION: add job_id to the job_status structure, keep up with
     * them in the PINT_client_sm structure so we can tell the
     * difference.
     */

    return 1;
}

/* remove_getattr_failure()
 */
static int remove_getattr_failure(PINT_client_sm *sm_p,
				  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: getattr_failure\n");

    /* TODO: unpost operations that are still in progress, once we can. */

    /* ISSUE: can't tell which thing completed (with an error).
     *
     * SOLUTION: add job_id to the job_status structure, keep up with
     * them in the PINT_client_sm structure so we can tell the
     * difference.
     */

    /* Q: CAN WE HANDLE ALL THE SEND/RECV PAIRS FAILURE CASES WITH ONE
     * STATE?
     */

    return 1;
}

static int remove_datafile_remove_failure(PINT_client_sm *sm_p,
					  job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: datafile_remove_failure\n");

    return 1;
}

static int remove_rmdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: rmdirent_failure\n");

    return 1;
}

static int remove_object_remove_failure(PINT_client_sm *sm_p,
					job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "remove state: object_remove_failure\n");

    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 noexpandtab
 */
