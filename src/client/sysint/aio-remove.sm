/* 
 * (C) 2012 Clemson University
 *
 * See COPYING in top-level directory.
 */

#include "pvfs2-internal.h"
#include "pvfs2-aio.h"
#include "client-state-machine.h"
#include "str-utils.h"

extern job_context_id pint_client_sm_context;

enum
{
    REMOVE_PDIR_NULL = 675,
    REMOVE_REF_FOUND,
    REMOVE_LOOKUP_SM
};

/* helper function prototypes */
static int initialize_context(
    struct PINT_client_lookup_sm * lookup_sm,
    char *pathname,
    PVFS_object_ref ctx_starting_refn);

%%

machine pvfs2_client_aio_remove_sm
{
    state init
    {
        run remove_init;
        REMOVE_PDIR_NULL => parent_ref_abs_lookup_setup;
        REMOVE_REF_FOUND => file_ref_rel_lookup_setup;
        default => parent_ref_rel_lookup_setup;
    }

    state parent_ref_abs_lookup_setup
    {
        run remove_parent_ref_abs_lookup_setup;
        REMOVE_LOOKUP_SM => parent_ref_abs_lookup;
        REMOVE_REF_FOUND => file_ref_rel_lookup_setup;
        default => cleanup;
    }

    state parent_ref_abs_lookup
    {
        jump pvfs2_client_lookup_sm;
        default => parent_ref_abs_lookup_inspect;
    }

    state parent_ref_abs_lookup_inspect
    {
        run remove_parent_ref_abs_lookup_inspect;
        success => file_ref_rel_lookup_setup;
        default => cleanup;
    }

    state parent_ref_rel_lookup_setup
    {
        run remove_parent_ref_rel_lookup_setup;
        REMOVE_REF_FOUND => file_ref_rel_lookup_setup;
        REMOVE_LOOKUP_SM => parent_ref_rel_lookup;
        default => cleanup;
    }

    state parent_ref_rel_lookup
    {
        jump pvfs2_client_lookup_sm;
        default => parent_ref_rel_lookup_inspect;
    }

    state parent_ref_rel_lookup_inspect
    {
        run remove_parent_ref_rel_lookup_inspect;
        REMOVE_LOOKUP_SM => parent_ref_rel_lookup;
        REMOVE_REF_FOUND => file_ref_rel_lookup_setup;
        default => cleanup;
    }

    state file_ref_rel_lookup_setup
    {
        run remove_file_ref_rel_lookup_setup;
        REMOVE_REF_FOUND => getattr_setup;
        REMOVE_LOOKUP_SM => file_ref_rel_lookup;
        default => cleanup;
    }

    state file_ref_rel_lookup
    {
        jump pvfs2_client_lookup_sm;
        default => file_ref_rel_lookup_inspect;
    }

    state file_ref_rel_lookup_inspect
    {
        run remove_file_ref_rel_lookup_inspect;
        REMOVE_LOOKUP_SM => file_ref_rel_lookup;
        REMOVE_REF_FOUND => getattr_setup;
        default => cleanup;
    }

    state getattr_setup
    {
        run remove_getattr_setup;
        success => getattr_sm_run;
        default => cleanup;
    }

    state getattr_sm_run
    {
        jump pvfs2_client_getattr_sm;
        default => getattr_inspect;
    }

    state getattr_inspect
    {
        run remove_getattr_inspect;
        success => sm_setup;
        default => cleanup;
    }

    state sm_setup
    {
        run remove_sm_setup;
        success => sm_run;
        default => cleanup;
    }

    state sm_run
    {
        jump pvfs2_client_remove_sm;
        default => sm_inspect;
    }

    state sm_inspect
    {
        run remove_sm_inspect;
        default => cleanup;
    }

    state cleanup
    {
        run remove_cleanup;
        default => terminate;
    }
}

%%

static int initialize_context(
    struct PINT_client_lookup_sm * lookup_sm,
    char *pathname,
    PVFS_object_ref ctx_starting_refn)
{
    int i, ret = -PVFS_EINVAL, pathlen = 0, num_segments = 0;
    void *state = NULL;
    int cur_seg_index = 0, prev_ctx_index = 0;
    char *cur_seg_name = NULL;
    char *orig_pathname = NULL, *path_remaining = NULL, *slash_str = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;
    int num_consecutive_prev_ctx_dot_dots = 0;
    PINT_client_lookup_sm_ctx *ctx = NULL;
    PINT_client_lookup_sm_ctx *prev_ctx = NULL;

    gossip_debug(GOSSIP_LOOKUP_DEBUG, "initialize_context called\n");

    assert(lookup_sm->current_context <= lookup_sm->context_count);

    if(lookup_sm->current_context == lookup_sm->context_count)
    {
        /* we have used the last available context */
        lookup_sm->context_count++;
        if(lookup_sm->context_count == 1)
        {
            lookup_sm->contexts = malloc(sizeof(PINT_client_lookup_sm_ctx));
            if(!lookup_sm->contexts)
            {
                return -PVFS_ENOMEM;
            }
        }
        else
        {
            /* not the first one, so realloc to get one more */
            lookup_sm->contexts = realloc(lookup_sm->contexts,
                                          sizeof(PINT_client_lookup_sm_ctx) *
                                          lookup_sm->context_count);
            if(!lookup_sm->contexts)
            {
                return -PVFS_ENOMEM;
            }
        }
    }

    if (pathname && (lookup_sm->current_context > -1))
    {
        ctx = &lookup_sm->contexts[lookup_sm->current_context];
        assert(ctx);

        prev_ctx_index = (lookup_sm->current_context - 1);

        pathlen = strlen(pathname);
        num_segments = PINT_string_count_segments(pathname);

        if ((pathlen == 0) || (num_segments == 0))
        {
            return ret;
        }

        if ((pathlen > (PVFS_REQ_LIMIT_PATH_NAME_BYTES - 1)) ||
            (num_segments > MAX_LOOKUP_SEGMENTS))
        {
            gossip_err("Filename %s is too long\n", pathname);
            return -PVFS_ENAMETOOLONG;
        }

        memset(ctx, 0, sizeof(PINT_client_lookup_sm_ctx));

        ctx->current_segment = 0;
        ctx->total_segments = 0;
        ctx->ctx_starting_refn = ctx_starting_refn;

        /* initialize all segments within the context */
        orig_pathname = strdup(pathname);
        gossip_debug(GOSSIP_LOOKUP_DEBUG, " original pathname is: %s\n",
                     orig_pathname);
        while(!PINT_string_next_segment(pathname,&cur_seg_name,&state))
        {
            /* grab the next segment in the context to fill in */
            cur_seg = &(ctx->segments[cur_seg_index]);
            assert(cur_seg);
            memset(cur_seg, 0, sizeof(PINT_client_lookup_sm_segment));

            gossip_debug(GOSSIP_LOOKUP_DEBUG, " cur_seg_name[%d]: %s\n",
                         cur_seg_index, cur_seg_name);
            gossip_debug(GOSSIP_LOOKUP_DEBUG, " pathname is: %s\n",
                         pathname);

            if (strcmp(cur_seg_name,".") == 0)
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;

                gossip_debug(GOSSIP_LOOKUP_DEBUG,
                             " ignoring useless segment\n");
                continue;
            }
            else if (strcmp(cur_seg_name,"..") == 0)
            {
                /*
                   if this isn't true, we need to
                   grab the previous context's previous segment

                   if this weren't true, we'd normally:
                   assert(cur_seg_index > 0);
                */
                if ((cur_seg_index < 1) ||
                    (num_consecutive_prev_ctx_dot_dots > 0))
                {
                    PINT_client_lookup_sm_segment *prev_ctx_prev_seg;

                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG, "  got a '..' segment that "
                        "requires attention of the previous context\n");

                  init_next_prev_segment:
                    /*
                      grab the previous context to access the segments
                      within it, assuming a previous context is
                      available
                    */
                    if (prev_ctx_index < 0)
                    {
                        gossip_debug(GOSSIP_LOOKUP_DEBUG, "there are no "
                                     "more previous contexts available: "
                                     "failing lookup\n");
                        free(orig_pathname);
                        return -PVFS_ENOENT;
                    }

                    prev_ctx = &lookup_sm->contexts[prev_ctx_index];
                    assert(prev_ctx);
                    assert(prev_ctx->current_segment > 0);

                    num_consecutive_prev_ctx_dot_dots++;
                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG, "num consecutive '..' "
                        "segments requiring the previous segment "
                        "is now %d\n", num_consecutive_prev_ctx_dot_dots);

                    /*
                      further, if we have a number of consecutive '..'
                      segments, we may need to keep backing up into
                      the previous contexts' space
                    */
                    if (prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots < 0)
                    {
                        /* skip to next previous context, if any */
                        if (prev_ctx_index > -1)
                        {
                            /*
                              bump down dot dot count since it wasn't
                              used yet if we got here
                            */
                            num_consecutive_prev_ctx_dot_dots--;
                            prev_ctx_index--;
                            goto init_next_prev_segment;
                        }
                        gossip_debug(
                            GOSSIP_LOOKUP_DEBUG, "there are no more segments "
                            "in the previous context: failing lookup\n");
                        free(orig_pathname);
                        return -PVFS_ENOENT;
                    }

                    prev_ctx_prev_seg = &prev_ctx->segments[
                        prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots];
                    assert(prev_ctx_prev_seg);

                    /*
                      instead of decrementing the seg index and
                      continuing, we need to replace the last segment
                      copied from the last context in this case.  (so
                      we drop through to segment init)
                    */
                    ctx_starting_refn =
                        prev_ctx_prev_seg->seg_starting_refn;
                    cur_seg_name = prev_ctx_prev_seg->seg_name;
                    gossip_debug(
                        GOSSIP_LOOKUP_DEBUG,
                        "using previous segment: %s\n", cur_seg_name);

                    cur_seg_index--;
                }
                else
                {
                    gossip_debug(GOSSIP_LOOKUP_DEBUG,
                                 "  got a '..' segment\n");
                    cur_seg_index--;
                    continue;
                }
            }
            else
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;
            }

            /*
              fill in the current segment now.  the first segment
              MUST have the same starting refn as the context
            */
            if (cur_seg_index == 0)
            {
                cur_seg->seg_starting_refn = ctx_starting_refn;
            }
            if (cur_seg->seg_name)
            {
                free(cur_seg->seg_name);
            }
            cur_seg->seg_name = strdup(cur_seg_name);
            assert(cur_seg->seg_name);

            slash_str = orig_pathname;
            for (i = 0; i < cur_seg_index; i++) {
                slash_str = strchr(slash_str, '/');
                if (slash_str == NULL) {
                    break;
                }
                slash_str++;
            }
            /* path_remaining = strstr(orig_pathname, cur_seg_name); */
            path_remaining = slash_str;
            if (path_remaining)
            {
                gossip_debug(GOSSIP_LOOKUP_DEBUG,
                             " *path_remaining is: %s\n", path_remaining);

                cur_seg->path_remaining = strdup(path_remaining);
                assert(cur_seg->path_remaining);
            }
            else
            {
                cur_seg->path_remaining = NULL;
            }

            cur_seg_index++;
        }
        free(orig_pathname);

#if 0
    /* DEBUGGING ONLY */
    {
        int i = 0;
        gossip_debug(GOSSIP_LOOKUP_DEBUG, "Processed context path is:\n");
        for(i = 0; i < cur_seg_index; i++)
        {
            assert(ctx->segments[i].seg_name);
            gossip_debug(GOSSIP_LOOKUP_DEBUG, "/%s", 
                         ctx->segments[i].seg_name);
        }
        gossip_debug(GOSSIP_LOOKUP_DEBUG, "\n");
    }
#endif

        ctx->total_segments = cur_seg_index;
        assert(ctx->current_segment == 0);
        ret = 0;
    }
    return ret;
}

/*********************************************************/

PVFS_error PVFS_iaio_remove(
    const char *directory,
    const char *filename,
    PVFS_object_ref *pdir,
    int dirflag,
    const PVFS_credential *credential,
    PVFS_sys_op_id *op_id,
    PVFS_hint hints,
    void *user_ptr)
{
    int ret = -PVFS_EINVAL; 
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_iaio_remove entered\n");

    if (!directory || !filename)
    {
        gossip_err("invalid (NULL) required arguments\n");
        return ret;
    }

    PINT_smcb_alloc(&smcb, PVFS_AIO_REMOVE, sizeof(struct PINT_client_sm),
                    client_op_state_get_machine,
                    client_state_machine_terminate,
                    pint_client_sm_context);
    if (smcb == NULL)
    {
        return -PVFS_ENOMEM;
    }
    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    
    PINT_init_sysint_credential(sm_p->cred_p, credential);
    PVFS_hint_copy(hints, &(sm_p->hints));
    sm_p->u.aio_remove.directory = directory;
    sm_p->u.aio_remove.filename = filename;
    sm_p->u.aio_remove.pdir = pdir;
    sm_p->u.aio_remove.dirflag = dirflag;   

    return PINT_client_state_machine_post(
        smcb, op_id, user_ptr);
}

PVFS_error PVFS_aio_remove(
    const char *directory,
    const char *filename,
    PVFS_object_ref *pdir,
    int dirflag,
    const PVFS_credential *credential,
    PVFS_hint hints)
{
    PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_aio_remove entered\n");

    ret = PVFS_iaio_remove(directory, filename, pdir, dirflag, credential, &op_id,
                          hints, NULL);

    if (ret)
    {
        PVFS_perror_gossip("PVFS_iaio_remove call", ret);
        error = ret;
    }
    else
    {
        ret = PVFS_sys_wait(op_id, "aio_remove", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_sys_wait call", ret);
            error = ret;
        }
    }

    PINT_sys_release(op_id);
    return error;
}

/*******************************************************************/

static PINT_sm_action remove_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove state: init\n");
    
    memset(&sm_p->u.aio_remove.parent_ref, 0, sizeof(PVFS_object_ref));
    memset(&sm_p->u.aio_remove.file_ref, 0, sizeof(PVFS_object_ref));
    memset(&sm_p->u.aio_remove.lookup_resp, 0, sizeof(PVFS_sysresp_lookup));
    memset(&sm_p->u.aio_remove.getattr_resp, 0, sizeof(PVFS_sysresp_getattr));
    memset(&sm_p->u.aio_remove.attr, 0, sizeof(PVFS_sys_attr));    

    if (!(sm_p->u.aio_remove.pdir))
    {
        js_p->error_code = REMOVE_PDIR_NULL;
    }
    else
    {
        if (sm_p->u.aio_remove.directory)
        {
            js_p->error_code = 0;
        }
        else
        {
            sm_p->u.aio_remove.parent_ref = *(sm_p->u.aio_remove.pdir);
            js_p->error_code = REMOVE_REF_FOUND;
        }
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_parent_ref_abs_lookup_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    PVFS_fs_id lookup_fs_id;
    char pvfs_path[PVFS_PATH_MAX];
    PVFS_object_ref parent;
    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove state: "
                 "parent_ref_abs_lookup_setup\n");

    ret = PVFS_util_resolve(sm_p->u.aio_remove.directory, &lookup_fs_id,
                            pvfs_path, PVFS_PATH_MAX);

	if ((ret == 0) && (pvfs_path[0] == '\0'))
	{
            strcpy(pvfs_path, "/");
	}

    if (ret < 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    parent.handle = 0;
    parent.fs_id = lookup_fs_id;

    ret = PINT_cached_config_get_root_handle(parent.fs_id, &(parent.handle));
    if (ret < 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    if (strcmp(pvfs_path, "/") == 0)
    {
        sm_p->u.aio_remove.parent_ref.handle = parent.handle;
        sm_p->u.aio_remove.parent_ref.fs_id = lookup_fs_id;
        js_p->error_code = REMOVE_REF_FOUND;
    }
    else
    {
        PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
        if (lookup_frame == NULL)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
        memset(lookup_frame, 0, sizeof(PINT_client_sm));

        char *path = ((pvfs_path[0] == '/') ? &pvfs_path[1] : pvfs_path);

        PINT_init_msgarray_params(lookup_frame, lookup_fs_id);
        PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
        lookup_frame->u.lookup.orig_pathname = path;
        lookup_frame->u.lookup.starting_refn = parent;
        lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_remove.lookup_resp);
        lookup_frame->u.lookup.follow_link = PVFS2_LOOKUP_LINK_FOLLOW;
        lookup_frame->u.lookup.current_context = 0;
        PVFS_hint_copy(sm_p->hints, &(lookup_frame->hints));
        PVFS_hint_add(&(lookup_frame->hints), PVFS_HINT_HANDLE_NAME,
                      sizeof(PVFS_handle), &(parent.handle));

        ret = initialize_context(&lookup_frame->u.lookup, path, parent);
        if (ret != 0)
        {
            gossip_err("aio-remove: failed to init context (path = %s)\n", path);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
                lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            sm_p->u.aio_remove.parent_ref.fs_id = lookup_fs_id;
            sm_p->u.aio_remove.parent_ref.handle = parent.handle;
            js_p->error_code = REMOVE_REF_FOUND;
        }
        else
        {
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);
            js_p->error_code = REMOVE_LOOKUP_SM;

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         path, llu(parent.handle));
        }
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_parent_ref_abs_lookup_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove state: parent_ref_abs_lookup_inspect"                  "\n");

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                 smcb, &frame_id, &js_p->error_code,
                                 &frames_remaining);
    js_p->error_code = lookup_frame->error_code;
    if (js_p->error_code < 0)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    sm_p->u.aio_remove.parent_ref = sm_p->u.aio_remove.lookup_resp.ref;
    free(lookup_frame);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_parent_ref_rel_lookup_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: parent_ref_rel_lookup_setup\n");

    sm_p->u.aio_remove.cur = (char *)sm_p->u.aio_remove.directory;
    sm_p->u.aio_remove.last = (char *)sm_p->u.aio_remove.directory;
    sm_p->u.aio_remove.start = (char *)sm_p->u.aio_remove.directory;

    /* loop over chars to find a complete path segment */
    /* that is no longer than PVFS_NAME_MAX chars */
    while (*(sm_p->u.aio_remove.cur))
    {
        /* find next path seperator / */
        /* cur either points to a slash */
        /* or the first char of the path */
        /* there must be at least one */
        /* so n either case increment it first */
        for(sm_p->u.aio_remove.cur++;
            (*sm_p->u.aio_remove.cur && *sm_p->u.aio_remove.cur != '/');
            sm_p->u.aio_remove.cur++);
        if (sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start > PVFS_NAME_MAX-1)
        {
            /* we over-shot the limit go back to last */
            sm_p->u.aio_remove.cur = sm_p->u.aio_remove.last;
            if (sm_p->u.aio_remove.cur == sm_p->u.aio_remove.start)
            {
                js_p->error_code = -PVFS_ENAMETOOLONG;
                return SM_ACTION_COMPLETE;
            }
            break;
        }
        else
        {
            /* set up to add the next path segment */
            sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;
        }
    }

    sm_p->u.aio_remove.current_seg_path = malloc(PVFS_NAME_MAX);
    if (sm_p->u.aio_remove.current_seg_path == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    memset(sm_p->u.aio_remove.current_seg_path, 0, PVFS_NAME_MAX);
    strncpy(sm_p->u.aio_remove.current_seg_path, sm_p->u.aio_remove.start,
            sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start + 2);
    sm_p->u.aio_remove.start = sm_p->u.aio_remove.cur;
    sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;

    PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
    if (lookup_frame == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(lookup_frame, 0, sizeof(PINT_client_sm));

    PINT_init_msgarray_params(lookup_frame, sm_p->u.aio_remove.pdir->fs_id);
    PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
    lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_remove.current_seg_path;
    lookup_frame->u.lookup.starting_refn = *(sm_p->u.aio_remove.pdir);
    lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_remove.lookup_resp);
    lookup_frame->u.lookup.follow_link = PVFS2_LOOKUP_LINK_FOLLOW;
    lookup_frame->u.lookup.current_context = 0;
    PVFS_hint_copy(sm_p->hints, &(lookup_frame->hints));
    PVFS_hint_add(&(lookup_frame->hints), PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle),
                  &(sm_p->u.aio_remove.pdir->handle));

    ret = initialize_context(&(lookup_frame->u.lookup),
                             sm_p->u.aio_remove.current_seg_path,
                             *(sm_p->u.aio_remove.pdir));
    if (ret != 0)
    {
        gossip_err("aio-remove: failed to init context (path = %s)\n",
                   sm_p->u.aio_remove.current_seg_path);
        free(lookup_frame);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    if (lookup_frame->u.lookup.current_context == 0 &&
        lookup_frame->u.lookup.contexts[0].total_segments == 0)
    {
        free(lookup_frame);
        free(sm_p->u.aio_remove.current_seg_path);
        sm_p->u.aio_remove.current_seg_path = NULL;
        sm_p->u.aio_remove.parent_ref.fs_id = sm_p->u.aio_remove.pdir->fs_id;
        sm_p->u.aio_remove.parent_ref.handle = sm_p->u.aio_remove.pdir->handle;
        js_p->error_code = REMOVE_REF_FOUND;
    }
    else
    {
        js_p->error_code = REMOVE_LOOKUP_SM;
        PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

        gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                     sm_p->u.aio_remove.current_seg_path,
                     llu(sm_p->u.aio_remove.pdir->handle));
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_parent_ref_rel_lookup_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: parent_ref_rel_lookup_inspect\n");

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                smcb, &frame_id,
                                &js_p->error_code, &frames_remaining);

    js_p->error_code = lookup_frame->error_code;
    if (js_p->error_code)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    if (*(sm_p->u.aio_remove.cur))
    {
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_remove.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_remove.cur++;
                (*sm_p->u.aio_remove.cur && *sm_p->u.aio_remove.cur != '/');
                 sm_p->u.aio_remove.cur++);
            if (sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_remove.cur = sm_p->u.aio_remove.last;
                if (sm_p->u.aio_remove.cur == sm_p->u.aio_remove.start)
                {
                    free(lookup_frame);
                    js_p->error_code = -PVFS_ENAMETOOLONG;
                    return SM_ACTION_COMPLETE;
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;
            }
        }

        memset(sm_p->u.aio_remove.current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(sm_p->u.aio_remove.current_seg_path, sm_p->u.aio_remove.start,
                sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start + 1);
        sm_p->u.aio_remove.start = sm_p->u.aio_remove.cur;
        sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;

        lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_remove.current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_remove.lookup_resp.ref;
        lookup_frame->u.lookup.follow_link = PVFS2_LOOKUP_LINK_FOLLOW;
        lookup_frame->u.lookup.current_context = 0;

        ret = initialize_context(&(lookup_frame->u.lookup),
                                 sm_p->u.aio_remove.current_seg_path,
                                 sm_p->u.aio_remove.lookup_resp.ref);
        if (ret != 0)
        {
            gossip_err("aio-remove: failed to init context (path = %s)\n",
                       sm_p->u.aio_remove.current_seg_path);
            free(lookup_frame);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            free(sm_p->u.aio_remove.current_seg_path);
            sm_p->u.aio_remove.current_seg_path = NULL;
            js_p->error_code = REMOVE_REF_FOUND;
            sm_p->u.aio_remove.parent_ref.handle = sm_p->u.aio_remove.lookup_resp.ref.handle;
            sm_p->u.aio_remove.parent_ref.fs_id = sm_p->u.aio_remove.pdir->fs_id;
        }
        else
        {
            js_p->error_code = REMOVE_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         sm_p->u.aio_remove.current_seg_path,
                         llu(sm_p->u.aio_remove.lookup_resp.ref.handle));
        }
    }
    else
    {
        js_p->error_code = REMOVE_REF_FOUND;
        sm_p->u.aio_remove.parent_ref = lookup_frame->u.lookup.lookup_resp->ref;
        free(lookup_frame);
        free(sm_p->u.aio_remove.current_seg_path);
        sm_p->u.aio_remove.current_seg_path = NULL;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_file_ref_rel_lookup_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;

    memset(&sm_p->u.aio_remove.lookup_resp, 0, sizeof(PVFS_sysresp_lookup));

    if (sm_p->u.aio_remove.current_seg_path)
    {
        free(sm_p->u.aio_remove.current_seg_path);
        sm_p->u.aio_remove.current_seg_path = NULL;
    }

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: file_ref_rel_lookup_setup\n");

    sm_p->u.aio_remove.cur = (char *)sm_p->u.aio_remove.filename;
    sm_p->u.aio_remove.last = (char *)sm_p->u.aio_remove.filename;
    sm_p->u.aio_remove.start = (char *)sm_p->u.aio_remove.filename;

    /* loop over chars to find a complete path segment */
    /* that is no longer than PVFS_NAME_MAX chars */
    while (*(sm_p->u.aio_remove.cur))
    {
        /* find next path seperator / */
        /* cur either points to a slash */
        /* or the first char of the path */
        /* there must be at least one */
        /* so n either case increment it first */
        for(sm_p->u.aio_remove.cur++;
            (*sm_p->u.aio_remove.cur && *sm_p->u.aio_remove.cur != '/');
            sm_p->u.aio_remove.cur++);
        if (sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start > PVFS_NAME_MAX-1)
        {
            /* we over-shot the limit go back to last */
            sm_p->u.aio_remove.cur = sm_p->u.aio_remove.last;
            if (sm_p->u.aio_remove.cur == sm_p->u.aio_remove.start)
            {
                js_p->error_code = -PVFS_ENAMETOOLONG;
                return SM_ACTION_COMPLETE;
            }
            break;
        }
        else
        {
            /* set up to add the next path segment */
            sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;
        }
    }

    sm_p->u.aio_remove.current_seg_path = malloc(PVFS_NAME_MAX);
    if (sm_p->u.aio_remove.current_seg_path == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    memset(sm_p->u.aio_remove.current_seg_path, 0, PVFS_NAME_MAX);
    strncpy(sm_p->u.aio_remove.current_seg_path, sm_p->u.aio_remove.start,
            sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start + 2);
    sm_p->u.aio_remove.start = sm_p->u.aio_remove.cur;
    sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;

    PINT_client_sm *lookup_frame = malloc(sizeof(PINT_client_sm));
    if (lookup_frame == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(lookup_frame, 0, sizeof(PINT_client_sm));

    PINT_init_msgarray_params(lookup_frame, sm_p->u.aio_remove.parent_ref.fs_id);
    PINT_init_sysint_credential(lookup_frame->cred_p, sm_p->cred_p);
    lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_remove.current_seg_path;
    lookup_frame->u.lookup.starting_refn = sm_p->u.aio_remove.parent_ref;
    lookup_frame->u.lookup.lookup_resp = &(sm_p->u.aio_remove.lookup_resp);
    lookup_frame->u.lookup.follow_link = PVFS2_LOOKUP_LINK_NO_FOLLOW;
    lookup_frame->u.lookup.current_context = 0;
    PVFS_hint_copy(sm_p->hints, &(lookup_frame->hints));
    PVFS_hint_add(&(lookup_frame->hints), PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle),
                  &(sm_p->u.aio_remove.parent_ref.handle));

    ret = initialize_context(&(lookup_frame->u.lookup),
                             sm_p->u.aio_remove.current_seg_path,
                             sm_p->u.aio_remove.parent_ref);
    if (ret != 0)
    {
        gossip_err("aio-remove: failed to init context (path = %s)\n",
                   sm_p->u.aio_remove.current_seg_path);
        free(lookup_frame);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    if (lookup_frame->u.lookup.current_context == 0 &&
        lookup_frame->u.lookup.contexts[0].total_segments == 0)
    {
        free(lookup_frame);
        free(sm_p->u.aio_remove.current_seg_path);
        sm_p->u.aio_remove.current_seg_path = NULL;
        sm_p->u.aio_remove.file_ref.fs_id = sm_p->u.aio_remove.parent_ref.fs_id;
        sm_p->u.aio_remove.file_ref.handle = sm_p->u.aio_remove.parent_ref.handle;
        js_p->error_code = REMOVE_REF_FOUND;
    }
    else
    {
        js_p->error_code = REMOVE_LOOKUP_SM;
        PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

        gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                     sm_p->u.aio_remove.current_seg_path,
                     llu(sm_p->u.aio_remove.parent_ref.handle));
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_file_ref_rel_lookup_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: file_ref_rel_lookup_inspect\n");

    struct PINT_client_sm *lookup_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                smcb, &frame_id,
                                &js_p->error_code, &frames_remaining);

    js_p->error_code = lookup_frame->error_code;
    if (js_p->error_code)
    {
        free(lookup_frame);
        return SM_ACTION_COMPLETE;
    }

    if (*(sm_p->u.aio_remove.cur))
    {
        /* loop over chars to find a complete path segment */
        /* that is no longer than PVFS_NAME_MAX chars */
        while(*(sm_p->u.aio_remove.cur))
        {
            /* find next path seperator / */
            /* cur either points to a slash */
            /* or the first char of the path */
            /* there must be at least one */
            /* so n either case increment it first */
            for(sm_p->u.aio_remove.cur++;
                (*sm_p->u.aio_remove.cur && *sm_p->u.aio_remove.cur != '/');
                 sm_p->u.aio_remove.cur++);
            if (sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start > PVFS_NAME_MAX-1)
            {
                /* we over-shot the limit go back to last */
                sm_p->u.aio_remove.cur = sm_p->u.aio_remove.last;
                if (sm_p->u.aio_remove.cur == sm_p->u.aio_remove.start)
                {
                    free(lookup_frame);
                    js_p->error_code = -PVFS_ENAMETOOLONG;
                    return SM_ACTION_COMPLETE;
                }
                break;
            }
            else
            {
                /* set up to add the next path segment */
                sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;
            }
        }

        memset(sm_p->u.aio_remove.current_seg_path, 0, PVFS_NAME_MAX);
        strncpy(sm_p->u.aio_remove.current_seg_path, sm_p->u.aio_remove.start,
                sm_p->u.aio_remove.cur - sm_p->u.aio_remove.start + 1);
        sm_p->u.aio_remove.start = sm_p->u.aio_remove.cur;
        sm_p->u.aio_remove.last = sm_p->u.aio_remove.cur;

        lookup_frame->u.lookup.orig_pathname = sm_p->u.aio_remove.current_seg_path;
        lookup_frame->u.lookup.starting_refn = sm_p->u.aio_remove.lookup_resp.ref;
        lookup_frame->u.lookup.follow_link = PVFS2_LOOKUP_LINK_NO_FOLLOW;
        lookup_frame->u.lookup.current_context = 0;

        ret = initialize_context(&(lookup_frame->u.lookup),
                                 sm_p->u.aio_remove.current_seg_path,
                                 sm_p->u.aio_remove.lookup_resp.ref);
        if (ret != 0)
        {
            gossip_err("aio-remove: failed to init context (path = %s)\n",
                       sm_p->u.aio_remove.current_seg_path);
            free(lookup_frame);
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        }

        if (lookup_frame->u.lookup.current_context == 0 &&
            lookup_frame->u.lookup.contexts[0].total_segments == 0)
        {
            free(lookup_frame);
            free(sm_p->u.aio_remove.current_seg_path);
            sm_p->u.aio_remove.current_seg_path = NULL;
            js_p->error_code = REMOVE_REF_FOUND;
            sm_p->u.aio_remove.file_ref.handle = sm_p->u.aio_remove.lookup_resp.ref.handle;
            sm_p->u.aio_remove.file_ref.fs_id = sm_p->u.aio_remove.parent_ref.fs_id;
        }
        else
        {
            js_p->error_code = REMOVE_LOOKUP_SM;
            PINT_sm_push_frame(smcb, 0, (void *)lookup_frame);

            gossip_debug(GOSSIP_CLIENT_DEBUG, "lookup got: %s (parent %llu)\n",
                         sm_p->u.aio_remove.current_seg_path,
                         llu(sm_p->u.aio_remove.lookup_resp.ref.handle));
        }
    }
    else
    {
        js_p->error_code = REMOVE_REF_FOUND;
        sm_p->u.aio_remove.file_ref = lookup_frame->u.lookup.lookup_resp->ref;
        free(lookup_frame);
        free(sm_p->u.aio_remove.current_seg_path);
        sm_p->u.aio_remove.current_seg_path = NULL;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_getattr_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: getattr_setup\n");
    
    if ((sm_p->u.aio_remove.file_ref.handle == PVFS_HANDLE_NULL) ||
        (sm_p->u.aio_remove.file_ref.fs_id == PVFS_FS_ID_NULL))
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    PINT_client_sm *getattr_frame = malloc(sizeof(PINT_client_sm));
    if (!getattr_frame)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }   
    memset(getattr_frame, 0, sizeof(PINT_client_sm));
    
    PINT_init_msgarray_params(getattr_frame, sm_p->u.aio_remove.file_ref.fs_id);
    PINT_init_sysint_credential(getattr_frame->cred_p, sm_p->cred_p);
    getattr_frame->error_code = 0;
    getattr_frame->object_ref = sm_p->u.aio_remove.file_ref;
    getattr_frame->u.getattr.getattr_resp_p = &(sm_p->u.aio_remove.getattr_resp);
    PVFS_hint_copy(sm_p->hints, &(getattr_frame->hints));
    PVFS_hint_add(&(getattr_frame->hints), PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle), &(sm_p->u.aio_remove.file_ref.handle));

    PINT_SM_GETATTR_STATE_FILL(
        getattr_frame->getattr,
        sm_p->u.aio_remove.file_ref,
        PVFS_util_sys_to_object_attr_mask(
            PVFS_ATTR_SYS_TYPE),
        PVFS_TYPE_NONE,
        0);

    PINT_sm_push_frame(smcb, 0, (void *)getattr_frame);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_getattr_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: getattr_inspect\n");

    struct PINT_client_sm *getattr_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                smcb, &frame_id,
                                &js_p->error_code, &frames_remaining);

    js_p->error_code = getattr_frame->error_code;
    if (js_p->error_code)
    {
        free(getattr_frame);
        return SM_ACTION_COMPLETE;
    }

    sm_p->u.aio_remove.attr = getattr_frame->getattr.attr;
    free(getattr_frame);
    
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_sm_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_rename: sm_setup\n");

    if ((sm_p->u.aio_remove.attr.objtype == PVFS_TYPE_DIRECTORY) &&
        !(sm_p->u.aio_remove.dirflag))
    {
        js_p->error_code = -PVFS_EISDIR;
        return SM_ACTION_COMPLETE;
    }
    else if ((sm_p->u.aio_remove.attr.objtype != PVFS_TYPE_DIRECTORY) &&
        sm_p->u.aio_remove.dirflag)
    {
        js_p->error_code = -PVFS_ENOTDIR;
        return SM_ACTION_COMPLETE;
    }

    /* setup the remove sys call */
    if ((sm_p->u.aio_remove.parent_ref.handle == PVFS_HANDLE_NULL) ||
        (sm_p->u.aio_remove.parent_ref.fs_id == PVFS_FS_ID_NULL))
    {
        gossip_err("invalid (NULL) required argument\n");
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    PINT_client_sm *remove_frame = malloc(sizeof(PINT_client_sm));
    if (!remove_frame)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(remove_frame, 0, sizeof(PINT_client_sm));

    PINT_init_msgarray_params(remove_frame, sm_p->u.aio_remove.parent_ref.fs_id);
    PINT_init_sysint_credential(remove_frame->cred_p, sm_p->cred_p);
    remove_frame->u.remove.object_name = (char *)sm_p->u.aio_remove.filename;
    remove_frame->parent_ref = sm_p->u.aio_remove.parent_ref;
    remove_frame->u.remove.stored_error_code = 0;
    PVFS_hint_copy(sm_p->hints, &(remove_frame->hints));
    PVFS_hint_add(&(remove_frame->hints), PVFS_HINT_HANDLE_NAME,
                  sizeof(PVFS_handle), &(sm_p->u.aio_remove.parent_ref.handle));

    gossip_debug(
        GOSSIP_CLIENT_DEBUG, "Trying to remove entry %s under %llu,%d\n", 
        sm_p->u.aio_remove.filename, llu(sm_p->u.aio_remove.parent_ref.handle),
        sm_p->u.aio_remove.parent_ref.fs_id);

    PINT_sm_push_frame(smcb, 0, (void *)remove_frame);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action remove_sm_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int frame_id, frames_remaining;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: sm_inspect\n");

    struct PINT_client_sm *remove_frame = (PINT_client_sm *)PINT_sm_pop_frame(
                                smcb, &frame_id,
                                &js_p->error_code, &frames_remaining);

    js_p->error_code = remove_frame->error_code;
    free(remove_frame);

    return SM_ACTION_COMPLETE;
}


static PINT_sm_action remove_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "aio_remove: cleanup\n");

    if (sm_p->u.aio_remove.current_seg_path)
        free(sm_p->u.aio_remove.current_seg_path);

    sm_p->error_code = js_p->error_code;

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
