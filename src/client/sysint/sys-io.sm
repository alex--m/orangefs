/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"

#include "pinode-helper.h"
#include "pint-dcache.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "pcache.h"
#include "PINT-reqproto-encode.h"

extern job_context_id pint_client_sm_context;

enum {
    IO_NO_DATA = 1,
    IO_DATAFILE_MSGPAIRS_COMPLETE = 2
};

/* state function prototypes */
static int io_object_getattr_setup_msgpair(PINT_client_sm *sm_p,
					   job_status_s *js_p);
static int io_object_getattr_failure(PINT_client_sm *sm_p,
				     job_status_s *js_p);
static int io_datafile_setup_msgpairs(PINT_client_sm *sm_p,
				      job_status_s *js_p);
static int io_datafile_post_msgpairs(PINT_client_sm *sm_p,
				     job_status_s *js_p);
static int io_datafile_complete_msgpairs(PINT_client_sm *sm_p,
					 job_status_s *js_p);
static int io_cleanup(PINT_client_sm *sm_p,
		      job_status_s *js_p);

/* completion function prototypes */
static int io_object_getattr_comp_fn(void *v_p,
				     struct PVFS_server_resp *resp_p,
				     int index);

/* other helper functions */
static int io_find_target_datafiles(PVFS_Request io_req,
				    PVFS_offset io_req_offset, 
				    PVFS_Dist *dist_p,
				    PVFS_handle *input_handle_array,
				    int input_handle_count,
				    PVFS_handle *output_handle_array, 
				    int *handle_count_out_p);

%%

machine pvfs2_client_io_sm(object_getattr_setup_msgpair,
			   object_getattr_xfer_msgpair,
			   object_getattr_failure,
			   datafile_setup_msgpairs,
			   datafile_post_msgpairs,
			   datafile_complete_msgpairs,
			   cleanup)
{
    state object_getattr_setup_msgpair {
	run io_object_getattr_setup_msgpair;
	default => object_getattr_xfer_msgpair;
    }
    state object_getattr_xfer_msgpair {
	jump pvfs2_client_getattr_pcache_sm;
	success => datafile_setup_msgpairs;
	default => object_getattr_failure;
    }
    state object_getattr_failure {
	run io_object_getattr_failure;
	default => cleanup;
    }

    state datafile_setup_msgpairs {
	run io_datafile_setup_msgpairs;
	default => datafile_post_msgpairs;
    }
    state datafile_post_msgpairs {
	run io_datafile_post_msgpairs;
	default => cleanup;
    }
    state datafile_complete_msgpairs {
	run io_datafile_complete_msgpairs;
	default => datafile_complete_msgpairs;
	IO_DATAFILE_MSGPAIRS_COMPLETE => cleanup;
    }

    state cleanup {
	run io_cleanup;
	default => cleanup;
    }
}

%%

/* PVFS_sys_io()
 */
int PVFS_sys_io2(PVFS_pinode_reference pinode_ref,
		 PVFS_Request          io_req,
		 PVFS_offset           io_req_offset,
		 void                 *buffer,
		 PVFS_size             buffer_size,
		 PVFS_credentials      credentials,
		 PVFS_sysresp_io      *resp_p,
		 enum PVFS_sys_io_type io_type)
{
    int ret;
    PINT_client_sm *sm_p;
    PVFS_error error;

    if (resp_p == NULL) {
	gossip_lerr("NULL resp pointer\n");
	return -PVFS_EINVAL;
    }

    if (io_type != PVFS_SYS_IO_READ && io_type != PVFS_SYS_IO_WRITE) {
	return -PVFS_EINVAL;
    }

    /* allocate and build PINT_client_sm structure */
    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL) return -PVFS_ENOMEM;

    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.io.object_ref    = pinode_ref;
    sm_p->u.io.io_type       = io_type;
    sm_p->u.io.io_req        = io_req;
    sm_p->u.io.io_req_offset = io_req_offset;
    sm_p->u.io.buffer        = buffer;
    sm_p->u.io.buffer_size   = buffer_size;
    sm_p->u.io.io_resp_p     = resp_p;

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_IO);
    assert(ret == 0);

    while (!sm_p->op_complete && ret == 0) {
	ret = PINT_client_state_machine_test();
    }
    assert(ret == 0);

    error = sm_p->error_code;

    free(sm_p);

    return error;
}

/*******************************************************************/

static int io_object_getattr_setup_msgpair(PINT_client_sm *sm_p,
					   job_status_s *js_p)
{
    uint32_t attrmask;

    gossip_debug(CLIENT_DEBUG,
		 "(%p) io state: io_object_getattr_setup_msgpair\n",
		 sm_p);

    /* we need datafile handles, distribution, and common attribs */
    attrmask = (PVFS_ATTR_META_DFILES |
		PVFS_ATTR_META_DIST |
		PVFS_ATTR_COMMON_ALL);

    PINT_SERVREQ_GETATTR_FILL(sm_p->msgpair.req,
			      *sm_p->cred_p,
			      sm_p->u.io.object_ref.fs_id,
			      sm_p->u.io.object_ref.handle,
			      attrmask);

    /* fill in msgpair structure components */
    sm_p->msgpair.fs_id = sm_p->u.io.object_ref.fs_id;
    sm_p->msgpair.handle = sm_p->u.io.object_ref.handle;
    sm_p->msgpair.comp_fn = io_object_getattr_comp_fn;

    /* drop through and jump to getattr_pcache state machine */
    return 1;
}

/* io_object_getattr_comp_fn()
 *
 * Called to copy data from getattr response into the io-specific portion of
 * the PINT_client_sm structure, so we can use the data after returning to
 * this state machine.
 *
 * Return value is returned in job status, so it affects the resulting state
 * coming back from the nested state machine.
 *
 * Part of me would like to not have to replicate this code in every instance
 * that we want to grab this data; this particular function was ripped from
 * the getattr state machine and then modified.  However, I'm not sure if
 * there is a good way to generalize this.
 *
 * Q: MAYBE WE SHOULD JUST PUT A COMMON PVFS_object_attr IN THE PINT_client_sm
 *    STRUCTURE AND USE THAT IN ALL CASES?  IT WOULD MAKE FOR AN UGLIER
 *    STRUCTURE BUT OVERALL CLEANER CODE I THINK. -- RobR
 *
 *    ACTUALLY, IF WE GOT THE PINODE CACHE STUFF WORKING WE COULD JUST RETURN
 *    A PINODE REFERENCE AND BE DONE WITH IT; THAT WOULD PROBABLY BE BEST.
 *
 * Returns 0 for metafiles, error for all the other types.
 */
static int io_object_getattr_comp_fn(void *v_p,
				     struct PVFS_server_resp *resp_p,
				     int index)
{
    PVFS_object_attr *r_attr_p;

    /* this is a little kludge to get around some struct definition
     * issues in the headers.  maybe fix later?
     */
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;
    
    /* sanity checks: this is a getattr response and has a valid
     * type field
     */
    assert(resp_p->op == PVFS_SERV_GETATTR);
    assert(resp_p->u.getattr.attr.mask & PVFS_ATTR_COMMON_TYPE);

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0) {
	return resp_p->status;
    }

    if (resp_p->u.getattr.attr.objtype != PVFS_TYPE_METAFILE) {
	/* invalid type - we only do I/O on files */
	return -PVFS_EINVAL;
    }

    r_attr_p = &resp_p->u.getattr.attr;

    /* sanity checks */
    assert(r_attr_p->mask & PVFS_ATTR_META_DIST);
    assert(r_attr_p->u.meta.dist_size > 0);
		
    gossip_debug(CLIENT_DEBUG,
		 "io_object_getattr_comp_fn: copying %d bytes of dist.\n",
		 r_attr_p->u.meta.dist_size);

    /* here we make a copy of the distribution information.
     *
     * KLUDGE: there is no copy function for distributions
     * right now, so we do this nasty thing.
     */

    sm_p->u.io.dist_p = (PVFS_Dist *) malloc(r_attr_p->u.meta.dist_size);
    if (sm_p->u.io.dist_p == NULL) {
	assert(0);
	return -PVFS_ENOMEM;
    }

    /* this encodes the previously decoded distribution into
     * our new space.
     */
    PINT_Dist_encode(sm_p->u.io.dist_p, r_attr_p->u.meta.dist);

    /* this does an in-place decoding of the distribution.  now
     * we have a decoded version where we want it.
     *
     * NOTE: we need to free this later.
     */
    PINT_Dist_decode(sm_p->u.io.dist_p, NULL);

    /* save the size too */
    sm_p->u.io.dist_size = r_attr_p->u.meta.dist_size;

    /* sanity checks */
    assert(r_attr_p->mask & PVFS_ATTR_META_DFILES);
    assert(r_attr_p->u.meta.dfile_count > 0);

    gossip_debug(CLIENT_DEBUG,
		 "io_object_getattr_comp_fn: %d datafiles.\n",
		 r_attr_p->u.meta.dfile_count);
		
    /* save the datafile handles prior to freeing up the
     * buffers we used for messages.  we could keep them around
     * i suppose, but we're not going to do that for now.  later
     * it is likely that this stuff will be stuck in the pcache
     * anyway, so we'll be able to just reference it from there.
     */
    sm_p->u.io.datafile_handles =
	(PVFS_handle *) malloc(r_attr_p->u.meta.dfile_count * sizeof(PVFS_handle));
    if (sm_p->u.io.datafile_handles == NULL) {
	assert(0);
    }
    sm_p->u.io.datafile_count = r_attr_p->u.meta.dfile_count;
    memcpy(sm_p->u.io.datafile_handles,
	   r_attr_p->u.meta.dfile_array,
	   r_attr_p->u.meta.dfile_count * sizeof(PVFS_handle));

    return 0;
} /* io_object_getattr_comp_fn */

/* io_datafile_setup_io()
 *
 * Sets up msgpairs to send I/O requests to servers holding datafiles
 * that (might) have data for us (unless we hit EOF).
 *
 * This function swaps the original datafile_handles array for a new
 * array that just has datafiles that we think will have our data.  It
 * updates datafile_count appropriately as well.
 *
 * We use sm_p->msgarray for this purpose.
 *
 * NOTE: we could combine this with the post_msgpairs state, but this one
 *       has gotten pretty big already, so let's not.
 */
static int io_datafile_setup_msgpairs(PINT_client_sm *sm_p,
				      job_status_s *js_p)
{
    int i, ret;
    int target_datafile_count;
    PVFS_handle *target_datafile_array;

    gossip_debug(CLIENT_DEBUG,
		 "(%p) io state: io_datafile_setup_io\n",
		 sm_p);

    /* NOTE: i have no idea what this function does.  presumably it has
     * some important side-effects, since it doesn't have an output
     * parameter.
     *
     * TODO: make the Dist interface make sense.
     */
    ret = PINT_Dist_lookup(sm_p->u.io.dist_p);
    if (ret != 0) {
	assert(0);
    }

    target_datafile_array =
	(PVFS_handle *) malloc(sm_p->u.io.datafile_count * sizeof(PVFS_handle));
    if (target_datafile_array == NULL) {
	assert(0);
    }

    ret = io_find_target_datafiles(sm_p->u.io.io_req,
				   sm_p->u.io.io_req_offset,
				   sm_p->u.io.dist_p,
				   sm_p->u.io.datafile_handles,
				   sm_p->u.io.datafile_count,
				   target_datafile_array,
				   &target_datafile_count);
    if (ret != 0) {
	assert(0);
    }

    if (target_datafile_count == 0) {
	/* no data?  ok... */
	/* TODO: catch this earlier or something. */
	js_p->error_code = IO_NO_DATA;
	return 1;
    }

    gossip_debug(CLIENT_DEBUG,
		 "  datafile_setup_msgpairs: %d datafiles might have data\n",
		 sm_p->u.io.datafile_count);

    sm_p->msgarray = (PINT_client_sm_msgpair_state *)
	malloc(sm_p->u.io.datafile_count * sizeof(PINT_client_sm_msgpair_state *));
    if (sm_p->msgarray == 0) {
	assert(0);
    }

    for (i=0; i < target_datafile_count; i++) {
	int orig_index;
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

	gossip_debug(CLIENT_DEBUG,
		     "  sending I/O request for 0x%08Lx\n",
		     target_datafile_array[i]);

	/* find the original index for the handle */
	for (orig_index = 0; orig_index < sm_p->u.io.datafile_count; orig_index++)
	{
	    if (target_datafile_array[i] == sm_p->u.io.datafile_handles[orig_index])
		break;
	}
	assert(orig_index < sm_p->u.io.datafile_count); /* sanity check */

	/* fill in I/O request */
	PINT_SERVREQ_IO_FILL(msg_p->req,
			     *sm_p->cred_p,
			     sm_p->u.io.object_ref.fs_id,
			     target_datafile_array[i],
			     sm_p->u.io.io_type,
			     FLOWPROTO_ANY,
			     orig_index,
			     target_datafile_count,
			     sm_p->u.io.dist_p,
			     sm_p->u.io.io_req,
			     sm_p->u.io.io_req_offset);

	/* fill in msgpair structure components */
	msg_p->fs_id   = sm_p->u.io.object_ref.fs_id;
	msg_p->handle  = sm_p->u.io.datafile_handles[i];
	msg_p->comp_fn = NULL;
    }

    /*
     * Swap the new list in for the old one, freeing the old list.
     */
    free(sm_p->u.io.datafile_handles);
    sm_p->u.io.datafile_handles = target_datafile_array;
    sm_p->u.io.datafile_count   = target_datafile_count;
    

    return 1;
}

/* io_find_target_datafiles()
 *
 * determines what subset of the datafiles actually contain data that we
 * are interested in for this request
 *
 * returns 0 on success, -pvfs_error on failure
 *
 * TODO: make this step more efficient
 *
 * NOTE: this was ripped out of io.c and then modified.
 */
static int io_find_target_datafiles(PVFS_Request io_req,
				    PVFS_offset io_req_offset, 
				    PVFS_Dist *dist_p,
				    PVFS_handle *input_handle_array,
				    int input_handle_count,
				    PVFS_handle *output_handle_array, 
				    int *handle_count_out_p)
{
    int i, ret;
    struct PINT_Request_state *req_state = NULL;
    PINT_Request_file_data tmp_file_data;
    PINT_Request_result tmp_result;

    /* initialize output handle count */
    *handle_count_out_p = 0;

    req_state = PINT_New_request_state(io_req);
    if(!req_state)
    {
	return -PVFS_ENOMEM;
    }

    for(i=0; i < input_handle_count; i++)
    {
	/* NOTE: we don't have to give an accurate file size here,
	 * as long as we set the extend flag to tell the I/O req
	 * processor to continue past eof if needed
	 */
	tmp_file_data.fsize = 0;  
	tmp_file_data.dist = dist_p;
	tmp_file_data.iod_num = i;
	tmp_file_data.iod_count = input_handle_count;
	tmp_file_data.extend_flag = 1;

	/* if a file datatype offset was specified, go ahead and skip ahead 
	 * before calculating
	 */
	if(io_req_offset)
	{
	    memset(&tmp_result, 0, sizeof(PINT_Request_result));
	    tmp_result.bytemax = io_req_offset;
	    tmp_result.segmax = INT_MAX;
#if 0
	    ret = PINT_Process_request(req_state, &tmp_file_data,
		&segmax, NULL, NULL, &offset, &bytemax,
		&eof_flag, PINT_CKSIZE_LOGICAL_SKIP);
#endif
	    ret = PINT_Process_request(req_state,
				       NULL,
				       &tmp_file_data,
				       &tmp_result,
				       PINT_CKSIZE_LOGICAL_SKIP);
	    if (ret != 0)
	    {
		assert(ret < 0); /* parameter range check */

		PINT_Free_request_state(req_state);
		return ret;
	    }
	    if (PINT_REQUEST_STATE_OFFSET(req_state) == -1)
	    {
		/* no data here */
		continue;
	    }
	}

	memset(&tmp_result, 0, sizeof(PINT_Request_result));
	tmp_result.bytemax = 1;
	tmp_result.segmax = 1;
#if 0
	ret = PINT_Process_request(req_state, &tmp_file_data,
	    &segmax, NULL, NULL, &offset, &bytemax, &eof_flag,
	    PINT_CKSIZE);
#endif
	ret = PINT_Process_request(req_state,
				   NULL,
				   &tmp_file_data,
				   &tmp_result,
				   PINT_CKSIZE);
	if (ret != 0)
	{
	    assert(ret < 0); /* parameter range check */
	    PINT_Free_request_state(req_state);
	    return(ret);
	}

	/* did we find that any data belongs to this handle? */
	if (tmp_result.bytes != 0)
	{
	    assert(tmp_result.bytes > 0); /* parameter range checking */

	    gossip_debug(CLIENT_DEBUG,
			 "io_find_target_dfiles: datafile %d has %Ld bytes.\n",
			 i,
			 tmp_result.bytes);

	    output_handle_array[*handle_count_out_p] = input_handle_array[i]; 
	    (*handle_count_out_p)++;
	}
    }
    PINT_Free_request_state(req_state);

    return 0;
} /* io_find_target_datafiles */


/* io_datafile_post_msgpairs()
 *
 * This is basically a copy of msgpairarray.c:msgpairarray_post().
 * We need to handle the rest of the process somewhat differently though,
 * so we're going to have our own versions here.
 *
 * We use the msgarray to keep up with the initial send/recv pairs.
 *
 */
static int io_datafile_post_msgpairs(PINT_client_sm *sm_p,
				     job_status_s *js_p)
{
    int ret, i;

    gossip_debug(CLIENT_DEBUG,
		 "io_datafile_post_msgpairs state: post (%d message(s))\n",
		 sm_p->msgarray_count);

    assert(sm_p->msgarray_count > 0); /* sanity check */

    /* we don't know what this is set to prior to this function,
     * so we reset it here.
     */
    js_p->error_code = 0;

    /* set number of operations that must complete.
     *
     * NOTE: we're using the comp_ct in the first msgarray
     * entry to keep up with the count for the entire array.
     */
    sm_p->msgarray[0].comp_ct = 2 * sm_p->msgarray_count;

    /* run through array of msgpairarray to kick off */
    for (i=0; i < sm_p->msgarray_count; i++) {
	PVFS_msg_tag_t session_tag;
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

	/* determine server address from fs_id/handle pair.
	 * this is needed prior to encoding.
	 */
	ret = PINT_bucket_map_to_server(&msg_p->svr_addr,
					msg_p->handle,
					msg_p->fs_id);
	if (ret != 0) {
	    gossip_lerr("bucket map to server failed; probably invalid svr_addr\n");
	    assert(ret < 0); /* return value range check */
	    assert(0); /* placeholder until we have real error handling */
	}

	/* encode request. fills in encoded_req.
	 */
	ret = PINT_encode(&msg_p->req,
			  PINT_ENCODE_REQ,
			  &msg_p->encoded_req,
			  msg_p->svr_addr,
			  PINT_CLIENT_ENC_TYPE);
	if (ret != 0) {
	    gossip_lerr("pint_encode failed\n");
	    assert(ret < 0); /* return value range check */
	    assert(0); /* placeholder until we have real error handling */
	}

	/* calculate maximum response message size and allocate space.
	 * fills in max_resp_sz, encoded_resp_p
	 */
	msg_p->max_resp_sz = PINT_encode_calc_max_size(PINT_ENCODE_RESP,
						       msg_p->req.op,
						       PINT_CLIENT_ENC_TYPE);
	msg_p->encoded_resp_p = BMI_memalloc(msg_p->svr_addr,
					     msg_p->max_resp_sz,
					     BMI_RECV);
	if (msg_p->encoded_resp_p == NULL) {
	    assert(0);
	}

	/* get session tag to associate with send and receive.
	 * session tag is kept as a local variable.
	 */
	session_tag = get_next_session_tag();

	/* post receive of response; job_id stored in recv_id */
	ret = job_bmi_recv(msg_p->svr_addr,
			   msg_p->encoded_resp_p,
			   msg_p->max_resp_sz,
			   session_tag,
			   BMI_PRE_ALLOC,
			   sm_p,
			   &msg_p->recv_status,
			   &msg_p->recv_id,
			   pint_client_sm_context);
	if (ret < 0) {
	    gossip_lerr("post of receive failed\n");
	    assert(0);
	}
	else if (ret == 1) {
	    /* it shouldn't be possible for the receive to complete before
	     * we send the request.
	     */
	    assert(0); /* sanity check */
	}
	assert(ret == 0); /* return value range check */

	/* post send of request; job_id stored in send_id */
	ret = job_bmi_send_list(msg_p->encoded_req.dest,
				msg_p->encoded_req.buffer_list,
				msg_p->encoded_req.size_list,
				msg_p->encoded_req.list_count,
				msg_p->encoded_req.total_size,
				session_tag,
				msg_p->encoded_req.buffer_type,
				1,
				sm_p,
				&msg_p->send_status,
				&msg_p->send_id,
				pint_client_sm_context);
	if (ret < 0) {
	    gossip_lerr("post of send failed\n");
	    assert(0);
	}
	else if (ret == 1) {
	    /* send completed immediately; decrement the completion counter */
	    gossip_debug(CLIENT_DEBUG,
			 "  io_datafile_post_msgpairs: send completed immediately.\n");

	    /* 0 is the valid "completed job id" value, according to Phil */
	    msg_p->send_id = 0;

	    /* TODO: CHECK THE STATUS!!! */
	    assert(msg_p->send_status.error_code == 0);

	    /* decrement our count, since send is already done.
	     *
	     * recall we're using the comp_ct in the first array
	     * element to keep up with our count for the entire
	     * array.
	     */
	    sm_p->msgarray[0].comp_ct--;
	}
	assert(ret == 0 || ret == 1); /* return value range check */
    }

    return 0;
}

/* io_datafile_complete_msgpairs()
 *
 * This started off as a copy of msgpairarray.c:msgpairarray_complete(),
 * but we need to post flow operations as the bmi operations complete,
 * so we have some additional work to do.
 */
static int io_datafile_complete_msgpairs(PINT_client_sm *sm_p,
					 job_status_s *js_p)
{
    int i;
    int matched_job = 0;

    gossip_debug(CLIENT_DEBUG, "msgpairarray state: complete\n");

    /* match operation with something in the msgpair array */
    for (i=0; i < sm_p->msgarray_count; i++) {
	PINT_client_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

	if (msg_p->recv_id == js_p->id) {
	    matched_job = 1;

	    msg_p->recv_id     = 0;
	    msg_p->recv_status = *js_p;
	    break;
	}
	else if (msg_p->send_id == js_p->id) {
	    matched_job = 1;

	    msg_p->send_id     = 0;
	    msg_p->send_status = *js_p;
	    break;
	}
    }
    assert(matched_job == 1); /* sanity check */

    /* decrement comp_ct until all operations have completed.
     *
     * recall we're using the comp_ct in the first array element...
     */
    if (--sm_p->msgarray[0].comp_ct > 0) {
	return 0;
    }
    else {
	assert(sm_p->msgarray[0].comp_ct == 0); /* sanity check */
	js_p->error_code = IO_DATAFILE_MSGPAIRS_COMPLETE;
	gossip_debug(CLIENT_DEBUG, "  msgpairarray: all operations complete\n");

	return 1;
    }
}

static int io_object_getattr_failure(PINT_client_sm *sm_p,
				     job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
		 "(%p) io state: io_object_getattr_failure\n",
		 sm_p);
    assert(0);

    return 1;
}

static int io_cleanup(PINT_client_sm *sm_p,
		      job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
		 "(%p) io state: cleanup\n",
		 sm_p);

    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
