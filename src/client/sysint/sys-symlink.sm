/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"
#include "shared-state-methods.h"

extern job_context_id pint_client_sm_context;

static int symlink_init(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int symlink_dspace_create_setup_msgpair(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int symlink_dspace_create_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int symlink_crdirent_setup_msgpair(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int symlink_crdirent_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int symlink_setattr_setup_msgpair(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int symlink_setattr_failure(
    PINT_client_sm *sm_p, job_status_s *js_p);
static int symlink_cleanup(
    PINT_client_sm *sm_p, job_status_s *js_p);

/* completion function prototypes */
static int symlink_create_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);
static int symlink_crdirent_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);
static int symlink_setattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);

%%

machine pvfs2_client_symlink_sm(init,
                                symlink_parent_getattr_setup_msgpair,
                                symlink_parent_getattr_xfer_msgpair,
                                symlink_parent_getattr_failure,
                                dspace_create_setup_msgpair,
                                dspace_create_xfer_msgpair,
                                dspace_create_failure,
                                crdirent_setup_msgpair,
                                crdirent_xfer_msgpair,
                                crdirent_failure,
                                symlink_setattr_setup_msgpair,
                                symlink_setattr_xfer_msgpair,
                                symlink_setattr_failure,
                                cleanup)
{
    state init
    {
        run symlink_init;
        default => symlink_parent_getattr_setup_msgpair;
    }

    state symlink_parent_getattr_setup_msgpair
    {
        run PINT_sm_common_parent_getattr_setup_msgpair;
        success => symlink_parent_getattr_xfer_msgpair;
        default => symlink_parent_getattr_failure;
    }

    state symlink_parent_getattr_xfer_msgpair
    {
        jump pvfs2_client_getattr_acache_sm;
        success => dspace_create_setup_msgpair;
        default => symlink_parent_getattr_failure;
    }

    state symlink_parent_getattr_failure
    {
        run PINT_sm_common_parent_getattr_failure;
        default => cleanup;
    }

    state dspace_create_setup_msgpair
    {
        run symlink_dspace_create_setup_msgpair;
        success => dspace_create_xfer_msgpair;
        default => dspace_create_failure;
    }

    state dspace_create_xfer_msgpair
    {
        jump pvfs2_client_msgpair_sm;
        success => crdirent_setup_msgpair;
        default => dspace_create_failure;
    }

    state dspace_create_failure
    {
        run symlink_dspace_create_failure;
        default => cleanup;
    }

    state crdirent_setup_msgpair
    {
        run symlink_crdirent_setup_msgpair;
        success => crdirent_xfer_msgpair;
        default => crdirent_failure;
    }

    state crdirent_xfer_msgpair
    {
        jump pvfs2_client_msgpair_sm;
        success => symlink_setattr_setup_msgpair;
        default => crdirent_failure;
    }

    state crdirent_failure
    {
        run symlink_crdirent_failure;
        default => cleanup;
    }

    state symlink_setattr_setup_msgpair
    {
        run symlink_setattr_setup_msgpair;
        success => symlink_setattr_xfer_msgpair;
        default => cleanup;
    }

    state symlink_setattr_xfer_msgpair
    {
        jump pvfs2_client_msgpair_sm;
        success => cleanup;
        default => symlink_setattr_failure;
    }

    state symlink_setattr_failure
    {
        run symlink_setattr_failure;
        default => cleanup;
    }

    state cleanup
    {
        run symlink_cleanup;
        default => terminate;
    }
}

%%

int PVFS_sys_symlink(
    char *entry_name,
    PVFS_object_ref parent_ref,
    char *target,
    PVFS_sys_attr attr,
    PVFS_credentials credentials,
    PVFS_sysresp_symlink *resp)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_symlink entered\n");

    if ((entry_name == NULL) || (resp == NULL) || (target == NULL))
    {
        return ret;
    }

    if (((strlen(entry_name) + 1) > PVFS_REQ_LIMIT_SEGMENT_BYTES) ||
        ((strlen(target) + 1) > PVFS_REQ_LIMIT_SEGMENT_BYTES))
    {
        return -PVFS_ENAMETOOLONG;
    }

    if ((attr.mask & PVFS_ATTR_SYS_ALL_SETABLE) !=
        PVFS_ATTR_SYS_ALL_SETABLE)
    {
        gossip_lerr("Error: Attribute sanity check failed\n");
        return ret;
    }

    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.sym.link_name = entry_name;
    sm_p->u.sym.link_target = target;
    sm_p->parent_ref = parent_ref;
    sm_p->u.sym.sym_resp = resp;
    sm_p->u.sym.sys_attr = &attr;

    gossip_debug(
        GOSSIP_CLIENT_DEBUG, "Symlinking %s under parent handle %Lu "
        "on fs %d to %s\n", entry_name, Lu(parent_ref.handle),
        parent_ref.fs_id, target);

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_SYMLINK);
    if (ret)
    {
	gossip_lerr("Error: PINT_client_state_machine_post() failure.\n");
        free(sm_p);
        return ret;
    }

    while (!sm_p->op_complete && (ret == 0))
    {
	gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_symlink calling "
                     "PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }

    if (ret)
    {
	gossip_lerr("Error: PINT_client_state_machine_test() failure.\n");
	free(sm_p);
	return(ret);
    }

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_symlink completed\n");

    error = sm_p->error_code;

    free(sm_p);
    return error;
}

/****************************************************************/

static int symlink_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "symlink state: init\n");

    assert(js_p->error_code == 0);
    return 1;
}

static int symlink_create_comp_fn(void *v_p,
                                  struct PVFS_server_resp *resp_p,
                                  int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "symlink_create_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CREATE);

    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    /* otherwise, just stash the newly symlinkd meta handle */
    sm_p->u.sym.symlink_handle = resp_p->u.create.handle;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "*** Got newly created symlink "
                 "handle %Lu\n", Lu(sm_p->u.sym.symlink_handle));

    return 0;
}

/* 
   NOTE: this function only does a sanity check and doesn't
   need to be called.  Set the completion function to NULL
   when setting up the crdirent msgpair to avoid this
*/
static int symlink_crdirent_comp_fn(void *v_p,
                                   struct PVFS_server_resp *resp_p,
                                   int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "symlink_crdirent_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CRDIRENT);

    if (resp_p->status != 0)
    {
	return resp_p->status;
    }
    return 0;
}

/* 
   NOTE: this function only does a sanity check and doesn't
   need to be called.  Set the completion function to NULL
   when setting up the setattr msgpair to avoid this
*/
static int symlink_setattr_comp_fn(void *v_p,
                                  struct PVFS_server_resp *resp_p,
                                  int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "symlink_setattr_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_SETATTR);

    if (resp_p->status != 0)
    {
	return resp_p->status;
    }
    return 0;
}

static int symlink_dspace_create_setup_msgpair(PINT_client_sm *sm_p,
                                               job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;
    PVFS_handle_extent_array meta_handle_extent_array;
    PINT_client_sm_msgpair_state *msg_p = NULL;
    struct server_configuration_s *server_config = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "symlink state: "
                 "dspace_create_setup_msgpair\n");

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG," create: posting create req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    server_config = PINT_get_server_config_struct();
    ret = PINT_bucket_get_next_meta(
        server_config, sm_p->parent_ref.fs_id,
        &msg_p->svr_addr, &meta_handle_extent_array);
    PINT_put_server_config_struct(server_config);

    if (ret < 0)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
        return 1;
    }

    PINT_SERVREQ_CREATE_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->parent_ref.fs_id,
        PVFS_TYPE_SYMLINK,
        meta_handle_extent_array);

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle = meta_handle_extent_array.extent_array[0].first;
    msg_p->comp_fn = symlink_create_comp_fn;

    return 1;
}

static int symlink_dspace_create_failure(PINT_client_sm *sm_p,
                                         job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "symlink state: dspace_create_failure\n");
    return 1;
}

static int symlink_crdirent_setup_msgpair(PINT_client_sm *sm_p,
					 job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "symlink state: crdirent_setup_msgpair\n");

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG," symlink: posting crdirent req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    PINT_SERVREQ_CRDIRENT_FILL(msg_p->req,
                               *sm_p->cred_p,
                               sm_p->u.sym.link_name,
                               sm_p->u.sym.symlink_handle,
                               sm_p->parent_ref.handle,
                               sm_p->parent_ref.fs_id);

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle = sm_p->u.sym.symlink_handle;
    msg_p->comp_fn = symlink_crdirent_comp_fn;

    ret = PINT_bucket_map_to_server(&msg_p->svr_addr,
                                    sm_p->parent_ref.handle,
                                    sm_p->parent_ref.fs_id);
    if (ret < 0)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
    return 1;
}

static int symlink_crdirent_failure(PINT_client_sm *sm_p,
				   job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "symlink state: crdirent_failure\n");
    return 1;
}

static int symlink_setattr_setup_msgpair(PINT_client_sm *sm_p,
                                        job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "symlink state: setattr_setup_msgpair\n");

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG," symlink: posting setattr req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    PINT_SERVREQ_SETATTR_FILL(msg_p->req,
                              *sm_p->cred_p,
                              sm_p->parent_ref.fs_id,
                              sm_p->u.sym.symlink_handle,
                              PVFS_TYPE_SYMLINK,
                              *sm_p->u.sym.sys_attr,
                              (PVFS_ATTR_COMMON_TYPE | PVFS_ATTR_SYMLNK_ALL));

    /* fill in symlink specific attributes */
    msg_p->req.u.setattr.attr.u.sym.target_path =
        sm_p->u.sym.link_target;

    /* NOTE: path len always includes null terminator */
    msg_p->req.u.setattr.attr.u.sym.target_path_len =
        strlen(sm_p->u.sym.link_target) + 1;

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->parent_ref.fs_id;
    msg_p->handle = sm_p->u.sym.symlink_handle;
    msg_p->comp_fn = symlink_setattr_comp_fn;

    ret = PINT_bucket_map_to_server(&msg_p->svr_addr,
                                    msg_p->handle,
                                    msg_p->fs_id);
    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
    return 1;
}

static int symlink_setattr_failure(PINT_client_sm *sm_p,
                                  job_status_s *js_p)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "symlink state: setattr_failure\n");
    return 1;
}

static int symlink_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p)
{
    PVFS_object_ref symlink_ref;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "symlink state: cleanup\n");

    sm_p->error_code = js_p->error_code;

    symlink_ref.handle = sm_p->u.sym.symlink_handle;
    symlink_ref.fs_id = sm_p->parent_ref.fs_id;

    /* fill in outgoing response fields */
    sm_p->u.sym.sym_resp->ref = symlink_ref;

    if (sm_p->msgarray)
    {
        free(sm_p->msgarray);
    }

    sm_p->op_complete = 1;
    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
