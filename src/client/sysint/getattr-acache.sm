/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_getattr_acache_sm
 *
 * The purpose of this state machine is to obtain simple attributes for an
 * object.  These attributes could come from a local cache (the acache)
 * or be obtained from a remote server.
 *
 * This state machine is *not* appropriate for use, in itself, as a getattr
 * replacement.  This is mostly because it doesn't handle returning datafile
 * handles or grabbing sizes of objects.  That's ok; we only need that stuff
 * in a couple of specific cases, and those will be handled elsewhere.
 *
 * This state machine uses the msgpair structure in the PINT_client_sm
 * structure in order to perform the message passing.  It assumes that this
 * has been previously set up by the state machine above this one.  In
 * particular the following fields of the msgpair structure must be filled in:
 * - req (unencoded getattr request)
 * - fs_id
 * - handle
 * - comp_fn - called to pull attributes out of decoded response and store
 *   them in the appropriate place for the state machine jumping to this one
 *   (e.g. copies datafile handles out in the remove case)
 *
 * This state machine in turns jumps to the pvfs2_msgpairarray_sm 
 * to perform * messaging, if necessary.
 *
 * NOTE: the comp_fn can cause a non-zero error_code to be passed back up from
 *       the msgpair state machine and through this state machine back to the
 *       one that jumped to here.  so be aware!
 *
 * TODO: if we fail to get attributes on something, we should try to ensure
 *       that the dcache is cleared of any entries pertaining to that object.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "pvfs2-util.h"

#include "pint-servreq.h"
#include "acache.h"
#include "PINT-reqproto-encode.h"

enum
{
    GETATTR_ACACHE_MISS = 1
};

static int getattr_acache_lookup(
    PINT_client_sm *sm_p, job_status_s *js_p);

%%

nested machine pvfs2_client_getattr_acache_sm(lookup,
					      xfer_msgpair)
{
    state lookup
    {
        run getattr_acache_lookup;
        success => return;
        GETATTR_ACACHE_MISS => xfer_msgpair;
        default => return;
    }

    state xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        default => return;
    }
}

%%


/* The idea is to check acache to see if we have an entry.  if so, set
 * up a fake, decoded response structure with the results so that we
 * can then call the comp_fn to copy data out of the response and into
 * the PINT_client_sm structure.
 */
static int getattr_acache_lookup(PINT_client_sm *sm_p,
				 job_status_s *js_p)
{
    uint32_t trimmed_mask = 0;
    struct PVFS_server_resp fake_resp;
    int status = 0;
    PVFS_object_ref object_ref;

    assert(sm_p->pinode == NULL);
    js_p->error_code = 0;

    object_ref.handle = sm_p->msgpair.handle;
    object_ref.fs_id = sm_p->msgpair.fs_id;

    assert(object_ref.handle != PVFS_HANDLE_NULL);
    assert(object_ref.fs_id != PVFS_FS_ID_NULL);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "getattr_acache state: lookup "
                 "on %Lu,%d\n", Lu(object_ref.handle),
                 object_ref.fs_id);

    /* point msgarray to the statically allocated msgpair */
    if (sm_p->msgarray != &(sm_p->msgpair))
    {
	    free(sm_p->msgarray);
    }
    sm_p->msgarray = &(sm_p->msgpair);
    sm_p->msgarray_count = 1;

    sm_p->pinode = PINT_acache_lookup(object_ref, &status);
    if (sm_p->pinode)
    {
        /*
          make sure pinode is not expired, and that it has all
          attribute info fields requested;

          NOTE that the req attrmask has been tampered with by
          sys-getattr.sm.
        */
        if (status == PINODE_STATUS_VALID)
        {
            /*
              the trimmed mask is used for making sure that we're only
              checking attr bits that make sense for the object type
              since the caller may have requested all attributes in
              the case where it doesn't know what type of object we're
              doing the getattr against.
            */
            trimmed_mask = sm_p->msgpair.req.u.getattr.attrmask;
            if (sm_p->pinode->attr.objtype == PVFS_TYPE_METAFILE)
            {
                /*
                  if a size was requested, we also need to match
                  the data size related bits when checking attrs;

                  PVFS_ATTR_DATA_SIZE was specially added by
                  sys-getattr.sm setup msgpair if size is requested.
                */
                if (trimmed_mask & PVFS_ATTR_DATA_SIZE)
                {
                    trimmed_mask &= (PVFS_ATTR_META_ALL |
                                     PVFS_ATTR_DATA_SIZE |
                                     PVFS_ATTR_COMMON_ALL);
                }
                else
                {
                    trimmed_mask &= (PVFS_ATTR_META_ALL |
                                     PVFS_ATTR_COMMON_ALL);
                }

                if (trimmed_mask == sm_p->pinode->attr.mask)
                {
                    goto cache_hit;
                }
            }
            else if (sm_p->pinode->attr.objtype == PVFS_TYPE_SYMLINK)
            {
                trimmed_mask &= (PVFS_ATTR_SYMLNK_ALL | PVFS_ATTR_COMMON_ALL);
                if (trimmed_mask == sm_p->pinode->attr.mask)
                {
                    goto cache_hit;
                }
            }
            else if (sm_p->pinode->attr.objtype == PVFS_TYPE_DIRECTORY)
            {
                goto cache_hit;
            }

            /*
              normally, if we get here, we've got a cache miss.
              setattr is an exception as it now does write-through
              acache updates.  (i.e. it's a hit in invalid cases
              because it'll be updated properly on success; flushed on
              failure)
            */
            if (sm_p->op != PVFS_SYS_SETATTR)
            {
                goto cache_miss;
            }

          cache_hit:
            gossip_debug(GOSSIP_ACACHE_DEBUG, "acache: acache hit "
                         "[%Lu]\n", Lu(object_ref.handle));

            /* build a fake response for completion */
            fake_resp.op = PVFS_SERV_GETATTR;
            fake_resp.status = 0;

            /*
              skip the deep fill (i.e. copy) of attributes on cache
              hit.  by setting the acache_hit flag, caller state
              machine won't try to read those attributes out of this
              faked response in their getattr completion functions.
              also, the caller MUST call PINT_acache_release or
              PINT_acache_release_refn on acache hit.
            */
            sm_p->acache_hit = 1;
            sm_p->msgpair.comp_fn(sm_p, &fake_resp, 0);
            return 1;
        }
      cache_miss:
        /*
          to avoid having an entry in the cache that doesn't exactly
          match what the caller asked for, in this case invalidate the
          entry; note invalidate implies an internal acache release
        */
        gossip_debug(GOSSIP_ACACHE_DEBUG, "acache: invalid acache "
                     "miss [%Lu]\n",Lu(object_ref.handle));
        sm_p->acache_hit = 0;
        PINT_acache_invalidate(object_ref);
    }
    gossip_debug(GOSSIP_ACACHE_DEBUG, "acache: clean acache miss [%Lu] "
                 "\n", Lu(object_ref.handle));

    js_p->error_code = GETATTR_ACACHE_MISS;
    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
