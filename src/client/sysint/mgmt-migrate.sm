/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>
#include <unistd.h>

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-util.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "PINT-reqproto-encode.h"
#include "pvfs2-internal.h"


extern job_context_id pint_client_sm_context;

static int mgmt_migrate_comp_fn(
		void *v_p, struct PVFS_server_resp *resp, int i);

%%

machine pvfs2_client_mgmt_migrate_sm{
	
	state init{
		run mgmt_migrate_init;
		default => migrate_setup_msgpair;
	}
	
	state migrate_setup_msgpair{
		run mgmt_migrate_setup_msgpair;
		success => migrate_xfer_msgpair;
		default => cleanup;
	}
	
	state migrate_xfer_msgpair{
		jump pvfs2_msgpairarray_sm;
		default => cleanup;
	}
				
	state cleanup{
		run mgmt_migrate_cleanup;
		default => terminate;
	}
		
}

%%


PVFS_error PVFS_imgmt_migrate(
		PVFS_object_ref ref,
		const PVFS_credentials *credentials,
		PVFS_sys_op_id *op_id,
                char *dist_ser,
		PVFS_hint hints,
		void *user_ptr)
{
    int ret = -PVFS_EINVAL;
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;
    
     gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "PVFS_imgmt_migrate entered\n");
                 
                 
     
    if ((ref.handle == PVFS_HANDLE_NULL) ||
        (ref.fs_id == PVFS_FS_ID_NULL))
    {
        gossip_err("invalid (NULL) required argument\n");
        return ret;
    }
             
    
    PINT_smcb_alloc(&smcb, PVFS_MGMT_MIGRATE,
    				sizeof(struct PINT_client_sm),
    				client_op_state_get_machine,
    				client_state_machine_terminate,
    				pint_client_sm_context);
    if(smcb == NULL){
    	return -PVFS_ENOMEM;
    }
       
    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_init_msgarray_params(sm_p, ref.fs_id);
    PINT_init_sysint_credentials(sm_p->cred_p, credentials);
    
    /* fill in stuff in the union */
    sm_p->u.migrate.dist_server = dist_ser;
    sm_p->error_code = 0;
    sm_p->object_ref = ref;
    PVFS_hint_copy(hints, &sm_p->hints);
    
	return PINT_client_state_machine_post(
				smcb, op_id, user_ptr);
}


PVFS_error PVFS_mgmt_migrate(
		PVFS_object_ref ref,
		const PVFS_credentials *credentials,
                char *dist_server,
		PVFS_hint hints)
{
	PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_mgmt_migrate entered\n");		
			
	ret = PVFS_imgmt_migrate(ref, credentials, &op_id, dist_server, hints, NULL);
	if(ret)
	{
		PVFS_perror_gossip("PVFS_imgmt_migrate call", ret);
        error = ret;			
	}
	else
	{
		ret = PVFS_mgmt_wait(op_id, "migrate", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_mgmt_wait call", ret);
            error = ret;
        }
    }		
			
	
    PINT_sys_release(op_id);
    return error;
}
/************************************************************************/

static int mgmt_migrate_comp_fn(
		void *v_p, struct PVFS_server_resp *resp, int i)
{
	/*need to know what this does */
	gossip_debug(GOSSIP_CLIENT_DEBUG, "mgmt_migrate_comp_fn\n");
	
	
	return resp->status;			
}


static PINT_sm_action mgmt_migrate_init(
		struct PINT_smcb *smcb, job_status_s *js_p)
{
	gossip_debug(GOSSIP_CLIENT_DEBUG, "mgmt_migrate_init called\n");
	assert(js_p->error_code == 0);
	return SM_ACTION_COMPLETE;
}

static PINT_sm_action mgmt_migrate_setup_msgpair(
		struct PINT_smcb *smcb, job_status_s *js_p)
{
	gossip_debug(GOSSIP_CLIENT_DEBUG, "mgmt_migrate_setup_msgpair called\n");
	
	struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
	int ret = -PVFS_EINVAL;
	PINT_sm_msgpair_state *msg_p = NULL;
	
	js_p->error_code = 0;
	
	PINT_msgpair_init(&sm_p->msgarray_op);
	msg_p = &sm_p->msgarray_op.msgpair;
	
	PINT_SERVREQ_MGMT_MIGRATE_FILL( 
	    msg_p->req,
	    *sm_p->cred_p,
	    sm_p->object_ref.fs_id,
	    sm_p->object_ref.handle,
            sm_p->u.migrate.dist_server,
    	    sm_p->hints);
    
    /*stuff here as well */
        msg_p->fs_id = sm_p->object_ref.fs_id;
        msg_p->handle = sm_p->object_ref.handle;
        msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY; 
  	msg_p->comp_fn = mgmt_migrate_comp_fn;
  	   	
   	ret = PINT_cached_config_map_to_server(
   	&msg_p->svr_addr, msg_p->handle, msg_p->fs_id);
   	
   	if(ret)
   	{
   		gossip_err("Failed to map to server address\n");
   		js_p->error_code = ret;
   	}
   	
   	PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
   	
   	return SM_ACTION_COMPLETE;
}   		
   		

static PINT_sm_action mgmt_migrate_cleanup(
		struct PINT_smcb *smcb, job_status_s *js_p)
{
	struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
	
	gossip_debug(GOSSIP_CLIENT_DEBUG,
		"mgmt_migrate state: mgmt_migrate_cleanup\n");
		
	sm_p->error_code = js_p->error_code;	
		
	/*do something involving cache or free allocated stuff*/	
		
	PINT_SET_OP_COMPLETE;
	return SM_ACTION_TERMINATE;	
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
*/
