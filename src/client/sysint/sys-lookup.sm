/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"

#include "pinode-helper.h"
#include "ncache.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"
#include "shared-state-methods.h"

extern job_context_id pint_client_sm_context;

#define GET_CURRENT_SEGMENT()                                             \
&(sm_p->u.lookup.contexts[sm_p->u.lookup.current_context].segments[       \
sm_p->u.lookup.contexts[sm_p->u.lookup.current_context].current_segment])
#define GET_CURRENT_CONTEXT()                                             \
&(sm_p->u.lookup.contexts[sm_p->u.lookup.current_context])
#define GET_PREVIOUS_CONTEXT()                                            \
(sm_p->u.lookup.current_context ?                                         \
 &(sm_p->u.lookup.contexts[sm_p->u.lookup.current_context - 1]) : NULL)

enum
{
    LOOKUP_CONTINUE         = 2,
    LOOKUP_TYPE_DIRECTORY   = 3,
    LOOKUP_TYPE_METAFILE    = 4,
    LOOKUP_TYPE_RELATIVE_LN = 5,
    LOOKUP_TYPE_ABSOLUTE_LN = 6,
    LOOKUP_TYPE_LN_NO_FOLLOW= 7
};

/* state function prototypes */
static int lookup_init(PINT_client_sm *sm_p,
		       job_status_s *js_p);
static int lookup_segment_lookup_setup_msgpair(PINT_client_sm *sm_p,
                                               job_status_s *js_p);
static int lookup_segment_lookup_failure(PINT_client_sm *sm_p,
                                         job_status_s *js_p);
static int lookup_segment_verify_attr_present(PINT_client_sm *sm_p,
                                              job_status_s *js_p);
static int lookup_segment_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p);
static int lookup_segment_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p);
static int lookup_segment_check_attr_type(PINT_client_sm *sm_p,
                                          job_status_s *js_p);
static int lookup_segment_handle_relative_link(PINT_client_sm *sm_p,
                                               job_status_s *js_p);
static int lookup_segment_handle_absolute_link(PINT_client_sm *sm_p,
                                               job_status_s *js_p);
static int lookup_context_check_completion(PINT_client_sm *sm_p,
                                           job_status_s *js_p);
static int lookup_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p);

/* completion function prototypes */
static int lookup_segment_lookup_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);

static int lookup_segment_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);

/* helper function prototypes */
static int initialize_context(
    PINT_client_lookup_sm_ctx *ctx,
    PINT_client_lookup_sm_ctx *prev_ctx,
    char *pathname,
    PVFS_pinode_reference ctx_starting_refn);

static void finalize_context(
    PINT_client_lookup_sm_ctx *ctx);

%%

machine pvfs2_client_lookup_sm(
    lookup_init,
    lookup_segment_lookup_setup_msgpair,
    lookup_segment_lookup_xfer_msgpair,
    lookup_segment_lookup_failure,
    lookup_segment_verify_attr_present,
    lookup_segment_getattr_setup_msgpair,
    lookup_segment_getattr_xfer_msgpair,
    lookup_segment_getattr_failure,
    lookup_segment_check_attr_type,
    lookup_segment_handle_relative_link,
    lookup_segment_handle_absolute_link,
    lookup_context_check_completion,
    lookup_cleanup)
{
    state lookup_init
    {
	run lookup_init;
	success => lookup_segment_lookup_setup_msgpair;
        default => lookup_cleanup;
    }

    state lookup_segment_lookup_setup_msgpair
    {
	run lookup_segment_lookup_setup_msgpair;
        success => lookup_segment_lookup_xfer_msgpair;
	default => lookup_segment_lookup_failure;
    }

    state lookup_segment_lookup_xfer_msgpair
    {
        jump pvfs2_client_lookup_ncache_sm;
	success => lookup_segment_verify_attr_present;
        default => lookup_segment_lookup_failure;
    }

    state lookup_segment_lookup_failure
    {
	run lookup_segment_lookup_failure;
	default => lookup_cleanup;
    }

    state lookup_segment_verify_attr_present
    {
	run lookup_segment_verify_attr_present;
        success => lookup_segment_check_attr_type;
        default => lookup_segment_getattr_setup_msgpair;
    }

    state lookup_segment_getattr_setup_msgpair
    {
        run lookup_segment_getattr_setup_msgpair;
        success => lookup_segment_getattr_xfer_msgpair;
        default => lookup_segment_getattr_failure;
    }

    state lookup_segment_getattr_xfer_msgpair
    {
	jump pvfs2_client_getattr_acache_sm;
        success => lookup_segment_check_attr_type;
        default => lookup_segment_getattr_failure;
    }

    state lookup_segment_getattr_failure
    {
        run lookup_segment_getattr_failure;
        default => lookup_cleanup;
    }

    state lookup_segment_check_attr_type
    {
        run lookup_segment_check_attr_type;
        LOOKUP_TYPE_DIRECTORY => lookup_context_check_completion;
        LOOKUP_TYPE_METAFILE => lookup_context_check_completion;
        LOOKUP_TYPE_LN_NO_FOLLOW => lookup_context_check_completion;
        LOOKUP_TYPE_RELATIVE_LN => lookup_segment_handle_relative_link;
        LOOKUP_TYPE_ABSOLUTE_LN => lookup_segment_handle_absolute_link;
        default => lookup_cleanup;
    }

    state lookup_context_check_completion
    {
        run lookup_context_check_completion;
        LOOKUP_CONTINUE => lookup_segment_lookup_setup_msgpair;
        default => lookup_cleanup;
    }

    state lookup_segment_handle_relative_link
    {
        run lookup_segment_handle_relative_link;
        success => lookup_segment_lookup_setup_msgpair;
        default => lookup_cleanup;
    }

    state lookup_segment_handle_absolute_link
    {
        run lookup_segment_handle_absolute_link;
        success => lookup_segment_lookup_setup_msgpair;
        default => lookup_cleanup;
    }

    state lookup_cleanup
    {
        run lookup_cleanup;
        default => lookup_init;
    }
}

%%

static int initialize_context(
    PINT_client_lookup_sm_ctx *ctx,
    PINT_client_lookup_sm_ctx *prev_ctx,
    char *pathname,
    PVFS_pinode_reference ctx_starting_refn)
{
    int ret = -PVFS_EINVAL, pathlen = 0, num_segments = 0;
    void *state = NULL;
    int cur_seg_index = 0;
    char *cur_seg_name = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;
    int num_consecutive_prev_ctx_dot_dots = 0;

    gossip_debug(LOOKUP_DEBUG, "initialize_context called\n");

    if (ctx && pathname)
    {
        pathlen = strlen(pathname);
        num_segments = PINT_string_count_segments(pathname);

        if ((pathlen == 0) || (num_segments == 0))
        {
            return ret;
        }

        if ((pathlen > (PVFS_REQ_LIMIT_PATH_NAME_BYTES - 1)) ||
            (num_segments > PVFS_REQ_LIMIT_PATH_SEGMENT_COUNT))
        {
            gossip_err("Error: Filename %s is too long\n",
                       pathname);
            return -PVFS_ENAMETOOLONG;
        }

        memset(ctx, 0, sizeof(PINT_client_lookup_sm_ctx));

        ctx->current_segment = 0;
        ctx->total_segments = 0;
        ctx->ctx_starting_refn = ctx_starting_refn;

        /* initialize all segments within the context */
        while(!PINT_string_next_segment(pathname,&cur_seg_name,&state))
        {
            /* grab the next segment in the context to fill in */
            cur_seg = &(ctx->segments[cur_seg_index]);
            assert(cur_seg);
            memset(cur_seg, 0, sizeof(PINT_client_lookup_sm_segment));

            gossip_debug(LOOKUP_DEBUG, " cur_seg_name[%d]: %s\n",
                         cur_seg_index, cur_seg_name);
            if (strcmp(cur_seg_name,".") == 0)
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;

                gossip_debug(LOOKUP_DEBUG, " ignoring useless segment\n");
                continue;
            }
            else if (strcmp(cur_seg_name,"..") == 0)
            {
                /*
                   if this isn't true, we need to
                   grab the previous context's previous segment

                   if this weren't true, we'd normally:
                   assert(cur_seg_index > 0);
                */
                if ((cur_seg_index < 1) ||
                    (num_consecutive_prev_ctx_dot_dots > 0))
                {
                    PINT_client_lookup_sm_segment *prev_ctx_prev_seg;

                    gossip_debug(
                        LOOKUP_DEBUG, "  got a '..' segment that "
                        "requires attention of the previous context\n");

                    /*
                      in this case, a previous ctx MUST have been
                      provided, otherwise, the lookup should fail
                    */
                    assert(prev_ctx);
                    assert(prev_ctx->current_segment > 0);

                    num_consecutive_prev_ctx_dot_dots++;
                    gossip_debug(
                        LOOKUP_DEBUG, "num consecutive '..' "
                        "segments requiring the previous segment "
                        "is now %d\n", num_consecutive_prev_ctx_dot_dots);

                    /*
                      further, if we have a number of consecutive
                      '..' segments, we need to keep backing up
                      into the previous context (so long as there
                      are that many segments in the previous ctx!)
                    */
                    if (prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots < 0)
                    {
                        gossip_debug(
                            LOOKUP_DEBUG, "there are no more segments "
                            "in the previous context: failing lookup\n");
                        return -PVFS_ENOENT;
                    }
                    prev_ctx_prev_seg = &prev_ctx->segments[
                        prev_ctx->current_segment -
                        num_consecutive_prev_ctx_dot_dots];
                    assert(prev_ctx_prev_seg);

                    /*
                      instead of decrementing the seg index and
                      continuing, we need to replace the last segment
                      copied from the last context in this case.  (so
                      we drop through to segment init)
                    */
                    ctx_starting_refn =
                        prev_ctx_prev_seg->seg_starting_refn;
                    cur_seg_name = prev_ctx_prev_seg->seg_name;
                    gossip_debug(
                        LOOKUP_DEBUG, "using previous segment: %s\n",
                        cur_seg_name);

                    cur_seg_index--;
                }
                else
                {
                    gossip_debug(LOOKUP_DEBUG, "  got a '..' segment\n");
                    cur_seg_index--;
                    continue;
                }
            }
            else
            {
                /* reset the count of consecutive dot dot segments */
                num_consecutive_prev_ctx_dot_dots = 0;
            }

            /*
              fill in the current segment now.  the first segment
              MUST have the same starting refn as the context
            */
            if (cur_seg_index == 0)
            {
                cur_seg->seg_starting_refn = ctx_starting_refn;
            }
            cur_seg->seg_name = strdup(cur_seg_name);
            assert(cur_seg->seg_name);

            cur_seg_index++;
        }

#if 0
    /* DEBUGGING ONLY */
    {
        int i = 0;
        gossip_debug(LOOKUP_DEBUG, "Processed context path is:\n");
        for(i = 0; i < cur_seg_index; i++)
        {
            assert(ctx->segments[i].seg_name);
            gossip_debug(LOOKUP_DEBUG, "/%s", ctx->segments[i].seg_name);
        }
        gossip_debug(LOOKUP_DEBUG, "\n");
    }
#endif

        ctx->total_segments = cur_seg_index;
        assert(ctx->current_segment == 0);
        ret = 0;
    }
    return ret;
}

static void finalize_context(
    PINT_client_lookup_sm_ctx *ctx)
{
    int i = 0;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(LOOKUP_DEBUG, "finalize_context called\n");

    for(i = 0; i < MAX_LOOKUP_SEGMENTS; i++)
    {
        cur_seg = &ctx->segments[i];
        assert(cur_seg);

        if (cur_seg->seg_name)
        {
            gossip_debug(LOOKUP_DEBUG, "Freeing segment %s\n",
                         cur_seg->seg_name);
            free(cur_seg->seg_name);
            cur_seg->seg_name = NULL;
        }
        PINT_acache_object_attr_deep_free(
            &(cur_seg->seg_attr));
    }
}

/****************************************************************/

int PVFS_sys_ref_lookup(
    PVFS_fs_id fs_id,
    char* relative_pathname,
    PVFS_pinode_reference parent,
    PVFS_credentials credentials,
    PVFS_sysresp_lookup *resp,
    int follow_link)
{
    int ret = -PVFS_EINVAL;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_ref_lookup entered\n");

    if ((relative_pathname == NULL) || (resp == NULL))
    {
        return ret;
    }

    sm_p = (PINT_client_sm *)malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }

    gossip_debug(CLIENT_DEBUG, "lookup got: %s (parent %Lu)\n",
                 relative_pathname, Lu(parent.handle));

    memset(sm_p, 0, sizeof(PINT_client_sm));
    sm_p->cred_p = &credentials;
    sm_p->u.lookup.orig_pathname = relative_pathname;
    sm_p->u.lookup.starting_refn = parent;
    sm_p->u.lookup.lookup_resp = resp;
    sm_p->u.lookup.follow_link = follow_link;
    sm_p->u.lookup.current_context = 0;

    ret = initialize_context(&(sm_p->u.lookup.contexts[0]), NULL,
                             relative_pathname, parent);
    if (ret != 0)
    {
        gossip_err("PVFS_sys_ref_lookup failed to init context\n");
        free(sm_p);
        return ret;
    }

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_LOOKUP);
    assert(ret == 0);

    while (!sm_p->op_complete && (ret == 0))
    {
	ret = PINT_client_state_machine_test();
    }
    assert(ret == 0);

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_ref_lookup completed\n");

    error = sm_p->error_code;

    free(sm_p);
    return error;
}

int PVFS_sys_lookup(
    PVFS_fs_id fs_id, char* name,
    PVFS_credentials credentials,
    PVFS_sysresp_lookup *resp,
    int follow_link)
{
    int ret = -EINVAL;
    PVFS_pinode_reference parent;

    if (name && resp)
    {
        parent.handle = 0;
        parent.fs_id = fs_id;

        ret = PINT_bucket_get_root_handle(parent.fs_id,&parent.handle);
        if (ret < 0)
        {
            return ret;
        }

        /* special case root handle lookup, since we already know it */
        if (strcmp(name, "/") == 0)
        {
            resp->pinode_refn.handle = parent.handle;
            resp->pinode_refn.fs_id = fs_id;
            ret = 0;
        }
        else
        {
            /*
              strip off leading slash (if any) and lookup the rest
              of the path.  NOTE: If it's always an error to not
              have a leading slash, we should check that above
              without doing this function call.
            */
            char *path = ((name[0] == '/') ? &name[1] : name);
            ret = PVFS_sys_ref_lookup(
                fs_id, path, parent, credentials, resp, follow_link);
        }
    }
    return ret;
}

/****************************************************************/

static int lookup_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "lookup state: lookup_init\n");

    assert(js_p->error_code == 0);
    return 1;
}

static int lookup_segment_lookup_setup_msgpair(PINT_client_sm *sm_p,
                                            job_status_s *js_p)
{
    PINT_client_sm_msgpair_state *msg_p = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_segment_lookup_setup_msgpair\n");

    js_p->error_code = 0;

    /*
      NOTE:

      the pvfs2 lookup_path server operation has an optimization that
      allows several path components to be resolved at once.  this
      code here resolves on a segment-by-segment basis, so we're not
      allowing for that optimization.

      once we're sure this code is correct, we can start using that
      optimization again.  it's tricky in distributed meta data setups
      where a path with nested symlinks is distributed across multiple
      servers (where the optimization doesn't help much either).

      while this code isn't as efficient without using that
      optimization, it works and is easy to understand.

      fix this by storing the remaining path in each segment
      (i.e. starting with this segment, the entire remaining path),
      and always do the lookup on that path name.
      [ this would be fixed in the segment init code and here ]

      then in the comp_fn for this, advance through all properly
      resolved segments by filling them all in (starting_refn,
      resolved_refn) and advancing the current_segment
    */

    /* do a lookup on the current segment of the current context */
    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    PINT_SERVREQ_LOOKUP_PATH_FILL(
        msg_p->req,
        *sm_p->cred_p,
        cur_seg->seg_name,
        cur_seg->seg_starting_refn.fs_id,
        cur_seg->seg_starting_refn.handle,
        PVFS_ATTR_COMMON_ALL);

    gossip_debug(LOOKUP_DEBUG, "Looking up segment %s under handle %Lu\n",
                 cur_seg->seg_name, Lu(cur_seg->seg_starting_refn.handle));

    /* fill in msgpair structure components */
    msg_p->fs_id = cur_seg->seg_starting_refn.fs_id;
    msg_p->handle = cur_seg->seg_starting_refn.handle;
    msg_p->comp_fn = lookup_segment_lookup_comp_fn;

    if (PINT_bucket_map_to_server(&msg_p->svr_addr,
                                  msg_p->handle,
                                  msg_p->fs_id) < 0)
    {
        gossip_err("Failed to get meta server information\n");
        js_p->error_code = -PVFS_EINVAL;
    }
    return 1;
}

static int lookup_segment_lookup_failure(PINT_client_sm *sm_p,
                                      job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_segment_lookup_failure\n");
    return 1;
}

static int lookup_segment_verify_attr_present(PINT_client_sm *sm_p,
                                              job_status_s *js_p)
{
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_segment_verify_attr_present\n");

    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    /*
      NOTE: there are two cases here where we need to fetch the attrs.

      1) either the attrs are not present at all (i.e. objtype is
         uninitialized).  this is normal for a distributed meta data
         setups (where we got a handle but still need to fetch the attrs)
      2) we got a symlink back from the lookup and we need to fetch
         the target path.  if we got a symlink, we ALWAYS need to fetch
         the target path UNLESS:
         a) we're on the last segment, and
         b) we're on the initial context (context 0), and
         c) we were told NOT to follow the link

      This second case is handled in check_attr_type method.
    */
    if ((cur_seg->seg_attr.objtype == PVFS_TYPE_NONE) ||
        (cur_seg->seg_attr.objtype == PVFS_TYPE_SYMLINK))
    {
        /* if we don't have the attr, direct sm to fetch the attr */
        gossip_debug(LOOKUP_DEBUG, " -- NO attrs for %s\n",
                     cur_seg->seg_name);

        js_p->error_code = 1;
    }
    else
    {
        gossip_debug(LOOKUP_DEBUG, " -- we have the attrs for %s\n",
                     cur_seg->seg_name);

        /* otherwise, continue to next state */
        js_p->error_code = 0;
    }
    return 1;
}

static int lookup_segment_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p)
{
    PINT_client_sm_msgpair_state *msg_p = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(CLIENT_DEBUG, "lookup state: "
                 "lookup_segment_getattr_setup_msgpair\n");

    js_p->error_code = 0;

    /*
      do a getattr on the resolved handle of the current
      segment in the current context
    */
    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    PINT_SERVREQ_GETATTR_FILL(
        msg_p->req,
        *sm_p->cred_p,
        cur_seg->seg_resolved_refn.fs_id,
        cur_seg->seg_resolved_refn.handle,
        (PVFS_ATTR_COMMON_ALL | PVFS_ATTR_SYMLNK_ALL));

    gossip_debug(LOOKUP_DEBUG, "Doing GETATTR on resolved handle %Lu\n",
                 Lu(cur_seg->seg_resolved_refn.handle));

    msg_p->fs_id   = cur_seg->seg_resolved_refn.fs_id;
    msg_p->handle  = cur_seg->seg_resolved_refn.handle;
    msg_p->comp_fn = lookup_segment_getattr_comp_fn;

    if (PINT_bucket_map_to_server(&msg_p->svr_addr,
                                  msg_p->handle,
                                  msg_p->fs_id) < 0)
    {
	gossip_err("Error: failure mapping to server.\n");
        js_p->error_code = -PVFS_EINVAL;
    }
    return 1;
}

static int lookup_segment_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_segment_getattr_failure\n");
    return 1;
}

static int lookup_segment_check_attr_type(PINT_client_sm *sm_p,
                                          job_status_s *js_p)
{
    PINT_client_lookup_sm_ctx *cur_ctx = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_segment_check_attr_type\n");

    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    cur_ctx = GET_CURRENT_CONTEXT();
    assert(cur_ctx);

    switch(cur_seg->seg_attr.objtype)
    {
        case PVFS_TYPE_DIRECTORY:
            js_p->error_code = LOOKUP_TYPE_DIRECTORY;
            break;
        case PVFS_TYPE_METAFILE:
            js_p->error_code = LOOKUP_TYPE_METAFILE;
            break;
        case PVFS_TYPE_SYMLINK:
            /*
              check if we need to skip the symlink resolution
              (in the case that it's the final segment and the
              user requested that we do NOT follow the last link)
            */
            if ((cur_seg->seg_attr.objtype == PVFS_TYPE_SYMLINK) &&
                (cur_ctx->current_segment == (cur_ctx->total_segments - 1)) &&
                (sm_p->u.lookup.current_context == 0) &&
                (sm_p->u.lookup.follow_link == PVFS2_LOOKUP_LINK_NO_FOLLOW))
            {
                gossip_debug(LOOKUP_DEBUG, "** skipping final symlink "
                             "resolution due to user request\n");
                js_p->error_code = LOOKUP_TYPE_LN_NO_FOLLOW;
            }
            else
            {
                assert(cur_seg->seg_attr.u.sym.target_path);

                if (cur_seg->seg_attr.u.sym.target_path[0] == '/')
                {
                    js_p->error_code = LOOKUP_TYPE_ABSOLUTE_LN;
                }
                else
                {
                    js_p->error_code = LOOKUP_TYPE_RELATIVE_LN;
                }
            }
            break;
        default:
            gossip_debug(CLIENT_DEBUG, "cannot resolve object of "
                         "type %d\n", cur_seg->seg_attr.objtype);
            js_p->error_code = -PVFS_EINVAL;
    }
    return 1;
}

static int lookup_segment_handle_relative_link(PINT_client_sm *sm_p,
                                               job_status_s *js_p)
{
    int ret = -1;
    PINT_client_lookup_sm_ctx *cur_ctx = NULL;
    PINT_client_lookup_sm_ctx *prev_ctx = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;
    char *relative_symlink_target = NULL;

    js_p->error_code = 0;

    /*
      NOTE: if we have a relative link, we need to essentially
      recurse.  we're basically doing that iteratively by moving to a
      new context and continuing along our completely linear state
      machine.  the absolute link case is a simplification of this
      case.  the reason this is tricker is because the relative link
      may contain '.' and '..' characters (i.e. foo -> ../oldfoo)
    */
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_segment_handle_relative_link\n");

    /* grab the current segment that has a relative link to be resolved */
    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    relative_symlink_target = cur_seg->seg_attr.u.sym.target_path;

    sm_p->u.lookup.current_context++;
    if (sm_p->u.lookup.current_context > (MAX_LOOKUP_CONTEXTS - 1))
    {
        js_p->error_code = -PVFS_EMLINK;
        return 1;
    }

    cur_ctx = GET_CURRENT_CONTEXT();
    assert(cur_ctx);

    prev_ctx = GET_PREVIOUS_CONTEXT();

    /*
      and initialize the new context with the information we have so
      that it can resolve this absolute link.

      the starting refn is initialized as the starting refn of
      the segment that resolves to this relative link, since the
      link must be relative to that starting parent
    */
    ret = initialize_context(cur_ctx, prev_ctx,
                             relative_symlink_target,
                             cur_seg->seg_starting_refn);
    if (ret != 0)
    {
        js_p->error_code = ret;
    }
    return 1;
}

static int lookup_segment_handle_absolute_link(PINT_client_sm *sm_p,
                                               job_status_s *js_p)
{
    int ret = -1;
    PINT_client_lookup_sm_ctx *cur_ctx = NULL;
    PINT_client_lookup_sm_ctx *prev_ctx = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;
    char *absolute_symlink_target = NULL;
    PVFS_pinode_reference root_refn;

    js_p->error_code = 0;

    /*
      NOTE: if we have an absolute link, we need to essentially
      recurse.  we're basically doing that iteratively by moving to a
      new context and continuing along our completely linear state
      machine.
    */
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_segment_handle_absolute_link\n");

    /* grab the current segment that has an absolute link to be resolved */
    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    absolute_symlink_target = cur_seg->seg_attr.u.sym.target_path;

    sm_p->u.lookup.current_context++;
    if (sm_p->u.lookup.current_context > (MAX_LOOKUP_CONTEXTS - 1))
    {
        js_p->error_code = -PVFS_EMLINK;
        return 1;
    }

    cur_ctx = GET_CURRENT_CONTEXT();
    assert(cur_ctx);

    prev_ctx = GET_PREVIOUS_CONTEXT();

    /*
      and initialize the new context with the information we have so
      that it can resolve this absolute link.

      the starting refn is initialized as the root refn matching the
      fs_id that this lookup started with.
    */
    root_refn.fs_id = sm_p->u.lookup.starting_refn.fs_id;
    ret = PINT_bucket_get_root_handle(root_refn.fs_id, &root_refn.handle);
    assert(ret == 0);

    ret = initialize_context(cur_ctx, prev_ctx,
                             absolute_symlink_target,
                             root_refn);
    if (ret != 0)
    {
        js_p->error_code = ret;
    }
    return 1;
}

static int lookup_context_check_completion(PINT_client_sm *sm_p,
                                           job_status_s *js_p)
{
    PVFS_pinode_reference last_resolved_refn;
    PINT_client_lookup_sm_ctx *cur_ctx = NULL;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_context_check_completion\n");

    cur_ctx = GET_CURRENT_CONTEXT();
    assert(cur_ctx);

    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    last_resolved_refn = cur_seg->seg_resolved_refn;

    /*
      since we're here, we've completed resolving the previous
      segment, so update the context's current_segment to be the next
      one
    */
  check_for_completion:
    cur_ctx->current_segment++;

    if (cur_ctx->current_segment == cur_ctx->total_segments)
    {
        /*
          if we've run out of segments, we've completed a context
          lookup
        */
        cur_ctx->ctx_resolved_refn = last_resolved_refn;

        /*
          NOTE: we're only done if the current_segment == the total
          segments AND we're in context 0 (i.e. the initial context)
        */
        if (sm_p->u.lookup.current_context == 0)
        {
            /* we are done, done at this point */
            sm_p->u.lookup.lookup_resp->pinode_refn =
                cur_ctx->ctx_resolved_refn;
            js_p->error_code = 0;
            return 1;
        }
        else
        {
            /*
              otherwise, bump back to the previous segment and update
              the state of the segment that we had previously left off
              at in that context
            */
            sm_p->u.lookup.current_context--;

            cur_ctx = GET_CURRENT_CONTEXT();
            assert(cur_ctx);

            cur_seg = GET_CURRENT_SEGMENT();
            assert(cur_seg);

            /*
              this segment resolved to be the last
              context refn resolved
            */
            cur_seg->seg_resolved_refn = last_resolved_refn;

            /*
              NOTE: once we're done updating the state of the segment
              in this context, we should check one more time if we've
              reached completion since we just effectively resolved a
              new segment
            */
            goto check_for_completion;
        }
    }
    else
    {
        /*
          otherwise, we just need to prepare for the next segment
          resolution (by filling in the starting refn), now that we
          have the previous one.  the current_segment has already been
          adjusted.
        */
        cur_seg = GET_CURRENT_SEGMENT();
        assert(cur_seg);

        cur_seg->seg_starting_refn = last_resolved_refn;
    }

    js_p->error_code = LOOKUP_CONTINUE;
    return 1;
}

static int lookup_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p)
{
    int i = 0;

    gossip_debug(CLIENT_DEBUG, "lookup state: lookup_cleanup\n");

    sm_p->error_code = js_p->error_code;

    /* clean up all used memory for this lookup */
    for(i = 0; i < MAX_LOOKUP_CONTEXTS; i++)
    {
        finalize_context(&sm_p->u.lookup.contexts[i]);
    }

    /* mark operation as complete */
    sm_p->op_complete = 1;
    return 0;
}

static int lookup_segment_lookup_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *)v_p;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(CLIENT_DEBUG, "lookup_segment_lookup_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_LOOKUP_PATH);

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }            

    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    /*
      if the lookup_path optimization is being used, this
      may not be true.  leave it here until we fix that
    */
    assert(index == 0);

    assert(resp_p->u.lookup_path.handle_count);

    /* store the retrieved handle in the current segment */
    cur_seg->seg_resolved_refn.handle =
        resp_p->u.lookup_path.handle_array[index];
    cur_seg->seg_resolved_refn.fs_id =
        cur_seg->seg_starting_refn.fs_id;

    /*
      store the retrieved attr in the current
      segment (if one was returned)
    */
    if (resp_p->u.lookup_path.handle_count ==
        resp_p->u.lookup_path.attr_count)
    {
        PINT_acache_object_attr_deep_free(
            &(cur_seg->seg_attr));
        PINT_acache_object_attr_deep_copy(
            &(cur_seg->seg_attr),
            &(resp_p->u.lookup_path.attr_array[index]));
    }
    return 0;
}

static int lookup_segment_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *)v_p;
    PINT_client_lookup_sm_segment *cur_seg = NULL;

    gossip_debug(CLIENT_DEBUG, "lookup_segment_getattr_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_GETATTR);

    if (resp_p->status != 0)
    {
        gossip_debug(CLIENT_DEBUG, " getattr failed with code %d\n",
                     resp_p->status);
        return resp_p->status;
    }            

    cur_seg = GET_CURRENT_SEGMENT();
    assert(cur_seg);

    assert(index == 0);

    PINT_acache_object_attr_deep_free(
        &(cur_seg->seg_attr));
    PINT_acache_object_attr_deep_copy(
        &(cur_seg->seg_attr),
        &(resp_p->u.getattr.attr));

    return 0;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
