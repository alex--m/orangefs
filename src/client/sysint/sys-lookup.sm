/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"

#include "pinode-helper.h"
#include "ncache.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "PINT-reqproto-encode.h"
#include "shared-state-methods.h"

extern job_context_id pint_client_sm_context;

enum
{
    LOOKUP_CONTINUE = 2,
    LOOKUP_SYMLINK = 3
};

/* state function prototypes */
static int lookup_init(PINT_client_sm *sm_p,
		       job_status_s *js_p);
static int lookup_check_completion(PINT_client_sm *sm_p,
                                   job_status_s *js_p);
static int lookup_msg_setup_msgpair(PINT_client_sm *sm_p,
                                    job_status_s *js_p);
static int lookup_msg_failure(PINT_client_sm *sm_p,
                              job_status_s *js_p);
static int lookup_symlink_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p);
static int lookup_symlink_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p);
static int lookup_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p);

/* completion function prototypes */
static int lookup_msg_comp_fn(void *v_p,
                              struct PVFS_server_resp *resp_p,
                              int index);
static int lookup_symlink_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);

%%

machine pvfs2_client_lookup_sm(init,
                               lookup_check_completion,
                               lookup_msg_setup_msgpair,
			       lookup_msg_xfer_msgpair,
			       lookup_msg_failure,
                               lookup_symlink_getattr_setup_msgpair,
                               lookup_symlink_getattr_xfer_msgpair,
                               lookup_symlink_getattr_failure,
			       cleanup)
{
    state init {
	run lookup_init;
	default => lookup_msg_setup_msgpair;
    }

    state lookup_msg_setup_msgpair {
	run lookup_msg_setup_msgpair;
        success => lookup_msg_xfer_msgpair;
	default => lookup_msg_failure;
    }

    state lookup_msg_xfer_msgpair {
        jump pvfs2_client_lookup_ncache_sm;
	default => lookup_check_completion;
    }

    state lookup_msg_failure {
	run lookup_msg_failure;
	default => cleanup;
    }

    state lookup_check_completion {
	run lookup_check_completion;
        success => cleanup;
        LOOKUP_CONTINUE => lookup_msg_setup_msgpair;
        LOOKUP_SYMLINK => lookup_symlink_getattr_setup_msgpair;
	default => lookup_msg_failure;
    }

    state lookup_symlink_getattr_setup_msgpair {
        run lookup_symlink_getattr_setup_msgpair;
        success => lookup_symlink_getattr_xfer_msgpair;
        default => lookup_symlink_getattr_failure;
    }

    state lookup_symlink_getattr_xfer_msgpair {
	jump pvfs2_client_getattr_acache_sm;
        success => lookup_msg_setup_msgpair;
        default => lookup_symlink_getattr_failure;
    }

    state lookup_symlink_getattr_failure {
        run lookup_symlink_getattr_failure;
        default => cleanup;
    }

    state cleanup {
        run lookup_cleanup;
        default => init;
    }
}

%%

int PVFS_sys_ref_lookup(
    PVFS_fs_id fs_id,
    char* relative_pathname,
    PVFS_pinode_reference parent,
    PVFS_credentials credentials,
    PVFS_sysresp_lookup *resp,
    int follow_link)
{
    int ret = -PVFS_EINVAL, pathlen = 0, num_segments = 0;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_ref_lookup entered\n");

    /* parameter checking goes here.  assume everything from the user
     * is ok past this point.
     */
    if ((relative_pathname == NULL) || (resp == NULL))
    {
        return ret;
    }

    pathlen = strlen(relative_pathname);
    num_segments = PINT_string_count_segments(relative_pathname);
    gossip_debug(CLIENT_DEBUG, "LOOKUP: %s has %d segments\n",
                 relative_pathname, num_segments);

    if ((pathlen == 0) || (num_segments == 0))
    {
        return ret;
    }

    if ((pathlen > (PVFS_REQ_LIMIT_PATH_NAME_BYTES - 1)) ||
        (num_segments > PVFS_REQ_LIMIT_PATH_SEGMENT_COUNT))
    {
        gossip_lerr("Error: Filename %s is too long\n",
                    relative_pathname);
	return -PVFS_ENAMETOOLONG;
    }

    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.lookup.orig_pathname = relative_pathname;
    sm_p->u.lookup.starting_refn = parent;
    sm_p->u.lookup.lookup_resp = resp;
    sm_p->u.lookup.follow_link = follow_link;
    sm_p->u.lookup.num_segments = num_segments;
    sm_p->u.lookup.remaining_pathname = (char *)
        malloc(sizeof(char) * PVFS_SEGMENT_MAX);
    assert(sm_p->u.lookup.remaining_pathname);
    strncpy(sm_p->u.lookup.remaining_pathname, relative_pathname,
            PVFS_SEGMENT_MAX);
    sm_p->u.lookup.remaining_starting_refn.fs_id = fs_id;
    sm_p->u.lookup.remaining_starting_refn.handle = parent.handle;
    sm_p->u.lookup.resolve_symlink = 0;
    sm_p->u.lookup.num_symlinks_followed = 0;
    sm_p->u.lookup.use_symlink_parent = 0;
    sm_p->u.lookup.symlink_parent_refn.handle = (PVFS_handle)0;
    sm_p->u.lookup.symlink_parent_refn.fs_id = (PVFS_fs_id)0;
    sm_p->u.lookup.post_link_segment = NULL;

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_LOOKUP);
    assert(ret == 0);

    /* while !done call progress function */
    while (!sm_p->op_complete && (ret == 0))
    {
	ret = PINT_client_state_machine_test();
    }
    assert(ret == 0);

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_ref_lookup completed\n");

    /* save our return value */
    error = sm_p->error_code;

    /* clean up after ourselves */
    free(sm_p);
    return error;
}

int PVFS_sys_lookup(
    PVFS_fs_id fs_id, char* name,
    PVFS_credentials credentials,
    PVFS_sysresp_lookup *resp,
    int follow_link)
{
    int ret = -EINVAL;
    PVFS_pinode_reference parent;

    if (name && resp)
    {
        parent.handle = 0;
        parent.fs_id = fs_id;

        ret = PINT_bucket_get_root_handle(parent.fs_id,&parent.handle);
        if (ret < 0)
        {
            return ret;
        }

        /* NOTE: special case is that we're doing a lookup of the root
         * handle (which we got during the getconfig) so we want to check
         * to see if we're looking up "/"; if so, then get the root handle
         * from the bucket table interface and return
         */
        if (!strcmp(name, "/"))
        {
            resp->pinode_refn.handle = parent.handle;
            resp->pinode_refn.fs_id = fs_id;
            ret = 0;
        }
        else
        {
            /*
              strip off leading slash (if any) and lookup the rest
              of the path.  NOTE: If it's always an error to not
              have a leading slash, we should check that above
              without doing this function call.
            */
            char *path = ((name[0] == '/') ? &name[1] : name);
            ret = PVFS_sys_ref_lookup(fs_id, path, parent,
                                      credentials, resp, follow_link);
        }
    }
    return ret;
}

/****************************************************************/

static int lookup_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "lookup state: init\n");

    assert(js_p->error_code == 0);

    /* do the request scheduler thing, if necessary */

    return 1;
}

static int lookup_check_completion(PINT_client_sm *sm_p,
                                   job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_check_completion\n");


    /*
      at this point we hit one of several cases:
      1) the lookup_msg_comp_fn saw a symlink and we need to
         continue resolution (TODO: if appropriate flag is set)
      2) no more segments; successful lookup
      3) need to query another meta server to continue resolution
      4) error, bad lookup (entry cannot be resolved)
    */
    if (sm_p->u.lookup.resolve_symlink == PVFS2_LOOKUP_LINK_FOLLOW)
    {
        js_p->error_code = LOOKUP_SYMLINK;
        sm_p->u.lookup.resolve_symlink = 0;
        if (sm_p->u.lookup.num_symlinks_followed++ >
            PVFS_REQ_LIMIT_MAX_SYMLINK_RESOLUTION_COUNT)
        {
            gossip_err("Cannot resolve more than %d symlinks; "
                       "aborting resolution and assuming infinite loop\n",
                       PVFS_REQ_LIMIT_MAX_SYMLINK_RESOLUTION_COUNT);
            sm_p->u.lookup.last_error = -PVFS_EMLINK;
            goto lookup_failure;
        }
        goto lookup_continue;
    }
    else if (sm_p->u.lookup.num_segments == 0)
    {
        /*
          in the case of partial path symlink resolution,
          we've led the state machine to be here, but
          still have a post_link_segment to resolve, so
          reset the remaining_pathname to where we last left off
          before current symlink resolution completion
        */
        if (sm_p->u.lookup.post_link_segment)
        {
            memset(sm_p->u.lookup.remaining_pathname, 0,
                   PVFS_SEGMENT_MAX);
            strncpy(sm_p->u.lookup.remaining_pathname,
                    sm_p->u.lookup.post_link_segment, PVFS_SEGMENT_MAX);
            free(sm_p->u.lookup.post_link_segment);
            sm_p->u.lookup.post_link_segment = NULL;

            /* continue with symlink resolution; recompute num segments */
            sm_p->u.lookup.num_segments =
                PINT_string_count_segments(
                    sm_p->u.lookup.remaining_pathname);

            if (sm_p->u.lookup.num_symlinks_followed++ >
                PVFS_REQ_LIMIT_MAX_SYMLINK_RESOLUTION_COUNT)
            {
                gossip_err("Cannot resolve more than %d symlinks; "
                           "aborting resolution and assuming infinite "
                           "loop\n",
                           PVFS_REQ_LIMIT_MAX_SYMLINK_RESOLUTION_COUNT);
                sm_p->u.lookup.last_error = -PVFS_EMLINK;
                goto lookup_failure;
            }

            js_p->error_code = LOOKUP_CONTINUE;
            goto lookup_continue;
        }

        /* success case: direct state machine to cleanup */
        js_p->error_code = 0;
    }
    else if (sm_p->u.lookup.last_error == 0)
    {
        /* continue looking on another meta-server */
        js_p->error_code = LOOKUP_CONTINUE;
        goto lookup_continue;
    }
    else
    {
      lookup_failure:
        /* error case: direct state machine to failure */
        js_p->error_code = (sm_p->u.lookup.last_error ?
                            sm_p->u.lookup.last_error :
                            -PVFS_ENOENT);
    }
  
  lookup_continue:

    return 1;
}

static int lookup_msg_setup_msgpair(PINT_client_sm *sm_p,
                                    job_status_s *js_p)
{
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_msg_setup_msgpair\n");

    /* clear error field in job */
    js_p->error_code = 0;

    gossip_debug(CLIENT_DEBUG," lookup: posting lookup_path req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    PINT_SERVREQ_LOOKUP_PATH_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->u.lookup.remaining_pathname,
        sm_p->u.lookup.remaining_starting_refn.fs_id,
        sm_p->u.lookup.remaining_starting_refn.handle,
        PVFS_ATTR_COMMON_ALL);

    gossip_debug(CLIENT_DEBUG,
                 "Looking up path %s under handle %Lu and fs %d "
                 "[ %d segments ]\n",
                 sm_p->u.lookup.remaining_pathname,
                 Lu(sm_p->u.lookup.remaining_starting_refn.handle),
                 sm_p->u.lookup.remaining_starting_refn.fs_id,
                 sm_p->u.lookup.num_segments);

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->u.lookup.remaining_starting_refn.fs_id;
    msg_p->handle = sm_p->u.lookup.remaining_starting_refn.handle;
    msg_p->comp_fn = lookup_msg_comp_fn;

    if (PINT_bucket_map_to_server(&msg_p->svr_addr,
                                  msg_p->handle,
                                  msg_p->fs_id) < 0)
    {
        gossip_err("Failed to get meta server information\n");
        assert(0);
    }
    return 1;
}

static int lookup_msg_comp_fn(void *v_p,
                              struct PVFS_server_resp *resp_p,
                              int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;
    char buf[PVFS_SEGMENT_MAX] = {0};
    char tmp[PVFS_SEGMENT_MAX] = {0};

    gossip_debug(CLIENT_DEBUG, "lookup_msg_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_LOOKUP_PATH);

    /*
      If we get an error here, we need to at least partially
      process the returned attrs and handles, so just stash
      the error value in case we need it later, while resetting
      the error code to allow us to continue processing.
    */
    sm_p->u.lookup.last_error = resp_p->status;
    resp_p->status = 0;

    gossip_debug(CLIENT_DEBUG, "Got %d handle(s) & %d attr(s) returned\n",
                 resp_p->u.lookup_path.handle_count,
                 resp_p->u.lookup_path.attr_count);

#if 0
    /* DEBUGGING ONLY */
    {
        int i = 0;
        for(i = 0; i < resp_p->u.lookup_path.handle_count; i++)
        {
            gossip_debug(CLIENT_DEBUG, "Handle %d is %Lu\n",
                         i, Lu(resp_p->u.lookup_path.handle_array[i]));
        }
    }
#endif

    if (resp_p->u.lookup_path.handle_count)
    {
        if (resp_p->u.lookup_path.handle_array[
                resp_p->u.lookup_path.handle_count - 1] !=
            sm_p->u.lookup.symlink_refn.handle)
        {
            gossip_debug(
                CLIENT_DEBUG," *** - Overwriting starting refn "
                "handle %Lu with %Lu\n",
                Lu(sm_p->u.lookup.remaining_starting_refn.handle),
                Lu(resp_p->u.lookup_path.handle_array[
                       resp_p->u.lookup_path.handle_count - 1]));
            sm_p->u.lookup.tmp_remaining_refn =
                sm_p->u.lookup.remaining_starting_refn;
            sm_p->u.lookup.remaining_starting_refn.handle =
                resp_p->u.lookup_path.handle_array[
                    resp_p->u.lookup_path.handle_count - 1];
        }
    }

    /* FIXME: INSERT ALL ATTRS IN ARRAY INTO ACACHE HERE */
    /* TODO : INSERT ALL ATTRS IN ARRAY INTO ACACHE HERE */

    /* adjust local lookup processing state */
    sm_p->u.lookup.num_segments -= resp_p->u.lookup_path.handle_count;
    assert(sm_p->u.lookup.num_segments > -1);

    if (sm_p->u.lookup.num_segments == 0)
    {
        /* check for the special case of symlink resolution */
        if (resp_p->u.lookup_path.attr_count &&
            (resp_p->u.lookup_path.attr_array[
                resp_p->u.lookup_path.attr_count - 1].objtype ==
             PVFS_TYPE_SYMLINK))
        {
            if ((resp_p->u.lookup_path.handle_count > 1) &&
                (sm_p->u.lookup.remaining_pathname[0] != '/'))
            {
                sm_p->u.lookup.symlink_parent_refn.handle =
                    resp_p->u.lookup_path.handle_array[
                        resp_p->u.lookup_path.handle_count - 2];
                sm_p->u.lookup.symlink_parent_refn.fs_id =
                    sm_p->u.lookup.starting_refn.fs_id;
                sm_p->u.lookup.use_symlink_parent = 1;
            }
            /*
              store the symlink handle so we know which handle
              to do the symlink_getattr on
            */
            assert(resp_p->u.lookup_path.handle_count > 0);
            sm_p->u.lookup.symlink_refn.handle =
                resp_p->u.lookup_path.handle_array[
                    resp_p->u.lookup_path.handle_count - 1];
            /* FIXME: assuming fs_id same as starting point */
            sm_p->u.lookup.symlink_refn.fs_id =
                sm_p->u.lookup.starting_refn.fs_id;

            if (resp_p->u.lookup_path.handle_count &&
                (resp_p->u.lookup_path.handle_array[
                    resp_p->u.lookup_path.handle_count - 1] !=
                 sm_p->u.lookup.symlink_refn.handle))
            {
                gossip_debug(
                    CLIENT_DEBUG," *** 2 - Overwriting "
                    "starting refn handle %Lu with %Lu\n",
                    Lu(sm_p->u.lookup.remaining_starting_refn.handle),
                    Lu(sm_p->u.lookup.starting_refn.handle));
                
                sm_p->u.lookup.tmp_remaining_refn =
                    sm_p->u.lookup.remaining_starting_refn;
                sm_p->u.lookup.remaining_starting_refn =
                    sm_p->u.lookup.starting_refn;
            }

            /*
              check_completion routine will take care of the rest
              as long as we set this flag
            */
            sm_p->u.lookup.resolve_symlink = sm_p->u.lookup.follow_link;
            if (sm_p->u.lookup.resolve_symlink == PVFS2_LOOKUP_LINK_NO_FOLLOW)
            {
                /* store final symlink refn into respose */
                sm_p->u.lookup.lookup_resp->pinode_refn =
                    sm_p->u.lookup.symlink_refn;
            }
            return 1;
        }

        /* restore the real error/success code */
        resp_p->status = sm_p->u.lookup.last_error;

        /* copy out the final looked up handle value to sys response */
        sm_p->u.lookup.lookup_resp->pinode_refn.handle =
            resp_p->u.lookup_path.handle_array[
                resp_p->u.lookup_path.handle_count - 1];
        /*
          FIXME: for now requires that the final resolved name must be
          on the same fs as the starting name to be resolved.
        */
        sm_p->u.lookup.lookup_resp->pinode_refn.fs_id =
            sm_p->u.lookup.starting_refn.fs_id;

#if 0
        /* insert final lookup entry into ncache if appropriate */
        if (!sm_p->ncache_hit)
        {
            PVFS_pinode_reference parent_refn;

            parent_refn.fs_id =
                sm_p->u.lookup.lookup_resp->pinode_refn.fs_id;
            parent_refn.handle =
                resp_p->u.lookup_path.handle_array[
                    resp_p->u.lookup_path.handle_count - 1];

            gossip_debug(NCACHE_DEBUG, "Final segment %s has starting "
                         "handle %Lu (response had %d handles total)\n",
                         sm_p->u.lookup.remaining_pathname,
                         Lu(parent_refn.handle),
                         resp_p->u.lookup_path.handle_count);

            PINT_ncache_insert(sm_p->u.lookup.remaining_pathname,
                               sm_p->u.lookup.lookup_resp->pinode_refn,
                               parent_refn);
        }
#endif
    }
    else if ((resp_p->u.lookup_path.handle_count !=
              resp_p->u.lookup_path.attr_count))
    {
        /*
          this is the case where we have a distributed metadata
          setup and a lookup returned a handle without an attribute
          since we need to get those from another server
        */
        int next_path_segment =
            resp_p->u.lookup_path.handle_count;

#if 0
        /*
          if we didn't get a ncache hit, insert all
          resolved segments into the ncache here
        */
        if (!sm_p->ncache_hit)
        {
            int i = 0;
            char cur_segment[PVFS_SEGMENT_MAX] = {0};
            PVFS_pinode_reference parent_refn, cur_refn;

            parent_refn = sm_p->u.lookup.starting_refn;
            for(i = 0; i < resp_p->u.lookup_path.handle_count; i++)
            {
                snprintf(buf, PVFS_SEGMENT_MAX, "%s",
                         sm_p->u.lookup.remaining_pathname);
                PINT_get_path_element(buf, i, cur_segment,
                                      PVFS_SEGMENT_MAX);
                
                cur_refn.fs_id = parent_refn.fs_id;
                cur_refn.handle =
                    resp_p->u.lookup_path.handle_array[i];

                gossip_debug(
                    CLIENT_DEBUG, "[%d] Got partial lookup "
                    "\"%s\" Handle %Lu back\n", i, cur_segment,
                    Lu(cur_refn.handle));

                if (PINT_ncache_lookup(
                        cur_segment, parent_refn, &cur_refn) < 0)
                {
                    PINT_ncache_insert(cur_segment, cur_refn, parent_refn);
                }
                parent_refn = cur_refn;
            }
        }
#endif
        gossip_debug(CLIENT_DEBUG, "Getting path element %d from "
                     "path %s [num segments is %d]\n", next_path_segment,
                     sm_p->u.lookup.remaining_pathname,
                     sm_p->u.lookup.num_segments);

        /*
          here we're updating the remaining_pathname by stripping
          off the parts of the path that were just looked up.
          out new parent handle is already valid at this point
        */
        snprintf(buf, PVFS_SEGMENT_MAX, "%s",
                 sm_p->u.lookup.remaining_pathname);
        memset(sm_p->u.lookup.remaining_pathname, 0, PVFS_SEGMENT_MAX);
        PINT_get_path_element(
            buf, next_path_segment, tmp, PVFS_SEGMENT_MAX);
        assert(strlen(tmp) > 0);

        strncpy(sm_p->u.lookup.remaining_pathname,
                strstr(buf, tmp), PVFS_SEGMENT_MAX);

        gossip_debug(CLIENT_DEBUG, "Remaining pathname is %s | "
                     "new starting handle is %Lu\n",
                     sm_p->u.lookup.remaining_pathname,
                     Lu(sm_p->u.lookup.remaining_starting_refn.handle));
    }
    else if ((resp_p->u.lookup_path.attr_count ==
              resp_p->u.lookup_path.handle_count) &&
             (resp_p->u.lookup_path.attr_count > 0))
    {
        if (resp_p->u.lookup_path.attr_array[
                resp_p->u.lookup_path.attr_count - 1].objtype ==
            PVFS_TYPE_SYMLINK)
        {
            char *ptr = NULL;
            char tmp_segment[PVFS_SEGMENT_MAX] = {0};

            /* reset the default remaining path parent refn */
            sm_p->u.lookup.use_symlink_parent = 0;

            /* unless it was already properly set above */
            if (sm_p->u.lookup.tmp_remaining_refn.handle !=
                sm_p->u.lookup.starting_refn.handle)
            {
                gossip_debug(
                    CLIENT_DEBUG," *** 3 - Overwriting starting "
                    "refn handle %Lu with %Lu\n",
                    Lu(sm_p->u.lookup.remaining_starting_refn.handle),
                    Lu(sm_p->u.lookup.starting_refn.handle));

                sm_p->u.lookup.remaining_starting_refn =
                    sm_p->u.lookup.starting_refn;
            }

            if (resp_p->u.lookup_path.handle_count > 1)
            {
                sm_p->u.lookup.tmp_remaining_refn.handle =
                    resp_p->u.lookup_path.handle_array[
                        resp_p->u.lookup_path.handle_count - 2];
            }

            /*
              store the symlink handle so we know which handle
              to do the symlink_getattr on
            */
            assert(resp_p->u.lookup_path.handle_count > 0);
            sm_p->u.lookup.symlink_refn.handle =
                resp_p->u.lookup_path.handle_array[
                    resp_p->u.lookup_path.handle_count - 1];

            /*
              if we have a non-absolute link target, we need to
              use the last resolved segment as the symlink parent
              instead of the previously assigned
              'remaining_starting_refn'.  we fill this in here
              and it's only used in the getattr_comp_fn if a
              non-absolute (i.e. relative) path is detected.

              the post link segment is used to store the remaining
              pathname to resolve after the current symlink is resolved.
            */
            if ((resp_p->u.lookup_path.handle_count > 1) &&
                (sm_p->u.lookup.remaining_pathname[0] != '/'))
            {
                sm_p->u.lookup.symlink_parent_refn.handle =
                    resp_p->u.lookup_path.handle_array[
                        resp_p->u.lookup_path.handle_count - 2];
                sm_p->u.lookup.symlink_parent_refn.fs_id =
                    sm_p->u.lookup.starting_refn.fs_id;
                sm_p->u.lookup.use_symlink_parent = 1;
            }

            /*
              at this point, the post link segment should
              contain exactly the pathname after the path
              remaining currently (including the symlink
              segment) in order to continue resolution
              after the upcoming symlink resolution.
              so this makes that happen.
            */
            if (PINT_get_path_element(
                    sm_p->u.lookup.remaining_pathname,
                    (resp_p->u.lookup_path.handle_count - 1),
                    tmp_segment, PVFS_SEGMENT_MAX))
            {
                gossip_err("Cannot get path element %d from %s\n",
                           (resp_p->u.lookup_path.handle_count - 1),
                           sm_p->u.lookup.remaining_pathname);
                assert(0);
            }
            sm_p->u.lookup.post_link_segment = (char *)
                malloc(PVFS_SEGMENT_MAX);
            assert(sm_p->u.lookup.post_link_segment);
            memset(sm_p->u.lookup.post_link_segment, 0,
                   PVFS_SEGMENT_MAX);

            ptr = strstr(sm_p->u.lookup.remaining_pathname,
                         tmp_segment);
            assert(ptr);

            ptr += strlen(tmp_segment);
            assert(ptr);

            /* be sure to skip '/' if we've landed on one */
            if (*ptr == '/')
            {
                ptr++;
            }

            strncpy(sm_p->u.lookup.post_link_segment, ptr,
                    PVFS_SEGMENT_MAX);

            /* FIXME: assuming fs_id same as starting point */
            sm_p->u.lookup.symlink_refn.fs_id =
                sm_p->u.lookup.starting_refn.fs_id;

            sm_p->u.lookup.resolve_symlink = 1;
            return 1;
        }
    }
    return 1;
}

static int lookup_msg_failure(PINT_client_sm *sm_p,
                              job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "lookup state: lookup_msg_failure\n");
    return 1;
}

static int lookup_symlink_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p)
{
    int ret = -1;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(CLIENT_DEBUG, "lookup state: "
                 "lookup_symlink_getattr_setup_msgpair\n");

    /* clear error field in job */
    js_p->error_code = 0;

    /* clear ncache hit flag */
    sm_p->ncache_hit = 0;

    gossip_debug(CLIENT_DEBUG," lookup: posting symlink getattr "
                 "req on handle %Lu (parent is %Lu)\n",
                 Lu(sm_p->u.lookup.symlink_refn.handle),
                 Lu(sm_p->u.lookup.remaining_starting_refn.handle));

    /*
      lookup_msg_comp_fn can lead to a case where the symlink to
      resolve is the same as the assigned parent handle.
      if that's the case, we need to retrieve the real parent
      handle which was stashed earlier before it was overwritten
    */
    if (sm_p->u.lookup.symlink_refn.handle ==
        sm_p->u.lookup.remaining_starting_refn.handle)
    {
        sm_p->u.lookup.remaining_starting_refn.handle =
            sm_p->u.lookup.tmp_remaining_refn.handle;

        gossip_debug(
            CLIENT_DEBUG," ADJUSTED: lookup: posting symlink getattr "
            "req on handle %Lu (parent is %Lu)\n",
            Lu(sm_p->u.lookup.symlink_refn.handle),
            Lu(sm_p->u.lookup.remaining_starting_refn.handle));
    }

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    /* fill in getattr request */
    PINT_SERVREQ_GETATTR_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->u.lookup.symlink_refn.fs_id,
        sm_p->u.lookup.symlink_refn.handle,
        (PVFS_ATTR_COMMON_ALL | PVFS_ATTR_SYMLNK_ALL));

    /* fill in msgpair structure components */
    msg_p->fs_id   = sm_p->u.lookup.symlink_refn.fs_id;
    msg_p->handle  = sm_p->u.lookup.symlink_refn.handle;
    msg_p->comp_fn = lookup_symlink_getattr_comp_fn;

    ret = PINT_bucket_map_to_server(&msg_p->svr_addr,
                                    msg_p->handle,
                                    msg_p->fs_id);
    if (ret != 0)
    {
	gossip_err("Error: failure mapping to server.\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* TODO: real error handling */
    }
    return 1;
}

static int lookup_symlink_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index)
{
    PVFS_object_attr *attr = NULL;
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_symlink_getattr_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_GETATTR);

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    attr = (sm_p->acache_hit ?
            &sm_p->pinode->attr :
            &resp_p->u.getattr.attr);
    assert(attr);

    /* more sanity checks */
    assert(attr->objtype == PVFS_TYPE_SYMLINK);
    assert(attr->mask & PVFS_ATTR_SYMLNK_TARGET);
    assert(attr->u.sym.target_path_len > 0);
    assert(attr->u.sym.target_path);

    /*
      re-load state to continue processing as normal
      now that we have a new pathname to resolve;

      note: the remaining_starting_refn was already
      set by the previous lookup_msg_comp_fn call.
    */
    memset(sm_p->u.lookup.remaining_pathname, 0,
           PVFS_SEGMENT_MAX);
    strncpy(sm_p->u.lookup.remaining_pathname,
            attr->u.sym.target_path, PVFS_SEGMENT_MAX);
    assert(sm_p->u.lookup.remaining_pathname);

    sm_p->u.lookup.num_segments =
        PINT_string_count_segments(sm_p->u.lookup.remaining_pathname);

    gossip_debug(CLIENT_DEBUG, "Remaining Lookup Path is %s "
                 "[ parent is %Lu|%d ]\n",
                 sm_p->u.lookup.remaining_pathname,
                 Lu(sm_p->u.lookup.remaining_starting_refn.handle),
                 sm_p->u.lookup.remaining_starting_refn.fs_id);

    /*
      adjust remaining starting path depending on if this link
      has an absolute or relative target path
    */
    if (sm_p->u.lookup.use_symlink_parent &&
        (sm_p->u.lookup.remaining_pathname[0] != '/'))
    {
        /*
          we must assert that the symlink_parent_refn was properly
          filled in by the last lookup_comp_fn
        */
        assert(sm_p->u.lookup.symlink_parent_refn.handle !=
               (PVFS_handle)0);
        assert(sm_p->u.lookup.symlink_parent_refn.fs_id !=
               (PVFS_fs_id)0);

        /*
          reset the remaining_starting_refn to where
          we last left off before symlink resolution
        */
        sm_p->u.lookup.remaining_starting_refn =
            sm_p->u.lookup.symlink_parent_refn;

        gossip_debug(CLIENT_DEBUG, "Adjusted Relative Remaining "
                     "Lookup Path is %s [ parent is %Lu|%d ]\n",
                     sm_p->u.lookup.remaining_pathname,
                     Lu(sm_p->u.lookup.remaining_starting_refn.handle),
                     sm_p->u.lookup.remaining_starting_refn.fs_id);
    }
    else if (sm_p->u.lookup.remaining_pathname[0] == '/')
    {
        sm_p->u.lookup.remaining_starting_refn =
            sm_p->u.lookup.starting_refn;

        gossip_debug(CLIENT_DEBUG, "Adjusted Absolute Remaining "
                     "Lookup Path is %s [ parent is %Lu|%d ]\n",
                     sm_p->u.lookup.remaining_pathname,
                     Lu(sm_p->u.lookup.remaining_starting_refn.handle),
                     sm_p->u.lookup.remaining_starting_refn.fs_id);
    }
    sm_p->u.lookup.use_symlink_parent = 0;
    sm_p->u.lookup.symlink_parent_refn.handle = (PVFS_handle)0;
    sm_p->u.lookup.symlink_parent_refn.fs_id = (PVFS_fs_id)0;
    return 0;
}


static int lookup_symlink_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_symlink_getattr_failure\n");

    assert(sm_p->u.lookup.post_link_segment);
    free(sm_p->u.lookup.post_link_segment);
    sm_p->u.lookup.post_link_segment = NULL;
    return 1;
}

static int lookup_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "lookup state: cleanup\n");

    sm_p->error_code = js_p->error_code;

    if (sm_p->u.lookup.remaining_pathname)
    {
        free(sm_p->u.lookup.remaining_pathname);
    }

    /* mark operation as complete */
    sm_p->op_complete = 1;

    return 0;
}


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
