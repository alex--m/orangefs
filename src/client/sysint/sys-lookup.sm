/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"

#include "pinode-helper.h"
#include "pint-dcache.h"
#include "pint-servreq.h"
#include "pint-bucket.h"
#include "pcache.h"
#include "PINT-reqproto-encode.h"
#include "shared-state-methods.h"

extern job_context_id pint_client_sm_context;

enum
{
    LOOKUP_CONTINUE = 2,
    LOOKUP_SYMLINK = 3
};

/* state function prototypes */
static int lookup_init(PINT_client_sm *sm_p,
		       job_status_s *js_p);
static int lookup_check_completion(PINT_client_sm *sm_p,
                                   job_status_s *js_p);
static int lookup_msg_setup_msgpair(PINT_client_sm *sm_p,
                                    job_status_s *js_p);
static int lookup_msg_failure(PINT_client_sm *sm_p,
                              job_status_s *js_p);
static int lookup_symlink_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p);
static int lookup_symlink_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p);
static int lookup_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p);

/* completion function prototypes */
static int lookup_msg_comp_fn(void *v_p,
                              struct PVFS_server_resp *resp_p,
                              int index);
static int lookup_symlink_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index);

%%

machine pvfs2_client_lookup_sm(init,
                               lookup_check_completion,
                               lookup_msg_setup_msgpair,
			       lookup_msg_xfer_msgpair,
			       lookup_msg_failure,
                               lookup_symlink_getattr_setup_msgpair,
                               lookup_symlink_getattr_xfer_msgpair,
                               lookup_symlink_getattr_failure,
			       cleanup)
{
    state init {
	run lookup_init;
	default => lookup_msg_setup_msgpair;
    }

    state lookup_msg_setup_msgpair {
	run lookup_msg_setup_msgpair;
        success => lookup_msg_xfer_msgpair;
	default => lookup_msg_failure;
    }

    state lookup_msg_xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
	default => lookup_check_completion;
    }

    state lookup_msg_failure {
	run lookup_msg_failure;
	default => cleanup;
    }

    state lookup_check_completion {
	run lookup_check_completion;
        success => cleanup;
        LOOKUP_CONTINUE => lookup_msg_setup_msgpair;
        LOOKUP_SYMLINK => lookup_symlink_getattr_setup_msgpair;
	default => lookup_msg_failure;
    }

    state lookup_symlink_getattr_setup_msgpair {
        run lookup_symlink_getattr_setup_msgpair;
        success => lookup_symlink_getattr_xfer_msgpair;
        default => lookup_symlink_getattr_failure;
    }

    state lookup_symlink_getattr_xfer_msgpair {
	jump pvfs2_client_getattr_pcache_sm;
        success => lookup_msg_setup_msgpair;
        default => lookup_symlink_getattr_failure;
    }

    state lookup_symlink_getattr_failure {
        run lookup_symlink_getattr_failure;
        default => cleanup;
    }

    state cleanup {
        run lookup_cleanup;
        default => init;
    }
}

%%

int PVFS_sys_ref_lookup(
    PVFS_fs_id fs_id,
    char* relative_pathname,
    PVFS_pinode_reference parent,
    PVFS_credentials credentials,
    PVFS_sysresp_lookup *resp)
{
    int ret = -PVFS_EINVAL, pathlen = 0, num_segments = 0;
    PINT_client_sm *sm_p = NULL;
    PVFS_error error;

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_ref_lookup entered\n");

    /* parameter checking goes here.  assume everything from the user
     * is ok past this point.
     */
    if ((relative_pathname == NULL) || (resp == NULL))
    {
        return ret;
    }

    pathlen = strlen(relative_pathname);
    num_segments = PINT_string_count_segments(relative_pathname);

    if ((pathlen == 0) || (num_segments == 0))
    {
        return ret;
    }

    if ((pathlen > (PVFS_REQ_LIMIT_PATH_NAME_BYTES - 1)) ||
        (num_segments > PVFS_REQ_LIMIT_PATH_SEGMENT_COUNT))
    {
        gossip_lerr("Error: Filename %s is too long\n",
                    relative_pathname);
	return -PVFS_ENAMETOOLONG;
    }

    sm_p = (PINT_client_sm *) malloc(sizeof(*sm_p));
    if (sm_p == NULL)
    {
        return -PVFS_ENOMEM;
    }
    memset(sm_p, 0, sizeof(*sm_p));

    sm_p->cred_p = &credentials;
    sm_p->u.lookup.orig_pathname = relative_pathname;
    sm_p->u.lookup.starting_refn = parent;
    sm_p->u.lookup.lookup_resp = resp;
    sm_p->u.lookup.num_segments = num_segments;
    sm_p->u.lookup.remaining_pathname = (char *)
        malloc(sizeof(char) * PVFS_SEGMENT_MAX);
    assert(sm_p->u.lookup.remaining_pathname);
    strncpy(sm_p->u.lookup.remaining_pathname, relative_pathname,
            PVFS_SEGMENT_MAX);
    sm_p->u.lookup.remaining_starting_refn.fs_id = fs_id;
    sm_p->u.lookup.remaining_starting_refn.handle = parent.handle;
    sm_p->u.lookup.resolve_symlink = 0;
    sm_p->u.lookup.num_symlinks_followed = 0;

    gossip_debug(CLIENT_DEBUG, "Looking up %s under parent handle "
                 "%Lu on fs %d\n", relative_pathname, parent.handle,
                 parent.fs_id);

    ret = PINT_client_state_machine_post(sm_p, PVFS_SYS_LOOKUP);
    assert(ret == 0);

    /* while !done call progress function */
    while (!sm_p->op_complete && (ret == 0))
    {
	gossip_debug(CLIENT_DEBUG, "PVFS_sys_ref_lookup calling "
                     "PINT_client_state_machine_test()\n");
	ret = PINT_client_state_machine_test();
    }
    assert(ret == 0);

    gossip_debug(CLIENT_DEBUG, "PVFS_sys_ref_lookup completed\n");

    /* save our return value */
    error = sm_p->error_code;

    /* clean up after ourselves */
    free(sm_p);
    return error;
}

int PVFS_sys_lookup(
    PVFS_fs_id fs_id, char* name,
    PVFS_credentials credentials,
    PVFS_sysresp_lookup *resp)
{
    int ret = -EINVAL;
    PVFS_pinode_reference parent;

    if (name && resp)
    {
        parent.handle = 0;
        parent.fs_id = fs_id;

        ret = PINT_bucket_get_root_handle(parent.fs_id,&parent.handle);
        if (ret < 0)
        {
            return ret;
        }

        /* NOTE: special case is that we're doing a lookup of the root
         * handle (which we got during the getconfig) so we want to check
         * to see if we're looking up "/"; if so, then get the root handle
         * from the bucket table interface and return
         */
        if (!strcmp(name, "/"))
        {
            resp->pinode_refn.handle = parent.handle;
            resp->pinode_refn.fs_id = fs_id;
            ret = 0;
        }
        else
        {
            /*
              strip off leading slash (if any) and lookup the rest
              of the path.  NOTE: If it's always an error to not
              have a leading slash, we should check that above
              without doing this function call.
            */
            char *path = ((name[0] == '/') ? &name[1] : name);
            ret = PVFS_sys_ref_lookup(fs_id, path, parent,
                                      credentials, resp);
        }
    }
    return ret;
}

/****************************************************************/

static int lookup_init(PINT_client_sm *sm_p,
		       job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "lookup state: init\n");

    assert(js_p->error_code == 0);

    /* do the request scheduler thing, if necessary */

    return 1;
}

static int lookup_check_completion(PINT_client_sm *sm_p,
                                   job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_check_completion\n");

    /*
      at this point; if not, we hit one of several cases:
      1) the lookup_msg_comp_fn saw a symlink and we need to
         continue resolution
      2) no more segments; successful lookup
      3) need to query another meta server to continue resolution
      4) error, bad lookup (entry cannot be resolved)
    */
    if (sm_p->u.lookup.resolve_symlink)
    {
        /* continue with symlink resolution */
        js_p->error_code = LOOKUP_SYMLINK;
        sm_p->u.lookup.resolve_symlink = 0;
        if (sm_p->u.lookup.num_symlinks_followed++ >
            PVFS_REQ_LIMIT_MAX_SYMLINK_RESOLUTION_COUNT)
        {
            gossip_err("Cannot resolve more than %d symlinks; "
                       "aborting resolution and assuming infinite loop\n",
                       PVFS_REQ_LIMIT_MAX_SYMLINK_RESOLUTION_COUNT);
            sm_p->u.lookup.last_error = -PVFS_EMLINK;
            goto lookup_failure;
        }
        goto lookup_continue;
    }
    else if (sm_p->u.lookup.num_segments == 0)
    {
        /* success case: direct state machine to cleanup */
        js_p->error_code = 0;
    }
    else if (sm_p->u.lookup.last_error == 0)
    {
        /* continue looking on another meta-server */
        js_p->error_code = LOOKUP_CONTINUE;
        goto lookup_continue;
    }
    else
    {
      lookup_failure:
        /* error case: direct state machine to failure */
        js_p->error_code = (sm_p->u.lookup.last_error ?
                            sm_p->u.lookup.last_error :
                            -PVFS_ENOENT);
    }
  
  lookup_continue:

    return 1;
}

static int lookup_msg_setup_msgpair(PINT_client_sm *sm_p,
                                    job_status_s *js_p)
{
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_msg_setup_msgpair\n");

    /* clear error field in job */
    js_p->error_code = 0;

    gossip_debug(CLIENT_DEBUG," lookup: posting lookup_path req\n");

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    PINT_SERVREQ_LOOKUP_PATH_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->u.lookup.remaining_pathname,
        sm_p->u.lookup.remaining_starting_refn.fs_id,
        sm_p->u.lookup.remaining_starting_refn.handle,
        PVFS_ATTR_COMMON_ALL);

    gossip_debug(CLIENT_DEBUG,
                 "Looking up path %s under handle %Lu and fs %d\n",
                 sm_p->u.lookup.remaining_pathname,
                 sm_p->u.lookup.remaining_starting_refn.handle,
                 sm_p->u.lookup.remaining_starting_refn.fs_id);

    /* fill in msgpair structure components */
    msg_p->fs_id = sm_p->u.lookup.remaining_starting_refn.fs_id;
    msg_p->handle = sm_p->u.lookup.remaining_starting_refn.handle;
    msg_p->comp_fn = lookup_msg_comp_fn;

    if (PINT_bucket_map_to_server(&msg_p->svr_addr,
                                  msg_p->handle,
                                  msg_p->fs_id) < 0)
    {
        gossip_err("Failed to get meta server information\n");
        assert(0);
    }
    return 1;
}

static int lookup_msg_comp_fn(void *v_p,
                              struct PVFS_server_resp *resp_p,
                              int index)
{
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;
    char buf[PVFS_SEGMENT_MAX] = {0};
    
    gossip_debug(CLIENT_DEBUG, "lookup_msg_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_LOOKUP_PATH);

    /*
      If we get an error here, we need to at least partially
      process the returned attrs and handles, so just stash
      the error value in case we need it later, while resetting
      the error code to allow us to continue processing.
    */
    sm_p->u.lookup.last_error = resp_p->status;
    resp_p->status = 0;

    gossip_debug(CLIENT_DEBUG, "Got %d handle(s) & %d attr(s) returned\n",
                 resp_p->u.lookup_path.handle_count,
                 resp_p->u.lookup_path.attr_count);

    /* FIXME: INSERT ALL ATTRS IN ARRAY INTO PCACHE HERE */
    /* TODO : INSERT ALL ATTRS IN ARRAY INTO PCACHE HERE */

    /* adjust local lookup processing state */
    sm_p->u.lookup.num_segments -= resp_p->u.lookup_path.handle_count;
    assert(sm_p->u.lookup.num_segments > -1);

    if (sm_p->u.lookup.num_segments == 0)
    {
        /* check for the special case of symlink resolution */
        if (resp_p->u.lookup_path.attr_count &&
            (resp_p->u.lookup_path.attr_array[
                resp_p->u.lookup_path.attr_count - 1].objtype ==
             PVFS_TYPE_SYMLINK))
        {
            /*
              FIXME: we're not guaranteed this is always true...right?
              the tricky thing would be if the link pointed to a file on
              a different filesystem (i.e. different root dir/handle).
              this isn't supported at the moment since fs ids are not
              returned from the server along with the resolved handles.

              think about for later though, it could be cool.
            */
            sm_p->u.lookup.remaining_starting_refn =
                sm_p->u.lookup.starting_refn;

            /*
              store the symlink handle so we know which handle
              to do the symlink_getattr on
            */
            assert(resp_p->u.lookup_path.handle_count > 0);
            sm_p->u.lookup.symlink_refn.handle =
                resp_p->u.lookup_path.handle_array[
                    resp_p->u.lookup_path.handle_count - 1];

            /* FIXME: assuming fs_id same as starting point */
            sm_p->u.lookup.symlink_refn.fs_id =
                sm_p->u.lookup.starting_refn.fs_id;

            /*
              given the pinode_refn of the current symlink, our
              check_completion routine will take care of the rest
              as long as we set this flag
            */
            sm_p->u.lookup.resolve_symlink = 1;
            return 1;
        }

        /* restore the real error/success code */
        resp_p->status = sm_p->u.lookup.last_error;

        /* copy out the final looked up handle value to sys response */
        sm_p->u.lookup.lookup_resp->pinode_refn.handle =
            resp_p->u.lookup_path.handle_array[
                resp_p->u.lookup_path.handle_count - 1];
        /*
          FIXME: for now requires that the final resolved name must be
          on the same fs as the starting name to be resolved.
        */
        sm_p->u.lookup.lookup_resp->pinode_refn.fs_id =
            sm_p->u.lookup.starting_refn.fs_id;
    }
    else if ((resp_p->u.lookup_path.handle_count !=
              resp_p->u.lookup_path.attr_count))
    {
        int next_path_segment =
            ((resp_p->u.lookup_path.attr_count == 0) ? 0 :
             resp_p->u.lookup_path.handle_count);
#if 0
        /* debugging only */
        for(i = 0; i < resp_p->u.lookup_path.handle_count; i++)
        {
            gossip_debug(CLIENT_DEBUG, "[%d] Got partial lookup "
                         "Handle %Lu back\n", i,
                         resp_p->u.lookup_path.handle_array[i]);
        }
#endif
        gossip_debug(CLIENT_DEBUG, "Getting path element %d from "
                     "path %s\n", next_path_segment,
                     sm_p->u.lookup.remaining_pathname);

        /* overwrite remaining pathname with newly remaining pathname */
        snprintf(buf, PVFS_SEGMENT_MAX, "%s",
                 sm_p->u.lookup.remaining_pathname);
        memset(sm_p->u.lookup.remaining_pathname, 0, PVFS_SEGMENT_MAX);
        PINT_get_path_element(
            buf, next_path_segment,
            sm_p->u.lookup.remaining_pathname, PVFS_SEGMENT_MAX);
        assert(sm_p->u.lookup.remaining_pathname &&
               strlen(sm_p->u.lookup.remaining_pathname) > 0);

        /* update our starting lookup reference handle */
        sm_p->u.lookup.remaining_starting_refn.handle =
            resp_p->u.lookup_path.handle_array[
                resp_p->u.lookup_path.handle_count - 1];
        /*
          FIXME: will server ever pass a different fs_id ?
          lookup resp from server doesn't ever pass an fs_id back;
          if it ever does, be sure to stash that here
        */
        gossip_debug(CLIENT_DEBUG, "Remaining pathname is %s | "
                     "new starting handle is %Lu\n",
                     sm_p->u.lookup.remaining_pathname,
                     sm_p->u.lookup.remaining_starting_refn.handle);
    }
    return 1;
}

static int lookup_msg_failure(PINT_client_sm *sm_p,
                              job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "lookup state: lookup_msg_failure\n");
    return 1;
}

static int lookup_symlink_getattr_setup_msgpair(PINT_client_sm *sm_p,
                                                job_status_s *js_p)
{
    int ret = -1;
    PINT_client_sm_msgpair_state *msg_p = NULL;

    gossip_debug(CLIENT_DEBUG, "lookup state: "
                 "lookup_symlink_getattr_setup_msgpair\n");

    /* clear error field in job */
    js_p->error_code = 0;

    gossip_debug(CLIENT_DEBUG," lookup: posting symlink getattr "
                 "req on handle %Lu\n",
                 sm_p->u.lookup.remaining_starting_refn.handle);

    msg_p = &sm_p->msgpair;
    memset(msg_p, 0, sizeof(PINT_client_sm_msgpair_state));

    /* fill in getattr request */
    PINT_SERVREQ_GETATTR_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->u.lookup.symlink_refn.fs_id,
        sm_p->u.lookup.symlink_refn.handle,
        (PVFS_ATTR_COMMON_ALL | PVFS_ATTR_SYMLNK_ALL));

    /* fill in msgpair structure components */
    msg_p->fs_id   = sm_p->u.lookup.symlink_refn.fs_id;
    msg_p->handle  = sm_p->u.lookup.symlink_refn.handle;
    msg_p->comp_fn = lookup_symlink_getattr_comp_fn;

    ret = PINT_bucket_map_to_server(&msg_p->svr_addr,
                                    msg_p->handle,
                                    msg_p->fs_id);
    if (ret != 0)
    {
	gossip_err("Error: failure mapping to server.\n");
	assert(ret < 0); /* return value range check */
	assert(0); /* TODO: real error handling */
    }
    return 1;
}

static int lookup_symlink_getattr_comp_fn(
    void *v_p,
    struct PVFS_server_resp *resp_p,
    int index)
{
    PVFS_object_attr *attr = NULL;
    PINT_client_sm *sm_p = (PINT_client_sm *) v_p;

    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_symlink_getattr_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_GETATTR);

    /* if we get an error, just return immediately, don't try to
     * actually fill anything in.
     */
    if (resp_p->status != 0)
    {
	return resp_p->status;
    }

    attr = (sm_p->pcache_hit ?
            &sm_p->pinode->attr :
            &resp_p->u.getattr.attr);
    assert(attr);

    /* more sanity checks */
    assert(attr->objtype == PVFS_TYPE_SYMLINK);
    assert(attr->mask & PVFS_ATTR_SYMLNK_TARGET);
    assert(attr->u.sym.target_path_len > 0);
    assert(attr->u.sym.target_path);

    /*
      re-load state to continue processing as normal
      now that we have a new pathname to resolve;

      note: the remaining_starting_refn was already
      set by the previous lookup_msg_comp_fn call.
    */
    memset(sm_p->u.lookup.remaining_pathname, 0,
           PVFS_SEGMENT_MAX);
    strncpy(sm_p->u.lookup.remaining_pathname,
            attr->u.sym.target_path, PVFS_SEGMENT_MAX);
    sm_p->u.lookup.num_segments =
        PINT_string_count_segments(sm_p->u.lookup.remaining_pathname);

    gossip_debug(CLIENT_DEBUG, "Remaining Lookup Path is %s\n",
                 sm_p->u.lookup.remaining_pathname);

    return 0;
}


static int lookup_symlink_getattr_failure(PINT_client_sm *sm_p,
                                          job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG,
                 "lookup state: lookup_symlink_getattr_failure\n");
    return 1;
}

static int lookup_cleanup(PINT_client_sm *sm_p,
                          job_status_s *js_p)
{
    gossip_debug(CLIENT_DEBUG, "lookup state: cleanup\n");

    sm_p->error_code = js_p->error_code;

    if (sm_p->u.lookup.remaining_pathname)
    {
        free(sm_p->u.lookup.remaining_pathname);
    }

    /* mark operation as complete */
    sm_p->op_complete = 1;

    return 0;
}


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
