/* 
 * Copyright ï¿½ Acxiom Corporation, 2006
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"

extern job_context_id pint_client_sm_context;

enum
{
    CREATE_RETRY = 170
};

/* completion function prototype */
static int create_file_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);


/* misc helper functions */
static PINT_dist* get_default_distribution(PVFS_fs_id fs_id);

%%
/* this will be rewritten to just send create_file request */
machine pvfs2_client_create_file_sm
{
    state init
    {
        run create_file_init;
        success => create_file_setup_msgpair;
        default => cleanup;
    }

    state create_file_setup_msgpair
    {
        run create_file_setup_msgpair;
        success => create_file_xfer_msgpair;
        default => cleanup;
    }

    state create_file_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => cleanup;
        default => create_file_failure;
    }

    state create_file_failure
    {
        run create_file_failure;
        default => cleanup;
    } 

    state cleanup
    {
        run create_file_cleanup;
        CREATE_RETRY => init;
        default => terminate;
    }
}

%%

/* will need to edit proto struct to pass these arguments in */
/* an internal form - see constituent requests to determine */
/* proto format - create, set_attr, crdirent should have relevant */
/* formats for object_name, parent_ref, attr, dist, layout */
/** Initiate creation of a file with a specified distribution.
 */
PVFS_error PVFS_isys_create_file(
    char *object_name,
    PVFS_object_ref parent_ref,
    PVFS_sys_attr attr,
    const PVFS_credentials *credentials,
    PVFS_sys_dist *dist,
    PVFS_sys_layout *layout,
    PVFS_sysresp_create *resp,
    PVFS_sys_op_id *op_id,
    void *user_ptr)
{
    PVFS_error ret = -PVFS_EINVAL;
    PINT_smcb *smcb = NULL;
    PINT_client_sm *sm_p = NULL;
    int num_dfiles_req;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_isys_create_file entered\n");

    if ((parent_ref.handle == PVFS_HANDLE_NULL) ||
        (parent_ref.fs_id == PVFS_FS_ID_NULL) ||
        (object_name == NULL) || (resp == NULL))
    {
        gossip_err("invalid (NULL) required argument\n");
        return ret;
    }

    if ((attr.mask & PVFS_ATTR_SYS_ALL_SETABLE) != PVFS_ATTR_SYS_ALL_SETABLE)
    {
        gossip_lerr("PVFS_isys_create() failure: invalid attribute mask: %d, "
                    "expected SYS_ALL_SETABLE (%d)\n",
                    attr.mask, PVFS_ATTR_SYS_ALL_SETABLE);
        return ret;
    }

    if ((attr.mask & PVFS_ATTR_SYS_DFILE_COUNT) &&
        ((attr.dfile_count < 1) ||
         (attr.dfile_count > PVFS_REQ_LIMIT_DFILE_COUNT)))
    {
		gossip_err("Error: invalid number of datafiles (%d) specified "
                   "in PVFS_sys_create_file().\n", (int)attr.dfile_count);
		return ret;
    }

    if ((strlen(object_name) + 1) > PVFS_REQ_LIMIT_SEGMENT_BYTES)
    {
        return -PVFS_ENAMETOOLONG;
    }

    PINT_smcb_alloc(&smcb, PVFS_SYS_CREATE,
             sizeof(struct PINT_client_sm),
             client_op_state_get_machine,
             client_state_machine_terminate,
             pint_client_sm_context);
    if (smcb == NULL)
    {
        return -PVFS_ENOMEM;
    }
    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* set up the create-file request */
    PINT_init_msgarray_params(&sm_p->msgarray_params, parent_ref.fs_id);
    PINT_init_sysint_credentials(sm_p->cred_p, credentials);
    sm_p->u.create.object_name = object_name;
    sm_p->u.create.create_resp = resp;
    sm_p->u.create.datafile_handles = NULL;
    PVFS_util_copy_sys_attr(&sm_p->u.create.sys_attr, &attr);
    sm_p->u.create.stored_error_code = 0;
    sm_p->u.create.retry_count = 0;
    sm_p->parent_ref = parent_ref;

    /* copy layout to sm struct */
    if(layout)
    {
        sm_p->u.create.layout.algorithm = layout->algorithm;
        if(layout->algorithm == PVFS_SYS_LAYOUT_LIST)
        {
            sm_p->u.create.layout.server_list.count = layout->server_list.count;
            sm_p->u.create.layout.server_list.servers =
                malloc(layout->server_list.count * sizeof(PVFS_BMI_addr_t));
            if(!sm_p->u.create.layout.server_list.servers)
            {
                return -PVFS_ENOMEM;
            }
            memcpy(sm_p->u.create.layout.server_list.servers,
                   layout->server_list.servers,
                   layout->server_list.count * sizeof(PVFS_BMI_addr_t));
        }
    }
    else
    {
        sm_p->u.create.layout.algorithm = PVFS_SYS_LAYOUT_ROUND_ROBIN;
    }

    sm_p->object_ref = parent_ref;

    /* If the user specifies a distribution use that
       else, use the default distribution */
    if (dist)
    {
        if (!dist->name)
        {
            PINT_smcb_free(smcb);
            return -PVFS_EINVAL;
        }

        sm_p->u.create.dist = PINT_dist_create(dist->name);
        if (!sm_p->u.create.dist)
        {
            PINT_smcb_free(smcb);
            return -PVFS_ENOMEM;
        }
        sm_p->u.create.dist->params = dist->params;
    }
    else
    {
        /* Get the default distribution */
        sm_p->u.create.dist = get_default_distribution(sm_p->parent_ref.fs_id);
        if (!sm_p->u.create.dist)
        {
            PINT_smcb_free(smcb);
            return -PVFS_ENOMEM;
        }
    }

    /* If an application hint has been provided, use that to request dfile
       else, if a tabfile hint has been provided, use that instead*/
    num_dfiles_req = 0;
    if (attr.mask & PVFS_ATTR_SYS_DFILE_COUNT)
    {
        num_dfiles_req = attr.dfile_count;
    }
    else
    {
        /* Check the mount options */
        int rc;
        struct PVFS_sys_mntent mntent;

        rc = PVFS_util_get_mntent_copy(sm_p->object_ref.fs_id, &mntent);
        if (0 == rc)
        {
            num_dfiles_req = mntent.default_num_dfiles;
            PVFS_util_free_mntent(&mntent);
        }
    }

    /* Determine the number of dfiles, passing in client hints to
       override any server hints */
    ret = PINT_cached_config_get_num_dfiles(sm_p->object_ref.fs_id,
                                            sm_p->u.create.dist,
                                            num_dfiles_req,
                                            &sm_p->u.create.num_data_files);

    if (ret < 0)
    {
        gossip_err("Failed to get number of data servers\n");
        PINT_smcb_free(smcb);
        return ret;
    }

    gossip_debug(
        GOSSIP_CLIENT_DEBUG, "Creating file %s under %llu, %d\n",
        object_name, llu(parent_ref.handle), parent_ref.fs_id);
          
    return PINT_client_state_machine_post(
        smcb,  op_id, user_ptr);
}


/** Create a file with a specified distribution.
 */
PVFS_error PVFS_sys_create_file(
    char *object_name,
    PVFS_object_ref parent_ref,
    PVFS_sys_attr attr,
    const PVFS_credentials *credentials,
    PVFS_sys_dist *dist,
    PVFS_sys_layout *layout,
    PVFS_sysresp_create *resp)
{
    PVFS_error ret = -PVFS_EINVAL, error = 0;
    PVFS_sys_op_id op_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "PVFS_sys_create_file entered\n");

    ret = PVFS_isys_create(object_name, parent_ref, attr, credentials,
                           dist, layout, resp, &op_id, NULL);
    if (ret)
    {
        PVFS_perror_gossip("PVFS_isys_create_file call", ret);
        error = ret;
    }
    else
    {
        ret = PVFS_sys_wait(op_id, "create_file", &error);
        if (ret)
        {
            PVFS_perror_gossip("PVFS_sys_wait call", ret);
            error = ret;
        }
    }

    PINT_sys_release(op_id);
    return error;
}


static PINT_sm_action create_file_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_file state: init\n");

    assert((js_p->error_code == 0) ||
           (js_p->error_code == CREATE_RETRY));

    if (js_p->error_code == CREATE_RETRY)
    {
        js_p->error_code = 0;

        return job_req_sched_post_timer(
            sm_p->msgarray_params.retry_delay, smcb, 0, js_p, &tmp_id,
            pint_client_sm_context);
    }

   return SM_ACTION_COMPLETE;
}


static int create_file_comp_fn(void *v_p,
                               struct PVFS_server_resp *resp_p,
                               int index)
{
    PINT_smcb *smcb = v_p;
    PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_file_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CREATE);

    if (resp_p->status != 0)
    {
		return resp_p->status;
    }

    /* otherwise, just stash the newly created meta handle */
    sm_p->u.create.metafile_handle = resp_p->u.create.handle;

    gossip_debug(
        GOSSIP_CLIENT_DEBUG, "*** Got newly created handle %llu\n",
        llu(sm_p->u.create.metafile_handle));

    return 0;
}


static PINT_sm_action create_file_setup_msgpair(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    PVFS_handle_extent_array meta_handle_extent_array;
    PINT_sm_msgpair_state *msg_p = NULL;
    struct server_configuration_s *server_config = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_file state: "
                 "create_file_setup_msgpair\n");

    js_p->error_code = 0;

    if (sm_p->u.create.num_data_files > PVFS_REQ_LIMIT_DFILE_COUNT)
    {
        sm_p->u.create.num_data_files = PVFS_REQ_LIMIT_DFILE_COUNT;
        gossip_err("Warning: reducing number of data "
                     "files to PVFS_REQ_LIMIT_DFILE_COUNT\n");
    }

    gossip_debug(GOSSIP_CLIENT_DEBUG, "need to create %d datafiles\n",
                 sm_p->u.create.num_data_files);

    gossip_debug(GOSSIP_CLIENT_DEBUG," create_file: posting create-file req\n");

    PINT_init_msgpair(sm_p, msg_p);

    server_config = PINT_get_server_config_struct(
        sm_p->object_ref.fs_id);

    ret = PINT_cached_config_get_next_meta(
        server_config, sm_p->object_ref.fs_id,
        &msg_p->svr_addr, &meta_handle_extent_array);

    PINT_put_server_config_struct(server_config);

    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /* set up create-file request */
    PINT_SERVREQ_CREATE_FILE_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->object_ref.fs_id,
        sm_p->parent_ref.handle,
        sm_p->u.create_file.object_name,
        sm_p->u.create_file.attr,
        PVFS_ATTR_META_ALL /*sm_p->u.create_file.sys_attr*/,
        sm_p->u.create_file.dist,
        sm_p->u.create_file.num_data_files,
        meta_handle_extent_array);

    msg_p->fs_id = sm_p->object_ref.fs_id;
    msg_p->handle = meta_handle_extent_array.extent_array[0].first;
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = create_file_comp_fn;

    return SM_ACTION_COMPLETE;
}


static PINT_sm_action create_file_failure(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    sm_p->u.create.stored_error_code = js_p->error_code;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create_file state: request failure error=%d\n", 
                 sm_p->u.create.stored_error_code);
    return SM_ACTION_COMPLETE;
}


/* you need a cleanup function - use this as a template */
static PINT_sm_action create_file_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_ref metafile_ref;
    PVFS_size tmp_size = 0;
    int ret;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_file state: cleanup\n");

    PVFS_util_release_sys_attr(&sm_p->u.create.sys_attr);

   /* PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);  ??? */

    sm_p->error_code = (sm_p->u.create.stored_error_code ?
                        sm_p->u.create.stored_error_code :
                        js_p->error_code);

    memset(&metafile_ref, 0, sizeof(metafile_ref));

    if (sm_p->error_code == 0)
    {
        metafile_ref.handle = sm_p->u.create.metafile_handle;
        metafile_ref.fs_id = sm_p->object_ref.fs_id;

        /* fill in outgoing response fields */
        sm_p->u.create.create_resp->ref = metafile_ref;

        /* insert newly created metafile into the ncache */
        PINT_ncache_update((const char*) sm_p->u.create.object_name, 
                           (const PVFS_object_ref*) &metafile_ref, 
                           (const PVFS_object_ref*) &(sm_p->object_ref));

        /* we only insert a cache entry if the entire create succeeds,
         * i.e. crdirent succeeded.  set size to 0 */
        ret = PINT_acache_update(metafile_ref,
                                 &sm_p->u.create.cache_attr, /*where filled???*/
                                 &tmp_size);
        if(ret < 0)
        {
            js_p->error_code = ret;
        }
    }
    else if ((PVFS_ERROR_CLASS(-sm_p->error_code) == PVFS_ERROR_BMI) &&
             (sm_p->u.create.retry_count < sm_p->msgarray_params.retry_limit))
    {
        sm_p->u.create.stored_error_code = 0;
        sm_p->u.create.retry_count++;

        gossip_debug(GOSSIP_CLIENT_DEBUG, "Retrying create operation "
                     "(attempt number %d)\n", sm_p->u.create.retry_count);

        js_p->error_code = CREATE_RETRY;
        return SM_ACTION_COMPLETE;
    }

    PINT_free_object_attr(&sm_p->u.create.cache_attr);

    if (sm_p->u.create.io_handle_extent_array)
    {
        free(sm_p->u.create.io_handle_extent_array);
        sm_p->u.create.io_handle_extent_array = NULL;
    }

    if (sm_p->u.create.data_server_addrs)
    {
        free(sm_p->u.create.data_server_addrs);
        sm_p->u.create.data_server_addrs = NULL;
    }

    if (sm_p->u.create.datafile_handles)
    {
        free(sm_p->u.create.datafile_handles);
        sm_p->u.create.datafile_handles = NULL;
    }

    if (sm_p->u.create.dist)
    {
        PINT_dist_free(sm_p->u.create.dist);
        sm_p->u.create.dist = NULL;
    }

    if(sm_p->u.create.layout.algorithm == PVFS_SYS_LAYOUT_LIST)
    {
        free(sm_p->u.create.layout.server_list.servers);
    }

    if (sm_p->msgarray != &(sm_p->msgpair))
    {
        free(sm_p->msgarray);
        sm_p->msgarray = NULL;
    }

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}



/**
 * Returns the default distribution, or NULL if the distribution could not
 * be created.  The default distribution is read from the server
 * configuration if possible.  If the server config does not specify a
 * default distribution, simple_stripe will be used.
 */
static PINT_dist* get_default_distribution(PVFS_fs_id fs_id)
{
    server_configuration_s* server_config = NULL;
    PINT_dist* dist = NULL;

    /* Retrieve the server configuration (with mutex) */
    server_config = PINT_get_server_config_struct(fs_id);

    /* If a default dist is specified in the config, use that
       else just create a simple_stripe distribution */
    if (NULL != server_config &&
        NULL != server_config->default_dist_config.name)
    {
        dist = PINT_dist_create(server_config->default_dist_config.name);
        
        if (dist)
        {
            PINT_llist_p iter = server_config->default_dist_config.param_list;

            /* Set supplied the distribution parameters */
            while (iter)
            {
                int rc;
                distribution_param_configuration* param =PINT_llist_head(iter);

                /* If we are at the list end, break
                   else, set the distribution parameter to the given value */
                if (NULL == param)
                {
                    break;
                }
                else
                {
                    rc = dist->methods->set_param(dist->dist_name,
                                                  dist->params,
                                                  param->name,
                                                  &param->value);

                    if (0 != rc)
                    {
                        gossip_err("Error setting distribution parameter\n"
                                   "  dist: %s\n"
                                   "  param name: %s\n"
                                   "  param value: %lld\n",
                                   dist->dist_name, param->name,
                                   lld(param->value));
                    }
                }
                iter = PINT_llist_next(iter);
            }                
        }
        else
        {
            gossip_err("Error creating default distribution: %s\n",
                       server_config->default_dist_config.name);
        }
    }
    else
    {
        dist = PINT_dist_create(PVFS_DIST_SIMPLE_STRIPE_NAME);
    }

    /* Release the server config mutex */
    PINT_put_server_config_struct(server_config);

    return dist;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
