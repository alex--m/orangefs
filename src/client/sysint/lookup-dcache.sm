/* 
 * (C) 2003 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_client_getattr_pcache_sm
 *
 * The purpose of this state machine is to resolve a segment (one component
 * of a path) and a parent handle down to an object handle.  This object handle
 * might already be present in a local cache (the dcache) or could be obtained
 * from a remote server.
 *
 * This state machine uses the msgpair structure in the PINT_client_sm
 * structure in order to perform the message passing.  It assumes that this
 * has been previously set up by the state machine above this one.  In particular
 * the following fields of the msgpair structure must be filled in:
 * - req (unencoded lookup request)
 * - fs_id
 * - handle
 * - comp_fn - called to pull attributes out of decoded response and store
 *   them in the appropriate place for the state machine jumping to this one
 *   (e.g. copies object handle out in the remove case)
 *
 * This state machine in turns jumps to the pvfs2_client_msgpair_sm to perform
 * messaging, if necessary.
 *
 * NOTE: the comp_fn can cause a non-zero error_code to be passed back up from
 *       the msgpair state machine and through this state machine back to the
 *       one that jumped to here.  so be aware!
 *
 * TODO: sometimes we will get new attributes back with the lookup response.
 *       we should add these into the pcache as appropriate.
 */

#include <string.h>
#include <assert.h>

#include "client-state-machine.h"
#include "state-machine-fns.h"
#include "pvfs2-debug.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"

#include "pint-servreq.h"
#include "pint-dcache.h"
#include "PINT-reqproto-encode.h"

enum {
    LOOKUP_DCACHE_MISS = 1
};

static int lookup_dcache_lookup(PINT_client_sm *sm_p,
				job_status_s *js_p);

%%

nested machine pvfs2_client_lookup_dcache_sm(lookup,
					     xfer_msgpair)
{
    state lookup {
	run lookup_dcache_lookup;
	success => return;
	LOOKUP_DCACHE_MISS => xfer_msgpair;
	default => return;
    }

    state xfer_msgpair {
	jump pvfs2_client_msgpair_sm;
	default => return;
    }
}

%%

/* lookup_dcache_lookup()
 */
static int lookup_dcache_lookup(PINT_client_sm *sm_p,
				job_status_s *js_p)
{
    int ret;
    PVFS_pinode_reference parent_ref, object_ref;

    gossip_debug(CLIENT_DEBUG, "lookup_dcache state: lookup\n");

    assert(js_p->error_code == 0); /* sanity check */

    /* for now we don't want to deal with anything with more than one
     * segment.
     */
    assert(PINT_string_count_segments(sm_p->u.remove.object_name) <= 1);

    parent_ref.fs_id  = sm_p->msgpair.fs_id;
    parent_ref.handle = sm_p->msgpair.handle;

    ret = PINT_dcache_lookup(sm_p->msgpair.req.u.lookup_path.path,
			     parent_ref,
			     &object_ref);
    if (ret == PCACHE_LOOKUP_SUCCESS) {
	/* TODO: GET RID OF THIS ENUM AND ENSURE THAT RETURN VALUE
	 *       CONVENTION IS OK.
	 */
	struct PVFS_server_resp fake_resp;

	/* build a fake response, call the completion function on it */
	fake_resp.op = PVFS_SERV_LOOKUP_PATH;
	fake_resp.status = 0;
	fake_resp.u.lookup_path.handle_array = &object_ref.handle;
	fake_resp.u.lookup_path.attr_array   = NULL; /* hope this is ok! */
	fake_resp.u.lookup_path.handle_count = 1;
	fake_resp.u.lookup_path.attr_count   = 0;

	ret = sm_p->msgpair.comp_fn(sm_p, &fake_resp, 0);
	return 1;
    }

    /* miss; need to look up */

    js_p->error_code = LOOKUP_DCACHE_MISS;
    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
