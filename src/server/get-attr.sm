/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_get_attr_sm
 *
 * This state machine handles incoming server getattr operations.  These
 * are the operations sent by PVFS_sys_getattr() among others.
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-types-debug.h"

enum
{
    STATE_METAFILE = 7,
    STATE_SYMLINK  = 9
};

static inline char *get_object_type(int objtype)
{
    static char *obj_types[] =
    {
        "NONE", "METAFILE", "DATAFILE",
        "DIRECTORY", "SYMLINK", "DIRDATA", "UNKNOWN"
    };

    switch(objtype)
    {
        case PVFS_TYPE_NONE:
            return obj_types[0];
        case PVFS_TYPE_METAFILE:
            return obj_types[1];
        case PVFS_TYPE_DATAFILE:
            return obj_types[2];
        case PVFS_TYPE_DIRECTORY:
            return obj_types[3];
        case PVFS_TYPE_SYMLINK:
            return obj_types[4];
        case PVFS_TYPE_DIRDATA:
            return obj_types[5];
    }
    return obj_types[6];
}

static int getattr_cleanup(
    PINT_server_op *s_op, job_status_s* js_p);
static int getattr_verify_attribs(
    PINT_server_op *s_op, job_status_s* js_p);
static int getattr_read_symlink_target(
    PINT_server_op *s_op, job_status_s* js_p);
static int getattr_read_metafile_datafile_handles_if_required(
    PINT_server_op *s_op, job_status_s* js_p);
static int getattr_read_metafile_distribution_if_required(
    PINT_server_op *s_op, job_status_s* js_p);
static int getattr_setup_resp(
    PINT_server_op *s_op, job_status_s* js_p);

extern PINT_server_trove_keys_s Trove_Common_Keys[];

%%

machine pvfs2_get_attr_sm(prelude,
                          cleanup,
                          setup_resp,
                          final_response,
                          verify_attribs,
                          read_symlink_target,
                          read_metafile_datafile_handles_if_required,
                          read_metafile_distribution_if_required)
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => verify_attribs;
        default => final_response;
    }

    state verify_attribs
    {
        run getattr_verify_attribs;
        STATE_SYMLINK => read_symlink_target;
        STATE_METAFILE => read_metafile_datafile_handles_if_required;
        default => setup_resp;
    }

    state read_symlink_target
    {
        run getattr_read_symlink_target;
        default => setup_resp;
    }

    state read_metafile_datafile_handles_if_required
    {
        run getattr_read_metafile_datafile_handles_if_required;
        default => read_metafile_distribution_if_required;
    }

    state read_metafile_distribution_if_required
    {
        run getattr_read_metafile_distribution_if_required;
        default => setup_resp;
    }

    state setup_resp
    {
        run getattr_setup_resp;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run getattr_cleanup;
        default => terminate;
    }
}

%%

/* getattr_verify_attribs()
 *
 * We initialize the attribute mask that will be returned in this function.
 * This mask can be augmented in some of the other states.
 */
static int getattr_verify_attribs(PINT_server_op *s_op, job_status_s* js_p)
{
    PVFS_object_attr *resp_attr = NULL;

    PINT_STATE_DEBUG("verify_attribs");

    js_p->error_code = 0;

    /*
      explicitly copy basic attributes structure (read in from the
      prelude.sm for the matching dspace) into response to be sent
      back to the client.  this is mostly for readability here to be
      sure we know which fields are valid in the response at this
      point.
    */
    resp_attr = &s_op->resp.u.getattr.attr;
    memset(resp_attr, 0, sizeof(PVFS_object_attr));

    resp_attr->owner = s_op->attr.owner;
    resp_attr->group = s_op->attr.group;
    resp_attr->perms = s_op->attr.perms;
    resp_attr->atime = s_op->attr.atime;
    resp_attr->mtime = s_op->attr.mtime;
    resp_attr->ctime = s_op->attr.ctime;
    resp_attr->mask = s_op->attr.mask;
    resp_attr->objtype = s_op->attr.objtype;
    resp_attr->u.meta.dfile_count = s_op->attr.u.meta.dfile_count;
    resp_attr->u.meta.dist_size = s_op->attr.u.meta.dist_size;

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "+ attrs read from dspace: (owner = %d, group = %d, "
                 "perms = %o, type = %d\n   atime = %Ld, mtime = %Ld, "
                 "ctime = %Ld |\n   dfile_count = %d | dist_size = %d)\n",
                 resp_attr->owner, resp_attr->group, resp_attr->perms,
                 resp_attr->objtype, Ld(resp_attr->atime),
                 Ld(resp_attr->mtime), Ld(resp_attr->ctime),
                 (int)resp_attr->u.meta.dfile_count,
                 (int)resp_attr->u.meta.dist_size);

    /*
      weed out the attr mask of the response based on what the client
      request asked for.  also, check if we need to retrieve more
      information before returning the response to the client (by
      guiding the state machine to get it).

      we can safely do this now that we have the type of the object
      (read in from the dspace, not stored in the resp_attr), and we
      have the original client request attr mask
      (s_op->req->u.getattr.attrmask).
    */
    if (resp_attr->objtype == PVFS_TYPE_METAFILE)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  Req handle %Lu refers to a metafile\n",
                     Lu(s_op->req->u.getattr.handle));

        if (s_op->req->u.getattr.attrmask & PVFS_ATTR_META_DFILES)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         " dspace has dfile_count of %d\n",
                         resp_attr->u.meta.dfile_count);
            resp_attr->mask |= PVFS_ATTR_META_DFILES;
        }
        else
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, " client doesn't want "
                         "dfile info, clearing response attr mask\n");
            resp_attr->mask &= ~PVFS_ATTR_META_DFILES;
        }

        if (s_op->req->u.getattr.attrmask & PVFS_ATTR_META_DIST)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         " dspace has dist size of %d\n",
                         resp_attr->u.meta.dist_size);

            resp_attr->mask |= PVFS_ATTR_META_DIST;
        }
        else
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, " client doesn't want "
                         "dist info, clearing response attr mask\n");

            resp_attr->mask &= ~PVFS_ATTR_META_DIST;
        }

        if ((resp_attr->mask & PVFS_ATTR_META_DFILES) ||
            (resp_attr->mask & PVFS_ATTR_META_DIST))
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, " * client wants extra "
                         "meta info, about to retrieve it now\n");
            js_p->error_code = STATE_METAFILE;
        }
        else
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG, " * client doesn't want "
                         "extra meta info, preparing response now\n");
        }
    }
    else if (resp_attr->objtype == PVFS_TYPE_DATAFILE)
    {
        /*
          note: the prelude already retrieved the size for us, so
          there's no special action that needs to be taken if we have
          a datafile here (other than adjusting our mask to include
          the data information and copying the retrieved size from the
          ds_attribute the prelude used)
        */
        resp_attr->u.data.size = s_op->ds_attr.b_size;
        resp_attr->mask |= PVFS_ATTR_DATA_ALL;

	gossip_debug(GOSSIP_GETATTR_DEBUG, "  handle %Lu refers to "
                     "a datafile (size = %Ld).\n",
                     Lu(s_op->req->u.getattr.handle),
                     Ld(resp_attr->u.data.size));
    }
    else if (resp_attr->objtype == PVFS_TYPE_DIRECTORY)
    {
	gossip_debug(
            GOSSIP_GETATTR_DEBUG, "  handle %Lu refers to "
            "a directory. doing nothing special\n",
            Lu(s_op->req->u.getattr.handle));
        assert(resp_attr->mask & PVFS_ATTR_COMMON_ALL);
    }
    else if (resp_attr->objtype == PVFS_TYPE_DIRDATA)
    {
	gossip_debug(
            GOSSIP_GETATTR_DEBUG, "  handle %Lu refers to "
            "a dirdata object. doing nothing special\n",
            Lu(s_op->req->u.getattr.handle));
        assert(resp_attr->mask & PVFS_ATTR_COMMON_ALL);
    }
    else if (resp_attr->objtype == PVFS_TYPE_SYMLINK)
    {
	gossip_debug(
            GOSSIP_GETATTR_DEBUG, "  handle %Lu refers to a symlink.\n",
            Lu(s_op->req->u.getattr.handle));

        /*
          we'll definitely have to fetch the symlink target in this
          case, as the prelude will never retrieve it for us
        */
        js_p->error_code = STATE_SYMLINK;
    }
    else
    {
	gossip_debug(
            GOSSIP_GETATTR_DEBUG, "  handle %Lu refers to something "
            "unknown -- assuming datafile!\n",
            Lu(s_op->req->u.getattr.handle));

        resp_attr->objtype = PVFS_TYPE_DATAFILE;
        resp_attr->u.data.size = s_op->ds_attr.b_size;
        resp_attr->mask |= (PVFS_ATTR_COMMON_TYPE | PVFS_ATTR_DATA_ALL);

	gossip_debug(GOSSIP_GETATTR_DEBUG, "  handle %Lu now refers to "
                     "a datafile (size = %Ld).\n",
                     Lu(s_op->req->u.getattr.handle),
                     Ld(resp_attr->u.data.size));
    }
    return 1;
}

static int getattr_read_symlink_target(
    PINT_server_op *s_op, job_status_s* js_p)
{
    int ret;
    job_id_t i;

    PINT_STATE_DEBUG("read_symlink_target");

    /* if we don't need to fill in the symlink target, skip it */
    if (!(s_op->req->u.getattr.attrmask & PVFS_ATTR_SYMLNK_TARGET))
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "skipping symlink target read\n");
        js_p->error_code = 0;
        return 1;
    }

    s_op->key.buffer    = Trove_Common_Keys[SYMLINK_TARGET_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[SYMLINK_TARGET_KEY].size;

    /*
      optimistically add mask value to indicate the symlink target is
      filled (error_code is checked in next state)
    */
    s_op->resp.u.getattr.attr.mask |= PVFS_ATTR_SYMLNK_TARGET;

    s_op->resp.u.getattr.attr.u.sym.target_path_len = PVFS_NAME_MAX;
    s_op->resp.u.getattr.attr.u.sym.target_path =
	malloc(s_op->resp.u.getattr.attr.u.sym.target_path_len);
    if (!s_op->resp.u.getattr.attr.u.sym.target_path)
    {
	js_p->error_code = -PVFS_ENOMEM;
	return(1);
    }

    s_op->val.buffer    = s_op->resp.u.getattr.attr.u.sym.target_path;
    s_op->val.buffer_sz = s_op->resp.u.getattr.attr.u.sym.target_path_len;

    ret = job_trove_keyval_read(
        s_op->req->u.getattr.fs_id,
        s_op->req->u.getattr.handle,
        &(s_op->key),
        &(s_op->val),
        0,
        NULL,
        s_op,
        0,
        js_p,
        &i,
        server_job_context);

    return ret;
}


static int getattr_read_metafile_datafile_handles_if_required(
    PINT_server_op *s_op, job_status_s* js_p)
{
    int dfile_count;
    int ret;
    job_id_t i;

    PINT_STATE_DEBUG("read_metafile_datafile_handles_if_required");

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);

    js_p->error_code = 0;

    /* if we don't need to fill in the dfiles, skip them */
    if (!(s_op->req->u.getattr.attrmask & PVFS_ATTR_META_DFILES))
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "skipping data handle read\n");
        return 1;
    }

    dfile_count = s_op->resp.u.getattr.attr.u.meta.dfile_count;

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 " request has dfile_count of %d | dspace has %d\n",
                 s_op->resp.u.getattr.attr.u.meta.dfile_count,
                 s_op->resp.u.getattr.attr.u.meta.dfile_count);

    /* verify that the retrieved dfile count is sane */
    if (!PVFS_REQ_LIMIT_DFILE_COUNT_IS_VALID(dfile_count))
    {
        gossip_err("The requested dfile count of %d is invalid; "
                   "aborting operation.\n", dfile_count);
	gossip_err( "+ attrs read from dspace: (owner = %d, group = %d, "
		     "perms = %o, type = %d\n   atime = %Ld, mtime = %Ld, "
		     "ctime = %Ld |\n   dfile_count = %d | dist_size = %d)\n",
		     s_op->resp.u.getattr.attr.owner,
		     s_op->resp.u.getattr.attr.group, 
		     s_op->resp.u.getattr.attr.perms,
		     s_op->resp.u.getattr.attr.objtype, 
		     Ld(s_op->resp.u.getattr.attr.atime),
		     Ld(s_op->resp.u.getattr.attr.mtime), 
		     Ld(s_op->resp.u.getattr.attr.ctime),
		     (int)s_op->resp.u.getattr.attr.u.meta.dfile_count,
		     (int)s_op->resp.u.getattr.attr.u.meta.dist_size);
	gossip_err("handle: %Lu (%Lx), fsid: %d.\n",
	    Lu(s_op->req->u.getattr.handle),
	    Lu(s_op->req->u.getattr.handle),
	    (int)s_op->req->u.getattr.fs_id);


	js_p->error_code = -PVFS_EOVERFLOW;
	return 1;
    }

    s_op->key.buffer    = Trove_Common_Keys[METAFILE_HANDLES_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[METAFILE_HANDLES_KEY].size;

    /* add mask value to indicate the data file array is filled */
    s_op->resp.u.getattr.attr.mask |= PVFS_ATTR_META_DFILES;

    s_op->resp.u.getattr.attr.u.meta.dfile_array =
        malloc(dfile_count * sizeof(PVFS_handle));
    if (!s_op->resp.u.getattr.attr.u.meta.dfile_array)
    {
        gossip_err("Cannot allocate dfile array of count %d\n",
                   dfile_count);
	js_p->error_code = -PVFS_ENOMEM;
	return 1;
    }

    s_op->val.buffer    = s_op->resp.u.getattr.attr.u.meta.dfile_array;
    s_op->val.buffer_sz = (dfile_count * sizeof(PVFS_handle));

    gossip_debug(GOSSIP_GETATTR_DEBUG,
		 "  reading %d datafile handles (coll_id = %d, "
                 "handle = %Lu, key = %s (%d), val_buf = %p (%d))\n",
		 dfile_count,
		 s_op->req->u.getattr.fs_id,
		 Lu(s_op->req->u.getattr.handle),
		 (char *) s_op->key.buffer,
		 s_op->key.buffer_sz,
		 s_op->val.buffer,
		 s_op->val.buffer_sz);

    ret = job_trove_keyval_read(
        s_op->req->u.getattr.fs_id,
        s_op->req->u.getattr.handle,
        &s_op->key,
        &s_op->val,
        0,
        NULL,
        s_op,
        0,
        js_p,
        &i,
        server_job_context);

    return ret;
}

static int getattr_read_metafile_distribution_if_required(
    PINT_server_op *s_op, job_status_s* js_p)
{
    int ret;
    job_id_t i;

    PINT_STATE_DEBUG("read_metafile_distribution_if_required");

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);

    js_p->error_code = 0;

    /* if we don't need to fill in the distribution, skip it */
    if (!(s_op->req->u.getattr.attrmask & PVFS_ATTR_META_DIST))
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG, "skipping data handle "
                     "distribution read\n");
        return 1;
    }

    s_op->key.buffer    = Trove_Common_Keys[METAFILE_DIST_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[METAFILE_DIST_KEY].size;

    /*
      there *should* be some distribution information.  if not, dump
      which handle is busted and assertion die for now while we're not
      handling this kind of error
    */
    if (s_op->resp.u.getattr.attr.u.meta.dist_size < 1)
    {
        gossip_err("Cannot Read Dist!  Got an invalid dist size for "
                   "handle %Lu,%d\n",Lu(s_op->req->u.getattr.handle),
                   s_op->req->u.getattr.fs_id);
    }
    assert(s_op->resp.u.getattr.attr.u.meta.dist_size > 0);

    /* add mask value to indicate the distribution is filled */
    s_op->resp.u.getattr.attr.mask |= PVFS_ATTR_META_DIST;

    s_op->resp.u.getattr.attr.u.meta.dist =
	malloc(s_op->resp.u.getattr.attr.u.meta.dist_size);
    if(!s_op->resp.u.getattr.attr.u.meta.dist)
    {
        gossip_err("Cannot allocate dist of size %d\n",
                   s_op->resp.u.getattr.attr.u.meta.dist_size);
	js_p->error_code = -PVFS_ENOMEM;
	return 1;
    }

    s_op->val.buffer    = s_op->resp.u.getattr.attr.u.meta.dist;
    s_op->val.buffer_sz = s_op->resp.u.getattr.attr.u.meta.dist_size;

    ret = job_trove_keyval_read(
        s_op->req->u.getattr.fs_id,
        s_op->req->u.getattr.handle,
        &(s_op->key),
        &(s_op->val),
        0,
        NULL,
        s_op,
        0,
        js_p,
        &i,
        server_job_context);

    return ret;
}

static int getattr_setup_resp(PINT_server_op *s_op, job_status_s* js_p)
{
    PVFS_object_attr *resp_attr = NULL;

    PINT_STATE_DEBUG("setup_resp");

    resp_attr = &s_op->resp.u.getattr.attr;
    
    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "- returning retrieved attrs: (owner = %d, group = %d, "
                 "perms = %o, type = %d\n  atime = %Ld, mtime = %Ld, "
                 "ctime = %Ld |\n   dfile_count = %d | dist_size = %d)\n",
                 resp_attr->owner, resp_attr->group, resp_attr->perms,
                 resp_attr->objtype, Ld(resp_attr->atime),
                 Ld(resp_attr->mtime), Ld(resp_attr->ctime),
                 (int)resp_attr->u.meta.dfile_count,
                 (int)resp_attr->u.meta.dist_size);

    if (resp_attr->objtype == PVFS_TYPE_METAFILE)
    {
        if (resp_attr->mask & PVFS_ATTR_META_DFILES)
        {
            if (resp_attr->u.meta.dfile_count)
            {
                assert(resp_attr->u.meta.dfile_array);
            }
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "  also returning %d datafile handles\n",
                         resp_attr->u.meta.dfile_count);
        }

        if (resp_attr->mask & PVFS_ATTR_META_DIST)
        {
            assert(resp_attr->u.meta.dist);
            PINT_dist_decode(resp_attr->u.meta.dist, NULL);
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "  also returning dist size of %d\n",
                         resp_attr->u.meta.dist_size);
        }
    }
    else if ((resp_attr->objtype == PVFS_TYPE_DATAFILE) &&
             (resp_attr->mask & PVFS_ATTR_DATA_SIZE))
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning data size of %Ld\n",
                     Ld(resp_attr->u.data.size));
    }
    else if ((resp_attr->objtype == PVFS_TYPE_SYMLINK) &&
             (resp_attr->mask & PVFS_ATTR_SYMLNK_TARGET))
    {
        if (js_p->error_code == 0)
        {
            assert(resp_attr->u.sym.target_path);
            assert(resp_attr->u.sym.target_path_len);
            /*
              adjust target path len down to actual size ; always
              include the null termination char in the target_path_len
            */
            resp_attr->u.sym.target_path_len =
                (strlen(resp_attr->u.sym.target_path) + 1);

            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "  also returning link target of %s (len %d)\n",
                         resp_attr->u.sym.target_path,
                         resp_attr->u.sym.target_path_len);
        }
        else
        {
            gossip_err("Failed to retrieve symlink target path for "
                       "handle %Lu,%d\n",Lu(s_op->req->u.getattr.handle),
                       s_op->req->u.getattr.fs_id);
            PVFS_perror("Symlink retrieval failure",js_p->error_code);

            js_p->error_code = -PVFS_EINVAL;
            return 1;
        }
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG,"@ End %s attributes: sending "
                 "attr status %d (error code = %d)\n",
                 get_object_type(resp_attr->objtype),
		 s_op->resp.status, js_p->error_code);

#if 0
    gossip_debug(GOSSIP_GETATTR_DEBUG, "returning attrmask ");
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG,
                        s_op->resp.u.getattr.attr.mask);
#endif

    return 1;
}

static int getattr_cleanup(PINT_server_op *s_op, job_status_s* js_p)
{
    PINT_STATE_DEBUG("getattr_cleanup");

    if (s_op->resp.u.getattr.attr.objtype == PVFS_TYPE_METAFILE)
    {
        if (s_op->resp.u.getattr.attr.mask & PVFS_ATTR_META_DFILES)
        {
            if (s_op->resp.u.getattr.attr.u.meta.dfile_array)
            {
                free(s_op->resp.u.getattr.attr.u.meta.dfile_array);
            }
        }

        if (s_op->resp.u.getattr.attr.mask & PVFS_ATTR_META_DIST)
        {
            if (s_op->resp.u.getattr.attr.u.meta.dist)
            {
                free(s_op->resp.u.getattr.attr.u.meta.dist);
            }
        }
    }

    if (s_op->resp.u.getattr.attr.objtype == PVFS_TYPE_SYMLINK)
    {
        if (s_op->resp.u.getattr.attr.mask & PVFS_ATTR_SYMLNK_TARGET)
        {
            if (s_op->resp.u.getattr.attr.u.sym.target_path)
            {
                free(s_op->resp.u.getattr.attr.u.sym.target_path);
            }
        }
    }
    return(server_state_machine_complete(s_op));
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */

