/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 *
 * Changes by Acxiom Corporation to add dirent_count field to attributes
 * Copyright Â© Acxiom Corporation, 2005.
 */

/* pvfs2_get_attr_sm
 *
 * This state machine handles incoming server getattr operations.  These
 * are the operations sent by PVFS_sys_getattr() among others.
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "pvfs2-config.h"
#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"
#include "pint-security.h"
#include "security-util.h"
#include "pint-uid-map.h"
#include "check.h"
#include "capcache.h"

/* this was defined as a handle const - we have those in pvfs2-handle.h */
/* static uint64_t UINT64_HIGH = 0xffffffffffffffffULL; */

#if defined(ENABLE_SECURITY_KEY) || defined(ENABLE_SECURITY_CERT)
#define ENABLE_SECURITY_MODE
#endif

/* These are defined in src/common/misc/pvfs2-internal.h
 * This table SHOULD be defined using macros not the strings
 * See Trove_Common_Keys in src/server/pvfs2-server.c
 * This should be fixed as soon as possible
 */

PINT_server_trove_keys_s Trove_Special_Keys[] =
{
    {"user.pvfs2.dist_name"    , SPECIAL_DIST_NAME_KEYLEN},
    {"user.pvfs2.dist_params"  , SPECIAL_DIST_PARAMS_KEYLEN},
    {"user.pvfs2.num_dfiles"   , SPECIAL_DEFAULT_NUM_DFILES_KEYLEN},
    {"user.pvfs2.meta_hint"    , SPECIAL_METAFILE_HINT_KEYLEN},
    {"user.pvfs2.mirror.copies", SPECIAL_MIRROR_COPIES_KEYLEN},
    {"user.pvfs2.mirror.handles", SPECIAL_MIRROR_HANDLES_KEYLEN},
    {"user.pvfs2.mirror.status" , SPECIAL_MIRROR_STATUS_KEYLEN},
};

enum
{
    STATE_METAFILE   = 7,
    STATE_SYMLINK    = 9,
    STATE_DIR        = 10,
    STATE_DIR_HINT   = 11,
    STATE_DONE       = 12,
    SKIP_NEXT_STATE  = 13,
    STATE_CAPABILITY = 14,
    STATE_DIRDATA    = 15,
    STATE_DATA_SIZE  = 16,
};

static void free_nested_getattr_data(struct PINT_server_op *s_op);
static void free_keyval_buffers(struct PINT_server_op *s_op);

%%

nested machine pvfs2_get_attr_work_sm
{
    state verify_attribs
    {
        run getattr_verify_attribs;
        STATE_SYMLINK => read_symlink_target;
        STATE_METAFILE => read_datafile_handles;
        STATE_DIR => get_bitmap_and_dirdata_handles;
        default => setup_resp;
        /* STATE_DIR => get_dist_dir_attr; */
        /* STATE_DIRDATA => get_dirent_count; */
    }

/* SYMLINK */

    state read_symlink_target
    {
        run getattr_read_symlink_target;
        default => check_if_capability_required;
    }

/* METAFILE */

/*
    state read_metafile_hint
    {
        run getattr_read_metafile_hint;
        default => interpret_metafile_hint;
    }

    state interpret_metafile_hint
    {
        run getattr_interpret_metafile_hint;
        STATE_METAFILE => read_metafile_datafile_handles_if_required;
        default => check_if_capability_required;
        default => read_datafile_handles;
    }
*/

    state read_datafile_handles
    {
        run getattr_read_datafile_handles;
        success => datafile_handles_safety_check;
        default => check_if_capability_required;
    }

    state datafile_handles_safety_check
    {
        run getattr_datafile_handles_safety_check;
        default => read_metafile_distribution;
        /*
         success => read_mirrored_copies_count_if_required; 
         default => check_if_capability_required;
         */
    }

    /* V3 should not need these states any more */
    /*
    state read_mirrored_copies_count_if_required
    {
        run getattr_read_mirrored_copies_count_if_required;
        SKIP_NEXT_STATE => read_metafile_distribution_if_required;
        default => read_mirrored_handles_if_required;
    }

    state read_mirrored_handles_if_required
    {
        run getattr_read_mirrored_handles_if_required;
        SKIP_NEXT_STATE => read_metafile_distribution_if_required;
        default => mirrored_handles_safety_check;
    }
 
    state mirrored_handles_safety_check
    {
        run getattr_mirrored_handles_safety_check;
        success => read_metafile_distribution_if_required;
        default => setup_resp;
    }
    */
    /* V3 End of old states */

    state read_metafile_distribution
    {
        run getattr_read_metafile_distribution;
        default => interpret_metafile_distribution;
    }

    state interpret_metafile_distribution
    {
        run interpret_metafile_distribution;
        default => check_if_capability_required;
    }

/*
    state detect_stuffed
    {
        run getattr_detect_stuffed;
        default => read_stuffed_size;
    }

    state read_stuffed_size
    {
        run getattr_read_stuffed_size;
        success => interpret_stuffed_size;
        default => check_if_capability_required;
    }

    state interpret_stuffed_size
    {
        run getattr_interpret_stuffed_size;
        default => check_if_capability_required;
    }
*/

/* DIRECTORY */

/* V3 dist_dir_attr is no longer part of the ds attributes
 * remove this state
 */
/*
    state get_dist_dir_attr
    {
        run getattr_get_dist_dir_attr;
        STATE_DIR_HINT => get_dir_hint;
        default => get_bitmap_and_dirdata_handles;
    }
*/

    state get_bitmap_and_dirdata_handles
    {
        run getattr_get_bitmap_and_dirdata_handles;
        success => get_dir_hint;
        default => check_if_capability_required;
    }

    state get_dir_hint
    {
        run getattr_get_dir_hint;
        STATE_DONE => check_if_capability_required;
        default => interpret_dir_hint;
    }

    state interpret_dir_hint
    {
        run getattr_interpret_dir_hint;
        default => check_if_capability_required;
    }

/* DIRDATA */
/*
    state get_dirent_count
    {
        run getattr_get_dirent_count;
        STATE_DONE => check_if_capability_required;
        default => interpret_dirent_count;
    }

    state interpret_dirent_count
    {
        run getattr_interpret_dirent_count;
        default => check_if_capability_required;
    }
*/


/* PERMISSIONS */

    state check_if_capability_required
    {
        run getattr_check_if_capability_required;
        STATE_CAPABILITY => read_acl;
        default => setup_resp;
    }

    state read_acl
    {
        run getattr_read_acl;
        default => create_capability;
    }

    state create_capability
    {
        run getattr_create_capability;
        default => setup_resp;
    }

    state setup_resp
    {
        run getattr_setup_resp;
        default => return;
    }
}

nested machine pvfs2_get_attr_with_prelude_sm
{
    state init
    {
        run getattr_with_prelude_init;
        default => prelude;
    }

    state prelude
    {
        jump pvfs2_prelude_sm;
        success => setup_op;
        default => return;
    }

    state setup_op
    {
        run getattr_setup_op;
        default => do_work;
    }

    state do_work
    {
        jump pvfs2_get_attr_work_sm;
        default => return;
    }
}

machine pvfs2_get_attr_sm
{
    state work
    {
        jump pvfs2_get_attr_with_prelude_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run getattr_cleanup;
        default => terminate;
    }
}

%%



/* getattr_verify_attribs()
 *
 * We initialize the attribute mask that will be returned in this
 * function.  This mask can be augmented in some of the other states.
 */
static PINT_sm_action getattr_verify_attribs(struct PINT_smcb *smcb,
                                             job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = NULL;

    js_p->error_code = 0;

    /*
     * explicitly copy basic attributes structure (read in from the
     * prelude.sm for the matching dspace) into response to be sent
     * back to the client.  this is mostly for readability here to be
     * sure we know which fields are valid in the response at this
     * point. - NOW done in bulk because it is much more likely that we
     * fail to add new fields than have a hard time understanding the
     * fields.
    */
    respattr = &s_op->resp.u.getattr.attr;
    memset(respattr, 0, sizeof(PVFS_object_attr));

    PINT_copy_object_attr_fixed(respattr, &s_op->attr);

    /* this apparently needs a special computation */
    respattr->mtime = PINT_util_mkversion_time(s_op->attr.mtime);
    if (respattr->mtime == 0)
    {
        /*
         * this is a compatibility hack to allow existing storage
         * spaces to be automagically converted to this versioned time
         * on-disk format slowly over time and doing the right thing in
         * the meantime
         */
        respattr->mtime = s_op->attr.mtime;

        gossip_debug(GOSSIP_GETATTR_DEBUG, " No version found!  Using "
                     "mtime %llu\n", llu(respattr->mtime));
    }
    else
    {
        gossip_debug(
            GOSSIP_GETATTR_DEBUG, " VERSION is %llu, mtime is %llu\n",
            llu(s_op->attr.mtime), llu(respattr->mtime));
    }

    gossip_debug(
        GOSSIP_GETATTR_DEBUG,
        "+  _DSPACE_ retrieved attrs: [mask = 0x%08x, owner = %d, group = %d\n\t"
        "perms = %o, type = %d, atime = %llu, mtime = %llu\n\t"
        "ctime = %llu, ntime = %llu, dfile_count = %d, dist_size = %d]\n",
        respattr->mask,
        respattr->owner, respattr->group, respattr->perms,
        respattr->objtype, llu(respattr->atime),
        llu(respattr->mtime), llu(respattr->ctime),llu(respattr->ntime),
        (int)respattr->u.meta.dfile_count,
        (int)respattr->u.meta.dist_size);

    /*
     * weed out the attr mask of the response based on what the client
     * request asked for.  also, check if we need to retrieve more
     * information before returning the response to the client (by
     * guiding the state machine to get it).
     *
     * we can safely do this now that we have the type of the object
     * (read in from the dspace, not stored in the respattr), and we
     * have the original client request attr mask
     * (s_op->u.getattr.attrmask).
     */
    switch(respattr->objtype)
    {
        case PVFS_TYPE_METAFILE:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: metafile\n");
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "  Req handle %s refers to a metafile\n",
                         PVFS_OID_str(&s_op->u.getattr.handle));

    #if 0
            //respattr->u.meta.dfile_count = s_op->attr.u.meta.dfile_count;
            //respattr->u.meta.dist_size = s_op->attr.u.meta.dist_size;
            if (s_op->u.getattr.attrmask & PVFS_ATTR_META_DFILES)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " dspace has dfile_count of %d\n",
                             respattr->u.meta.dfile_count);
                respattr->mask |= PVFS_ATTR_META_DFILES;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG, " client doesn't want "
                             "dfile info, clearing response attr mask\n");
                respattr->mask &= ~PVFS_ATTR_META_DFILES;
            }

            if (s_op->u.getattr.attrmask & PVFS_ATTR_META_DIST)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " dspace has dist size of %d\n",
                             respattr->u.meta.dist_size);

                respattr->mask |= PVFS_ATTR_META_DIST;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG, " client doesn't want "
                             "dist info, clearing response attr mask\n");

                respattr->mask &= ~PVFS_ATTR_META_DIST;
            }

            if (s_op->u.getattr.attrmask & PVFS_ATTR_META_MIRROR_DFILES)
            {
               gossip_debug(GOSSIP_GETATTR_DEBUG,"client wants mirrored "
                                                 "handles.\n");
               respattr->mask |= PVFS_ATTR_META_MIRROR_DFILES;
               //respattr->u.meta.mirror_copies_count = 0;
               //respattr->u.meta.mirror_dfile_array  = NULL;
            }
            else
            {
               gossip_debug(GOSSIP_GETATTR_DEBUG,"client doesn't want "
                                                 "mirrored handles.\n");
               respattr->mask &= ~(PVFS_ATTR_META_MIRROR_DFILES);
            }
    #endif
            respattr->mask = PVFS_ATTR_META_ALL;
            js_p->error_code = STATE_METAFILE;
            break;


        case PVFS_TYPE_DATAFILE:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: datafile\n");
            /*
             * note: the prelude already retrieved the size for us, so
             * there's no special action that needs to be taken if we have
             * a datafile here (other than adjusting our mask to include
             * the data information and copying the retrieved size from the
             * ds_attribute the prelude used)
             */
            //respattr->u.data.size = s_op->ds_attr.u.datafile.b_size;

            gossip_debug(GOSSIP_GETATTR_DEBUG, "  handle %s refers to "
                         "a datafile (size = %lld).\n",
                         PVFS_OID_str(&s_op->u.getattr.handle),
                         lld(respattr->u.data.size));

            respattr->mask = PVFS_ATTR_DATA_ALL;
            js_p->error_code = 0;
            break;


        case PVFS_TYPE_DIRECTORY:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: directory\n");

#if 0
            /* check for Distdir struct */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DISTDIR_ATTR)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: distdir_struct needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DISTDIR_ATTR;
                js_p->error_code = STATE_DIR;
            }   
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: distdir_struct not needed.\n");
                js_p->error_code = 0;
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }   

            /* Check for Dirdata handles */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_DIRDATA)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirdata_handles needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_DIRDATA;
                js_p->error_code = STATE_DIR;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirdata_handles not needed\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }

#if 0  
  /* Becky:  removing check for dirent_count.  ASSUMPTION:for a directory type, at most, we
   * return the bitmap and dirdata handles from keyval db along with data from the 
   * PVFS_TYPE_DIRECTORY dspace record.  dirent_count is only retrieved when we
   * are processing a PVFS_TYPE_DIRDATA dspace record.
   */
            /* Check for Dirent Count */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_DIRENT_COUNT)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirent_count needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_DIRENT_COUNT;
                js_p->error_code = STATE_DIR;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dirent_count not needed\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }

#endif

            /* check fir Dir Hints */
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_HINT)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dir hint needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_HINT;
                js_p->error_code = STATE_DIR;
            }
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                            " getattr: dir hint not needed\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }
#endif
            respattr->mask = PVFS_ATTR_DIR_ALL;
            js_p->error_code = STATE_DIR;
            break;


        case PVFS_TYPE_DIRDATA:
#if 0
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: dirdata\n");
            if (s_op->u.getattr.attrmask & PVFS_ATTR_DIR_DIRENT_COUNT)
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: dirent_count needed.\n");
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
                respattr->mask |= PVFS_ATTR_DIR_DIRENT_COUNT;
         
                /* to prevent encoding of the bitmap, handles, and sids 
                 * when all we want is the dirent-count. NOTE: (1)By 
                 * default, prelude retrieves these values for 
                 * PVFS_TYPE_DIRDATA handles. (2)The most up-to-date 
                 * value for dirent-count is kept in the PVFS_TYPE_DIRDATA 
                 * dspace record.
                 */
                respattr->u.dirdata.dist_dir_attr.bitmap_size  =0;
                respattr->u.dirdata.dist_dir_attr.dirdata_count=0;
                respattr->u.dirdata.dist_dir_attr.sid_count    =0;
                js_p->error_code = 0;
            }   
            else
            {
                gossip_debug(GOSSIP_GETATTR_DEBUG,
                             " getattr: dirent_count not needed.\n");
                js_p->error_code = 0;
                assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
            }   
/*
            gossip_debug(
                GOSSIP_GETATTR_DEBUG, "  handle %s refers to "
                "a dirdata object. doing nothing special\n",
                PVFS_OID_str(&s_op->u.getattr.handle));
            assert(respattr->mask & PVFS_ATTR_COMMON_ALL);
*/
#endif
            respattr->mask = PVFS_ATTR_DIRDATA_ALL;
            js_p->error_code = 0;
            break;


        case PVFS_TYPE_SYMLINK:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: symlink\n");
            gossip_debug(
                GOSSIP_GETATTR_DEBUG, "  handle %s refers to a symlink.\n",
                PVFS_OID_str(&s_op->u.getattr.handle));

            /*
              we'll definitely have to fetch the symlink target in this
              case, as the prelude will never retrieve it for us
            */

            respattr->mask = PVFS_ATTR_SYMLNK_ALL;
            js_p->error_code = STATE_SYMLINK;
            break;


        case PVFS_TYPE_INTERNAL:
            PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG, "type: internal\n");
            /* nothing interesting to add; this is meaningless to a client */
            break;


        default:
            /* if we don't understand the object type, then it probably indicates
             * a bug or some data corruption.  All trove objects should have a
             * type set.
             */
            gossip_err(
                "Error: got unknown type when verifying attributes for "
                "handle %s.\n", 
                PVFS_OID_str(&s_op->u.getattr.handle));
            js_p->error_code = -PVFS_ENXIO;
js_p->error_code = -PVFS_ENOENT;
            break;
    }/*end switch on object type */

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_read_symlink_target(struct PINT_smcb *smcb,
                                                  job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t i;
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);

    respattr->u.sym.target_path_len = PVFS_NAME_MAX;
    respattr->u.sym.target_path = malloc(respattr->u.sym.target_path_len);

    if (!respattr->u.sym.target_path)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    free_keyval_buffers(s_op);

    s_op->key.buffer    = Trove_Common_Keys[SYMLINK_TARGET_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[SYMLINK_TARGET_KEY].size;

    s_op->val.buffer = respattr->u.sym.target_path;
    s_op->val.buffer_sz = respattr->u.sym.target_path_len;

    /* this will get cleaned up with attr structure */
    s_op->free_val = 0;

    ret = job_trove_keyval_read(s_op->u.getattr.fs_id,
                                s_op->u.getattr.handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &i,
                                server_job_context,
                                s_op->req->hints);


    return ret;
}

#if 0
static PINT_sm_action getattr_read_metafile_hint(struct PINT_smcb *smcb,
                                                 job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;
    char *buf = NULL;

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);
    buf = (char *) calloc(sizeof(uint32_t) + 1, 1);
    if (buf == NULL) 
    {
        js_p->error_code = -PVFS_ENOMEM;
        /*If we hit an error the DIST & DFILES are no longer valid*/
        s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DIST;
        s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DFILES;
        s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
        return 1;
    }

    js_p->error_code = 0;

    free_keyval_buffers(s_op);

    s_op->key.buffer = Trove_Special_Keys[METAFILE_HINT_KEY].key;
    s_op->key.buffer_sz = Trove_Special_Keys[METAFILE_HINT_KEY].size;

    s_op->val.buffer = buf;
    s_op->val.buffer_sz = sizeof(s_op->resp.u.getattr.attr.u.meta.hint) + 1;
    s_op->free_val = 1;

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "  reading metafile hint (coll_id = %d, "
                 "handle = %s, key = %s (%d), val_buf = %p (%d))\n",
                 s_op->u.getattr.fs_id,
                 PVFS_OID_str(&s_op->u.getattr.handle),
                 (char *)s_op->key.buffer,
                 s_op->key.buffer_sz, s_op->val.buffer,
                 s_op->val.buffer_sz);

    ret = job_trove_keyval_read(s_op->u.getattr.fs_id,
                                s_op->u.getattr.handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &i,
                                server_job_context,
                                s_op->req->hints);

    return ret;
}

static PINT_sm_action getattr_interpret_metafile_hint(PINT_smcb *smcb,
                                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = NULL;
    PVFS_metafile_attr *meta = &(s_op->resp.u.getattr.attr.u.meta); 
    respattr = &s_op->resp.u.getattr.attr;

    assert(respattr->objtype == PVFS_TYPE_METAFILE);

    if (js_p->error_code == 0 || js_p->error_code == -TROVE_ENOENT)
    {
        if (js_p->error_code == 0)
        {
            memcpy(&(meta->flags), s_op->val.buffer, sizeof(meta->flags));
        }

        gossip_debug(GOSSIP_GETATTR_DEBUG, " * client wants extra "
                     "meta info, about to retrieve it now\n");
        js_p->error_code = STATE_METAFILE;

        if ( (respattr->mask  & PVFS_ATTR_META_MIRROR_DFILES) && 
            !(meta->flags & PVFS_MIRROR_FL) ) 
        {
            respattr->mask &= ~(PVFS_ATTR_META_MIRROR_DFILES);
        }
    }
    else
    {
        /*If we hit an error the DIST & DFILES are no longer valid*/
        respattr->mask &= ~PVFS_ATTR_META_DIST;
        respattr->mask &= ~PVFS_ATTR_META_DFILES;
        respattr->mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
    }
    return SM_ACTION_COMPLETE;
}
#endif

/* V3 rename ... _read_datafile_handles_ ... */
static PINT_sm_action getattr_read_datafile_handles(struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    int dfile_count = 0, sid_count = 0;
    job_id_t i;
    PVFS_object_attr *respattr;

    respattr = &(s_op->resp.u.getattr.attr);

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);

    js_p->error_code = 0;

    dfile_count = respattr->u.meta.dfile_count;
    sid_count = respattr->u.meta.sid_count;

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 " request has dfile_count of %d | dspace has %d\n",
                 respattr->u.meta.dfile_count,
                 respattr->u.meta.dfile_count);

    /* verify that the retrieved dfile count is sane */
    if (!PVFS_REQ_LIMIT_DFILE_COUNT_IS_VALID(dfile_count))
    {
        gossip_err("The requested dfile count of %d is invalid; "
                   "aborting operation.\n", dfile_count);
        gossip_err(
            "+ attrs read from dspace: (owner = %d, group = %d, "
            "perms = %o, type = %d\n   atime = %lld, mtime = %lld, "
            "ctime = %lld |\n   dfile_count = %d | dist_size = %d)\n",
            respattr->owner, respattr->group, respattr->perms,
            respattr->objtype, 
            lld(respattr->atime), lld(respattr->mtime), lld(respattr->ctime),
            (int)respattr->u.meta.dfile_count,
            (int)respattr->u.meta.dist_size);

        gossip_err("handle: %s, fsid: %d.\n",
            PVFS_OID_str(&s_op->u.getattr.handle),
            (int)s_op->u.getattr.fs_id);

        /*If we hit an error the DIST & DFILES are no longer valid*/
        respattr->mask &= ~PVFS_ATTR_META_DIST;
        respattr->mask &= ~PVFS_ATTR_META_DFILES;
        respattr->mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
        
        js_p->error_code = -PVFS_EOVERFLOW;
        return SM_ACTION_COMPLETE;
    }

    free_keyval_buffers(s_op);

    s_op->key.buffer = Trove_Common_Keys[METAFILE_HANDLES_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[METAFILE_HANDLES_KEY].size;

    respattr->u.meta.dfile_array = malloc(OSASZ(dfile_count, sid_count));

    //TJS: Check this pointer math
    respattr->u.meta.sid_array = 
         (PVFS_SID *)&respattr->u.meta.dfile_array[dfile_count];


    if (!respattr->u.meta.dfile_array)
    {
        gossip_err("Cannot allocate dfile array of count %d with sid_count:"
                   " %d\n", dfile_count, sid_count);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* We set the sid_array to the appropriate place after the dfile_array */
    s_op->val.buffer = respattr->u.meta.dfile_array;
    s_op->val.buffer_sz = OSASZ(dfile_count, sid_count);
    /* this will get cleaned up with attr structure */
    s_op->free_val = 0;

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "  reading %d datafile handles (coll_id = %d, "
                 "handle = %s, key = %s (%d), val_buf = %p (%d))\n",
                 dfile_count, s_op->u.getattr.fs_id,
                 PVFS_OID_str(&s_op->u.getattr.handle),
                 (char *)s_op->key.buffer,
                 s_op->key.buffer_sz, s_op->val.buffer,
                 s_op->val.buffer_sz);

    ret = job_trove_keyval_read(s_op->u.getattr.fs_id
                               ,s_op->u.getattr.handle
                               ,&s_op->key
                               ,&s_op->val
                               ,0
                               ,NULL
                               ,smcb
                               ,0
                               ,js_p
                               ,&i
                               ,server_job_context
                               ,s_op->req->hints);

    return ret;
}

/* V3 Should not need this any more */
#if 0
static PINT_sm_action getattr_read_mirrored_copies_count_if_required(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    gossip_debug(GOSSIP_MIRROR_DEBUG,"Executing %s...\n",__func__);

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_resp *resp = &(s_op->resp);
    PVFS_metafile_attr *meta =  &(resp->u.getattr.attr.u.meta);
    int ret = -PVFS_EINVAL;
    job_id_t job_id;

   /* Are we mirroring? */
    if (!(resp->u.getattr.attr.mask & PVFS_ATTR_META_MIRROR_DFILES))
    {
        gossip_debug(GOSSIP_MIRROR_DEBUG,"\tMirroring is NOT turned on "
                                         "for this handle(%s)..\n"
                                        ,PVFS_OID_str(&s_op->u.getattr.handle));
        js_p->error_code = SKIP_NEXT_STATE;

        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_MIRROR_DEBUG,"\tMirroring IS turned on for this "
                                     "handle(%s)...\n"
                                    ,PVFS_OID_str(&s_op->u.getattr.handle));

    js_p->error_code = 0;

    /* setup job to read user.pvfs2.mirror.copies */

    /* initialize */
    free_keyval_buffers(s_op);

    /* set key = user.pvfs2.mirror.copies */
    s_op->key.buffer    = Trove_Special_Keys[MIRROR_COPIES_KEY].key;
    s_op->key.buffer_sz = Trove_Special_Keys[MIRROR_COPIES_KEY].size;


    /* setup space for retrieved value */
    /* TODO: Do mirrored copies need to be changed to get SID data? */
    meta->mirror_copies_count = 0;
    meta->mirror_dfile_array  = NULL;
    s_op->val.buffer = &(meta->mirror_copies_count);
    s_op->val.buffer_sz = sizeof(meta->mirror_copies_count);
    s_op->free_val = 0;

    /* submit job to read the value */
    ret = job_trove_keyval_read(
        s_op->u.getattr.fs_id
       ,s_op->u.getattr.handle
       ,&s_op->key
       ,&s_op->val
       ,0
       ,NULL
       ,smcb
       ,0
       ,js_p
       ,&job_id
       ,server_job_context
       ,s_op->req->hints);

    return ret;
}/*end getattr_read_mirrored_copies_if_required*/
#endif


/* V3 should not need this any more */
#if 0
static PINT_sm_action getattr_read_mirrored_handles_if_required(
        struct PINT_smcb *smcb,
        job_status_s *js_p)
{
   gossip_debug(GOSSIP_MIRROR_DEBUG,"Executing %s ...\n",__func__);

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_resp *resp = &(s_op->resp);
    PVFS_metafile_attr *meta =  &(resp->u.getattr.attr.u.meta);
    int ret = -PVFS_EINVAL;
    job_id_t job_id;

   /* Did we find mirror.copies? */
    if (js_p->error_code < 0)
    {
        gossip_debug(GOSSIP_MIRROR_DEBUG,"\tNumber of mirrored copies cannot "
                                         "be retrieved.\n");
        if (resp->u.getattr.attr.mask & (PVFS_ATTR_META_DFILES |
                                         PVFS_ATTR_META_DIST) )
        {
            resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
            js_p->error_code = SKIP_NEXT_STATE;
        } else {
            resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
            resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_DFILES;
            resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_DIST;
        }
        free_keyval_buffers(s_op);
/*
        memset(&(s_op->key),0,sizeof(s_op->key));
        memset(&(s_op->val),0,sizeof(s_op->val));
        s_op->free_val = 0;
*/

        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_MIRROR_DEBUG,"\tNumber of mirrored copies count "
                                     "successfully retrieved.\n");

   /* check number of mirrored copies */
    if (meta->mirror_copies_count == 0)
    {
       gossip_debug(GOSSIP_MIRROR_DEBUG,"\tNumber of mirrored copies "
                                        "is ZERO.\n");
       gossip_lerr("Mirror handles requested, but number of mirrored copies "
                   "is zero.\n");
       resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
       js_p->error_code = SKIP_NEXT_STATE;
       return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_MIRROR_DEBUG,"\tNumber of mirrored copies "
                                     "retrieved : %d\n"
                                    ,meta->mirror_copies_count);


   /* check to see if total number of mirrored handles is sane */
   if ( (meta->dfile_count * meta->mirror_copies_count) >
         PVFS_REQ_LIMIT_MIRROR_DFILE_COUNT )
   {
       gossip_lerr("Number of mirrored handles(%d) exceeds the system "
                   "limit(%d)\n"
                  ,meta->dfile_count * meta->mirror_copies_count
                  ,PVFS_REQ_LIMIT_MIRROR_DFILE_COUNT); 
       resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
       js_p->error_code = SKIP_NEXT_STATE;
       return SM_ACTION_COMPLETE;
   }

   js_p->error_code = 0;
   /* get mirrored handles and status of each handle */

   /* initialize */
    free_keyval_buffers(s_op);

   /* allocate space for keys and values */
   s_op->keyval_count = 2;
   s_op->free_val = 1;
   s_op->key_a = s_op->val_a = NULL;
   s_op->error_a = NULL;
   
   s_op->key_a   = malloc(sizeof(*s_op->key_a)   * s_op->keyval_count);
   s_op->val_a   = malloc(sizeof(*s_op->val_a)   * s_op->keyval_count);
   s_op->error_a = malloc(sizeof(*s_op->error_a) * s_op->keyval_count);
   if (!s_op->key_a || !s_op->val_a || !s_op->error_a)
   {
      gossip_lerr("Cannot allocate memory for key/val/error.\n");
      js_p->error_code = -PVFS_ENOMEM;
      goto error_exit;
   }
   memset(s_op->key_a,0,sizeof(*s_op->key_a));
   memset(s_op->val_a,0,sizeof(*s_op->val_a));
   memset(s_op->error_a,0,sizeof(*s_op->error_a));

   /* set key = user.pvfs2.mirror.handles */
   s_op->key_a[0].buffer    = Trove_Special_Keys[MIRROR_HANDLES_KEY].key;
   s_op->key_a[0].buffer_sz = Trove_Special_Keys[MIRROR_HANDLES_KEY].size;

   /* setup buffer space for handles */
   /* TJS: decide if this goes away or needs to be modified */
   s_op->val_a[0].buffer = malloc(sizeof(PVFS_handle) * 
                                  meta->dfile_count   *
                                  meta->mirror_copies_count);
   if (!s_op->val_a[0].buffer)
   {
      gossip_lerr("Cannot allocate memory for mirrored handles.\n");
      js_p->error_code = -PVFS_ENOMEM;
      goto error_exit;
   }
   memset(s_op->val_a[0].buffer,0,sizeof(PVFS_handle) *
                                  meta->dfile_count   *
                                  meta->mirror_copies_count);
   s_op->val_a[0].buffer_sz = sizeof(PVFS_handle) *
                              meta->dfile_count   *
                              meta->mirror_copies_count;

   /* set key = user.pvfs2.mirror.status */
   s_op->key_a[1].buffer    = Trove_Special_Keys[MIRROR_STATUS_KEY].key;
   s_op->key_a[1].buffer_sz = Trove_Special_Keys[MIRROR_STATUS_KEY].size;

   /* setup buffer space for handle statuses */
   s_op->val_a[1].buffer = malloc(sizeof(PVFS_handle) *
                                  meta->dfile_count   *
                                  meta->mirror_copies_count);
   if (!s_op->val_a[1].buffer)
   {
       gossip_lerr("Cannot allocate memory for mirrored handle statuses.\n");
       js_p->error_code = -PVFS_ENOMEM;
       goto error_exit;
   }
   memset(s_op->val_a[1].buffer,0,sizeof(PVFS_handle) *
                                  meta->dfile_count   *
                                  meta->mirror_copies_count);
   s_op->val_a[1].buffer_sz = sizeof(PVFS_handle) *
                              meta->dfile_count   *
                              meta->mirror_copies_count;

   
   /* call job to retrieve the key/val pairs */
   ret = job_trove_keyval_read_list(
          s_op->u.getattr.fs_id
         ,s_op->u.getattr.handle
         ,s_op->key_a
         ,s_op->val_a
         ,s_op->error_a
         ,s_op->keyval_count
         ,0
         ,NULL
         ,smcb
         ,0
         ,js_p
         ,&job_id
         ,server_job_context
         ,s_op->req->hints );

   return ret;

error_exit:
    free_keyval_buffers(s_op);

   resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;

   return SM_ACTION_COMPLETE;
}/*end getattr_read_mirrored_handles_if_required*/


/* V3 should not need this any more */
static PINT_sm_action getattr_mirrored_handles_safety_check(
        struct PINT_smcb *smcb,
        job_status_s *js_p)
{
   gossip_debug(GOSSIP_MIRROR_DEBUG,"Executing %s ...\n",__func__);

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PVFS_server_resp *resp = &(s_op->resp);
    PVFS_metafile_attr *meta =  &(resp->u.getattr.attr.u.meta);
    int row,col,index;
    int i;


   js_p->error_code = 0;

   /* Check the error code for each key/val pair. */
   for (i=0; i<s_op->keyval_count; i++)
   {
       if (s_op->error_a[i] != 0)
       {
           gossip_debug(GOSSIP_MIRROR_DEBUG,"\tRetrieval of key(%s) failed.\n"
                                           ,(char *)s_op->key_a[i].buffer);
           js_p->error_code = s_op->error_a[i];
       }
   }

   if (js_p->error_code)
   {
      goto error_exit;
   }

   gossip_debug(GOSSIP_MIRROR_DEBUG,"\tWe successfully retrieved handles and "
                                    "statuses.\n");

   for (i=0; i<s_op->keyval_count; i++)
   {  /* Did we get the data that we were expecting from 
       * user.pvfs2.mirror.handles(i=0) or 
       * user.pvfs2.mirror.statuses(i=1)? 
       */

     if (s_op->val_a[i].read_sz != s_op->val_a[i].buffer_sz)
     {
         gossip_lerr("Error: %s key found val size: %d when "
                    "expecting val size: %d\n"
                    ,(char *)s_op->key_a[i].buffer
                    ,s_op->val_a[i].read_sz
                    ,s_op->val_a[i].buffer_sz);
         js_p->error_code = s_op->val_a[i].buffer_sz;
     }
   }/*end for*/

   if (js_p->error_code)
   {
       goto error_exit;
   } 

   /*initialize permanent data structures*/
   meta->mirror_dfile_array = s_op->val_a[0].buffer;
   s_op->u.getattr.mirror_dfile_status_array = s_op->val_a[1].buffer;

   /* Take over responsibility for freeing the buffers. */
   s_op->free_val = 0;

   /*
   s_op->val_a[0].buffer = s_op->val_a[1].buffer = NULL;
   */

   /* Check the mirroring status for each handle.  If the status is non-zero,
    * the handle is not valid, so put a null in the mirrory array for that
    * handle.  Otherwise, do nothing.
   */
   for (row = 0; row <  meta->mirror_copies_count; row++)
   {
      for (col = 0; col < meta->dfile_count; col++)
      {
         index = (row * meta->dfile_count) + col;
         if (!PVFS_OID_cmp(&s_op->u.getattr.mirror_dfile_status_array[index],
                &PVFS_HANDLE_HIGH ))
         {
             meta->mirror_dfile_array[index] = PVFS_HANDLE_NULL;
         }
         gossip_debug(GOSSIP_MIRROR_DEBUG,
                      "\tmirror handle[%d]:%s \t"
                      "status:%s\n"
                      ,index
                      ,PVFS_OID_str(&meta->mirror_dfile_array[index])
                      ,PVFS_OID_str(&s_op->u.getattr.mirror_dfile_status_array[index]));
      }
   }

   /*Cleanup*/
    free_keyval_buffers(s_op);

   js_p->error_code = 0;
   return SM_ACTION_COMPLETE;

error_exit:
   /* if we have an error, cleanup, and pretend that we never attempted
    * mirrors in the first place.
   */
      gossip_debug(GOSSIP_MIRROR_DEBUG,"\tCleaning up mirror operation...\n");
      js_p->error_code = 0;
      free_keyval_buffers(s_op);
#if 0
      for (i=0; i<s_op->keyval_count; i++)
      {
          if (s_op->val_a[i].buffer)
              free(s_op->val_a[i].buffer);
      }
      free(s_op->key_a);
      free(s_op->val_a);
      free(s_op->error_a);
      s_op->key_a = s_op->val_a = NULL;
      s_op->error_a = NULL;
      s_op->keyval_count = 0; 
#endif
      
      /*We MUST set the number of copies to zero to prevent encoding errors
       *later.
      */
      meta->mirror_copies_count = 0;
      meta->mirror_dfile_array = NULL;
      s_op->u.getattr.mirror_dfile_status_array = NULL;
      resp->u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;
      return SM_ACTION_COMPLETE;
}/*end getattr_mirrored_handles_safety_check*/
#endif

static PINT_sm_action getattr_read_metafile_distribution(
        struct PINT_smcb *smcb,
        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    assert(s_op->attr.objtype == PVFS_TYPE_METAFILE);

    js_p->error_code = 0;

    free_keyval_buffers(s_op);

    s_op->key.buffer = Trove_Common_Keys[METAFILE_DIST_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[METAFILE_DIST_KEY].size;

    /*
      there *should* be some distribution information.  if not, dump
      which handle is busted and assertion die for now while we're not
      handling this kind of error
    */
    if (s_op->resp.u.getattr.attr.u.meta.dist_size < 1)
    {
        gossip_err("Cannot Read Dist!  Got an invalid dist size for "
                   "handle %s,%d\n",
                   PVFS_OID_str(&s_op->u.getattr.handle),
                   s_op->u.getattr.fs_id);
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }
    assert(s_op->resp.u.getattr.attr.u.meta.dist_size > 0);

    s_op->val.buffer_sz = s_op->resp.u.getattr.attr.u.meta.dist_size; 
    s_op->val.buffer = malloc(s_op->val.buffer_sz);
    if (!s_op->val.buffer)
    {
        gossip_err("Cannot allocate dist of size %d\n",
                   s_op->val.buffer_sz);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->free_val = 1;

    ret = job_trove_keyval_read(
        s_op->u.getattr.fs_id, s_op->u.getattr.handle,
        &(s_op->key), &(s_op->val),
        0,
        NULL,
        smcb, 0, js_p, &i, server_job_context, s_op->req->hints);

    return ret;
}

#if 0
static PINT_sm_action getattr_read_stuffed_size(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t job_id;

    if (js_p->error_code == -TROVE_ENOENT)
    {
        gossip_debug(
            GOSSIP_GETATTR_DEBUG, "Getattr detected non-stuffed file.\n");
        /* this means that the keyval fields used to indicate a file is
         * stuffed are not present.  Set mask accordingly and continue.
         */
        s_op->resp.u.getattr.attr.mask |= PVFS_ATTR_META_UNSTUFFED;
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }
    if (js_p->error_code)
    {
        /* any other error code here is just a normal error case */
        /* preserve error code and catch next error transition */
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(
        GOSSIP_GETATTR_DEBUG, "Getattr detected stuffed file.\n");
    /* otherwise, we found keyval fields indicating that the file is
     * stuffed.  It does not matter if the client asked for the size or not;
     * we must retrieve a valid stuffed_size value for the attrs.
     */
    s_op->resp.u.getattr.attr.mask &= (~(PVFS_ATTR_META_UNSTUFFED));

    return(job_trove_dspace_getattr(
        s_op->u.getattr.fs_id,
        s_op->resp.u.getattr.attr.u.meta.dfile_array[0],
        smcb,
        &s_op->ds_attr,
        0,
        js_p,
        &job_id,
        server_job_context,
        s_op->req->hints));
}

static PINT_sm_action getattr_interpret_stuffed_size(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_metafile_attr *meta    = &(s_op->resp.u.getattr.attr.u.meta);

    if (js_p->error_code == 0)
    {
        meta->stuffed_size = s_op->ds_attr.u.datafile.b_size;
    }

    /* deliberately leave error_code unchanged so that any errors get 
     * handled in the next state
     */
    return SM_ACTION_COMPLETE;
}
#endif

/* interpret_metafile_distribution()
 *
 * capture and encode results of reading distribution
 */
static PINT_sm_action interpret_metafile_distribution(struct PINT_smcb *smcb,
                                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);
    
    if (js_p->error_code < 0)
    {
        return SM_ACTION_COMPLETE;
    }

    if (s_op->u.getattr.attrmask & PVFS_ATTR_META_DIST)
    {
        /* successfully read dist key; make sure we got something valid */
        if (s_op->val.read_sz != s_op->val.buffer_sz)
        {
            gossip_err("Error: %s key found val size: %d when expecting val size: %d\n",
                Trove_Common_Keys[METAFILE_DIST_KEY].key,
                s_op->val.read_sz,
                s_op->val.buffer_sz);

            /* clear bitmask to prevent double free between setup_resp and
             * PINT_free_object_attr()
             */
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DIST;

            js_p->error_code = -PVFS_EIO;
            return SM_ACTION_COMPLETE;
        }

        assert(s_op->val.buffer);
        PINT_dist_decode(&respattr->u.meta.dist, s_op->val.buffer);

        if(respattr->u.meta.dist == 0)
        {
            gossip_err("Found dist of 0 for handle %s,%d\n",
                       PVFS_OID_str(&s_op->u.getattr.handle),
                       s_op->u.getattr.fs_id);
            PVFS_perror("Metafile interpret_fetafile_distribution",
                        js_p->error_code);
            js_p->error_code = -PVFS_EIO;
            return SM_ACTION_COMPLETE;
        }
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/* check_if_capability_required
 *
 * Branch point for capability creation.
 */
static PINT_sm_action getattr_check_if_capability_required(
                                                  struct PINT_smcb *smcb,
                                                  job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* errors fall through */
    if (js_p->error_code < 0)
    {
        return SM_ACTION_COMPLETE;
    }

    if (s_op->u.getattr.attrmask & PVFS_ATTR_CAPABILITY)
    {
        js_p->error_code = STATE_CAPABILITY;
    }
    else
    {
        js_p->error_code = 0;
    }

    return SM_ACTION_COMPLETE;
}

/* getattr_read_acl
 * 
 * Reads any ACL data from Trove if a capability is requested.
 */
static PINT_sm_action getattr_read_acl(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;
    int ret;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (getattr sm) state: getattr_read_acl\n",
                 s_op, PINT_map_server_op_to_string(s_op->req->op));

    assert(s_op->u.getattr.attrmask & PVFS_ATTR_CAPABILITY);

    free_keyval_buffers(s_op);

    s_op->key.buffer = "system.posix_acl_access";
    s_op->key.buffer_sz = strlen(s_op->key.buffer) + 1;
    s_op->val.buffer = malloc(PVFS_REQ_LIMIT_VAL_LEN);
    if (!s_op->val.buffer)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->val.buffer_sz = PVFS_REQ_LIMIT_VAL_LEN;
    s_op->free_val = 1;
    
    gossip_debug(GOSSIP_PERMISSIONS_DEBUG, "About to retrieve acl keyvals "
                     "for handle %s\n", PVFS_OID_str(&s_op->target_handle));

    ret = job_trove_keyval_read(s_op->u.getattr.fs_id,
                                s_op->u.getattr.handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &tmp_id,
                                server_job_context,
                                s_op->req->hints);

    return ret;
}

/* getattr_create_capability
 *
 * Creates and fills in a capability object with the appropriate
 * operation mask for the given object.
 */
static PINT_sm_action getattr_create_capability(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);
    struct server_configuration_s *config;
    void *acl_buf;
    size_t acl_size;
    int ret;
    PVFS_uid uid;
    uint32_t num_groups;
    PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS];
#ifdef ENABLE_CAPCACHE
    int insert_flag = 1;
#endif

    if (js_p->error_code == -TROVE_ENOENT)
    {
        acl_buf = NULL;
        acl_size = 0;
        js_p->error_code = 0;
    }
    else if (js_p->error_code < 0)
    {
        /* let fatal errors fall through */
        return SM_ACTION_COMPLETE;
    }
    else
    {
        acl_buf = s_op->val.buffer;
        acl_size = s_op->val.read_sz;
    }

    ret = PINT_init_capability(&respattr->capability);
    if (ret < 0)
    {
        gossip_debug((GOSSIP_GETATTR_DEBUG|GOSSIP_SECURITY_DEBUG),
                     "getattr: capability init failed\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    respattr->capability.num_handles = 1;

    /* if this is a metadata allocate room for dfile handles */
    if (respattr->objtype == PVFS_TYPE_METAFILE)
    {
        respattr->capability.num_handles += respattr->u.meta.dfile_count;
    }

    /* if this is a directory allocate room for dirdata handles */
    if (respattr->objtype == PVFS_TYPE_DIRECTORY)
    {
        respattr->capability.num_handles +=
                             respattr->u.dir.dist_dir_attr.dirdata_count;
    }

    /* if there are extra handles allocate them here */
    respattr->capability.handle_array = 
            calloc(respattr->capability.num_handles, sizeof(PVFS_handle));

    if (!respattr->capability.handle_array)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    respattr->capability.handle_array[0] = s_op->u.getattr.handle;

    /* if this is a metadata copy dfile handles into place */
    if (respattr->objtype == PVFS_TYPE_METAFILE)
    {
        /* copy datafile handles after the metafile handle */
        memcpy((respattr->capability.handle_array + 1),
               respattr->u.meta.dfile_array,
               respattr->u.meta.dfile_count * sizeof(PVFS_handle));
    }

    /* if this is a directory copy dirdata handles into place */
    if (respattr->objtype == PVFS_TYPE_DIRECTORY)
    {
        /* copy datafile handles after the directory handle */
        memcpy((respattr->capability.handle_array + 1),
               respattr->u.dir.dirdata_handles,
               respattr->u.dir.dist_dir_attr.dirdata_count *
                                             sizeof(PVFS_handle));
    }

    /* map credential based on credential certificate */
    ret = PINT_map_credential(&s_op->u.getattr.credential, &uid, &num_groups,
                              group_array);
    if (ret != 0)
    {
        PINT_cleanup_capability(&respattr->capability);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

#ifdef ENABLE_SECURITY_MODE
    /* no capabilities for unsigned credential; some operations
       still allowed */
    if (!IS_UNSIGNED_CRED(&s_op->u.getattr.credential))
    {
#endif
    /* generate permissions mask based on uid and (optional) ACLs */
    ret = PINT_get_capabilities(acl_buf,
                                acl_size,
                                uid,
                                group_array,
                                num_groups,
                                respattr,
                                &respattr->capability.op_mask);
    if (ret < 0)
    {
        PINT_cleanup_capability(&respattr->capability);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }
#ifdef ENABLE_SECURITY_MODE
    } /* if */
#endif
    
    respattr->capability.fsid = s_op->u.getattr.fs_id;

    config = get_server_config_struct();
    respattr->capability.issuer = 
                    (char *) malloc(strlen(config->server_alias) + 3);

    if (respattr->capability.issuer == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

#if defined(ENABLE_CAPCACHE) && defined(ENABLE_SECURITY_MODE)
    /* if capability fields match cached capability, use
       signature from that capability */
    ret = PINT_capcache_quick_sign(&respattr->capability);
    if (ret != 0)
    {
        ret = PINT_sign_capability(&respattr->capability);        
    }
    else
    {
        /* no need to insert capability into cache */
        insert_flag = 0;
    }
#else
    ret = PINT_sign_capability(&respattr->capability);
#endif

    if (ret < 0)
    {
        gossip_debug((GOSSIP_GETATTR_DEBUG|GOSSIP_SECURITY_DEBUG),
                     "getattr: failed to sign capability\n");
        PINT_cleanup_capability(&respattr->capability);
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }
                                 
    respattr->mask |= PVFS_ATTR_CAPABILITY;

    PINT_debug_credential(&s_op->u.getattr.credential, 
                          "getattr: using credential",
                          uid, num_groups, group_array);

    PINT_debug_capability(&respattr->capability, "Created");

#ifdef ENABLE_CAPCACHE
    /* Cache the new capability */
    if (insert_flag)
    {
        ret = PINT_capcache_insert(&respattr->capability);
        if (ret < 0)
        {
            /* issue a warning */
            gossip_err("Warning: could not cache capability\n");
        }
    }
#endif /* ENABLE_CAPCACHE */

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_setup_resp(struct PINT_smcb *smcb,
                                         job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *respattr = &(s_op->resp.u.getattr.attr);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "  getattr_setup_resp: error_code = %d\n",
                 js_p->error_code);
    if (js_p->error_code > 0)
    {
        /* if we reach this state with a positive error code it means that
         * nothing is wrong; we just used one of the explicit STATE_*
         * transitions
         */
        js_p->error_code = 0;
    }
    if (js_p->error_code < 0)
    {
        free_nested_getattr_data(s_op);
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "-  retrieved attrs: [owner = %d, group = %d\n\t"
                 "perms = %o, type = %d, atime = %llu, mtime = %llu\n\t"
                 "ctime = %llu, dist_size = %d, dirent_count = %d]\n",
                 respattr->owner, respattr->group, respattr->perms,
                 respattr->objtype, llu(respattr->atime),
                 llu(respattr->mtime), llu(respattr->ctime),
                 (int)respattr->u.meta.dist_size,
                 (int)respattr->u.dir.dirent_count);

    switch (respattr->objtype)
    {
    case PVFS_TYPE_METAFILE :
        if (respattr->u.meta.dfile_count)
        {
            assert(respattr->u.meta.dfile_array);
        }
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning %d datafile handles\n",
                     respattr->u.meta.dfile_count);
/* V3 remove */
#if 0
        if (respattr->mask & PVFS_ATTR_META_MIRROR_DFILES)
        {
           if (respattr->u.meta.mirror_copies_count)
                       assert(respattr->u.meta.mirror_dfile_array);
           gossip_debug(GOSSIP_GETATTR_DEBUG,
                        "  also returning %d mirrored copies\n"
                       ,respattr->u.meta.mirror_copies_count);
        }
#endif
        /* we have already gathered the dist field in an earlier state */
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning dist size of %d\n",
                     respattr->u.meta.dist_size);
        break;
    case PVFS_TYPE_DIRDATA :
        respattr->u.dirdata.dist_dir_attr.bitmap_size = 0;
        respattr->u.dirdata.dist_dir_attr.dirdata_count = 0;
        respattr->u.dirdata.dist_dir_attr.sid_count = 0;
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning dirent count of %lld\n",
                     lld(respattr->u.dirdata.dirent_count));
        break;
    case PVFS_TYPE_DATAFILE :
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning data size of %lld\n",
                     lld(respattr->u.data.size));
        break;
    case PVFS_TYPE_SYMLINK :
        if (js_p->error_code == 0)
        {
            assert(respattr->u.sym.target_path);
            assert(respattr->u.sym.target_path_len);
            /*
              adjust target path len down to actual size ; always
              include the null termination char in the target_path_len
            */
            respattr->u.sym.target_path_len =
                            (strlen(respattr->u.sym.target_path) + 1);

            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "  also returning link target of %s (len %d)\n",
                         respattr->u.sym.target_path,
                         respattr->u.sym.target_path_len);
        }
        else
        {
            gossip_err("Failed to retrieve symlink target path for "
                       "handle %s,%d\n",
                       PVFS_OID_str(&s_op->u.getattr.handle),
                       s_op->u.getattr.fs_id);
            PVFS_perror("Symlink retrieval failure",js_p->error_code);

            free_nested_getattr_data(s_op);
            js_p->error_code = -PVFS_EINVAL;
            return SM_ACTION_COMPLETE;
        }
        break;
    case PVFS_TYPE_DIRECTORY :
    {
        uint32_t dirent_file_count_i;
        int bcount;
        unsigned char *c;

        /* !!! may change later */
        gossip_debug(GOSSIP_GETATTR_DEBUG, " server returning "
                     "dirent_count = %llu "
                     "dirdata_servers_count = %d "
                     "dfile_count = %d "
                     "dist_name_len    = %d "
                     "dist_params_len  = %d\n",
                     llu(respattr->u.dir.dirent_count),
                     respattr->u.dir.dist_dir_attr.dirdata_count,
                     respattr->u.dir.hint.dfile_count,
                     respattr->u.dir.hint.dist_name_len,
                     respattr->u.dir.hint.dist_params_len);

        /* gossip bitmap */
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     " server returning dist_dir_bitmap as:\n");

        for(bcount = respattr->u.dir.dist_dir_attr.bitmap_size - 1;
            bcount >= 0 ;
            bcount--)
        {
            c = (unsigned char *)(respattr->u.dir.dist_dir_bitmap + bcount);
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         " i=%d : %02x %02x %02x %02x\n",
                         bcount, c[3], c[2], c[1], c[0]);
        }

        gossip_debug(GOSSIP_GETATTR_DEBUG, "\n");

        for (dirent_file_count_i = 0;
             dirent_file_count_i < respattr->u.dir.dist_dir_attr.dirdata_count;
             dirent_file_count_i++)
        {
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         "    dirdata_handle[%d] = %s\n",
                         dirent_file_count_i,
                         PVFS_OID_str(&respattr->u.dir.dirdata_handles[
                                                 dirent_file_count_i]));
        }
    }
    break;
    default :
    break;
    }

    if (respattr->mask & PVFS_ATTR_CAPABILITY)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "  also returning capability with mask %#x\n",
                     respattr->capability.op_mask);
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG,"@ End %s attributes: sending "
                 "status %d (error = %d)\n",
                 PINT_util_get_object_type(respattr->objtype),
                 s_op->resp.status, js_p->error_code);

#if 1
    gossip_debug(GOSSIP_GETATTR_DEBUG, "returning attrmask\n");
    PINT_attrmask_print(GOSSIP_GETATTR_DEBUG,
                        s_op->resp.u.getattr.attr.mask);
#endif

    free_nested_getattr_data(s_op);
    return SM_ACTION_COMPLETE;
}

static void free_nested_getattr_data(struct PINT_server_op *s_op)
{
    /* free up anything that was set up specifically by this nested machine */
    free_keyval_buffers(s_op);

    if (s_op->u.getattr.mirror_dfile_status_array)
    {
        free(s_op->u.getattr.mirror_dfile_status_array);
        s_op->u.getattr.mirror_dfile_status_array = NULL;
    }

    return;
}

static PINT_sm_action getattr_cleanup(struct PINT_smcb *smcb,
                                      job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    free_keyval_buffers(s_op);

    PINT_free_object_attr(&s_op->resp.u.getattr.attr);
    return(server_state_machine_complete(smcb));
}

static PINT_sm_action getattr_with_prelude_init(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    js_p->error_code = 0;    
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_setup_op(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    memset(&s_op->resp.u.getattr.attr, 0, sizeof(PVFS_object_attr));
    s_op->resp.op = s_op->req->op;

    s_op->u.getattr.handle                    = s_op->req->u.getattr.handle;
    s_op->u.getattr.fs_id                     = s_op->req->u.getattr.fs_id;
    s_op->u.getattr.attrmask                  = s_op->req->u.getattr.attrmask;
    s_op->u.getattr.mirror_dfile_status_array = NULL;
    s_op->u.getattr.credential                = s_op->req->u.getattr.credential;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_datafile_handles_safety_check(
        struct PINT_smcb *smcb,
        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    if ((js_p->error_code == 0) &&
        (s_op->u.getattr.attrmask & PVFS_ATTR_META_DFILES))
    {
        /* successfully read datafile key; make sure we got something valid */
        if (s_op->val.read_sz != s_op->val.buffer_sz)
        {
            gossip_err("Error: %s key found val size: %d when "
                       "expecting val size: %d\n",
                       Trove_Common_Keys[METAFILE_HANDLES_KEY].key,
                       s_op->val.read_sz,
                       s_op->val.buffer_sz);

            /* clear bitmask to prevent double free between setup_resp and
             * PINT_free_object_attr()
             */
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DFILES;
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_DIST;
            s_op->resp.u.getattr.attr.mask &= ~PVFS_ATTR_META_MIRROR_DFILES;

            js_p->error_code = -PVFS_EIO;
            return SM_ACTION_COMPLETE;
        }
    }

    /* otherwise deliberately preserve existing error code */
    return SM_ACTION_COMPLETE;
}

/* attr already read in don't need this state */
#if 0
static PINT_sm_action getattr_get_dist_dir_attr(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{   
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret; 
    job_id_t tmp_id;
    
    if (!(s_op->u.getattr.attrmask & PVFS_ATTR_DISTDIR_ATTR))
    {    
         /* the caller didn't really want the dist_dir_attr;
          * skip to DIR_HINT!
          */
         js_p->error_code = STATE_DIR_HINT;
         return SM_ACTION_COMPLETE;
    }
    
    free_keyval_buffers(s_op);

    s_op->key.buffer = Trove_Common_Keys[DIST_DIR_ATTR_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[DIST_DIR_ATTR_KEY].size;
    s_op->val.buffer = &s_op->resp.u.getattr.attr.u.dir.dist_dir_attr;
    s_op->val.buffer_sz = sizeof(PVFS_dist_dir_attr);
    s_op->free_val = 0;
    
    js_p->error_code = 0;
    ret = job_trove_keyval_read(s_op->u.getattr.fs_id,
                                s_op->u.getattr.handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &tmp_id,
                                server_job_context,
                                s_op->req->hints);

    return ret;
}
#endif

static PINT_sm_action getattr_get_bitmap_and_dirdata_handles(
                                                 struct PINT_smcb *smcb,
                                                 job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t tmp_id;
    PVFS_object_attr *attr;

    attr = &s_op->resp.u.getattr.attr;

    if (js_p->error_code == -TROVE_ENOENT)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "getattr: no DIST_DIR_ATTR key present!!\n");
        attr->u.dir.dist_dir_bitmap = NULL;
        attr->u.dir.dirdata_handles = NULL;
        return SM_ACTION_COMPLETE;
    }

    assert(attr->u.dir.dist_dir_attr.dirdata_count > 0 &&
           attr->u.dir.dist_dir_attr.bitmap_size > 0);

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "getattr: get dist-dir-attr for dir meta handle %s "
                 "with tree_height=%d, dirdata_count=%d, bitmap_size=%d, "
                 "split_size=%d, server_no=%d and branch_level=%d\n",
                 PVFS_OID_str(&s_op->u.getattr.handle),
                 attr->u.dir.dist_dir_attr.tree_height,
                 attr->u.dir.dist_dir_attr.dirdata_count,
                 attr->u.dir.dist_dir_attr.bitmap_size,
                 attr->u.dir.dist_dir_attr.split_size,
                 attr->u.dir.dist_dir_attr.server_no,
                 attr->u.dir.dist_dir_attr.branch_level);

    /* allocate space for bitmap, dirdata handles, and dirdata sids */
    attr->u.dir.dist_dir_bitmap =
                malloc(attr->u.dir.dist_dir_attr.bitmap_size *
                             sizeof(PVFS_dist_dir_bitmap_basetype));

    attr->u.dir.dirdata_handles =
                (PVFS_OID *)malloc(OSASZ(attr->u.dir.dist_dir_attr.dirdata_count, 
                                          attr->u.dir.dist_dir_attr.sid_count));
    
    attr->u.dir.dirdata_sids = (PVFS_SID *)(attr->u.dir.dirdata_handles +
                               attr->u.dir.dist_dir_attr.dirdata_count);

    if(!attr->u.dir.dist_dir_bitmap || !attr->u.dir.dirdata_handles)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* total 2 keyvals, DIST_DIRDATA_BITMAP, DIST_DIRDATA_HANDLES */

    free_keyval_buffers(s_op);

    /* allocate space for keys and values */
    s_op->keyval_count = 2;
    s_op->key_a = s_op->val_a = NULL;
    s_op->error_a = NULL;
    s_op->free_val = 0;

    s_op->key_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->val_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->error_a = calloc(s_op->keyval_count, sizeof(PVFS_error));

    if(! s_op->key_a || ! s_op->val_a || ! s_op->error_a)
    {
        gossip_lerr("Cannot allocate memory for key/val/error.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->key_a[0].buffer = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;
    s_op->key_a[0].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;

    s_op->val_a[0].buffer_sz = attr->u.dir.dist_dir_attr.bitmap_size *
                               sizeof(PVFS_dist_dir_bitmap_basetype);

    s_op->val_a[0].buffer = attr->u.dir.dist_dir_bitmap;

    s_op->key_a[1].buffer = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;
    s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;

    s_op->val_a[1].buffer = attr->u.dir.dirdata_handles;
    s_op->val_a[1].buffer_sz = OSASZ(attr->u.dir.dist_dir_attr.dirdata_count, 
                                     attr->u.dir.dist_dir_attr.sid_count);

    js_p->error_code = 0;
    ret = job_trove_keyval_read_list(s_op->u.getattr.fs_id,
                                     s_op->u.getattr.handle,
                                     s_op->key_a,
                                     s_op->val_a,
                                     s_op->error_a,
                                     s_op->keyval_count,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &tmp_id,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

#if 0
        
#if 0
static PINT_sm_action getattr_get_dirent_count(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret;
    job_id_t tmp_id;
    PVFS_object_attr *attr;
    int i;
    unsigned char *c;

    if (js_p->error_code == -TROVE_ENOENT)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "getattr: no DIST_DIR_ATTR key present, "
                     "not getting dirent_count! \n");
        return SM_ACTION_COMPLETE;
    }

    attr = &s_op->resp.u.getattr.attr;
    
    if (s_op->u.getattr.attrmask & PVFS_ATTR_DISTDIR_ATTR)
    {
        
        /* gossip bitmap */
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "getattr: dist_dir_bitmap as:\n");
        for(i = attr->u.dir.dist_dir_attr.bitmap_size - 1; i >= 0; i--)
        {   
            c = (unsigned char *)(attr->u.dir.dist_dir_bitmap + i);
            gossip_debug(GOSSIP_GETATTR_DEBUG,
                         " i=%d : %02x %02x %02x %02x\n",
                         i, c[3], c[2], c[1], c[0]);
        }
        gossip_debug(GOSSIP_GETATTR_DEBUG, "\n");
        
        gossip_debug(GOSSIP_GETATTR_DEBUG, 
                     "\t getattr: dirdata handles array of directory %s.\n",
                     PVFS_OID_str(&s_op->u.getattr.handle));
        
        for(i = 0; i < attr->u.dir.dist_dir_attr.dirdata_count; i++)
        {   
            gossip_debug(GOSSIP_MKDIR_DEBUG, 
                         "\t\tdirdata server %d: %s.\n",
                         i, PVFS_OID_str(&attr->u.dir.dirdata_handles[i]));
        }
    }

    if (!(s_op->u.getattr.attrmask & PVFS_ATTR_DIR_DIRENT_COUNT))
    {
         /* the caller didn't really want the dirent count; skip to get
          * directory hints
          */
         js_p->error_code = STATE_DIR_HINT;
         return SM_ACTION_COMPLETE;
    }


    /* get dirent_count of incoming dirdata handle. */
    ret = job_trove_keyval_get_handle_info(s_op->u.getattr.fs_id,
                                           s_op->u.getattr.handle,
                                           TROVE_KEYVAL_HANDLE_COUNT | 0,
                                           &s_op->u.getattr.keyval_handle_info,
                                           smcb,
                                           0,
                                           js_p,
                                           &tmp_id,
                                           server_job_context,
                                           s_op->req->hints);

    return ret;
}

static PINT_sm_action getattr_interpret_dirent_count(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    switch(js_p->error_code)
    {
        case -TROVE_ENOENT:
            js_p->error_code = 0;
            s_op->resp.u.getattr.attr.u.dir.dirent_count = 0;
            break;
        case 0:
            s_op->resp.u.getattr.attr.u.dir.dirent_count =
                          s_op->u.getattr.keyval_handle_info.count;
            break;
        default:
            return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_GETATTR_DEBUG, "getattr: dirent_count: %lld\n",
                 lld(s_op->resp.u.getattr.attr.u.dir.dirent_count));

    return SM_ACTION_COMPLETE;
}
#endif

#endif

static PINT_sm_action getattr_get_dir_hint(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret, i;
    job_id_t tmp_id;
    PVFS_object_attr *attr_p;
    unsigned char *c;

    /* wrapping up get_bitmap_and_dirdata_handles */
    if (js_p->error_code == -TROVE_ENOENT)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "getattr: no DIST_DIR_ATTR key present, "
                     "not getting DIR_HINTS! \n");
        return SM_ACTION_COMPLETE;
    }

    attr_p = &s_op->resp.u.getattr.attr;

    /* gossip bitmap */
    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "getattr: dist_dir_bitmap as:\n");

    for(i = attr_p->u.dir.dist_dir_attr.bitmap_size - 1; i >= 0 ; i--)
    {
        c = (unsigned char *)(attr_p->u.dir.dist_dir_bitmap + i);
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     " i=%d : %02x %02x %02x %02x\n",
                     i, c[3], c[2], c[1], c[0]);
    }
    gossip_debug(GOSSIP_GETATTR_DEBUG, "\n");

    gossip_debug(GOSSIP_GETATTR_DEBUG,
                 "\t getattr: dirdata handles array of directory %s.\n",
                 PVFS_OID_str(&s_op->u.getattr.handle));

    for(i = 0; i < attr_p->u.dir.dist_dir_attr.dirdata_count; i++)
    {
        gossip_debug(GOSSIP_GETATTR_DEBUG,
                     "\t\tdirdata server %d: %s.\n",
                     i, PVFS_OID_str(&attr_p->u.dir.dirdata_handles[i]));
    }

    /* NOTE: memory allocations are released in the getattr_cleanup()
     * function 
     */

    gossip_debug(GOSSIP_SERVER_DEBUG, "  trying to getxattr of %s,%s,%s "
                 "of dir handle (coll_id = %d, handle = %s\n",
                 Trove_Special_Keys[DIST_NAME_KEY].key,
                 Trove_Special_Keys[DIST_PARAMS_KEY].key, 
                 Trove_Special_Keys[DEFAULT_NUM_DFILES_KEY].key,
                 s_op->u.getattr.fs_id,
                 PVFS_OID_str(&s_op->u.getattr.handle));

    s_op->resp.u.getattr.attr.u.dir.hint.dist_params = 
                    (char *) calloc(1, PVFS_REQ_LIMIT_DIST_BYTES);

    if (!s_op->resp.u.getattr.attr.u.dir.hint.dist_params)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len = 
                    PVFS_REQ_LIMIT_DIST_BYTES;

    s_op->resp.u.getattr.attr.u.dir.hint.dist_name = 
        (char *) calloc(1, PVFS_REQ_LIMIT_DIST_NAME);

    if (!s_op->resp.u.getattr.attr.u.dir.hint.dist_name)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len = 
                    PVFS_REQ_LIMIT_DIST_NAME;

    free_keyval_buffers(s_op);

    /* Note NUM Special Keys is the number of user space attributes we
     * automatically read with get-attr - we know what they are so we
     * set up specifically for them.  Note sure why this is done with a
     * for loop below
     */
        
    s_op->key_a = (PVFS_ds_keyval *)calloc(NUM_SPECIAL_KEYS,
                                           sizeof(PVFS_ds_keyval));
    if (s_op->key_a == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->val_a = (PVFS_ds_keyval *)calloc(NUM_SPECIAL_KEYS
                                          ,sizeof(PVFS_ds_keyval));
    if (s_op->val_a == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->error_a = (PVFS_error*)calloc(NUM_SPECIAL_KEYS, sizeof(PVFS_error));
    if (s_op->error_a == NULL)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->free_val = 0;
    s_op->keyval_count = NUM_SPECIAL_KEYS;

    for (i = 0; i < NUM_SPECIAL_KEYS; i++)
    {
        s_op->key_a[i].buffer = Trove_Special_Keys[i].key;
        s_op->key_a[i].buffer_sz = Trove_Special_Keys[i].size;

        if (i == DEFAULT_NUM_DFILES_KEY)
        {
            s_op->val_a[i].buffer = (char *) calloc(1, 16);
            if (s_op->val_a[i].buffer == NULL)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return SM_ACTION_COMPLETE;
            }
            s_op->val_a[i].buffer_sz = 16;
        }
        else if (i == DIST_PARAMS_KEY)
        {
            s_op->val_a[i].buffer =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_params;
            s_op->val_a[i].buffer_sz =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len;
        }
        else if (i == DIST_NAME_KEY)
        {
            s_op->val_a[i].buffer =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_name;
            s_op->val_a[i].buffer_sz =
                        s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len;
        }
    }

    js_p->error_code = 0;
    ret = job_trove_keyval_read_list(s_op->u.getattr.fs_id, 
                                     s_op->u.getattr.handle,
                                     s_op->key_a,
                                     s_op->val_a,
                                     s_op->error_a,
                                     NUM_SPECIAL_KEYS,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &tmp_id,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

static PINT_sm_action getattr_interpret_dir_hint(struct PINT_smcb *smcb,
                                                 job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    if (js_p->error_code != 0 && js_p->error_code != -TROVE_ENOENT)
    {
        /* if we failed to get any of the keys, and the error code is due to
         * something other than the keys simply not being present, then
         * propigate the error.
         */
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_SERVER_DEBUG, 
        "getattr: job status code = %d\n", js_p->error_code);

    if (s_op->val_a && s_op->key_a)
    {
        long int dfile_count = 0;

        if (s_op->error_a[DIST_NAME_KEY] == 0)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, 
                "val_a[DIST_NAME_KEY] %p read_sz = %d dist_name = %s\n", 
                s_op->val_a[DIST_NAME_KEY].buffer, 
                s_op->val_a[DIST_NAME_KEY].read_sz,
                (char *)s_op->val_a[DIST_NAME_KEY].buffer);

            s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len = 
                            s_op->val_a[DIST_NAME_KEY].read_sz;
        }
        else
        {
            s_op->resp.u.getattr.attr.u.dir.hint.dist_name_len = 0;
        }            
/*        s_op->val_a[DIST_NAME_KEY].buffer = NULL; */

        if (s_op->error_a[DIST_PARAMS_KEY] == 0)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, 
                "val_a[DIST_PARAMS_KEY] %p read_sz = %d dist_params = %s\n", 
                s_op->val_a[DIST_PARAMS_KEY].buffer, 
                s_op->val_a[DIST_PARAMS_KEY].read_sz,
                (char *)s_op->val_a[DIST_PARAMS_KEY].buffer);

            s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len = 
                            s_op->val_a[DIST_PARAMS_KEY].read_sz;
        }
        else
        {
            s_op->resp.u.getattr.attr.u.dir.hint.dist_params_len = 0;
        }
        if (s_op->val_a[DIST_PARAMS_KEY].buffer)
        {
/*           s_op->val_a[DIST_PARAMS_KEY].buffer = NULL; */
        }

        if (s_op->error_a[DEFAULT_NUM_DFILES_KEY] == 0)
        {
            char *endptr = NULL;
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "val_a[DEFAULT_NUM_DFILES_KEY] %p read_sz = %d\n", 
                         s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer, 
                         s_op->val_a[DEFAULT_NUM_DFILES_KEY].read_sz);

            dfile_count = strtol(s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer,
                                 &endptr,
                                 10);

            if (*endptr != '\0' || dfile_count < 0)
            {
                dfile_count = 0;
            }
        }
        if(s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer)
        {
            free(s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer);
            s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer = NULL;
            s_op->val_a[DEFAULT_NUM_DFILES_KEY].buffer_sz = 0;
        }
/*
        s_op->keyval_count = 0;
        s_op->free_val = 0;
*/
        free_keyval_buffers(s_op);

        s_op->resp.u.getattr.attr.u.dir.hint.dfile_count = dfile_count;

        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "getattr: dir hint dfile_count: %d\n",
                     s_op->resp.u.getattr.attr.u.dir.hint.dfile_count);

        js_p->error_code = 0;
    }/* end if val_a and key_a */
    return SM_ACTION_COMPLETE;
}

#if 0
/* getattr_detect_stuffed()
 *
 * determine if a file is stuffed or not
 */
static PINT_sm_action getattr_detect_stuffed(struct PINT_smcb *smcb,
                                             job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;

    /* we can determine stuffedness by the presence of the dfiles req key */

    free_keyval_buffers(s_op);

    s_op->key.buffer = Trove_Common_Keys[NUM_DFILES_REQ_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[NUM_DFILES_REQ_KEY].size;
    s_op->val.buffer =  &s_op->u.getattr.num_dfiles_req;
    s_op->val.buffer_sz =  sizeof(s_op->u.getattr.num_dfiles_req);
    s_op->free_val = 0;

    return(job_trove_keyval_read(s_op->u.getattr.fs_id, 
                                 s_op->u.getattr.handle,
                                 &(s_op->key), 
                                 &(s_op->val), 
                                 0, 
                                 NULL,
                                 smcb,
                                 0,
                                 js_p,
                                 &tmp_id,
                                 server_job_context,
                                 s_op->req->hints));
}
#endif

static void free_keyval_buffers(struct PINT_server_op *s_op)
{
    int i = 0;

    if (s_op->free_val)
    {
        if (s_op->val.buffer)
        {
            free(s_op->val.buffer);
            s_op->val.buffer = NULL;
        }

        if (s_op->val_a)
        {
            for (i=0; i<s_op->keyval_count; i++)
            {
                if (s_op->val_a[i].buffer)
                {
                    free(s_op->val_a[i].buffer);
                    s_op->val_a[i].buffer = NULL;
                }
            }
        }
        s_op->free_val = 0;
    }
    memset(&(s_op->val),0,sizeof(s_op->val));
    memset(&(s_op->key),0,sizeof(s_op->key));

    if (s_op->val_a)
    {
        free(s_op->val_a);
        s_op->val_a = NULL;
    }
    if (s_op->key_a)
    {
        free(s_op->key_a);
        s_op->key_a = NULL;
    }
    if (s_op->error_a)
    {
        free(s_op->error_a);
        s_op->error_a = NULL;
    }
}

static int perm_getattr(PINT_server_op *s_op)
{
    int ret;

    ret = 0;

    return ret;
}

PINT_GET_OBJECT_REF_DEFINE(getattr);
PINT_GET_CREDENTIAL_DEFINE(getattr);

struct PINT_server_req_params pvfs2_get_attr_params =
{
    .string_name = "getattr",
    .perm = perm_getattr,
    .access_type = PINT_server_req_readonly,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getattr,
    .get_credential = PINT_get_credential_getattr,
    .state_machine = &pvfs2_get_attr_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

