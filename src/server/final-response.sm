/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */


#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

/* final-response state machine:
 * This is used as a nested state machine to perform two primary tasks:
 * - release the operation from the request scheduler
 * - send a response to the client
 */

/* PRECONDITIONS:
 * - the s_op->resp struct must be filled in with the response that
 *   needs to be sent (not yet encoded), with one exception:
 * - js_p->error_code must indicate the status value that you wish 
 *   to have set in the response structure
 * - if the operation has been scheduled, then the scheduled id must be
 *   stored in s_op->scheduled_id
 */

/* TODO: document pre and post conditions (what server_op fields do we
 * require, and which ones do we modify?)
 */


static int final_response_release(PINT_server_op *s_op, job_status_s *js_p);
static int final_response_send_resp(PINT_server_op *s_op, job_status_s *js_p);
static int final_response_cleanup(PINT_server_op *s_op, job_status_s *js_p);

%%

nested machine pvfs2_final_response_sm(release, send_resp, cleanup)
{
    state release
    {
	run final_response_release;
	default => send_resp;
    }

    state send_resp
    {
	run final_response_send_resp;
	default => cleanup;
    }

    state cleanup
    {
	run final_response_cleanup;
	default => return;
    }
}


%%

/* final_response_release()
 *
 * releases the operation from the request scheduler
 */
static int final_response_release(PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -1;
    job_id_t tmp_id;

    gossip_debug(GOSSIP_SERVER_DEBUG, 
		 "(%p) %s (final_response sm) state: release\n", s_op,
		 PINT_map_server_op_to_string(s_op->req->op));

    /* this seems a little odd, but since this is the first state of the
     * nested machine, now is the time to grab the error code if we
     * are going to use it
     */
    /* NOTE: we filter out any subsystem mask and make sure that this
     * shows up as a generic pvfs error on the client side
     */
    s_op->resp.status = -PVFS_ERROR_CODE(-js_p->error_code);

    /* catch cases in which the operation has not been scheduled */
    if (!s_op->scheduled_id)
    {
	js_p->error_code = 0;
	return 1;
    }

    ret = job_req_sched_release(s_op->scheduled_id,
				s_op,
				0,
				js_p,
				&tmp_id,
				server_job_context);

    return ret;
}

/* final_response_send_resp()
 *
 * encodes and sends a response to the client
 */
static int final_response_send_resp(PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -1;
    job_id_t tmp_id;
    
    gossip_debug(GOSSIP_SERVER_DEBUG, 
		 "(%p) %s (final_response sm) state: send_resp\n",
		 s_op,
		 PINT_map_server_op_to_string(s_op->req->op));

    if (js_p->error_code != 0)
    {
	gossip_lerr("Error: req_sched_release() failure; continuing...\n");
    }

    /* encode message */
    ret = PINT_encode(&s_op->resp,
		      PINT_ENCODE_RESP,
		      &(s_op->encoded),
		      s_op->addr,
		      s_op->decoded.enc_type);
    if (ret < 0)
    {
	gossip_lerr("Error: PINT_encode() failure.\n");
	/* TODO: probably should dump contents of response to give 
	 * some clues as to what went wrong
	 */
	js_p->error_code = ret;
	return 1;
    }

    /* send the response */
    ret = job_bmi_send_list(s_op->addr,
			    s_op->encoded.buffer_list,
			    s_op->encoded.size_list,
			    s_op->encoded.list_count,
			    s_op->encoded.total_size,
			    s_op->tag,
			    s_op->encoded.buffer_type,
			    0,
			    s_op,
			    0,
			    js_p,
			    &tmp_id,
			    server_job_context,
			    PVFS2_SERVER_RESPONSE_TIMEOUT);

    return ret;
}


/* final_response_cleanup()
 *
 * cleans up resources allocated while in this nested machine.  Right now 
 * that just means releasing the encoding of the response
 */
static int final_response_cleanup(PINT_server_op *s_op, job_status_s *js_p)
{
    gossip_debug(GOSSIP_SERVER_DEBUG, 
		 "(%p) %s (final_response sm) state: cleanup\n",
		 s_op,
		 PINT_map_server_op_to_string(s_op->req->op));

    PINT_encode_release(&s_op->encoded, PINT_ENCODE_RESP);

    /* decrement reference count for this bmi address */
    BMI_set_info(s_op->addr, BMI_DEC_ADDR_REF, NULL);

    js_p->error_code = 0;
    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
