/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/*
 *  PVFS2 server state machine for driving read I/O operations.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-request.h"
#include "pint-distribution.h"
#include "pint-request.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"
#include "trove.h"

#define CONTINUE_KMEANS 301

%%

nested machine pvfs2_kmeans_sm
{
    state bcast_inititial_centers
    {
	run bcast_initial_centers_fn;
    default => local_comp;
    }

    state local_comp
    {
        run local_comp_fn;
	success => allreduce_1;
    }

    state allreduce_1
    {
	jump pvfs2_allreduce_sm;
	success => allreduce_2;
    }
    
    state allreduce_2
    {
	jump pvfs2_allreduce_sm;
	success => avg_replace;
    }

    state avg_replace
    {
	run avg_replace_fn;
	success => allreduce_3;
    }

    state allreduce_3
    {
	jump pvfs2_allreduce_sm;
	success => check_done;
    }

    state check_done
    {
	run check_done_fn;
	CONTINUE_KMEANS => local_comp;
	success => return;
    }
}

%%

/* square of Euclid distance between two multi-dimensional points            */
__inline static
float euclid_dist_2(int    numdims,  /* no. dimensions */
                    float *coord1,   /* [numdims] */
                    float *coord2)   /* [numdims] */
{
  int i;
  float ans=0.0;

  for (i=0; i<numdims; i++)
    ans += (coord1[i]-coord2[i]) * (coord1[i]-coord2[i]);

  return(ans);
}

/*----< find_nearest_cluster() >---------------------------------------------*/
__inline static
int find_nearest_cluster(int     numClusters, /* no. clusters */
                         int     numCoords,   /* no. coordinates */
                         float  *object,      /* [numCoords] */
                         float **clusters)    /* [numClusters][numCoords] */
{
  int   index, i;
  float dist, min_dist;

  /* find the cluster id that has min distance to object */
  index    = 0;
  min_dist = euclid_dist_2(numCoords, object, clusters[0]);

  for (i=1; i<numClusters; i++) {
    dist = euclid_dist_2(numCoords, object, clusters[i]);
    /* no need square root */
    if (dist < min_dist) { /* find the min and its array index */
      min_dist = dist;
      index    = i;
    }
  }
  return(index);
}

/*
 */
static PINT_sm_action bcast_initial_centers_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *parent_s_op = PINT_sm_frame(smcb->parent_smcb, 0); /* pipeline.sm */
    int ret, i, tmp_id;
    int myRank = parent_s_op->u.pipeline.dfile_index, newRank, rootRank;
    PVFS_handle new_rank_handle;
    PVFS_BMI_addr_t svr_addr;
    PVFS_msg_tag_t session_tag = 5555;
    struct server_configuration_s *user_opts = get_server_config_struct();

    js_p->error_code = 0;

    if(myRank == 0) {
	for(i=1; i < parent_s_op->u.pipeline.dfile_count; i++) {
	    gossip_debug(GOSSIP_IO_DEBUG, "myRank=%d, newRank=%d\n", 
			 myRank, i);
	    new_rank_handle = parent_s_op->u.pipeline.dfile_array[i];
	    gossip_debug(GOSSIP_IO_DEBUG, "new_rank_handle=%llu\n", 
			 llu(new_rank_handle));
	    ret = PINT_cached_config_map_to_server(&svr_addr,
						   new_rank_handle,
						   parent_s_op->u.pipeline.fs_id);

	    if(ret < 0) {
		gossip_err("Failed to map meta server address\n");
		js_p->error_code = ret;
		return SM_ACTION_COMPLETE;
	    }

	    ret = job_bmi_send(svr_addr,
			       (void*)s_op->u.kmeans.clusters,
			       18*sizeof(float),
			       session_tag,
			       BMI_PRE_ALLOC,
			       0, /* 1: send_unexpected */
			       smcb,
			       0,
			       js_p,
			       &tmp_id,
			       server_job_context,
			       user_opts->server_job_bmi_timeout,
			       (PVFS_hint)parent_s_op->u.pipeline.hints);
	    
	    if(ret == 1) {
		js_p->error_code = ret;
		return SM_ACTION_COMPLETE;
	    }
	    
	    if(ret == 0) {
		js_p->error_code = ret;
		return SM_ACTION_DEFERRED;
	    }
	} /* end for() */
    }
    else /* all other nodes */ {
	/* RECV from rootRank */
	new_rank_handle = parent_s_op->u.pipeline.dfile_array[0];
	ret = PINT_cached_config_map_to_server(&svr_addr,
					       new_rank_handle,
					       parent_s_op->u.pipeline.fs_id);

	if(ret < 0) {
	    gossip_err("Failed to map meta server address\n");
	    js_p->error_code = ret;
	    return SM_ACTION_COMPLETE;
	}
	
	gossip_debug(GOSSIP_IO_DEBUG, "RECV from addr=%llu\n", llu(svr_addr));
	ret = job_bmi_recv(svr_addr,
			   (void*)s_op->u.kmeans.clusters,
			   18*sizeof(float),
			   session_tag,
			   BMI_PRE_ALLOC,
			   smcb,
			   0,
			   js_p,
			   &tmp_id,
			   server_job_context,
			   user_opts->server_job_bmi_timeout,
			   (PVFS_hint)parent_s_op->u.pipeline.hints);
	
	if(ret == 1) {
	    js_p->error_code = ret;
	    return SM_ACTION_COMPLETE;
	}
	
	if(ret == 0) {
	    js_p->error_code = ret;
	    return SM_ACTION_DEFERRED;
	}
    }
	
    return SM_ACTION_COMPLETE;
}

/*
 */
static PINT_sm_action local_comp_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i, j, index;

    s_op->u.kmeans.delta = 0.0;

    for(i=0; i<s_op->u.kmeans.numObjs; i++) {
	/* find the array index of nestest cluster center */
	index = find_nearest_cluster(s_op->u.kmeans.numClusters, 
				     s_op->u.kmeans.numCoords, 
				     s_op->u.kmeans.objects[i],
				     s_op->u.kmeans.clusters);
	 /* if membership changes, increase delta by 1 */
	if (s_op->u.kmeans.membership[i] != index) 
	    s_op->u.kmeans.delta += 1.0;

	/* assign the membership to object i */
	s_op->u.kmeans.membership[i] = index;
      
	/* update new cluster centers : sum of objects located within */
	s_op->u.kmeans.newClusterSize[index]++;
	for (j=0; j<s_op->u.kmeans.numCoords; j++)
	  s_op->u.kmeans.newClusters[index][j] += s_op->u.kmeans.objects[i][j];
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action avg_replace_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i, j;

    /* average the sum and replace old cluster centers with newClusters */
    for (i=0; i<s_op->u.kmeans.numClusters; i++) {
	for (j=0; j<s_op->u.kmeans.numCoords; j++) {
	    if (s_op->u.kmeans.clusterSize[i] > 1)
		s_op->u.kmeans.clusters[i][j] /= 
		    s_op->u.kmeans.clusterSize[i];
	    s_op->u.kmeans.newClusters[i][j] = 0.0;   /* set back to 0 */
	}
	s_op->u.kmeans.newClusterSize[i] = 0;   /* set back to 0 */
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action check_done_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    s_op->u.kmeans.delta = (s_op->u.kmeans.delta_tmp)/(s_op->u.kmeans.totalNumObjs);

    if(s_op->u.kmeans.delta > s_op->u.kmeans.threshold && s_op->u.kmeans.loop++ < 500)
	js_p->error_code = CONTINUE_KMEANS;
    else
	js_p->error_code = 0;

    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
