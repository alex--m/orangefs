/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/*
 *  PVFS2 server state machine for driving read I/O operations.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-request.h"
#include "pint-distribution.h"
#include "pint-request.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"
#include "trove.h"

#define CONTINUE_KMEANS 301

%%

nested machine pvfs2_kmeans_sm
{
    state local_comp
    {
        run local_comp_fn;
	success => allreduce_1;
    }

    state allreduce_1
    {
	jump pvfs2_allreduce_sm;
	success => allreduce_2;
    }
    
    state allreduce_2
    {
	jump pvfs2_allreduce_sm;
	success => avg_replace;
    }

    state avg_replace
    {
	run avg_replace_fn;
	success => allreduce_3;
    }

    state allreduce_3
    {
	jump pvfs2_allreduce_sm;
	success => check_done;
    }

    state check_done
    {
	run check_done_fn;
	CONTINUE_KMEANS => local_comp;
	success => return;
    }
}

%%

/* square of Euclid distance between two multi-dimensional points            */
__inline static
float euclid_dist_2(int    numdims,  /* no. dimensions */
                    float *coord1,   /* [numdims] */
                    float *coord2)   /* [numdims] */
{
  int i;
  float ans=0.0;

  for (i=0; i<numdims; i++)
    ans += (coord1[i]-coord2[i]) * (coord1[i]-coord2[i]);

  return(ans);
}

/*----< find_nearest_cluster() >---------------------------------------------*/
__inline static
int find_nearest_cluster(int     numClusters, /* no. clusters */
                         int     numCoords,   /* no. coordinates */
                         float  *object,      /* [numCoords] */
                         float **clusters)    /* [numClusters][numCoords] */
{
  int   index, i;
  float dist, min_dist;

  /* find the cluster id that has min distance to object */
  index    = 0;
  min_dist = euclid_dist_2(numCoords, object, clusters[0]);

  for (i=1; i<numClusters; i++) {
    dist = euclid_dist_2(numCoords, object, clusters[i]);
    /* no need square root */
    if (dist < min_dist) { /* find the min and its array index */
      min_dist = dist;
      index    = i;
    }
  }
  return(index);
}

/*
 */
static PINT_sm_action local_comp_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *user_opts = get_server_config_struct();
    int i, j, index;

    s_op->u.kmeans.delta = 0.0;
#if 0
    for(i=0; i<numObjs; i++) {
	/* find the array index of nestest cluster center */
	index = find_nearest_cluster(numClusters, numCoords, objects[i],
				     clusters);
	 /* if membership changes, increase delta by 1 */
	if (membership[i] != index) delta += 1.0;

	/* assign the membership to object i */
	membership[i] = index;
      
	/* update new cluster centers : sum of objects located within */
	newClusterSize[index]++;
	for (j=0; j<numCoords; j++)
	  newClusters[index][j] += objects[i][j];
    }
    }
#endif	
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action avg_replace_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i, j;
#if 0
    /* average the sum and replace old cluster centers with newClusters */
    for (i=0; i<numClusters; i++) {
      for (j=0; j<numCoords; j++) {
	if (clusterSize[i] > 1)
	  clusters[i][j] /= clusterSize[i];
	newClusters[i][j] = 0.0;   /* set back to 0 */
      }
      newClusterSize[i] = 0;   /* set back to 0 */
    }
#endif
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action check_done_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
#if 0
    s_op->u.kmeans.delta = delta_tmp/total_numObjs;

    if(delta > threshold && loop++ < 500)
	js_p->error_code = CONTINUE_KMEANS;
    else
	js_p->error_code = 0;
#endif
    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
