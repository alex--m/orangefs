/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/*Serverside getparam.sm*/

#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pint-event.h"
#include "pvfs2-internal.h"
#include "gossip.h"
#include "request-scheduler/request-scheduler.h"
#include "pint-security.h"
#include "pint-perf-counter.h" //Added this
#include "pint-util.h"         //Added this
#include "pvfs2-types.h"       //Added this

%%

machine pvfs2_getparam_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => work;
        default => final_response;
    }

    state work
    {
        run getparam_work;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run getparam_cleanup;
        default => terminate;
    }
}

%%

/* getparam_work()
 *
 * actually does the "work" involved in setting a runtime server parameter
 */
static PINT_sm_action getparam_work(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1; //Removed tmp_on = 0
    unsigned int key_count, interval, hist;  //added this line
    struct server_configuration_s *user_opts;

    //retreiving the various parameters
    ret = PINT_perf_get_info(PINT_server_pc, PINT_PERF_HISTORY_SIZE, &hist);
    if(ret != 0) /* Verify return value */;
    ret = PINT_perf_get_info(PINT_server_pc, PINT_PERF_KEY_COUNT, &key_count);
    if(ret != 0) /* Verify return value */;
    ret = PINT_perf_get_info(PINT_server_pc, PINT_PERF_UPDATE_INTERVAL, &interval);
    if(ret != 0) /* Verify return value */;
    user_opts = get_server_config_struct();

    if(user_opts->perf_update_interval != interval){
    /* handle the case where whats in server config conflicts with current perf setting */
    }
    if(user_opts->perf_update_history != hist){
    /* handle the case where whats in server config conflicts with current perf setting */
    }
    s_op->resp.u.mgmt_getparam.history = hist;
    s_op->resp.u.mgmt_getparam.interval = interval;
    s_op->resp.u.mgmt_getparam.key_count = key_count;
    /*gossip_lerr("Error: mgmt_getparam for unknown parameter %d.\n",
                (int)s_op->req->u.mgmt_getparam.param);
    */

    return SM_ACTION_COMPLETE;
}

/* getparam_cleanup()
 *
 * cleans up any resources consumed by this state machine and ends
 * execution of the machine
 */
static PINT_sm_action getparam_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    gossip_debug(GOSSIP_SERVER_DEBUG, " - getparam returning %d\n",
                 js_p->error_code);
    return(server_state_machine_complete(smcb));
}

static inline int PINT_get_object_ref_getparam(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = PVFS_FS_ID_NULL;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

static int perm_getparam(PINT_server_op *s_op)
{
    int ret;

    /*Requires no permission*/
   ret = 0;

    return ret;
}

struct PINT_server_req_params pvfs2_getparam_params =
{
    .string_name = "mgmt_getparam",
    .perm = perm_getparam,
    .access_type = PINT_server_req_modify,
    .get_object_ref = PINT_get_object_ref_getparam,
    .state_machine = &pvfs2_getparam_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
