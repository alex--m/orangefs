 /* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/*
 *  PVFS2 server state machine for driving write I/O operations.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-request.h"
#include "pint-distribution.h"
#include "pint-request.h"
#include "pvfs2-internal.h"
#include "rw-sm.h"
#include "trove.h"
#include "pint-segpool.h"

%%

nested machine pvfs2_write_sm
{
    state bmi_recv
    {
        run bmi_recv_call;
        default => trove_write;
    }

    state trove_write
    {
        run trove_write_call;
        default => check;
    }

    state check
    {
        run check_done;
	success => finished;
        LOOP => bmi_recv;
    }

    state finished
    {
        run epilog;
        default => return;
    }
}

%%

/*
 * PINT_process_request() -> job_bmi_recv()
 */
static PINT_sm_action bmi_recv_call(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct fp_queue_item *q_item = s_op->u.flow_write.q_item;
    PINT_segpool_handle_t seg_handle = s_op->u.flow_write.seg_handle;
    PINT_segpool_unit_id id = s_op->u.flow_write.id;
    int ret;
    job_id_t tmp_id;
    struct server_configuration_s *user_opts = get_server_config_struct();
    int count;
    PVFS_offset *offsets;
    PVFS_size *sizes;
    PVFS_size bytes;

    q_item->buffer_used = 0;
    
    if(!q_item->buffer){
        /* if the q_item has not been used, allocate a buffer */
        q_item->buffer = BMI_memalloc(
            q_item->parent->src.u.bmi.address,
            q_item->parent->buffer_size, BMI_RECV);
        /* TODO: error handling */
        assert(q_item->buffer);
    }

    bytes = q_item->parent->buffer_size;
    PINT_segpool_take_segments(seg_handle, id, &bytes, &count, 
			       &offsets, &sizes);
    gossip_debug(GOSSIP_IO_DEBUG, "%s: 3: count=%d, bytes=%ld\n", 
		 __func__, count, bytes);
    q_item->buffer_used = bytes;
    s_op->u.flow_write.offsets = offsets;
    s_op->u.flow_write.sizes = sizes;
    s_op->u.flow_write.segs = count;

    if(count == 0) {
	js_p->error_code = 0;
	return SM_ACTION_COMPLETE;
    }
    
    /* TODO: what if we recv less than expected? */
    ret = job_bmi_recv(q_item->parent->src.u.bmi.address,
		       (char *)q_item->buffer,
		       q_item->parent->buffer_size,
		       q_item->parent->tag,
		       BMI_PRE_ALLOC, 
		       smcb, 
		       0, /* unsigned long status_user_tag = 0 */
		       js_p,
		       &tmp_id,
		       server_job_context,
		       user_opts->server_job_flow_timeout,
		       (bmi_hint)q_item->parent->hints);
    
    if(ret < 0) {
	gossip_err("%s: I/O error occurred\n", __func__);
	/* FIXME: need to handle I/O error */
	//handle_io_error(ret, q_item, flow_data);
	js_p->error_code = -PVFS_EIO;
	return SM_ACTION_COMPLETE;
    }

    if(ret == 1) {
	js_p->error_code = 0;
	return SM_ACTION_COMPLETE;
    }
    if(ret == 0) {
	js_p->error_code = 0;
	return SM_ACTION_DEFERRED;
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action trove_write_call(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct fp_queue_item *q_item = s_op->u.flow_write.q_item;
    int ret;
    job_id_t tmp_id;
    struct filesystem_configuration_s *fs_config;
    struct server_configuration_s *server_config;

    gossip_debug(GOSSIP_IO_DEBUG, "%s: q_item->buffer_used=%ld\n", __func__, 
		 q_item->buffer_used);
    gossip_debug(GOSSIP_IO_DEBUG, "%s: q_item->buffer[0]=%s\n", __func__,
		 (char *)q_item->buffer);

    if(s_op->u.flow_write.segs == 0 && q_item->buffer_used == 0) {
	js_p->error_code = 0;
	return SM_ACTION_COMPLETE;
    }
    
    fs_config = PINT_config_get_filesystems(&server_config);
    
    ret = job_trove_bstream_write_list(
				       q_item->parent->dest.u.trove.coll_id,
				       q_item->parent->dest.u.trove.handle,
				       (char**)&q_item->buffer,
				       (TROVE_size *)&q_item->buffer_used,
				       1,
				       s_op->u.flow_write.offsets,
				       s_op->u.flow_write.sizes,
				       s_op->u.flow_write.segs,
				       &q_item->out_size,
				       fs_config->trove_sync_data,
				       NULL,
				       smcb,
				       0,
				       js_p,
				       &tmp_id,
				       server_job_context,
				       q_item->parent->hints);

    if(ret < 0) {
	gossip_err("%s: I/O error occurred\n", __func__);
	//handle_io_error(ret, q_item, flow_data);
	/* FIXME ***************/
	js_p->error_code = -PVFS_ENOMEM;
	return SM_ACTION_COMPLETE;
    }

    if(ret == 1) {
	/* immediate completion; trigger callback ourselves */
	js_p->error_code = 0;
	return SM_ACTION_COMPLETE;
    }

    /* FIXME: not sure if this is required */
    if(ret == 0) {
	return SM_ACTION_DEFERRED;
    }

    return SM_ACTION_COMPLETE;
}

static int check_done(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct fp_queue_item *q_item = s_op->u.flow_write.q_item;
    PINT_segpool_handle_t h = s_op->u.flow_write.seg_handle;
    js_p->error_code = 0;

    q_item->parent->total_transferred += q_item->buffer_used;
    gossip_debug(GOSSIP_IO_DEBUG, "%s: total_transferred=%ld\n", __func__,
		 q_item->parent->total_transferred);

    //if(!PINT_REQUEST_DONE(q_item->parent->file_req_state)) {
    if(!segpool_done(h)) {
	gossip_debug(GOSSIP_IO_DEBUG, "%s: write: LOOP\n", __func__);
	js_p->error_code = LOOP;
    }
    else {
	gossip_debug(GOSSIP_IO_DEBUG, "%s: write: DONE\n", __func__);
    }
    
    return SM_ACTION_COMPLETE;
}

static int epilog(struct PINT_smcb *smcb, job_status_s *js_p)
{
    js_p->error_code = 0;

    return SM_ACTION_COMPLETE;
    //return(server_state_machine_complete(smcb)); // why not this?
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
