/* 
 * (C) 2008 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "extent-utils.h"

extern job_context_id pint_client_sm_context;

enum
{
    LOCAL_OPERATION = 2,
    REMOTE_OPERATION = 3
};

enum
{
    CREATE_RETRY = 170
};

%%

/* this machine launches the main machine below */
/* mostly here to convert from a server to a client SM frame */
machine pvfs2_create_file_sm
{
    /* all server SMs run prelude for scheduler and security */
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => create;
        default => final_response;
    }

    state create
    {
        /* set up for jump to client SM */
        pjmp create_file_setup
        {
            default => pvfs2_create_file_work_sm;
        }
        default => setup_resp;
    }

    /* copy results back to server SM and prepare resp */
    state setup_resp
    {
        run create_file_resp;
        default => final_response;
    }

    /* send response */
    state final_response
    {
        jump pvfs2_final_response_sm;
        default => terminate;
    }
}

/* This SM was moved here from the client to allow server to */
/* server collective processing of file create */
machine pvfs2_create_file_work_sm
{
    state init
    {
        run create_file_init;
        default => parent_getattr;
    }

    state parent_getattr
    {
        jump pvfs2_get_attr_work_sm;
        success => parent_getattr_cleanup_and_inspect;
        default => cleanup_work;
    }

    state parent_getattr_cleanup_and_inspect
    {
        run create_file_parent_getattr_cleanup_and_inspect;
        LOCAL_OPERATION => do_dspace_create;
        REMOTE_OPERATION => dspace_xfer_msgpair_array;
        default => cleanup_work;
    }

    state do_dspace_create
    {
        jump pvfs2_create_work_sm;
        success => dspace_create_cleanup;
        default => cleanup_work;
    }

    state dspace_create_cleanup
    {
        run create_file_dspace_cleanup;
        success => datafiles_setup;
        default => cleanup_work;
    }

    state dspace_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        success => datafiles_setup;
        default => cleanup_work;
    }

    state datafiles_setup
    {
        run create_file_datafiles_setup;
        REMOTE_OPERATION => datafiles_remote_setup;
        LOCAL_OPERATION => datafiles_local_setup;
        default => cleanup_work;
    }

    state datafiles_remote_setup
    {
        run create_file_datafiles_remote_setup;
        REMOTE_OPERATION => datafiles_xfer_msgpair_array;
        default => datafiles_local_setup;
    }

    state datafiles_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        success => datafiles_local_setup;
        default => cleanup_work;
    }

    state datafiles_local_setup
    {
        run create_file_datafiles_local_setup;
        default => do_datafiles_local;
    }

    /* TODO: Needs to handle multiple local creates. */
    state do_datafiles_local
    {
        jump pvfs2_create_work_sm;
        success => datafiles_local_cleanup_and_setattr_setup;
        default => cleanup_work;
    }

    state datafiles_local_cleanup_and_setattr_setup
    {
        run create_file_datafiles_local_cleanup_and_setattr_setup;
        default => do_setattr;
/*
        LOCAL_OPERATION => do_setattr;
        REMOTE_OPERATION => setattr_xfer_msgpair_array;
        default => cleanup_work;
*/
    }

    state do_setattr
    {
        jump pvfs2_set_attr_work_sm;
        default => setattr_cleanup;
    }

    state setattr_cleanup
    {
        run create_file_setattr_cleanup;
        success => crdirent_setup;
        default => cleanup_work;
    }

    state setattr_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        success => crdirent_setup;
        default => cleanup_work;
    }

    state crdirent_setup
    {
        run create_file_crdirent_setup;
        success => do_crdirent;
        default => cleanup_work;
    }

    state do_crdirent
    {
        jump pvfs2_crdirent_work_sm;
        success => crdirent_cleanup;
        default => cleanup_work;
    }

    state crdirent_cleanup
    {
        run create_file_crdirent_cleanup;
        default => cleanup_work;
    }

    state cleanup_work
    {
        run create_file_work_cleanup;
        CREATE_RETRY => init;
        default => terminate;
    }
}

%%

/* action files for the main SM */

/* In this function transfer arguments from the request to the struct */
/* in the client SM - set all other values in client SM, create a push */
/* stack frame */

static PINT_sm_action create_file_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_setup entered\n");

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    struct PINT_client_sm *sm_p = malloc(sizeof(struct PINT_client_sm));
    if(!sm_p)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(sm_p, 0, sizeof(struct PINT_client_sm));

    /* Copied this from #define PINT_init_msgarray_params in client-state-machine.h
     * because PINT_get_server_config_struct(__fsid) was not available on the server
     * side. Use get_server_config_struct() instead. 
     */
    {
        PINT_sm_msgpair_params *mpp = &sm_p->msgarray_params;
        struct server_configuration_s *server_config =
            get_server_config_struct();
        mpp->job_context = server_job_context;
        if (server_config)
        {
            mpp->job_timeout = server_config->client_job_bmi_timeout;
            mpp->retry_limit = server_config->client_retry_limit;
            mpp->retry_delay = server_config->client_retry_delay_ms;
        }
        else
        {
            mpp->job_timeout = PVFS2_CLIENT_JOB_BMI_TIMEOUT_DEFAULT;
            mpp->retry_limit = PVFS2_CLIENT_RETRY_LIMIT_DEFAULT;
            mpp->retry_delay = PVFS2_CLIENT_RETRY_DELAY_MS_DEFAULT;
        }
    }

    sm_p->cred_p = &(s_op->req->credentials);
    sm_p->u.create_file.object_name = s_op->req->u.create_file.object_name;
    sm_p->u.create_file.attr = s_op->req->u.create_file.attr;
/* TODO: Pass this from the client. */
    sm_p->u.create_file.layout.algorithm = PVFS_SYS_LAYOUT_NONE;
/* TODO: Pass this from the client. */
    sm_p->u.create_file.dist = PINT_dist_create(PVFS_DIST_SIMPLE_STRIPE_NAME);
    sm_p->parent_ref.handle = s_op->req->u.create_file.parent_handle;
    sm_p->parent_ref.fs_id = s_op->req->u.create_file.fs_id;
    sm_p->object_ref.fs_id = sm_p->parent_ref.fs_id;
    sm_p->u.create_file.num_data_files = s_op->req->u.create_file.num_data_files;
    sm_p->u.create_file.meta_handle_extent_array.extent_count =
           s_op->req->u.create_file.meta_handle_extent_array.extent_count;
    sm_p->u.create_file.meta_handle_extent_array.extent_array =
           s_op->req->u.create_file.meta_handle_extent_array.extent_array;

    gossip_debug(GOSSIP_SERVER_DEBUG, "Creating file %s under %llu, %d\n",
        sm_p->u.create_file.object_name, llu(sm_p->parent_ref.handle),
        sm_p->parent_ref.fs_id);

    PINT_sm_push_frame(smcb, 0, sm_p);
    return(SM_ACTION_COMPLETE);
}

/* the one thing that returns from the create file is an object handle
 * copy back to server SM and set up response */

static PINT_sm_action create_file_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_PREVIOUS);
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;

    if (js_p->error_code == 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "Handle created: %llu\n",
                     llu(sm_p->u.create_file.metafile_handle));
        s_op->resp.u.create_file.handle = sm_p->u.create_file.metafile_handle;
        switch(s_op->req->u.create_file.attr.objtype)
        {
            case PVFS_TYPE_NONE:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type unknown.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_METAFILE:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type metafile.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_DATAFILE:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type datafile.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_DIRECTORY:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type directory.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_SYMLINK:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type symlink.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_DIRDATA:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type dirdata.\n", llu(js_p->handle));
                break;
        }
    }
    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    free(sm_p);

    return (SM_ACTION_COMPLETE);
}

/****************************************************************/

static PINT_sm_action create_file_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;
    struct PINT_server_op *s_op;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create file state: init\n");

    assert((js_p->error_code == 0) ||
           (js_p->error_code == CREATE_RETRY));

    if (js_p->error_code == CREATE_RETRY)
    {
        js_p->error_code = 0;

        return job_req_sched_post_timer(
            sm_p->msgarray_params.retry_delay, smcb, 0, js_p, &tmp_id,
            server_job_context);
    }

    /* Prepare to retrieve the parent's attributes. */
    s_op = malloc(sizeof(struct PINT_server_op));

    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));

    s_op->op = PVFS_SERV_GETATTR;
    s_op->u.getattr.handle = sm_p->parent_ref.handle;
    s_op->u.getattr.fs_id = sm_p->parent_ref.fs_id;
    s_op->u.getattr.attrmask = PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_HINT;

    s_op->attr.mask = PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_HINT;
    s_op->attr.objtype = PVFS_TYPE_DIRECTORY;

    PINT_sm_push_frame(smcb, 0, s_op);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_parent_getattr_cleanup_and_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int task_id;
    int error_code;
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_PREVIOUS);
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *attr = NULL;
    int num_dfiles_requested_override = 0;
    PINT_dist *current_dist; 
    int ret = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
        "create file state: parent_getattr_cleanup_and_inspect\n");

    assert(sm_p);
    assert(s_op);

    /* Copy the results before popping the stack. */
    attr = &sm_p->getattr.attr;
    assert(attr);
    memcpy(attr, &s_op->attr, sizeof(attr));
    memcpy(&sm_p->u.create_file.saved_parent_attr, &s_op->attr, sizeof(PVFS_object_attr));

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
//    free(s_op);

    js_p->error_code = error_code;

    if (error_code == 0) {
        /** Look at the attributes of the parent directory and
         *  decide if it impacts the file creation in any way.
         */
        gossip_debug(GOSSIP_CLIENT_DEBUG, "parent owner: %d, group: %d, perms: %d\n",
            (int)attr->owner, (int)attr->group, (int)attr->perms);

        /* do we have a setgid bit? */
        if(attr->perms & PVFS_G_SGID)
        {
            gossip_debug(GOSSIP_CLIENT_DEBUG, "parent has setgid bit set.\n");
            gossip_debug(GOSSIP_CLIENT_DEBUG, " - modifying requested attr "
                                              "for new file.\n");
            sm_p->u.create_file.attr.group = attr->group;
            /* note that permission checking is left to server even in this case */
        }
        gossip_debug(GOSSIP_CLIENT_DEBUG, "create_parent_getattr: [%p] "
            "dfile_count     = %d "
            "dist_name_len   = %d "
            "dist_params_len = %d\n",
            attr,
            attr->u.dir.hint.dfile_count,
            attr->u.dir.hint.dist_name_len,
            attr->u.dir.hint.dist_params_len);

        num_dfiles_requested_override = attr->u.dir.hint.dfile_count;
        /* override the # of data files for this create */
        if (num_dfiles_requested_override > 0)
        {
            /* Determine the number of dfiles */
            PINT_cached_config_get_num_dfiles(sm_p->object_ref.fs_id,
                    sm_p->u.create_file.dist,
                    num_dfiles_requested_override,
                    &sm_p->u.create_file.num_data_files);
        }
        gossip_debug(GOSSIP_CLIENT_DEBUG, "Setting number of datafiles to %d [requested %d]\n", 
            sm_p->u.create_file.num_data_files, num_dfiles_requested_override);
        current_dist = sm_p->u.create_file.dist;
        /* We have an overriding distribution name for this directory.. honor that */
        if (attr->u.dir.hint.dist_name_len > 0)
        {
            /* switch it only if it is different! */
            if (strcmp(attr->u.dir.hint.dist_name, current_dist->dist_name))
            {
                PINT_dist *new_dist = NULL;
                new_dist = PINT_dist_create(attr->u.dir.hint.dist_name);
                if (new_dist)
                {
                    gossip_debug(GOSSIP_CLIENT_DEBUG, "Overridding distribution name to %s instead of %s\n",
                        attr->u.dir.hint.dist_name,
                        current_dist->dist_name);
                    PINT_dist_free(current_dist);
                    sm_p->u.create_file.dist = new_dist;
                    current_dist = new_dist;
                }
                else
                {
                    gossip_debug(GOSSIP_CLIENT_DEBUG, "Could not override distribution name with %s instead of %s\n",
                        attr->u.dir.hint.dist_name,
                        current_dist->dist_name);
                }
            }
            else {
                gossip_debug(GOSSIP_CLIENT_DEBUG, "retaining current distribution name %s\n",
                    current_dist->dist_name);
            }
        }

        /* okay, we might need to override some dist params as well */
        if (attr->u.dir.hint.dist_params_len > 0)
        {
            /* We have a series of comma separated key:val strings */
            char **key, **val;
            int64_t tmp_val;
            int nparams = 0;

            /* ignore parse errors! */
            if (PINT_split_keyvals(attr->u.dir.hint.dist_params,
                &nparams, &key, &val) == 0)
            {
                int i;
                for (i = 0; i < nparams; i++)
                {
                    gossip_debug(GOSSIP_CLIENT_DEBUG, "distribution parameter %s, value %s\n",
                        key[i], val[i]);
                    /* NOTE: just as in server-config.c when parsing "Param" and
                     * "Value" fields, we will assume that all values are 64 bit
                     * integers.  The only difference here is that we scan
                     * directly into a 64 bit integer, rather than converting
                     * from the int format that dotconf supports.
                     */
                    ret = sscanf(val[i], SCANF_lld, &tmp_val);
                    if(ret != 1)
                    {
                        gossip_err("Error: unsupported type for distribution parameter %s, value %s found in directory hints.\n", 
                            key[i], val[i]);
                        gossip_err("Error: continuing anyway.\n");
                    }
                    else
                    {
                        if(current_dist->methods->set_param(current_dist->dist_name,
                            current_dist->params,
                            key[i],
                            &tmp_val))
                        {

                            gossip_err("Error: could not override hinted distribution parameter %s, value %s found in directory hints\n",
                                key[i],
                                val[i]);
                        }
                     }
                     free(key[i]);
                     free(val[i]);
                }
                free(key);
                free(val);
            }
        }

        /* TODO: Determine whether the dspace should be created locally
         * or remotely and setup up for the appropriate place. For now,
         * just assume local. */
       
        /* Set up the frame for the nested create state machine */
        js_p->error_code = LOCAL_OPERATION;
        s_op = malloc(sizeof(struct PINT_server_op));

        if(!s_op)
        {
            return -PVFS_ENOMEM;
        }
        /* zero out all members */
        memset(s_op, 0, sizeof(struct PINT_server_op));
        s_op->op = PVFS_SERV_CREATE;
        s_op->u.create.fs_id = sm_p->object_ref.fs_id;
        s_op->u.create.handle_extent_array = sm_p->u.create_file.meta_handle_extent_array;
        s_op->u.create.object_type = PVFS_TYPE_METAFILE;


        PINT_sm_push_frame(smcb, 0, s_op);
 
    }
    
    return(SM_ACTION_COMPLETE);
}

static PINT_sm_action create_file_dspace_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_PREVIOUS);
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create file state: dspace_cleanup\n");

    /* stash the newly created meta file handle */
    sm_p->u.create_file.metafile_handle = s_op->resp.u.create.handle;
    sm_p->u.create_file.metafile_handle = js_p->handle;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "Metafile handle %llu\n",
                 llu(sm_p->u.create_file.metafile_handle));

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
//    free(s_op);
    js_p->error_code = error_code;
 
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_datafiles_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *server_config = NULL;
    int ret = -PVFS_EINVAL;
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create file state: datafiles_setup\n");
        
    js_p->error_code = 0;

    if (sm_p->u.create_file.num_data_files > PVFS_REQ_LIMIT_DFILE_COUNT)
    {
        sm_p->u.create_file.num_data_files = PVFS_REQ_LIMIT_DFILE_COUNT;
        gossip_err("Warning: reducing number of data "
                     "files to PVFS_REQ_LIMIT_DFILE_COUNT\n");
    }   
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "need to create %d datafiles\n",
                 sm_p->u.create_file.num_data_files);
    
    /* allocate handle extent array objects */
    sm_p->u.create_file.io_handle_extent_array = (PVFS_handle_extent_array *)
        malloc(sm_p->u.create_file.num_data_files *
               sizeof(PVFS_handle_extent_array));
    if (!sm_p->u.create_file.io_handle_extent_array)
    {
        gossip_err("create: failed to allocate handle_extent_array\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocate data server bmi address array */
    if (sm_p->u.create_file.data_server_addrs == NULL)
    {
        sm_p->u.create_file.data_server_addrs = (PVFS_BMI_addr_t *)malloc(
            sm_p->u.create_file.num_data_files * sizeof(PVFS_BMI_addr_t));
    }
    if (!sm_p->u.create_file.data_server_addrs)
    {
        gossip_err("create: failed to allocate data server addrs\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    server_config = get_server_config_struct();

    ret = PINT_cached_config_map_servers(
        server_config,
        sm_p->object_ref.fs_id,
        &sm_p->u.create_file.num_data_files,
        &sm_p->u.create_file.layout,
        sm_p->u.create_file.data_server_addrs,
        sm_p->u.create_file.io_handle_extent_array);
    if(ret < 0)
    {
        gossip_err("create: failed to map the layout to a set of IO servers\n");
        js_p->error_code = ret;
        return 1;
    }

    if (ret)
    {
        gossip_err("Failed to retrieve data server addresses\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /* TODO: Set up for remote creates. For now skip them. */
    js_p->error_code = LOCAL_OPERATION;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_datafiles_remote_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{

    /* TODO: Handle setup for any datafiles that are to be created remotely. */
    js_p->error_code = 0;

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_datafiles_local_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *s_op;
    job_id_t tmp_id;
    int ret = -PVFS_EINVAL;
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create file state: datafiles_local_setup\n");

    /* allocate memory for the data handles if we haven't already */
    if (sm_p->u.create_file.datafile_handles == NULL)
    {
        sm_p->u.create_file.datafile_handles = (PVFS_handle *)malloc(
            sm_p->u.create_file.num_data_files * sizeof(PVFS_handle));

        if (sm_p->u.create_file.datafile_handles == NULL)
        {
            gossip_err("create: Failed to allocate data handle array\n");
            return -PVFS_ENOMEM;
        }
        memset(sm_p->u.create_file.datafile_handles, 0,
               sm_p->u.create_file.num_data_files * sizeof(PVFS_handle));
    }
    js_p->error_code = 0;

    /* Set up the frame for local creates */
    s_op = malloc(sizeof(struct PINT_server_op));
        
    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));
    s_op->op = PVFS_SERV_CREATE;
    s_op->u.create.fs_id = sm_p->object_ref.fs_id;
    s_op->u.create.handle_extent_array = sm_p->u.create_file.io_handle_extent_array[0];
    s_op->u.create.object_type = PVFS_TYPE_DATAFILE;
        
    s_op->target_fs_id = sm_p->object_ref.fs_id;
    s_op->target_handle = sm_p->object_ref.handle;
    s_op->credentials.uid = sm_p->cred_p->uid;
    s_op->credentials.gid = sm_p->cred_p->gid;
        
    PINT_sm_push_frame(smcb, 0, s_op);

    /* TODO: Use a centralized method of obtaining ds_attr
             that can be called from other places as well.  */
    memset(&(s_op->ds_attr), 0, sizeof(PVFS_ds_attributes));
    ret = job_trove_dspace_getattr(
        sm_p->object_ref.fs_id, sm_p->object_ref.handle, smcb, &(s_op->ds_attr),
        0, js_p, &tmp_id, server_job_context);

 
    return ret;
}

static PINT_sm_action create_file_datafiles_local_cleanup_and_setattr_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_PREVIOUS);
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;
    job_id_t tmp_id;
    int ret = -PVFS_EINVAL;

    assert(sm_p);
    assert(s_op);

    /* stash the newly created data file handle */
    sm_p->u.create_file.datafile_handles[0] = s_op->resp.u.create.handle;


    gossip_debug(GOSSIP_CLIENT_DEBUG, "Datafile handle %d is %llu\n",
                 0, llu(sm_p->u.create_file.datafile_handles[0]));

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    js_p->error_code = error_code;

    if (error_code != 0) {
//        free(s_op);
    }
    else {
        /* TODO: Determine whether setattr is local or remote and set
                 up for the appropriate one. For now just assume local. */
        /* We will just reuse the sm_p that was just popped to set up for setattr. */
        memset(s_op, 0, sizeof(struct PINT_server_op));
        PINT_sm_push_frame(smcb, 0, s_op);

        s_op->op = PVFS_SERV_SETATTR;
        s_op->credentials.uid = sm_p->cred_p->uid;
        s_op->credentials.gid = sm_p->cred_p->gid;
        s_op->u.setattr.handle = sm_p->parent_ref.handle;
        s_op->u.setattr.fs_id = sm_p->parent_ref.fs_id;
        s_op->u.setattr.attr = sm_p->u.create_file.attr;
        s_op->u.setattr.attr.objtype = PVFS_TYPE_METAFILE;
        s_op->u.setattr.attr.u.meta.dfile_array =
            sm_p->u.create_file.datafile_handles;
        s_op->u.setattr.attr.u.meta.dfile_count =
            sm_p->u.create_file.num_data_files;
        s_op->u.setattr.attr.u.meta.dist =
            sm_p->u.create_file.dist;
        s_op->u.setattr.attr.u.meta.dist_size =
            PINT_DIST_PACK_SIZE(sm_p->u.create_file.dist);
        s_op->attr = s_op->u.setattr.attr;

        /* TODO: Use a centralized method of obtaining ds_attr
                 that can be called from other places as well.  */
        memset(&(s_op->ds_attr), 0, sizeof(PVFS_ds_attributes));
        ret = job_trove_dspace_getattr(
            sm_p->parent_ref.fs_id, sm_p->u.create_file.metafile_handle, smcb, &(s_op->ds_attr),
            0, js_p, &tmp_id, server_job_context);

        js_p->error_code = LOCAL_OPERATION;
        return (ret);
    }
 
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_setattr_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;

    assert(s_op);
    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
//    free(s_op);
    js_p->error_code = error_code;
 
    return SM_ACTION_COMPLETE;
}

/* setup and push a new frame for calling the nested crdirent state machine */
static PINT_sm_action create_file_crdirent_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *s_op = malloc(sizeof(struct PINT_server_op));
/*    job_id_t tmp_id;
    int ret = -PVFS_EINVAL; */

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create state: crdirent_setup\n");

    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));
    PINT_sm_push_frame(smcb, 0, s_op);

    s_op->op = PVFS_SERV_CRDIRENT;
    memcpy(&s_op->attr, &sm_p->u.create_file.attr, sizeof(PVFS_object_attr));
/*    s_op->attr = sm_p->u.create_file.attr; */
    s_op->u.crdirent.name = sm_p->u.create_file.object_name;
    s_op->u.crdirent.new_handle = sm_p->u.create_file.metafile_handle;
    s_op->u.crdirent.parent_handle = sm_p->parent_ref.handle;
    s_op->u.crdirent.fs_id = sm_p->object_ref.fs_id;
    s_op->u.crdirent.dir_attr_update_required = 0;

    s_op->credentials.uid = sm_p->cred_p->uid;
    s_op->credentials.gid = sm_p->cred_p->gid;

    memcpy(&s_op->attr, &sm_p->u.create_file.saved_parent_attr, sizeof(PVFS_object_attr));

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_crdirent_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;

    assert(s_op);
    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
//    free(s_op);
    js_p->error_code = 0;
 
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_work_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_ref metafile_ref;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: work_cleanup\n");

    /* this is in common/misc/pvfs2-util.c which is normally only in the
     * client.  They sys_attr is not a flat structure, thus there are
     * utils to copy and free them.  Either need to stick with the
     * format in the protocol (will come to us in the request) or add
     * this code into the server - not much else in it is useful to the
     * server, so I'm leaning to the former
     */
/*    PVFS_util_release_sys_attr(&sm_p->u.create_file.sys_attr); */

    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);

    sm_p->error_code = (sm_p->u.create_file.stored_error_code ?
                        sm_p->u.create_file.stored_error_code :
                        js_p->error_code);

    memset(&metafile_ref, 0, sizeof(metafile_ref));

    if (sm_p->error_code == 0)
    {
        metafile_ref.handle = sm_p->u.create_file.metafile_handle;
        metafile_ref.fs_id = sm_p->object_ref.fs_id;
    }
    else if ((PVFS_ERROR_CLASS(-sm_p->error_code) == PVFS_ERROR_BMI) &&
             (sm_p->u.create_file.retry_count < sm_p->msgarray_params.retry_limit))
    {
        sm_p->u.create_file.stored_error_code = 0;
        sm_p->u.create_file.retry_count++;

        gossip_debug(GOSSIP_CLIENT_DEBUG, "Retrying create operation "
                     "(attempt number %d)\n", sm_p->u.create_file.retry_count);

        js_p->error_code = CREATE_RETRY;
        return SM_ACTION_COMPLETE;
    }

    PINT_free_object_attr(&sm_p->u.create_file.cache_attr);

    if (sm_p->u.create_file.io_handle_extent_array)
    {
        free(sm_p->u.create_file.io_handle_extent_array);
        sm_p->u.create_file.io_handle_extent_array = NULL;
    }

    if (sm_p->u.create_file.data_server_addrs)
    {
        free(sm_p->u.create_file.data_server_addrs);
        sm_p->u.create_file.data_server_addrs = NULL;
    }

    if (sm_p->u.create_file.datafile_handles)
    {
        free(sm_p->u.create_file.datafile_handles);
        sm_p->u.create_file.datafile_handles = NULL;
    }

    if (sm_p->u.create_file.dist)
    {
        PINT_dist_free(sm_p->u.create_file.dist);
        sm_p->u.create_file.dist = NULL;
    }

#if 0
    if(sm_p->u.create_file.layout.algorithm == PVFS_SYS_LAYOUT_LIST)
    {
        free(sm_p->u.create_file.layout.server_list.servers);
    }
#endif

    if (sm_p->msgarray && sm_p->msgarray != &(sm_p->msgpair))
    {
        free(sm_p->msgarray);
        sm_p->msgarray = NULL;
    }

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}


static inline int PINT_get_object_ref_create_file(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.create_file.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

struct PINT_server_req_params pvfs2_create_file_params =
{
    .string_name = "create_file",
    .get_object_ref = PINT_get_object_ref_create_file,
    .perm = PINT_SERVER_CHECK_NONE,
    .access_type = PINT_server_req_modify,
    .state_machine = &pvfs2_create_file_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
