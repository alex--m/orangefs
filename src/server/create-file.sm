/* 
 * (C) 2008 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "extent-utils.h"

extern job_context_id pint_client_sm_context;

enum
{
    LOCAL_OPERATION = 2,
    REMOTE_OPERATION = 3
};

enum
{
    CREATE_RETRY = 170
};

/* completion function prototypes */
static int create_create_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);

%%

/* The logic for this SM was moved here from the client to allow */
/* server to server collective processing of file create */
machine pvfs2_create_file_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => getattr_init;
        default => final_response;
    }

    state getattr_init
    {
        run create_file_getattr_init;
        default => getattr;
    }

    state getattr
    {
        jump pvfs2_get_attr_work_sm;
        success => getattr_cleanup_and_create_dspace_init;
        default => cleanup_stack_after_error;
    }

    state getattr_cleanup_and_create_dspace_init
    {
        run create_file_getattr_cleanup_and_create_dspace_init;
        LOCAL_OPERATION => do_dspace_create;
        REMOTE_OPERATION => dspace_xfer_msgpair_array;
        default => cleanup_stack_after_error;
    }

    state do_dspace_create
    {
        jump pvfs2_create_work_sm;
        success => dspace_create_local_cleanup;
        default => cleanup_stack_after_error;
    }

    state dspace_create_local_cleanup
    {
        run create_file_dspace_local_cleanup;
        success => datafiles_setup;
        default => final_response;
    }

    state dspace_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        success => dspace_create_remote_cleanup;
        default => cleanup_stack_after_error;
    }

    state dspace_create_remote_cleanup
    {
        run create_file_dspace_remote_cleanup;
        success => datafiles_setup;
        default => final_response;
    }

    state datafiles_setup
    {
        run create_file_datafiles_setup;
        success => datafiles_tree_create;
        LOCAL_OPERATION => datafiles_tree_create;
        REMOTE_OPERATION => datafiles_tree_create;
        default => cleanup_stack_after_error;
    }

    state datafiles_tree_create
    {
        jump pvfs2_tree_create_work_sm;
        success => setattr_setup;
        default => cleanup_stack_after_error;
    }

    state setattr_setup
    {
        run create_file_setattr_setup;
        LOCAL_OPERATION => do_setattr;
        REMOTE_OPERATION => setattr_xfer_msgpair_array;
        default => cleanup_stack_after_error;
    }

    state do_setattr
    {
        jump pvfs2_set_attr_work_sm;
        default => setattr_cleanup;
    }

    state setattr_cleanup
    {
        run create_file_setattr_cleanup;
        success => crdirent_setup;
        default => final_response;
    }

    state setattr_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        success => setattr_cleanup;
        default => cleanup_stack_after_error;
    }

    state crdirent_setup
    {
        run create_file_crdirent_setup;
        success => do_crdirent;
        default => final_response;
    }

    state do_crdirent
    {
        jump pvfs2_crdirent_work_sm;
        success => crdirent_cleanup;
        default => cleanup_stack_after_error;
    }

    state crdirent_cleanup
    {
        run create_file_crdirent_cleanup;
        default => setup_resp;
    }

    state setup_resp
    {
        run create_file_resp;
        default => final_response;
    }

    state cleanup_stack_after_error
    {
        run create_file_cleanup_stack_after_error;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run create_file_cleanup;
        default => terminate;
    }
}

%%

/* Set up to call getattr for the parent. */
static PINT_sm_action create_file_getattr_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *getattr_s_op;
    PINT_sm_msgpair_state *msg_p = NULL;
    struct PVFS_server_req *req;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_init entered\n");

    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    /* TODO: Pass this from the client. */
    s_op->u.create_file.layout.algorithm = PVFS_SYS_LAYOUT_NONE;
    /* TODO: Pass this from the client. */
    s_op->u.create_file.dist = PINT_dist_create(PVFS_DIST_SIMPLE_STRIPE_NAME);

    PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, getattr_s_op,
        s_op->req->u.create_file.parent_handle,
        s_op->req->u.create_file.fs_id, js_p->error_code, msg_p, req, 0);
    PINT_SERVREQ_GETATTR_FILL(*req,
                              s_op->credentials,
                              s_op->req->u.create_file.fs_id,
                              s_op->req->u.create_file.parent_handle,
                              PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_HINT);
    js_p->error_code = 0;
    return (SM_ACTION_COMPLETE);
}

static int create_create_comp_fn(void *v_p,
                                 struct PVFS_server_resp *resp_p,
                                 int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_create_comp_fn entered\n");

    assert(resp_p->op == PVFS_SERV_CREATE);
    s_op = PINT_sm_frame(smcb, -1);
    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    if (resp_p->status != 0)
    {
        return resp_p->status;
    }

    /* otherwise, just stash the newly created meta handle */
    s_op->u.create_file.metafile_handle = resp_p->u.create_file.handle;

    gossip_debug(
        GOSSIP_SERVER_DEBUG, "*** Got newly created handle %llu\n",
        llu(s_op->u.create_file.metafile_handle));

    return 0;
}

/* Clean up the stack from the getattr call. Set up to create the meta file. */
static PINT_sm_action create_file_getattr_cleanup_and_create_dspace_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int task_id;
    int error_code;
    struct PINT_server_op *s_op;
    struct PINT_server_op *getattr_s_op;
    struct PINT_server_op *create_s_op;
    int num_dfiles_requested_override = 0;
    PINT_dist *current_dist; 
    int ret = 0;
    PINT_sm_msgpair_state *msg_p = NULL;
    struct PVFS_server_req *req;
    int tmp_num_data_files;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_getattr_cleanup_and_create_dspace_init entered\n");

    getattr_s_op = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    assert(getattr_s_op->req->op == PVFS_SERV_GETATTR);
    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    PINT_copy_object_attr(&s_op->attr, &getattr_s_op->attr);

    free(getattr_s_op);
    getattr_s_op = NULL;

    js_p->error_code = error_code;
/* TODO: Why is this necessary? */
//error_code = 0;
    assert(js_p->error_code == 0);

    if (error_code == 0) {
        /** Look at the attributes of the parent directory and
         *  decide if it impacts the file creation in any way.
         */
        gossip_debug(GOSSIP_SERVER_DEBUG, "parent owner: %d, group: %d, perms: %d\n",
            (int)s_op->attr.owner, (int)s_op->attr.group, (int)s_op->attr.perms);

        /* do we have a setgid bit? */
        if(s_op->attr.perms & PVFS_G_SGID)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, "parent has setgid bit set.\n");
            gossip_debug(GOSSIP_SERVER_DEBUG, " - modifying requested attr "
                                              "for new file.\n");
            s_op->attr.group = getattr_s_op->attr.group;
        }
        gossip_debug(GOSSIP_SERVER_DEBUG, "create_parent_getattr: [%p] "
            "dfile_count     = %d "
            "dist_name_len   = %d "
            "dist_params_len = %d\n",
            &s_op->attr,
            s_op->attr.u.dir.hint.dfile_count,
            s_op->attr.u.dir.hint.dist_name_len,
            s_op->attr.u.dir.hint.dist_params_len);

        num_dfiles_requested_override = s_op->attr.u.dir.hint.dfile_count;
        /* override the # of data files for this create */
        if (num_dfiles_requested_override > 0)
        {
            /* Determine the number of dfiles */
            tmp_num_data_files = s_op->req->u.create_file.num_data_files;
            PINT_cached_config_get_num_dfiles(s_op->req->u.create_file.fs_id,
                    s_op->u.create_file.dist,
                    num_dfiles_requested_override,
                    &tmp_num_data_files);
            s_op->req->u.create_file.num_data_files = tmp_num_data_files;
        }
        gossip_debug(GOSSIP_SERVER_DEBUG, "Setting number of datafiles to %d [requested %d]\n", 
            s_op->req->u.create_file.num_data_files, num_dfiles_requested_override);
        current_dist = s_op->u.create_file.dist;
        /* We have an overriding distribution name for this directory.. honor that */
        if (s_op->attr.u.dir.hint.dist_name_len > 0)
        {
            /* switch it only if it is different! */
            if (strcmp(s_op->attr.u.dir.hint.dist_name, current_dist->dist_name))
            {
                PINT_dist *new_dist = NULL;
                new_dist = PINT_dist_create(s_op->attr.u.dir.hint.dist_name);
                if (new_dist)
                {
                    gossip_debug(GOSSIP_SERVER_DEBUG, "Overridding distribution name to %s instead of %s\n",
                        s_op->attr.u.dir.hint.dist_name,
                        current_dist->dist_name);
                    PINT_dist_free(current_dist);
                    s_op->u.create_file.dist = new_dist;
                    current_dist = new_dist;
                }
                else
                {
                    gossip_debug(GOSSIP_SERVER_DEBUG, "Could not override distribution name with %s instead of %s\n",
                        s_op->attr.u.dir.hint.dist_name,
                        current_dist->dist_name);
                }
            }
            else {
                gossip_debug(GOSSIP_SERVER_DEBUG, "retaining current distribution name %s\n",
                    current_dist->dist_name);
            }
        }

        /* okay, we might need to override some dist params as well */
        if (s_op->attr.u.dir.hint.dist_params_len > 0)
        {
            /* We have a series of comma separated key:val strings */
            char **key, **val;
            int64_t tmp_val;
            int nparams = 0;

            /* ignore parse errors! */
            if (PINT_split_keyvals(s_op->attr.u.dir.hint.dist_params,
                &nparams, &key, &val) == 0)
            {
                int i;
                for (i = 0; i < nparams; i++)
                {
                    gossip_debug(GOSSIP_SERVER_DEBUG, "distribution parameter %s, value %s\n",
                        key[i], val[i]);
                    /* NOTE: just as in server-config.c when parsing "Param" and
                     * "Value" fields, we will assume that all values are 64 bit
                     * integers.  The only difference here is that we scan
                     * directly into a 64 bit integer, rather than converting
                     * from the int format that dotconf supports.
                     */
                    ret = sscanf(val[i], SCANF_lld, &tmp_val);
                    if(ret != 1)
                    {
                        gossip_err("Error: unsupported type for distribution parameter %s, value %s found in directory hints.\n", 
                            key[i], val[i]);
                        gossip_err("Error: continuing anyway.\n");
                    }
                    else
                    {
                        if(current_dist->methods->set_param(current_dist->dist_name,
                            current_dist->params,
                            key[i],
                            &tmp_val))
                        {

                            gossip_err("Error: could not override hinted distribution parameter %s, value %s found in directory hints\n",
                                key[i],
                                val[i]);
                        }
                     }
                     free(key[i]);
                     free(val[i]);
                }
                free(key);
                free(val);
            }
        }

        PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, create_s_op,
            s_op->req->u.create_file.meta_handle_extent_array.extent_array[0].first,
            s_op->req->u.create_file.fs_id, js_p->error_code, msg_p, req, 0);

        PINT_SERVREQ_CREATE_FILL(
            *req,
            s_op->credentials,
            s_op->req->u.create_file.fs_id,
            PVFS_TYPE_METAFILE,
            s_op->req->u.create_file.meta_handle_extent_array);

        if (js_p->error_code == REMOTE_OPERATION)
        {
            msg_p->fs_id = s_op->req->u.create_file.fs_id;
            msg_p->handle = s_op->req->u.create_file.meta_handle_extent_array.extent_array[0].first;
            msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
            msg_p->comp_fn = create_create_comp_fn;
            ret = PINT_cached_config_map_to_server(&msg_p->svr_addr,
                s_op->req->u.create_file.meta_handle_extent_array.extent_array[0].first,
                s_op->req->u.create_file.fs_id);
            if (ret)
            {
                gossip_err("Failed to map address\n");
                js_p->error_code = 0;
            }
        }
    }
    return(SM_ACTION_COMPLETE);
}

/* Copy results and clean up the stack from creating the meta file locally. */
static PINT_sm_action create_file_dspace_local_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *create_s_op;
    struct PINT_server_op *s_op;
    int task_id;
    int error_code;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_dspace_local_cleanup entered\n");

    create_s_op = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    assert(create_s_op->req->op == PVFS_SERV_CREATE);
    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    /* stash the newly created meta file handle */
    s_op->u.create_file.metafile_handle = create_s_op->resp.u.create.handle;

    gossip_debug(GOSSIP_SERVER_DEBUG, "Metafile handle %llu\n",
                 llu(s_op->u.create_file.metafile_handle));

    free(create_s_op);
    create_s_op = NULL;

    js_p->error_code = error_code;
/* TODO: Why is this necessary? */
//    js_p->error_code = 0;
    assert(js_p->error_code == 0);
 
    return SM_ACTION_COMPLETE;
}

/* Copy results and clean up the stack from creating the meta file remotely. */
static PINT_sm_action create_file_dspace_remote_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *create_s_op;
    struct PINT_server_op *s_op;
    int task_id;
    int error_code;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_dspace_remote_cleanup entered\n");

    create_s_op = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
//    assert(create_s_op->req->op == PVFS_SERV_CREATE);
    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    free(create_s_op);
    create_s_op = NULL;

    js_p->error_code = error_code;
/* TODO: Why is this necessary? */
//    js_p->error_code = 0;
    assert(js_p->error_code == 0);
 
    return SM_ACTION_COMPLETE;
}

/* Prepare to create datafiles. Populate extents array.
   Probably some (one) will be local and some will be remote. */
static PINT_sm_action create_file_datafiles_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *tree_create_s_op = NULL;
    struct server_configuration_s *server_config = NULL;
    int ret = -PVFS_EINVAL;
    PINT_sm_msgpair_state *msg_p = NULL;
    struct PVFS_server_req *req;
    int tmp_num_data_files;
    
    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_datafiles_setup entered\n");

    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);
        
    js_p->error_code = 0;

    if (s_op->req->u.create_file.num_data_files > PVFS_REQ_LIMIT_DFILE_COUNT)
    {
        s_op->req->u.create_file.num_data_files = PVFS_REQ_LIMIT_DFILE_COUNT;
        gossip_err("Warning: reducing number of data "
                     "files to PVFS_REQ_LIMIT_DFILE_COUNT\n");
    }   
    
    gossip_debug(GOSSIP_SERVER_DEBUG, "need to create %d datafiles\n",
                 s_op->req->u.create_file.num_data_files);
    
    /* allocate handle extent array objects */
    s_op->u.create_file.io_handle_extent_array = (PVFS_handle_extent_array *)
        malloc(s_op->req->u.create_file.num_data_files *
               sizeof(PVFS_handle_extent_array));
    if (!s_op->u.create_file.io_handle_extent_array)
    {
        gossip_err("create: failed to allocate handle_extent_array\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(s_op->u.create_file.io_handle_extent_array, 0,
        s_op->req->u.create_file.num_data_files * sizeof(PVFS_handle_extent_array));

    /* allocate data server bmi address array */
    if (s_op->u.create_file.data_server_addrs == NULL)
    {
        s_op->u.create_file.data_server_addrs = (PVFS_BMI_addr_t *)malloc(
            s_op->req->u.create_file.num_data_files * sizeof(PVFS_BMI_addr_t));
    }
    if (!s_op->u.create_file.data_server_addrs)
    {
        gossip_err("create: failed to allocate data server addrs\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(s_op->u.create_file.data_server_addrs, 0,
        s_op->req->u.create_file.num_data_files * sizeof(PVFS_BMI_addr_t));

    server_config = get_server_config_struct();
    tmp_num_data_files = s_op->req->u.create_file.num_data_files;
    ret = PINT_cached_config_map_servers(
        server_config,
        s_op->req->u.create_file.fs_id,
        &tmp_num_data_files,
        &s_op->u.create_file.layout,
        s_op->u.create_file.data_server_addrs,
        s_op->u.create_file.io_handle_extent_array);
    if(ret < 0)
    {
        gossip_err("create: failed to map the layout to a set of IO servers\n");
        js_p->error_code = ret;
        return 1;
    }

    if (ret)
    {
        gossip_err("Failed to retrieve data server addresses\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = LOCAL_OPERATION;
    /* Create a server frame for processing the datafile creates. */
    PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, tree_create_s_op, 0, s_op->req->u.create_file.fs_id,
        js_p->error_code, msg_p, req, 0);
    PINT_SERVREQ_TREE_CREATE_FILL(
        *req,
        s_op->credentials,
        s_op->req->u.create_file.fs_id,
        0,
        s_op->req->u.create_file.num_data_files,
        s_op->u.create_file.io_handle_extent_array);

    /* allocate handle array for results */
    tree_create_s_op->resp.u.tree_create.handle_array = (PVFS_handle *)
        malloc(tree_create_s_op->req->u.tree_create.num_data_files *
               sizeof(PVFS_handle));
    if (! tree_create_s_op->resp.u.tree_create.handle_array)
    {
        gossip_err("tree_create: failed to allocate handle_array\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(tree_create_s_op->resp.u.tree_create.handle_array, 0,
        tree_create_s_op->req->u.tree_create.num_data_files *
               sizeof(PVFS_handle));

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static int create_setattr_comp_fn(void *v_p,
                                  struct PVFS_server_resp *resp_p,
                                  int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_setattr_comp_fn entered\n");

    assert(resp_p->op == PVFS_SERV_SETATTR);
    s_op = PINT_sm_frame(smcb, -1);
    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    return resp_p->status;
}

static PINT_sm_action create_file_setattr_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    struct PINT_server_op *tree_create_s_op;
    struct PINT_server_op *setattr_s_op;
    int ret = -PVFS_EINVAL;
    PINT_sm_msgpair_state *msg_p = NULL;
    struct PVFS_server_req *req;
    int task_id;
    int error_code;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_setattr_setup entered\n");

    /* Clean up stack from TREE_CREATE operation */
    tree_create_s_op = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    assert(tree_create_s_op);
    assert(tree_create_s_op->req->op == PVFS_SERV_TREE_CREATE);
    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    assert(s_op);
    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    /* allocate memory for the data handles if we haven't already */
    if (s_op->u.create_file.datafile_handles == NULL)
    {  
        s_op->u.create_file.datafile_handles = (PVFS_handle *)malloc(
            s_op->req->u.create_file.num_data_files * sizeof(PVFS_handle));
   
        if (s_op->u.create_file.datafile_handles == NULL)
        {
            gossip_err("create_file: Failed to allocate data handle array\n");
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
        memset(s_op->u.create_file.datafile_handles, 0,
               s_op->req->u.create_file.num_data_files * sizeof(PVFS_handle));
    }
    /* Copy the data handles that were created. */
    memcpy(s_op->u.create_file.datafile_handles,
           tree_create_s_op->resp.u.tree_create.handle_array,
           s_op->req->u.create_file.num_data_files * sizeof(PVFS_handle));

    /* Clean up memory allocated for the tree_create call. */
    if (tree_create_s_op->resp.u.tree_create.handle_array)
    {
        free(tree_create_s_op->resp.u.tree_create.handle_array);
    }
    free(tree_create_s_op);
    tree_create_s_op = NULL;

    /* Create a server frame for calling setattr. */
    PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, setattr_s_op,
        s_op->u.create_file.metafile_handle, s_op->req->u.create_file.fs_id,
        js_p->error_code, msg_p, req, 0);
    PINT_SERVREQ_SETATTR_FILL(
        *req,
        s_op->credentials,
        s_op->req->u.create_file.fs_id,
        s_op->u.create_file.metafile_handle,
        PVFS_TYPE_METAFILE,
        s_op->attr,
        PVFS_ATTR_COMMON_ALL | PVFS_ATTR_META_ALL);

    req->u.setattr.attr.u.meta.dfile_array =
        s_op->u.create_file.datafile_handles;
    req->u.setattr.attr.u.meta.dfile_count =
        s_op->req->u.create_file.num_data_files;
    req->u.setattr.attr.u.meta.dist =
        s_op->u.create_file.dist;
    req->u.setattr.attr.u.meta.dist_size =
        PINT_DIST_PACK_SIZE(s_op->u.create_file.dist);

    if (js_p->error_code == REMOTE_OPERATION)
    {
        msg_p->fs_id = s_op->req->u.create_file.fs_id;
        msg_p->handle = s_op->u.create_file.metafile_handle;
        msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
        msg_p->comp_fn = create_setattr_comp_fn;

        ret = PINT_cached_config_map_to_server(&msg_p->svr_addr, 
            s_op->u.create_file.metafile_handle,
            s_op->req->u.create_file.fs_id);

        if (ret)
        {
            gossip_err("Failed to map meta server address\n");
            js_p->error_code = 0;
        }
    }
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_setattr_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    int task_id;
    int error_code;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_setattr_cleanup entered\n");

    s_op = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    assert(s_op);
//    assert(s_op->req->op == PVFS_SERV_SETATTR);
    free(s_op);
    js_p->error_code = error_code;

//    js_p->error_code = 0;
    assert(js_p->error_code == 0);

    return SM_ACTION_COMPLETE;
}

/* setup and push a new frame for calling the nested crdirent state machine */
static PINT_sm_action create_file_crdirent_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *crdirent_s_op;
    PINT_sm_msgpair_state *msg_p;
    struct PVFS_server_req *req;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_crdirent_setup entered\n");

    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, crdirent_s_op,
        s_op->req->u.create_file.parent_handle,
        s_op->req->u.create_file.fs_id, js_p->error_code, msg_p, req, 0);

    PINT_SERVREQ_CRDIRENT_FILL(
        *req,
        s_op->credentials,
        s_op->req->u.create_file.object_name,
        s_op->u.create_file.metafile_handle,
        s_op->req->u.create_file.parent_handle,
        s_op->req->u.create_file.fs_id);

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_crdirent_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    int task_id;
    int error_code;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_crdirent_cleanup entered\n");

    s_op = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    assert(s_op);
    assert(s_op->req->op == PVFS_SERV_CRDIRENT);
    free(s_op);
    js_p->error_code = 0;
 
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_resp entered\n");
    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    if (js_p->error_code == 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "Handle created: %llu\n",
                     llu(s_op->u.create_file.metafile_handle));
        s_op->resp.u.create_file.handle = s_op->u.create_file.metafile_handle;
    }

    return (SM_ACTION_COMPLETE);
}


static PINT_sm_action create_file_cleanup_stack_after_error(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_cleanup_stack_after_error entered\n");

    assert(s_op);
    /* Make sure there was an extra frame on the stack that needed popping. */
    if (s_op->req && s_op->req->op == PVFS_SERV_CREATE_FILE) {
        return (SM_ACTION_COMPLETE);
    }

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    free(s_op);
    js_p->error_code = 0;
 
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_cleanup entered\n");
    gossip_debug(GOSSIP_SERVER_DEBUG, "s_op->req->op = %d\n", s_op->req->op);

    assert(s_op->req->op == PVFS_SERV_CREATE_FILE);

    if (s_op->u.create_file.datafile_handles)
    {
        free(s_op->u.create_file.datafile_handles);
        s_op->u.create_file.datafile_handles = NULL;
    }

    if (s_op->u.create_file.dist)
    {
        PINT_dist_free(s_op->u.create_file.dist);
        s_op->u.create_file.dist = NULL;
    }

    if (s_op->u.create_file.data_server_addrs)
    {
        free(s_op->u.create_file.data_server_addrs);
        s_op->u.create_file.data_server_addrs = NULL;
    }

    if (s_op->u.create_file.io_handle_extent_array)
    {
        free(s_op->u.create_file.io_handle_extent_array);
        s_op->u.create_file.io_handle_extent_array = NULL;
    }

#if 0
    if(sm_p->u.create_file.layout.algorithm == PVFS_SYS_LAYOUT_LIST)
    {
        free(sm_p->u.create_file.layout.server_list.servers);
    }
#endif

    return server_state_machine_complete(smcb);
}

static inline int PINT_get_object_ref_create_file(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.create_file.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

struct PINT_server_req_params pvfs2_create_file_params =
{
    .string_name = "create_file",
    .get_object_ref = PINT_get_object_ref_create_file,
    .perm = PINT_SERVER_CHECK_NONE,
    .access_type = PINT_server_req_modify,
    .state_machine = &pvfs2_create_file_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
