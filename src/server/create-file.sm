/* 
 * (C) 2008 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "extent-utils.h"

extern job_context_id pint_client_sm_context;

enum
{
    LOCAL_ATTRS = 2,
    REMOTE_ATTRS = 3
};

enum
{
    CREATE_RETRY = 170
};

/* completion function prototypes */
#if 0
static int create_datafiles_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
static int create_crdirent_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
#endif
static int create_delete_handles_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);

%%

/* this machine launches the main machine below */
/* mostly here to convert from a server to a client SM frame */
machine pvfs2_create_file_sm
{
    /* all server SMs run prelude for scheduler and security */
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => create;
        default => final_response;
    }

    state create
    {
        /* set up for jump to client SM */
        pjmp create_file_setup
        {
            default => pvfs2_create_file_work_sm;
        }
        default => setup_resp;
    }

    /* copy results back to server SM and prepare resp */
    state setup_resp
    {
        run create_file_resp;
        default => final_response;
    }

    /* send response */
    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run create_file_cleanup;
        default => terminate;
    }
}

/* This SM was moved here from the client to allow server to */
/* server collective processing of file create */
machine pvfs2_create_file_work_sm
{
    state init
    {
        run create_init;
        default => locate_attribs;
    }

    state locate_attribs
    {
        run create_find_attrs;
        LOCAL_ATTRS => parent_getattr_local_prelude;
        REMOTE_ATTRS => parent_getattr_remote;
        default => parent_getattr_remote;
    }

    state parent_getattr_local_prelude
    {
        jump pvfs2_server_prelude_sm;
        success => parent_getattr_local;
        default => final_response;
    }
        
    /* Retrieve the parent's attribs locally */
    state parent_getattr_local
    {
        jump pvfs2_get_attr_work_sm;
        success => parent_getattr_local_cleanup;
/* TODO: error handling */
        default => parent_getattr_remote;
    }

    /* Clean up the stack from local getattr */
    state parent_getattr_local_cleanup
    {
        run create_parent_getattr_local_cleanup;
        default => parent_getattr_inspect;
    }

    /* send request to Meta server with parent's attribs */
    state parent_getattr_remote
    {
        /* this is a client SM for doing a getattr from a server */
        jump pvfs2_server_getattr_sm;
        success => parent_getattr_inspect;
        default => cleanup_work;
    }

    state parent_getattr_inspect
    {
        run create_parent_getattr_inspect;
        success => dspace_create_setup;
        default => cleanup_work;
    }

    state dspace_create_setup
    {
        run create_dspace_setup;
        success => dspace_create_prelude;
        default => cleanup_work;
    }

    state dspace_create_prelude
    {
        jump pvfs2_server_prelude_sm;
        success => dspace_create;
        default => cleanup_work;
    }

    state dspace_create
    {
        jump pvfs2_create_work_sm;
        success => dspace_create_cleanup;
        default => cleanup_work;
    }

    state dspace_create_cleanup
    {
        run create_dspace_cleanup;
        success => datafiles_create_local_setup;
        default => cleanup_work;
    }


    /* set up to create Metadata for new file */
/*
    state dspace_create
    {
        run create_dspace_create;
//        success => datafiles_setup_msgpair_array;
        success => datafiles_create_local_setup;
        default => cleanup_work;
    }
*/

    state datafiles_create_local_setup
    {
        run create_datafiles_setup;
        success => datafiles_create_prelude;
        default => cleanup_work;
    }

    state datafiles_create_prelude
    {
        jump pvfs2_server_prelude_sm;
        success => datafiles_create_local;
        default => cleanup_work;
    }

    state datafiles_create_local
    {
        jump pvfs2_create_work_sm;
        success => datafiles_create_cleanup;
        default => cleanup_work;
    }

    state datafiles_create_cleanup
    {
        run create_datafiles_cleanup;
        success => setattr_setup;
        default => cleanup_work;
    }

    /* set up to create N datafiles on various servers */
    /* some of these might be local and should be handled locally */
    /* this is where the tree-based stuff will go */
/*
    state datafiles_setup_msgpair_array
    {
        run create_datafiles_setup_msgpair_array;
        success => datafiles_xfer_msgpair_array;
        default => cleanup_work;
    }
*/

    /* execute messages */
/*
    state datafiles_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        success => setattr_setup;
        default => datafiles_failure;
    }

    state datafiles_failure
    {
        run create_datafiles_failure;
        default => delete_handles_setup_msgpair_array;
    }
*/

    /* write datafile handles to metadata. This is local.*/
    state setattr_setup
    {
        run create_setattr_setup;
        success => setattr_prelude;
        default => cleanup_work;
    }

    state setattr_prelude
    {
        jump pvfs2_server_prelude_sm;
        success => do_setattr;
        default => cleanup_work;
    }

    state do_setattr
    {
        jump pvfs2_set_attr_work_sm;
        success => setattr_cleanup;
        default => cleanup_work;
    }

    state setattr_cleanup
    {
        run create_setattr_cleanup;
        success => crdirent_setup;
        default => cleanup_work;
    }

    /* set up to create dir entry - could be local */
/*
    state crdirent_setup_msgpair
    {
        run create_crdirent_setup_msgpair;
        success => crdirent_xfer_msgpair;
        default => crdirent_failure;
    }
*/

    /* execute messages */
/*
    state crdirent_xfer_msgpair
    {
        jump pvfs2_msgpairarray_sm;
        success => cleanup_work;
        default => crdirent_failure;
    }
*/

    state crdirent_setup
    {
        run create_crdirent_setup;
        success => crdirent_prelude;
        default => cleanup_work;
    }

    state crdirent_prelude
    {
        jump pvfs2_server_prelude_sm;
        success => do_crdirent;
        default => cleanup_work;
    }

    state do_crdirent
    {
        jump pvfs2_crdirent_work_sm;
        success => crdirent_cleanup;
        default => cleanup_work;
    }

    state crdirent_cleanup
    {
        run create_crdirent_cleanup;
        success => cleanup_work;
        default => crdirent_failure;
    }

    state crdirent_failure
    {
        run create_crdirent_failure;
        default => delete_handles_setup_msgpair_array;
    }

    /* set up to send message to delete handles in event of failure */
    state delete_handles_setup_msgpair_array
    {
        run create_delete_handles_setup_msgpair_array;
        success => delete_handles_xfer_msgpair_array;
        default => cleanup_work;
    }

    /* execute messages */
    state delete_handles_xfer_msgpair_array
    {
        jump pvfs2_msgpairarray_sm;
        default => cleanup_work;
    }

    state cleanup_work
    {
        run create_file_work_cleanup;
        CREATE_RETRY => init;
        default => terminate;
    }
}

%%

/* action files for the main SM */

/* In this function transfer arguments from the request to the struct */
/* in the client SM - set all other values in client SM, create a push */
/* stack frame */

static PINT_sm_action create_file_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    gossip_debug(GOSSIP_SERVER_DEBUG, "create_file_setup entered\n");

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    struct PINT_client_sm *sm_p = malloc(sizeof(struct PINT_client_sm));
    if(!sm_p)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(sm_p, 0, sizeof(struct PINT_client_sm));

    /* Copied this from #define PINT_init_msgarray_params in client-state-machine.h
     * because PINT_get_server_config_struct(__fsid) was not available on the server
     * side. Use get_server_config_struct() instead. 
     */
    {
        PINT_sm_msgpair_params *mpp = &sm_p->msgarray_params;
        struct server_configuration_s *server_config =
            get_server_config_struct();
        mpp->job_context = server_job_context;
        if (server_config)
        {
            mpp->job_timeout = server_config->client_job_bmi_timeout;
            mpp->retry_limit = server_config->client_retry_limit;
            mpp->retry_delay = server_config->client_retry_delay_ms;
        }
        else
        {
            mpp->job_timeout = PVFS2_CLIENT_JOB_BMI_TIMEOUT_DEFAULT;
            mpp->retry_limit = PVFS2_CLIENT_RETRY_LIMIT_DEFAULT;
            mpp->retry_delay = PVFS2_CLIENT_RETRY_DELAY_MS_DEFAULT;
        }
    }

    sm_p->cred_p = &(s_op->req->credentials);
    sm_p->u.create_file.object_name = s_op->req->u.create_file.object_name;
    sm_p->u.create_file.attr = s_op->req->u.create_file.attr;
/* TODO: Pass this from the client. */
    sm_p->u.create_file.layout.algorithm = PVFS_SYS_LAYOUT_NONE;
/* TODO: Pass this from the client. */
    sm_p->u.create_file.dist = PINT_dist_create(PVFS_DIST_SIMPLE_STRIPE_NAME);
    sm_p->parent_ref.handle = s_op->req->u.create_file.parent_handle;
    sm_p->parent_ref.fs_id = s_op->req->u.create_file.fs_id;
    sm_p->object_ref.fs_id = sm_p->parent_ref.fs_id;
    sm_p->u.create_file.num_data_files = s_op->req->u.create_file.num_data_files;
    sm_p->u.create_file.meta_handle_extent_array.extent_count =
           s_op->req->u.create_file.meta_handle_extent_array.extent_count;
    sm_p->u.create_file.meta_handle_extent_array.extent_array =
           s_op->req->u.create_file.meta_handle_extent_array.extent_array;

    gossip_debug(GOSSIP_SERVER_DEBUG, "Creating file %s under %llu, %d\n",
        sm_p->u.create_file.object_name, llu(sm_p->parent_ref.handle),
        sm_p->parent_ref.fs_id);

    PINT_sm_push_frame(smcb, 0, sm_p);
    return(SM_ACTION_COMPLETE);
}

/* the one thing that returns from the create file is an object handle
 * copy back to server SM and set up response */

static PINT_sm_action create_file_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    int task_id;
    int error_code;

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    if (js_p->error_code == 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "Handle created: %llu\n",
                     llu(js_p->handle));
        s_op->resp.u.create_file.handle = js_p->handle;
        switch(s_op->req->u.create_file.attr.objtype)
        {
            case PVFS_TYPE_NONE:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type unknown.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_METAFILE:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type metafile.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_DATAFILE:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type datafile.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_DIRECTORY:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type directory.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_SYMLINK:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type symlink.\n", llu(js_p->handle));
                break;
            case PVFS_TYPE_DIRDATA:
                PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DEBUG,
                    "new handle: %llu, type dirdata.\n", llu(js_p->handle));
                break;
        }
    }

    return (SM_ACTION_COMPLETE);
}

/* free anything hanging around */

static PINT_sm_action create_file_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    assert(sm_p);
    free(sm_p);
    return (SM_ACTION_COMPLETE);
}


/****************************************************************/

static PINT_sm_action create_init(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: init\n");

    assert((js_p->error_code == 0) ||
           (js_p->error_code == CREATE_RETRY));

    if (js_p->error_code == CREATE_RETRY)
    {
        js_p->error_code = 0;

        return job_req_sched_post_timer(
            sm_p->msgarray_params.retry_delay, smcb, 0, js_p, &tmp_id,
            server_job_context);
    }

    PINT_SM_GETATTR_STATE_FILL(
        sm_p->getattr,
        sm_p->object_ref,
        PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_HINT, 
        PVFS_TYPE_DIRECTORY,
        0);

   return SM_ACTION_COMPLETE;
}

#if 0
static int create_datafiles_comp_fn(void *v_p,
                                    struct PVFS_server_resp *resp_p,
                                    int index)
{
    PINT_smcb *smcb = v_p;
    PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    
    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create_datafiles_comp_fn[%d]\n",index);

    assert(resp_p->op == PVFS_SERV_CREATE);

    if (resp_p->status != 0)
    {
        gossip_err("%s: Failed to create data handle at server: %s "
                   "for file: %s\n", 
                   __func__, 
                   BMI_addr_rev_lookup(
                       sm_p->u.create_file.data_server_addrs[index]),
                       sm_p->u.create_file.object_name);
        PVFS_perror_gossip("Creation failure", resp_p->status);
	return resp_p->status;
    }

    /* allocate memory for the data handles if we haven't already */
    if (sm_p->u.create_file.datafile_handles == NULL)
    {
        sm_p->u.create_file.datafile_handles = (PVFS_handle *)malloc(
            sm_p->u.create_file.num_data_files * sizeof(PVFS_handle));

        if (sm_p->u.create_file.datafile_handles == NULL)
        {
            gossip_err("create: Failed to allocate data handle array\n");
            return -PVFS_ENOMEM;
        }
        memset(sm_p->u.create_file.datafile_handles, 0,
               sm_p->u.create_file.num_data_files * sizeof(PVFS_handle));
    }

    /* otherwise, just stash the newly created data file handle */
    sm_p->u.create_file.datafile_handles[index] = resp_p->u.create_file.handle;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "Datafile handle %d is %llu\n",
                 index, llu(sm_p->u.create_file.datafile_handles[index]));
    return 0;
}
#endif

#if 0
static int create_crdirent_comp_fn(void *v_p,
                                   struct PVFS_server_resp *resp_p,
                                   int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_crdirent_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_CRDIRENT);
    return resp_p->status;
}
#endif

static int create_delete_handles_comp_fn(void *v_p,
                                         struct PVFS_server_resp *resp_p,
                                         int index)
{
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_delete_handles_comp_fn\n");

    assert(resp_p->op == PVFS_SERV_REMOVE);

    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "Failed to remove handle number %d\n", index);
    }
    return resp_p->status;
}

/* check to be sure everything referenced off off sm_p is either set */
/* in the main machine, or generated in one of these state actions */

#if 0
/* this is the metafile create - should be all local */
static PINT_sm_action create_dspace_create(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: dspace_create\n");

    js_p->error_code = 0;

    if (sm_p->u.create_file.num_data_files > PVFS_REQ_LIMIT_DFILE_COUNT)
    {
        sm_p->u.create_file.num_data_files = PVFS_REQ_LIMIT_DFILE_COUNT;
        gossip_err("Warning: reducing number of data "
                     "files to PVFS_REQ_LIMIT_DFILE_COUNT\n");
    }

    gossip_debug(GOSSIP_CLIENT_DEBUG, "need to create %d datafiles\n",
                 sm_p->u.create_file.num_data_files);

    ret = job_trove_dspace_create(
        sm_p->parent_ref.fs_id,
        &sm_p->u.create_file.meta_handle_extent_array,
        PVFS_TYPE_METAFILE,
/*
        sm_p->u.create_file.attr.objtype,
*/
        NULL,
        TROVE_SYNC ,
        smcb,
        0,
        js_p,
        &i,
        server_job_context);

    if (js_p->error_code != 0)
    {
	return js_p->error_code;
    }

    /* otherwise, just stash the newly created meta handle */
    sm_p->u.create_file.metafile_handle = js_p->handle;

    gossip_debug(
        GOSSIP_CLIENT_DEBUG, "*** Got newly created handle %llu\n",
        llu(sm_p->u.create_file.metafile_handle));

    return SM_ACTION_COMPLETE;
}
#endif

static PINT_sm_action create_dspace_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *s_op;
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: dspace_create_setup\n");
        
    js_p->error_code = 0;

    /* Set up the frame for the nested create state machine */
    s_op = malloc(sizeof(struct PINT_server_op));
        
    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));
    s_op->op = PVFS_SERV_CREATE;
    s_op->u.create.fs_id = sm_p->object_ref.fs_id;
/*    s_op->u.create.handle = sm_p->u.create_file.meta_handle_extent_array.extent_array[0].first; */
    s_op->u.create.handle_extent_array = sm_p->u.create_file.meta_handle_extent_array;
    s_op->u.create.object_type = PVFS_TYPE_METAFILE;

    s_op->target_fs_id = sm_p->object_ref.fs_id;
/*    s_op->target_handle = sm_p->u.create_file.meta_handle_extent_array.extent_array[0].first; */
    s_op->credentials.uid = sm_p->cred_p->uid;
    s_op->credentials.gid = sm_p->cred_p->gid;
        
    PINT_sm_push_frame(smcb, 0, s_op);
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_dspace_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, 1);
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;

    /* stash the newly created meta file handle */
    sm_p->u.create_file.metafile_handle = s_op->resp.u.create.handle;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "Metafile handle %llu\n",
                 llu(sm_p->u.create_file.metafile_handle));

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    js_p->error_code = error_code;
 
    return SM_ACTION_COMPLETE;
}


static PINT_sm_action create_datafiles_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *server_config = NULL;
    PVFS_handle_extent_array *io_handle_extent_array;
    int ret = -PVFS_EINVAL;
    struct PINT_server_op *s_op;
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: datafiles_create_setup\n");
        
    js_p->error_code = 0;

    if (sm_p->u.create_file.num_data_files > PVFS_REQ_LIMIT_DFILE_COUNT)
    {
        sm_p->u.create_file.num_data_files = PVFS_REQ_LIMIT_DFILE_COUNT;
        gossip_err("Warning: reducing number of data "
                     "files to PVFS_REQ_LIMIT_DFILE_COUNT\n");
    }   
    
    gossip_debug(GOSSIP_CLIENT_DEBUG, "need to create %d datafiles\n",
                 sm_p->u.create_file.num_data_files);
    
    /* allocate handle extent array objects */
/* TODO: need to free this */
    io_handle_extent_array = (PVFS_handle_extent_array *)
        malloc(sm_p->u.create_file.num_data_files *
               sizeof(PVFS_handle_extent_array));
    if (!io_handle_extent_array)
    {
        gossip_err("create: failed to allocate handle_extent_array\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocate data server bmi address array */
    if (sm_p->u.create_file.data_server_addrs == NULL)
    {
        sm_p->u.create_file.data_server_addrs = (PVFS_BMI_addr_t *)malloc(
            sm_p->u.create_file.num_data_files * sizeof(PVFS_BMI_addr_t));
    }
    if (!sm_p->u.create_file.data_server_addrs)
    {
        gossip_err("create: failed to allocate data server addrs\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    server_config = get_server_config_struct();

    ret = PINT_cached_config_map_servers(
        server_config,
        sm_p->object_ref.fs_id,
        &sm_p->u.create_file.num_data_files,
        &sm_p->u.create_file.layout,
        sm_p->u.create_file.data_server_addrs,
        io_handle_extent_array);
    if(ret < 0)
    {
        gossip_err("create: failed to map the layout to a set of IO servers\n");
        js_p->error_code = ret;
        return 1;
    }

    if (ret)
    {
        gossip_err("Failed to retrieve data server addresses\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

/* TODO: make it work for more than 1 datafile */

    /* Set up the frame for the nested create state machine */
    s_op = malloc(sizeof(struct PINT_server_op));
        
    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));
    s_op->op = PVFS_SERV_CREATE;
    s_op->u.create.fs_id = sm_p->object_ref.fs_id;
    s_op->u.create.handle_extent_array = io_handle_extent_array[0];
    s_op->u.create.object_type = PVFS_TYPE_DATAFILE;
        
    s_op->target_fs_id = sm_p->object_ref.fs_id;
    s_op->target_handle = sm_p->object_ref.handle;
    s_op->credentials.uid = sm_p->cred_p->uid;
    s_op->credentials.gid = sm_p->cred_p->gid;
        
    PINT_sm_push_frame(smcb, 0, s_op);
 
    /* allocate memory for the data handles if we haven't already */
    if (sm_p->u.create_file.datafile_handles == NULL)
    {
        sm_p->u.create_file.datafile_handles = (PVFS_handle *)malloc(
            sm_p->u.create_file.num_data_files * sizeof(PVFS_handle));

        if (sm_p->u.create_file.datafile_handles == NULL)
        {
            gossip_err("create: Failed to allocate data handle array\n");
            return -PVFS_ENOMEM;
        }
        memset(sm_p->u.create_file.datafile_handles, 0,
               sm_p->u.create_file.num_data_files * sizeof(PVFS_handle));
    }
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_datafiles_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, 1);
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int task_id;
    int error_code;

/* TODO: make it work for more than 1 datafile */
    /* stash the newly created data file handle */
    sm_p->u.create_file.datafile_handles[0] = s_op->resp.u.create.handle;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "Datafile handle %d is %llu\n",
                 0, llu(sm_p->u.create_file.datafile_handles[0]));

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    js_p->error_code = error_code;
 
    return SM_ACTION_COMPLETE;
}

#if 0
/* sets up an array to create N datafiles */
/* some of these might be local and should be */
/* handled differently  - this will e re-written */
/* to do tree-based collective communication */
static PINT_sm_action create_datafiles_setup_msgpair_array(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL, i = 0;
    struct server_configuration_s *server_config = NULL;
    PVFS_handle_extent_array *io_handle_extent_array;
    struct PINT_server_op *s_op = malloc(sizeof(struct PINT_server_op));

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: "
                 "datafiles_setup_msgpair_array\n");

    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));
    s_op->req = malloc(sizeof(struct PVFS_server_req));
    if(!s_op->req)
    {
        return -PVFS_ENOMEM;
    }
    PINT_sm_push_frame(smcb, 0, s_op);

/* TODO: Use create_file instead. */
    s_op->op = PVFS_SERV_CREATE;
    s_op->req->u.create.fs_id = sm_p->object_ref.fs_id;
    s_op->req->u.create.object_type = PVFS_TYPE_DATAFILE;
//    s_op->req->u.create.handle_extent_array =  io_handle_extent_array;

    js_p->error_code = 0;

    /* allocate handle extent array objects */
/* TODO: need to free io_handle_extent_array */
    io_handle_extent_array = (PVFS_handle_extent_array *)
        malloc(sm_p->u.create_file.num_data_files *
               sizeof(PVFS_handle_extent_array));
    if (!io_handle_extent_array)
    {
        gossip_err("create: failed to allocate handle_extent_array\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocate data server bmi address array */
    if (sm_p->u.create_file.data_server_addrs == NULL)
    {
        sm_p->u.create_file.data_server_addrs = (PVFS_BMI_addr_t *)malloc(
            sm_p->u.create_file.num_data_files * sizeof(PVFS_BMI_addr_t));
    }
    if (!sm_p->u.create_file.data_server_addrs)
    {
        gossip_err("create: failed to allocate data server addrs\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    server_config = get_server_config_struct();

    ret = PINT_cached_config_map_servers(
        server_config,
        sm_p->object_ref.fs_id,
        &sm_p->u.create_file.num_data_files,
        &sm_p->u.create_file.layout,
        sm_p->u.create_file.data_server_addrs,
        io_handle_extent_array);
    if(ret < 0)
    {
        gossip_err("create: failed to map the layout to a set of IO servers\n");
        js_p->error_code = ret;
        return 1;
    }

    if (ret)
    {
        gossip_err("Failed to retrieve data server addresses\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    memset(&sm_p->msgpair, 0, sizeof(PINT_sm_msgpair_state));

    /* allocate msgarray and set msgarray_count */
    if (sm_p->msgarray && (sm_p->msgarray != &(sm_p->msgpair)))
    {
        free(sm_p->msgarray);
    }
    s_op->msgarray = (PINT_sm_msgpair_state *)malloc(
        (sm_p->u.create_file.num_data_files * sizeof(PINT_sm_msgpair_state)));
    if (s_op->msgarray == NULL)
    {
        gossip_err("create: failed to allocate msgarray\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->msgarray_count = sm_p->u.create_file.num_data_files;

    /* for each datafile, prepare to post a create send/recv pair */
    for(i = 0; i < sm_p->u.create_file.num_data_files; i++)
    {
        PINT_sm_msgpair_state *msg_p = &s_op->msgarray[i];

        PINT_SERVREQ_CREATE_FILL(
            msg_p->req,
            *sm_p->cred_p,
            sm_p->object_ref.fs_id,
            PVFS_TYPE_DATAFILE,     /* this creates a datafile */
            io_handle_extent_array[i]);
//            s_op->req->u.create.handle_extent_array.extent_array[i]);

        gossip_debug(GOSSIP_CLIENT_DEBUG,  "posting datafile[%d] create "
                     "with extents %llu-%llu\n", i,
                     llu(io_handle_extent_array[i].
                         extent_array[0].first),
                     llu(io_handle_extent_array[i].
                         extent_array[0].last));

        msg_p->fs_id = sm_p->object_ref.fs_id;
        msg_p->handle = io_handle_extent_array[i].extent_array[0].first;
        msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
        msg_p->comp_fn = create_datafiles_comp_fn;
        msg_p->svr_addr = sm_p->u.create_file.data_server_addrs[i];
    }
    return SM_ACTION_COMPLETE;
}
#endif

#if 0
static PINT_sm_action create_datafiles_failure(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    sm_p->u.create_file.stored_error_code = js_p->error_code;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create state: datafiles_failure\n");
    return SM_ACTION_COMPLETE;
}
#endif

/* this writes metadata to the metafile - this should now be local */

/* setup and push a new frame for calling the nested set-attr state machine */
static PINT_sm_action create_setattr_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *s_op = malloc(sizeof(struct PINT_server_op));

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create state: setattr_setup\n");

    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));
    PINT_sm_push_frame(smcb, 0, s_op);

    s_op->op = PVFS_SERV_SETATTR;
/*
    s_op->credentials.uid = sm_p->cred_p->uid;
    s_op->credentials.gid = sm_p->cred_p->gid;
*/
    s_op->u.setattr.handle = sm_p->object_ref.handle;
    s_op->u.setattr.fs_id = sm_p->object_ref.fs_id;
    s_op->u.setattr.attr = sm_p->u.create_file.attr;
    s_op->u.setattr.attr.objtype = PVFS_TYPE_METAFILE;
    s_op->u.setattr.attr.u.meta.dfile_array =
        sm_p->u.create_file.datafile_handles;
    s_op->u.setattr.attr.u.meta.dfile_count =
        sm_p->u.create_file.num_data_files;
    s_op->u.setattr.attr.u.meta.dist =
        sm_p->u.create_file.dist;
    s_op->u.setattr.attr.u.meta.dist_size =
        PINT_DIST_PACK_SIZE(sm_p->u.create_file.dist);
    s_op->attr = s_op->u.setattr.attr;

    s_op->target_fs_id = sm_p->object_ref.fs_id;
    s_op->target_handle = sm_p->u.create.metafile_handle;
    s_op->credentials.uid = sm_p->cred_p->uid;
    s_op->credentials.gid = sm_p->cred_p->gid;

#if 0
    PINT_SERVREQ_SETATTR_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->object_ref.fs_id,
        sm_p->u.create_file.metafile_handle,
        PVFS_TYPE_METAFILE,
        sm_p->u.create_file.attr,
        PVFS_ATTR_META_ALL);

    msg_p->req.u.setattr.attr.u.meta.dfile_array =
        sm_p->u.create_file.datafile_handles;
    msg_p->req.u.setattr.attr.u.meta.dfile_count =
        sm_p->u.create_file.num_data_files;
    msg_p->req.u.setattr.attr.u.meta.dist =
        sm_p->u.create_file.dist;
    msg_p->req.u.setattr.attr.u.meta.dist_size =
        PINT_DIST_PACK_SIZE(sm_p->u.create_file.dist);

    msg_p->fs_id = sm_p->object_ref.fs_id;
    msg_p->handle = sm_p->u.create_file.metafile_handle;
    msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
    msg_p->comp_fn = create_setattr_comp_fn;

    ret = PINT_cached_config_map_to_server(
        &msg_p->svr_addr, msg_p->handle, msg_p->fs_id);

    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
#endif
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_setattr_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int task_id;
    int error_code;

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    js_p->error_code = error_code;
 
    return SM_ACTION_COMPLETE;
}

/* setup and push a new frame for calling the nested crdirent state machine */
static PINT_sm_action create_crdirent_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *s_op = malloc(sizeof(struct PINT_server_op));

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create state: crdirent_setup\n");

    if(!s_op)
    {
        return -PVFS_ENOMEM;
    }
    /* zero out all members */
    memset(s_op, 0, sizeof(struct PINT_server_op));
    PINT_sm_push_frame(smcb, 0, s_op);

    s_op->op = PVFS_SERV_CRDIRENT;
    s_op->attr = sm_p->u.create_file.attr;
    s_op->u.crdirent.name = sm_p->u.create_file.object_name;
    s_op->u.crdirent.new_handle = sm_p->u.create_file.metafile_handle;
    s_op->u.crdirent.parent_handle = sm_p->parent_ref.handle;
    s_op->u.crdirent.fs_id = sm_p->object_ref.fs_id;
    s_op->u.crdirent.dir_attr_update_required = 0;

    s_op->target_fs_id = sm_p->object_ref.fs_id;
/*    s_op->target_handle = sm_p->u.create_file.metafile_handle; */
    s_op->target_handle = sm_p->parent_ref.handle;
    s_op->credentials.uid = sm_p->cred_p->uid;
    s_op->credentials.gid = sm_p->cred_p->gid;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_crdirent_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int task_id;
    int error_code;

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    js_p->error_code = error_code;
 
    return SM_ACTION_COMPLETE;
}

#if 0
/* this creates a directory entry - this may or may not be local */
static PINT_sm_action create_crdirent_setup_msgpair(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    PINT_sm_msgpair_state *msg_p = NULL;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create state: crdirent_setup_msgpair\n");

    js_p->error_code = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create: %s: posting crdirent req: parent handle: %llu, "
                 "name: %s, handle: %llu\n",
                 __func__,
                 llu(sm_p->object_ref.handle), sm_p->u.create_file.object_name,
                 llu(sm_p->u.create_file.metafile_handle));

    PINT_init_msgpair(sm_p, msg_p);

    PINT_SERVREQ_CRDIRENT_FILL(
        msg_p->req,
        *sm_p->cred_p,
        sm_p->u.create_file.object_name,
        sm_p->u.create_file.metafile_handle,
        sm_p->object_ref.handle,
        sm_p->object_ref.fs_id);

    msg_p->fs_id = sm_p->object_ref.fs_id;
    msg_p->handle = sm_p->object_ref.handle;
    msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
    msg_p->comp_fn = create_crdirent_comp_fn;

    ret = PINT_cached_config_map_to_server(
        &msg_p->svr_addr, sm_p->object_ref.handle,
        sm_p->object_ref.fs_id);

    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
    }
    return SM_ACTION_COMPLETE;
}
#endif

static PINT_sm_action create_crdirent_failure(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: crdirent_failure\n");

    sm_p->u.create_file.stored_error_code = js_p->error_code;

    if (sm_p->u.create_file.stored_error_code == -PVFS_EEXIST)
    {
        gossip_debug(GOSSIP_CLIENT_DEBUG, "crdirent failed: "
                     "dirent already exists!\n");
    }
    return SM_ACTION_COMPLETE;
}

/* delete the newly created meta and data handles */
static PINT_sm_action create_delete_handles_setup_msgpair_array(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL, i = 0, actual_count = 0;
    PVFS_BMI_addr_t metafile_server_addr;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: "
                 "delete_handles_setup_msgpair_array\n");

    js_p->error_code = 0;

    memset(&sm_p->msgpair, 0, sizeof(PINT_sm_msgpair_state));

    ret = PINT_cached_config_map_to_server(
        &metafile_server_addr, sm_p->u.create_file.metafile_handle,
        sm_p->object_ref.fs_id);

    if (ret)
    {
        gossip_err("Failed to map meta server address\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /*
      in the case that all datafiles have already been created,
      actual_count will be (sm_p->u.create_file.num_data_files + 1).
      otherwise, it will be somewhere between 1 (for the metafile) and
      1 + the number of data files
    */
    actual_count = 1;
    for(i = 0; i < sm_p->u.create_file.num_data_files; i++)
    {
        if (sm_p->u.create_file.datafile_handles &&
            (sm_p->u.create_file.datafile_handles[i] != PVFS_HANDLE_NULL))
        {
            actual_count++;
        }
    }

    if (sm_p->msgarray && (sm_p->msgarray != &(sm_p->msgpair)))
    {
        free(sm_p->msgarray);
    }
    sm_p->msgarray = (PINT_sm_msgpair_state *)malloc(
        (actual_count * sizeof(PINT_sm_msgpair_state)));

    if (sm_p->msgarray == NULL)
    {
        gossip_err("create: failed to allocate msgarray\n"); 
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    sm_p->msgarray_count = actual_count;

    assert(sm_p->u.create_file.data_server_addrs);

    /*
      for the metafile and each datafile, prepare to post a remove
      send/recv pair
    */
    for(i = 0; i < actual_count; i++)
    {
        PINT_sm_msgpair_state *msg_p = &sm_p->msgarray[i];

        gossip_debug(GOSSIP_CLIENT_DEBUG,
                     "create: posting data file remove req %d\n",i);

        /* arbitrarily handle deletion of the metafile last */
        if (i == (actual_count - 1))
        {
            PINT_SERVREQ_REMOVE_FILL(
                msg_p->req,
                *sm_p->cred_p,
                sm_p->object_ref.fs_id,
                sm_p->u.create_file.metafile_handle);

            msg_p->fs_id = sm_p->object_ref.fs_id;
            msg_p->handle = sm_p->u.create_file.metafile_handle;
            msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
            msg_p->comp_fn = create_delete_handles_comp_fn;
            msg_p->svr_addr = metafile_server_addr;

            gossip_debug(GOSSIP_CLIENT_DEBUG, " Preparing to remove "
                         "metafile handle %llu\n", llu(msg_p->handle));
        }
        else
        {
            PINT_SERVREQ_REMOVE_FILL(
                msg_p->req,
                *sm_p->cred_p,
                sm_p->object_ref.fs_id,
                sm_p->u.create_file.datafile_handles[i]);

            msg_p->fs_id = sm_p->object_ref.fs_id;
            msg_p->handle = sm_p->u.create_file.datafile_handles[i];
            msg_p->retry_flag = PVFS_MSGPAIR_NO_RETRY;
            msg_p->comp_fn = create_delete_handles_comp_fn;
            msg_p->svr_addr = sm_p->u.create_file.data_server_addrs[i];

            gossip_debug(GOSSIP_CLIENT_DEBUG, " Preparing to remove "
                         "datafile handle %llu\n", llu(msg_p->handle));
        }
    }
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action create_file_work_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_ref metafile_ref;
#if 0
    PVFS_size tmp_size = 0;
    int ret;
#endif

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: cleanup\n");

    /* this is in common/misc/pvfs2-util.c which is normally only in the
     * client.  They sys_attr is not a flat structure, thus there are
     * utils to copy and free them.  Either need to stick with the
     * format in the protocol (will come to us in the request) or add
     * this code into the server - not much else in it is useful to the
     * server, so I'm leaning to the former
     */
/*    PVFS_util_release_sys_attr(&sm_p->u.create_file.sys_attr); */

    PINT_SM_GETATTR_STATE_CLEAR(sm_p->getattr);

    sm_p->error_code = (sm_p->u.create_file.stored_error_code ?
                        sm_p->u.create_file.stored_error_code :
                        js_p->error_code);

    memset(&metafile_ref, 0, sizeof(metafile_ref));

    if (sm_p->error_code == 0)
    {
        metafile_ref.handle = sm_p->u.create_file.metafile_handle;
        metafile_ref.fs_id = sm_p->object_ref.fs_id;

        /* fill in outgoing response fields */
        sm_p->u.create_file.create_file_resp->ref = metafile_ref;

        /* do not maintina ncache and acache on server - only client */
#if 0
        /* insert newly created metafile into the ncache */
        PINT_ncache_update((const char*) sm_p->u.create_file.object_name, 
                           (const PVFS_object_ref*) &metafile_ref, 
                           (const PVFS_object_ref*) &(sm_p->object_ref));

        /* we only insert a cache entry if the entire create succeeds,
         * i.e. crdirent succeeded.  set size to 0 */
        ret = PINT_acache_update(metafile_ref,
                                 &sm_p->u.create_file.cache_attr,
                                 &tmp_size);
        if(ret < 0)
        {
            js_p->error_code = ret;
        }
#endif
    }
    else if ((PVFS_ERROR_CLASS(-sm_p->error_code) == PVFS_ERROR_BMI) &&
             (sm_p->u.create_file.retry_count < sm_p->msgarray_params.retry_limit))
    {
        sm_p->u.create_file.stored_error_code = 0;
        sm_p->u.create_file.retry_count++;

        gossip_debug(GOSSIP_CLIENT_DEBUG, "Retrying create operation "
                     "(attempt number %d)\n", sm_p->u.create_file.retry_count);

        js_p->error_code = CREATE_RETRY;
        return SM_ACTION_COMPLETE;
    }

    PINT_free_object_attr(&sm_p->u.create_file.cache_attr);

    if (sm_p->u.create_file.data_server_addrs)
    {
        free(sm_p->u.create_file.data_server_addrs);
        sm_p->u.create_file.data_server_addrs = NULL;
    }

    if (sm_p->u.create_file.datafile_handles)
    {
        free(sm_p->u.create_file.datafile_handles);
        sm_p->u.create_file.datafile_handles = NULL;
    }

    if (sm_p->u.create_file.dist)
    {
        PINT_dist_free(sm_p->u.create_file.dist);
        sm_p->u.create_file.dist = NULL;
    }

#if 0
    if(sm_p->u.create_file.layout.algorithm == PVFS_SYS_LAYOUT_LIST)
    {
        free(sm_p->u.create_file.layout.server_list.servers);
    }
#endif

    if (sm_p->msgarray != &(sm_p->msgpair))
    {
        free(sm_p->msgarray);
        sm_p->msgarray = NULL;
    }

    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}

/* In this function determine whether the parent's attribs    */
/* are stored locally. If they are, set up the frame to call  */
/* the nested get_attr state machine.                         */
static PINT_sm_action create_find_attrs(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *config = get_server_config_struct();
    char server_name[1024];

    gossip_debug(GOSSIP_CLIENT_DEBUG,
                 "create-file state: create_find_attrs\n");

    js_p->error_code = 0;

    PINT_cached_config_get_server_name(server_name, 1024, sm_p->parent_ref.handle,
        sm_p->parent_ref.fs_id);

    if (! strcmp(config->host_id, server_name)) {
        /* Set up the frame for the nested get_attr state machine */
        struct PINT_server_op *s_op = malloc(sizeof(struct PINT_server_op));

        if(!s_op)
        {
            return -PVFS_ENOMEM;
        }
        /* zero out all members */
        memset(s_op, 0, sizeof(struct PINT_server_op));

        s_op->op = PVFS_SERV_GETATTR;
        s_op->u.getattr.handle = sm_p->parent_ref.handle;
        s_op->u.getattr.fs_id = sm_p->parent_ref.fs_id;
        s_op->u.getattr.attrmask = PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_HINT;
        s_op->attr.mask = PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_HINT;
        s_op->attr.objtype = PVFS_TYPE_DIRECTORY;
        PINT_sm_push_frame(smcb, 0, s_op);
        js_p->error_code = LOCAL_ATTRS;

        s_op->target_fs_id = sm_p->parent_ref.fs_id;
        s_op->target_handle = sm_p->parent_ref.handle;
        s_op->credentials.uid = sm_p->cred_p->uid;
        s_op->credentials.gid = sm_p->cred_p->gid;
/*
        s_op->access_type = PINT_server_req_table[s_op->op].params->access_type(NULL);
        s_op->sched_policy = PINT_server_req_table[s_op->op].params->sched_policy;
*/
        return(SM_ACTION_COMPLETE);
    }
    else
    {
        /* it's not on this server. Fall through to another */
        /* state to do the lookup on the correct server.    */
        /* TODO:  set up machine for remote lookup here. I  */
        /* think PINT_SM_GETATTR_STATE_FILL should move from*/
        /* create_init to here.  */
        sm_p->getattr.object_ref = sm_p->parent_ref;
        sm_p->getattr.req_attrmask = PVFS_ATTR_COMMON_ALL|PVFS_ATTR_DIR_HINT;
        js_p->error_code = REMOTE_ATTRS;
        return(SM_ACTION_COMPLETE);
    }
}

static PINT_sm_action create_parent_getattr_local_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int task_id;
    int error_code;
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, 1);
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    memcpy(&sm_p->getattr.attr, &s_op->attr, sizeof(sm_p->getattr.attr));

    PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
    js_p->error_code = error_code;
    return(SM_ACTION_COMPLETE);
}

/** looks at the attributes of the parent directory and decides if it impacts
 *  the file creation in any way
 */
static PINT_sm_action create_parent_getattr_inspect(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_client_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *attr = NULL;
    int num_dfiles_requested_override = 0;
    PINT_dist *current_dist; 
    int ret = 0;

    gossip_debug(GOSSIP_CLIENT_DEBUG, "create state: parent_getattr_inspect\n");

    attr = &sm_p->getattr.attr;
    assert(attr);

    gossip_debug(GOSSIP_CLIENT_DEBUG, "parent owner: %d, group: %d, perms: %d\n",
        (int)attr->owner, (int)attr->group, (int)attr->perms);

    /* do we have a setgid bit? */
    if(attr->perms & PVFS_G_SGID)
    {
        gossip_debug(GOSSIP_CLIENT_DEBUG, "parent has setgid bit set.\n");
        gossip_debug(GOSSIP_CLIENT_DEBUG, " - modifying requested attr "
                                          "for new file.\n");
        sm_p->u.create_file.attr.group = attr->group;
        /* note that permission checking is left to server even in this case */
    }
    gossip_debug(GOSSIP_CLIENT_DEBUG, "create_parent_getattr: [%p] "
        "dfile_count     = %d "
        "dist_name_len   = %d "
        "dist_params_len = %d\n",
        attr,
        attr->u.dir.hint.dfile_count,
        attr->u.dir.hint.dist_name_len,
        attr->u.dir.hint.dist_params_len);

    num_dfiles_requested_override = attr->u.dir.hint.dfile_count;
    /* override the # of data files for this create */
    if (num_dfiles_requested_override > 0)
    {
        /* Determine the number of dfiles */
        PINT_cached_config_get_num_dfiles(sm_p->object_ref.fs_id,
                sm_p->u.create_file.dist,
                num_dfiles_requested_override,
                &sm_p->u.create_file.num_data_files);
    }
    gossip_debug(GOSSIP_CLIENT_DEBUG, "Setting number of datafiles to %d [requested %d]\n", 
        sm_p->u.create_file.num_data_files, num_dfiles_requested_override);
    current_dist = sm_p->u.create_file.dist;
    /* We have an overriding distribution name for this directory.. honor that */
    if (attr->u.dir.hint.dist_name_len > 0)
    {
        /* switch it only if it is different! */
        if (strcmp(attr->u.dir.hint.dist_name, current_dist->dist_name))
        {
            PINT_dist *new_dist = NULL;
            new_dist = PINT_dist_create(attr->u.dir.hint.dist_name);
            if (new_dist)
            {
                gossip_debug(GOSSIP_CLIENT_DEBUG, "Overridding distribution name to %s instead of %s\n",
                    attr->u.dir.hint.dist_name,
                    current_dist->dist_name);
                PINT_dist_free(current_dist);
                sm_p->u.create_file.dist = new_dist;
                current_dist = new_dist;
            }
            else
            {
                gossip_debug(GOSSIP_CLIENT_DEBUG, "Could not override distribution name with %s instead of %s\n",
                    attr->u.dir.hint.dist_name,
                    current_dist->dist_name);
            }
        }
        else {
            gossip_debug(GOSSIP_CLIENT_DEBUG, "retaining current distribution name %s\n",
                current_dist->dist_name);
        }
    }

    /* okay, we might need to override some dist params as well */
    if (attr->u.dir.hint.dist_params_len > 0)
    {
        /* We have a series of comma separated key:val strings */
        char **key, **val;
        int64_t tmp_val;
        int nparams = 0;

        /* ignore parse errors! */
        if (PINT_split_keyvals(attr->u.dir.hint.dist_params,
            &nparams, &key, &val) == 0)
        {
            int i;
            for (i = 0; i < nparams; i++)
            {
                gossip_debug(GOSSIP_CLIENT_DEBUG, "distribution parameter %s, value %s\n",
                    key[i], val[i]);
                /* NOTE: just as in server-config.c when parsing "Param" and
                 * "Value" fields, we will assume that all values are 64 bit
                 * integers.  The only difference here is that we scan
                 * directly into a 64 bit integer, rather than converting
                 * from the int format that dotconf supports.
                 */
                ret = sscanf(val[i], SCANF_lld, &tmp_val);
                if(ret != 1)
                {
                    gossip_err("Error: unsupported type for distribution parameter %s, value %s found in directory hints.\n", 
                        key[i], val[i]);
                    gossip_err("Error: continuing anyway.\n");
                }
                else
                {
                    if(current_dist->methods->set_param(current_dist->dist_name,
                        current_dist->params,
                        key[i],
                        &tmp_val))
                    {

                        gossip_err("Error: could not override hinted distribution parameter %s, value %s found in directory hints\n",
                            key[i],
                            val[i]);
                    }
                 }
                 free(key[i]);
                 free(val[i]);
            }
            free(key);
            free(val);
        }
    }
    return SM_ACTION_COMPLETE;
}

static inline int PINT_get_object_ref_create_file(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.create_file.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

struct PINT_server_req_params pvfs2_create_file_params =
{
    .string_name = "create_file",
    .get_object_ref = PINT_get_object_ref_create_file,
    .perm = PINT_SERVER_CHECK_NONE,
    .access_type = PINT_server_req_modify,
    .state_machine = &pvfs2_create_file_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
