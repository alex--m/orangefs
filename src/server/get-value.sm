/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_get_value_sm
 *
 * This state machine handles incoming server getvalue operations.  These
 * are the operations sent by PVFS_sys_getvalue().
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-perf-counter.h"
#include "pint-cached-config.h"
#include "dbpf-keyval.h"

#define FAILED_PERMS    100
#define END_OF_HANDLES  101
#define TARGET_ASSIGNED 102
#define MORE_TARGETS    103
#define GET_PATHS       104
#define MORE_QUERIES    105

/* if counts and tokens are equal we haven't worked it */
static inline int handled_query(PVFS_keyval_query o, PVFS_keyval_query q) 
{
    return ((o.count==q.count) && (o.token==q.token) &&
            (q.oper != PVFS_KEYVAL_QUERY_NOOP )) ? 0 : 1;
}

static int path_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
%%

machine pvfs2_get_value_sm
{
    state setup_resp
    {
        run getvalue_setup_resp;
        success => parse_query;
        default => final_response;
    }

    state parse_query
    {
        run getvalue_parse_query;
        success => assign_target;
        MORE_QUERIES => read_value;
        default => final_response;
    }

    state read_value
    {
        run getvalue_read_value;
        success => parse_query;
        default => final_response;
    }

    state assign_target
    {
        run getvalue_assign_target;
        TARGET_ASSIGNED => perms;
        END_OF_HANDLES => setup_get_paths;
        success => setup_get_paths;
        default => final_response;
    }

    state perms
    {
        jump pvfs2_prelude_attr_sm;
        default => check_perm_resp;
    }

    state check_perm_resp
    {
        run getvalue_check_perm_resp;
        FAILED_PERMS => remove_result;
        default => assign_target;
    }

    state remove_result
    {
      run getvalue_remove_result;
      default => assign_target;
    }

    state setup_get_paths
    {
        run getvalue_setup_get_paths;
        GET_PATHS => call_msgpairarray;
        default => final_response;
    }

    state call_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup   
    {
        run getvalue_cleanup;
        default => terminate;
    }
}

%%

/*
 * getvalue_setup_resp()
 * Set up the response - allocate needed resources
 */
static PINT_sm_action getvalue_setup_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret=0, i=0;
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_setup_resp: enter\n");
    ret = job_req_sched_post(s_op->op, s_op->target_fs_id, s_op->target_handle,
                             s_op->access_type, s_op->sched_policy,
                             smcb, 0, js_p, 
                             &(s_op->scheduled_id), server_job_context);
    PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: count: %u\n", s_op->req->u.getvalue.count);

    s_op->resp.u.getvalue.query_count = s_op->req->u.getvalue.count;
    /* copy query_p array over to resp struct */
    s_op->resp.u.getvalue.query_p = calloc( s_op->req->u.getvalue.count, 
        sizeof( PVFS_keyval_query ));
    memcpy( s_op->resp.u.getvalue.query_p, s_op->req->u.getvalue.query_p,
            s_op->req->u.getvalue.count * sizeof(PVFS_keyval_query) );

    /* allocate handle match array based on count value in query struct */
    for( i=0; i < s_op->req->u.getvalue.count; i++ )
    {
        if( (s_op->resp.u.getvalue.query_p[i].match = calloc(
             s_op->req->u.getvalue.query_p[i].count, sizeof(PVFS_handle))) == 0)
        {
            gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: malloc for "
                         "match failed for %u  handles\n",
                          s_op->req->u.getvalue.query_p[i].count);
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
    }

    /* dirent array is allocated in setup_get_paths so it's only allocated
     * if needed and only for the total number of handles we are looking up */

    s_op->resp.u.getvalue.dirent_count = 0;

    if( (s_op->key.buffer = calloc( DBPF_MAX_KEY_LENGTH, sizeof(char) ))==0 )
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    if( (s_op->val.buffer = calloc( DBPF_MAX_KEY_LENGTH, sizeof(char) ))==0 )
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }


    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: req: %p, fs_id: %d, "
                 "handle: %llu, count: %u, query_p: %p, key.buffer: %p, "
                 "val.buffer: %p\n",
                 s_op->req, s_op->req->u.getvalue.fs_id, 
                 llu(s_op->req->u.getvalue.handle), s_op->req->u.getvalue.count,
                 s_op->req->u.getvalue.query_p,
                 s_op->key.buffer, s_op->val.buffer);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: query_p: %p, token: %llu, "
                 "oper: %u, count: %u, match: %p, query: %s(%d)\n",
                 s_op->req->u.getvalue.query_p, 
                 llu(s_op->req->u.getvalue.query_p[0].token), 
                 s_op->req->u.getvalue.query_p[0].oper, 
                 s_op->req->u.getvalue.query_p[0].count, 
                 s_op->req->u.getvalue.query_p[0].match, 
                 (char *)s_op->req->u.getvalue.query_p[0].query.buffer,
                 s_op->req->u.getvalue.query_p[0].query.buffer_sz);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: query_p: %p, token: %llu, "
                 "oper: %u, count: %u, match: %p, query: %s(%d)\n",
                 s_op->req->u.getvalue.query_p, 
                 llu(s_op->req->u.getvalue.query_p[1].token), 
                 s_op->req->u.getvalue.query_p[1].oper, 
                 s_op->req->u.getvalue.query_p[1].count, 
                 s_op->req->u.getvalue.query_p[1].match, 
                 (char *)s_op->req->u.getvalue.query_p[1].query.buffer,
                 s_op->req->u.getvalue.query_p[1].query.buffer_sz);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: query_p: %p, token: %llu, "
                 "oper: %u, count: %u, match: %p, query: %s(%d)\n",
                 s_op->req->u.getvalue.query_p, 
                 llu(s_op->req->u.getvalue.query_p[2].token), 
                 s_op->req->u.getvalue.query_p[2].oper, 
                 s_op->req->u.getvalue.query_p[2].count, 
                 s_op->req->u.getvalue.query_p[2].match, 
                 (char *)s_op->req->u.getvalue.query_p[2].query.buffer,
                 s_op->req->u.getvalue.query_p[2].query.buffer_sz);

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_setup_resp: exit\n");

    return SM_ACTION_COMPLETE;
}

/*
 * parse query to break down into parts DBPF can handle
 */
static PINT_sm_action getvalue_parse_query(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i=0;
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_parse_query: enter\n");


    /* save ending position in last query struct before losing tabs on it */
    if( s_op->u.getvalue.current_query != NULL )
    {
        s_op->u.getvalue.current_query->token = js_p->position;
    }
    s_op->u.getvalue.current_query = NULL;

    /* iterate up the query_p array until we've done work */
    for( i=s_op->req->u.getvalue.count-1; i >= 0; i-- )
    {
        if( ! handled_query(s_op->req->u.getvalue.query_p[i],
                            s_op->resp.u.getvalue.query_p[i]) )
        {
            s_op->u.getvalue.current_query = 
                &(s_op->resp.u.getvalue.query_p[i]);
            gossip_debug(GOSSIP_GETVALUE_DEBUG,
                         "[GETVALUE]: getvalue_parse_query: setting current_"
                         "query to index %d at %p\n", i, 
                         s_op->u.getvalue.current_query);
            break;
        }
    }

    if( s_op->u.getvalue.current_query == NULL )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                     "[GETVALUE]: Couldn't find another query to execute\n");
        return SM_ACTION_COMPLETE; /* done all queries that need dbpf work*/
    }

    /* reset key/val */
    memset( s_op->key.buffer, 0, DBPF_MAX_KEY_LENGTH );
    memset( s_op->val.buffer, 0, DBPF_MAX_KEY_LENGTH );

    /*TODO if 
      set operation bail without copying operands since they are the kids */
    if( (s_op->u.getvalue.current_query->oper == PVFS_KEYVAL_QUERY_AND) ||
        (s_op->u.getvalue.current_query->oper == PVFS_KEYVAL_QUERY_OR) )
    {
        js_p->error_code = MORE_QUERIES;
        return SM_ACTION_COMPLETE;
    }

    /* assert that children exist */
    assert( (2*i + 2) < s_op->req->u.getvalue.count);

    /* set key as left operand, val as right */
    memcpy( s_op->key.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+1 ].query.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+1 ].query.buffer_sz);
    s_op->key.buffer_sz = 
        s_op->req->u.getvalue.query_p[ (2*i)+1 ].query.buffer_sz;

    memcpy( s_op->val.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+2 ].query.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+2 ].query.buffer_sz);
    s_op->val.buffer_sz = 
        s_op->req->u.getvalue.query_p[ (2*i)+2 ].query.buffer_sz;
    
    js_p->error_code = MORE_QUERIES;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_parse_query: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * keyval call to handle query 
 */
static PINT_sm_action getvalue_read_value(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: enter\n");

    ret = job_trove_keyval_read_value_query(
        s_op->req->u.getvalue.fs_id,
        s_op->u.getvalue.current_query->token,
        s_op->u.getvalue.current_query->oper,
        &(s_op->key),
        &(s_op->val),
        s_op->u.getvalue.current_query->match,
        &(s_op->u.getvalue.current_query->count),
        0,
        NULL,
        smcb,
        0,
        js_p,
        &i,
        server_job_context, s_op->req->hints);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: exit\n");

    return ret;
}

/*
 * getvalue_assign_target
 * assign a single handle to s_op->targets so permissions can be checked 
 * iterates through the query_p structs for any handle matches
 */
static PINT_sm_action getvalue_assign_target(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    uint32_t qindex = 0, hindex = 0;
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_assign_target: enter\n");

    qindex = s_op->u.getvalue.query_index;
    hindex = s_op->u.getvalue.handle_index;

    while( qindex < s_op->resp.u.getvalue.query_count )
    {
        if( hindex >= s_op->resp.u.getvalue.query_p[qindex].count )
        {
            hindex = 0;
            qindex++;
        }
        else if( PVFS_KEYVAL_QUERY_UNMASK_QUERY(
            s_op->resp.u.getvalue.query_p[qindex].oper) ==
            PVFS_KEYVAL_QUERY_NOOP )
        {
            qindex++;
        }
        else
        {
            break;
        }
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_assign_target: "
                 "query_p[%u].count: [%u], hindex [%u], qindex [%u]\n", 
                 qindex, s_op->resp.u.getvalue.query_p[qindex].count,
                 hindex, qindex);

    /* all done once we've gone through all query structs */
    if( qindex >= s_op->resp.u.getvalue.query_count )
    {
        s_op->u.getvalue.query_index = qindex;
        s_op->u.getvalue.handle_index = hindex;
        js_p->error_code = END_OF_HANDLES;
        return SM_ACTION_COMPLETE;
    }

    s_op->target_handle = 
        s_op->resp.u.getvalue.query_p[qindex].match[hindex];
    s_op->target_fs_id = s_op->req->u.getvalue.fs_id;

    s_op->u.getvalue.query_index = qindex;
    s_op->u.getvalue.handle_index = ++hindex;
    js_p->error_code = TARGET_ASSIGNED;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_assign_target: exit\n");

    return SM_ACTION_COMPLETE;
}

/* 
 * getvalue_check_perm_resp()
 * look at error_code from permission check, set error_code appropriately
 */
static PINT_sm_action getvalue_check_perm_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_check_perm_resp: enter\n");

    if( js_p->error_code != 0 )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                     "[GETVALUE]: Failed permission check on %llu, error: %d\n",
                     llu(s_op->target_handle), js_p->error_code);
        js_p->error_code =  FAILED_PERMS; 
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_check_perm_resp: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * getvalue_remove_result
 * remove a record, for permission check failure, from the result set shifting
 * pointers and counters as needed
 */
static PINT_sm_action getvalue_remove_result(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0, q_index=0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_remove_result: enter\n"); 

    js_p->error_code = 0;
    q_index = s_op->u.getvalue.query_index;
    assert( s_op->resp.u.getvalue.query_p[q_index].count > 0 );

    /* handle index is at the next value (see assign_target) so beginning there
     * move stuff forward */
    for( i = s_op->u.getvalue.handle_index; 
         i < s_op->resp.u.getvalue.query_p[q_index].count;
         i++ )
    {
        s_op->resp.u.getvalue.query_p[q_index].match[i-1] =
            s_op->resp.u.getvalue.query_p[q_index].match[i];
    }

    /* decrement count of handles, assign new empty item 0  as handle*/
    i = s_op->resp.u.getvalue.query_p[q_index].count--;
    s_op->resp.u.getvalue.query_p[q_index].match[i] = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_remove_result: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * getvalue_setup_resp()
 * Set up the request to get path for the handle - allocate needed resources
 */
static PINT_sm_action getvalue_setup_get_paths(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret=0, i=0;
    uint32_t orig_count=0, j=0;
    PINT_sm_msgpair_state *msg_p = NULL;
    PVFS_credentials creds;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_setup_get_paths: enter\n");
    js_p->error_code = GET_PATHS;

    /* iterate over each query object to see 
     * 1) total handle count
     * 2) which queries want paths returned 
     */

    s_op->u.getvalue.unknown_count = 0;
    s_op->u.getvalue.unknown_dirent = NULL;
    s_op->u.getvalue.unknown_handle = NULL;

    for(i=0; i < s_op->resp.u.getvalue.query_count; i++ )
    {
        uint32_t oper = PVFS_KEYVAL_QUERY_UNMASK_QUERY(
            s_op->resp.u.getvalue.query_p[i].oper);
        uint32_t path = PVFS_KEYVAL_QUERY_UNMASK_PATHS(
            s_op->resp.u.getvalue.query_p[i].oper);

        if( (oper != PVFS_KEYVAL_QUERY_NOOP) && 
            (path != PVFS_KEYVAL_RESULT_NO_PATHS) && 
            (s_op->resp.u.getvalue.query_p[i].count > 0) )
        {
            orig_count = s_op->u.getvalue.unknown_count;
            s_op->u.getvalue.unknown_count += 
                s_op->resp.u.getvalue.query_p[i].count;

            if( (s_op->u.getvalue.unknown_dirent = realloc(
                  s_op->u.getvalue.unknown_dirent, 
                  s_op->u.getvalue.unknown_count * sizeof(PVFS_dirent))) == 0 )
            {
                js_p->error_code = -TROVE_ENOMEM;
                return SM_ACTION_COMPLETE;
            }  

            /* initialize only the new memory */
            memset(s_op->u.getvalue.unknown_dirent + 
                   (orig_count * sizeof(PVFS_dirent)), 0,  
                   s_op->resp.u.getvalue.query_p[i].count*sizeof(PVFS_dirent));
                   
            if( (s_op->u.getvalue.unknown_handle = realloc(
                  s_op->u.getvalue.unknown_handle, 
                  s_op->u.getvalue.unknown_count * sizeof(PVFS_handle))) == 0 )
            {
                js_p->error_code = -TROVE_ENOMEM;
                return SM_ACTION_COMPLETE;
            }

            /* initialize only the new memory */
            memset(s_op->u.getvalue.unknown_handle + 
                   (orig_count * sizeof(PVFS_handle)), 0,  
                   s_op->resp.u.getvalue.query_p[i].count*sizeof(PVFS_handle));

            for(j=orig_count; j < s_op->u.getvalue.unknown_count; j++ )
            {
                uint32_t local_index = j - orig_count;
                s_op->u.getvalue.unknown_handle[j] =
                    s_op->resp.u.getvalue.query_p[i].match[local_index];
                s_op->u.getvalue.unknown_dirent[j].handle =
                    s_op->resp.u.getvalue.query_p[i].match[local_index];
            }
        }
    }

    if( s_op->u.getvalue.unknown_count == 0 )
    {
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: getvalue_setup_get_paths: "
                 "allocating room for %u dirents\n", 
                 s_op->u.getvalue.unknown_count);
    /* allocate dirent array for pathing based on total count of handle */
    if( (s_op->resp.u.getvalue.dirent_p = calloc(
        s_op->u.getvalue.unknown_count, sizeof(PVFS_dirent))) == 0 )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: malloc for "
                     "dirent failed for %u handles\n",
                      s_op->u.getvalue.unknown_count);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* prepare messages */
    PINT_msgpair_init(&s_op->msgarray_op);
    msg_p = &s_op->msgarray_op.msgpair;

    PINT_serv_init_msgarray_params(s_op, s_op->target_fs_id);

    msg_p->fs_id = s_op->target_fs_id;
    msg_p->handle = s_op->u.getvalue.unknown_handle[0];
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = path_comp_fn;

    /* send initial request to meta server of handle, just pick handle owner of
     * handle 0. */
    ret = PINT_cached_config_map_to_server( &msg_p->svr_addr, msg_p->handle,
                                             msg_p->fs_id );
    PINT_util_gen_credentials(&creds);
    PINT_SERVREQ_GETPATH_FILL( msg_p->req,
                               creds,
                               s_op->target_fs_id,
                               0,
                               s_op->u.getvalue.unknown_count,
                               s_op->u.getvalue.unknown_dirent,
                               NULL);
    PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_setup_get_paths: exit\n");
    return SM_ACTION_COMPLETE;
}


/* getvalue_cleanup()
 * free resources alloc'd by state machine
 */
static PINT_sm_action getvalue_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_cleanup: enter\n");
/*
    assert( s_op->resp.u.getvalue.query_p);
    for( i = 0; i < s_op->resp.u.getvalue.query_count; i++ )
    {
        if( s_op->resp.u.getvalue.query_p[i].match )
            free(s_op->resp.u.getvalue.query_p[i].match);
    }

    free(s_op->resp.u.getvalue.query_p);
    if( s_op->resp.u.getvalue.dirent_p )
        free(s_op->resp.u.getvalue.dirent_p);
*/
    if( s_op->u.getvalue.unknown_handle )
        free(s_op->u.getvalue.unknown_handle);
    if( s_op->u.getvalue.unknown_dirent )
        free(s_op->u.getvalue.unknown_dirent);
   
    free(s_op->key.buffer);
    free(s_op->val.buffer);

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_cleanup: exit\n");

    return(server_state_machine_complete(smcb));
}


/* path_comp_fn()
 *
 * msgpair completion function to handle processing batch create response i
 * from another server
 */
static int path_comp_fn(void *v_p,
                        struct PVFS_server_resp *resp_p,
                        int index)
{
    PINT_smcb *smcb = v_p;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int i;
                
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: enter\n");

    assert(resp_p->op == PVFS_SERV_GETPATH);

    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: GETPATH returned "
                     "error: %d\n", resp_p->status);
        return resp_p->status;
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: get_path "
                 " must return with the same number dirents as we queried: "
                 " unknown (%u), resp count (%u)\n",
                 s_op->u.getvalue.unknown_count, resp_p->u.getpath.count);
    assert( s_op->u.getvalue.unknown_count == resp_p->u.getpath.count);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: handling "
                 "%u entries, current entries: %u\n", resp_p->u.getpath.count,
                 s_op->resp.u.getvalue.dirent_count);
    for(i=0; i < resp_p->u.getpath.count; i++ )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: "
                     "path response: handle/path %d: (%llu):(%s)\n", i, 
                     llu(resp_p->u.getpath.dirent[i].handle),
                     resp_p->u.getpath.dirent[i].d_name); 
        memcpy(s_op->resp.u.getvalue.dirent_p [i].d_name,
               resp_p->u.getpath.dirent[i].d_name, PVFS_NAME_MAX + 1);
        s_op->resp.u.getvalue.dirent_p[i].handle = 
            s_op->u.getvalue.unknown_handle[i];
        s_op->resp.u.getvalue.dirent_count++;
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: "
                     "copied to s_op->resp.u.getvalue.dirent_p[%d]\n", 
                     s_op->resp.u.getvalue.dirent_count-1);
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: exit\n");
    return 0;
}

PINT_GET_OBJECT_REF_DEFINE(getvalue);

struct PINT_server_req_params pvfs2_get_value_params =
{
    .string_name = "getvalue",
    .perm = PINT_SERVER_CHECK_READ,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getvalue,
    .state_machine = &pvfs2_get_value_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

