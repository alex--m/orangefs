/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_get_value_sm
 *
 * This state machine handles incoming server getvalue operations.  These
 * are the operations sent by PVFS_sys_getvalue().
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-perf-counter.h"
#include "pint-cached-config.h"
#include "dbpf-keyval.h"

#define FAILED_PERMS    100
#define EMPTY_RESULT    101
#define TARGET_ASSIGNED 102
#define MORE_TARGETS    103
#define GET_PATHS       104

static int path_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
%%

machine pvfs2_get_value_sm
{
    state setup_resp
    {
        run getvalue_setup_resp;
        success => read_value;
        default => final_response;
    }

    state read_value
    {
        run getvalue_read_value;
        success => assign_target;
        default => final_response;
    }

    state assign_target
    {
        run getvalue_assign_target;
        TARGET_ASSIGNED => perms;
        default => final_response;
    }

    state perms
    {
        jump pvfs2_prelude_attr_sm;
        default => check_resp;
    }

    state check_resp
    {
        run getvalue_check_resp;
        FAILED_PERMS => remove_result;
        MORE_TARGETS => assign_target;
        default => setup_get_paths;
    }

    state remove_result
    {
      run getvalue_remove_result;
      MORE_TARGETS => assign_target;
      default => setup_get_paths;
    }

    state setup_get_paths
    {
        run getvalue_setup_get_paths;
        GET_PATHS => call_msgpairarray;
        default => final_response;
    }

    state call_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup   
    {
        run getvalue_cleanup;
        default => terminate;
    }
}

%%

/*
 * getvalue_setup_resp()
 * Set up the response - allocate needed resources
 */
static PINT_sm_action getvalue_setup_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret=0, i=0;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    js_p->error_code = 0;
    ret = job_req_sched_post(s_op->op, s_op->target_fs_id, s_op->target_handle,
                             s_op->access_type, s_op->sched_policy,
                             smcb, 0, js_p, 
                             &(s_op->scheduled_id), server_job_context);
    PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);

    /* allocate buffer for all keyval buffers (attr and val) */
    if( (s_op->u.getvalue.buffer = malloc( s_op->req->u.getvalue.count * 2 * 
                                           PVFS_NAME_MAX )) == 0 )
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(s_op->u.getvalue.buffer, 0, 
      s_op->req->u.getvalue.count * 2 * PVFS_NAME_MAX);

    /* copy req values to state structs */
    s_op->u.getvalue.count = s_op->req->u.getvalue.count;
    s_op->u.getvalue.original_count = s_op->req->u.getvalue.count;
    s_op->u.getvalue.match_count = 0;
    s_op->u.getvalue.target_i = 0;

    /* initialize response structs and buffers */
    s_op->resp.u.getvalue.token = TROVE_ITERATE_END;
    s_op->resp.u.getvalue.count = 0;
    s_op->resp.u.getvalue.match_count = 0;

    if( (s_op->resp.u.getvalue.dirent = 
        malloc( s_op->u.getvalue.original_count * sizeof(PVFS_dirent)) ) == 0 ) 
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(s_op->resp.u.getvalue.dirent, 0, s_op->u.getvalue.original_count * 
      sizeof(PVFS_dirent));

    if( (s_op->resp.u.getvalue.key = 
        malloc(s_op->u.getvalue.original_count*sizeof(PVFS_ds_keyval)) ) == 0 ) 
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(s_op->resp.u.getvalue.key, 0, s_op->u.getvalue.original_count * 
      sizeof(PVFS_ds_keyval));

    if( (s_op->resp.u.getvalue.val = 
        malloc(s_op->u.getvalue.original_count*sizeof(PVFS_ds_keyval)) ) == 0 ) 
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(s_op->resp.u.getvalue.val, 0, s_op->u.getvalue.original_count * 
      sizeof(PVFS_ds_keyval));


    /* point individual keyval buffers into s_op->u big buffer */
    for( i = 0; i < s_op->u.getvalue.original_count; i++ )
    {
        s_op->resp.u.getvalue.key[i].buffer = s_op->u.getvalue.buffer + 
            (2 * i * PVFS_NAME_MAX); 
        s_op->resp.u.getvalue.key[i].buffer_sz = PVFS_NAME_MAX;

        s_op->resp.u.getvalue.val[i].buffer = s_op->u.getvalue.buffer + 
            ((2 * i * PVFS_NAME_MAX) + PVFS_NAME_MAX);
        s_op->resp.u.getvalue.val[i].buffer_sz = PVFS_NAME_MAX;
    }
    return SM_ACTION_COMPLETE;
}

/*
 *
 */
static PINT_sm_action getvalue_read_value(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: enter, token: %llu, "
                 "key buf_sz: %d, val buf_sz: %d\n",
                 llu(s_op->req->u.getvalue.token), 
                 s_op->req->u.getvalue.key.buffer_sz,
                 s_op->req->u.getvalue.val.buffer_sz);

    ret = job_trove_keyval_read_value_query(
        s_op->req->u.getvalue.fs_id,
        s_op->req->u.getvalue.token,
        s_op->req->u.getvalue.query_type,
        &(s_op->req->u.getvalue.key),
        &(s_op->req->u.getvalue.val),
        s_op->resp.u.getvalue.dirent,
        s_op->resp.u.getvalue.key,
        s_op->resp.u.getvalue.val,
        &(s_op->u.getvalue.count),
        &(s_op->u.getvalue.match_count),
        0,
        NULL,
        smcb,
        0,
        js_p,
        &i,
        server_job_context, s_op->req->hints);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: exit\n");

    return ret;
}

static PINT_sm_action getvalue_assign_target(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    js_p->error_code = 0;

    /* only store position after first time in state (if count is non-zero 
     * we'll be back */
    if( s_op->resp.u.getvalue.count == 0 )
    {
        s_op->resp.u.getvalue.count = s_op->u.getvalue.count;
        s_op->resp.u.getvalue.match_count = 
            ( s_op->u.getvalue.match_count > s_op->u.getvalue.count) ? 
            ( s_op->u.getvalue.count ) : ( s_op->u.getvalue.match_count );
        s_op->resp.u.getvalue.token = js_p->position;
    }

    if( s_op->u.getvalue.count == 0 )
    {   /* no records found, no targets to set */
        s_op->resp.u.getvalue.token = TROVE_ITERATE_END;
        return SM_ACTION_COMPLETE;
    }

    assert( s_op->u.getvalue.target_i < s_op->u.getvalue.count );
    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: assign_target: target_i: %d, count: %d, "
                 "token: %llu\n",
                 s_op->u.getvalue.target_i, s_op->u.getvalue.count,
                 s_op->resp.u.getvalue.token);

    s_op->target_handle = 
        s_op->resp.u.getvalue.dirent[ s_op->u.getvalue.target_i ].handle;
    s_op->target_fs_id = s_op->req->u.getvalue.fs_id;

    js_p->error_code = TARGET_ASSIGNED;
    return SM_ACTION_COMPLETE;
}


/* getvalue_check_resp()
 */
static PINT_sm_action getvalue_check_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    if( js_p->error_code != 0 )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                     "[GETVALUE]: Failed permission check on %llu, error: %d\n",
                     llu(s_op->target_handle), js_p->error_code);
        js_p->error_code =  FAILED_PERMS; 
    }
    else
    {
        /* if next result is, change error code to say so */
        if( ++s_op->u.getvalue.target_i < s_op->u.getvalue.count )
        {
            js_p->error_code = MORE_TARGETS;
        }
        else
        {
            js_p->error_code = 0;
        }
    }
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getvalue_remove_result(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int i = 0;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_DBPF_KEYVAL_DEBUG,
                 "[DBPF KEYVAL]: remove_result enter target_i: %u, "
                 "count: %u\n", s_op->u.getvalue.target_i,
                 s_op->u.getvalue.count);

    /* squish result array (key, val, dirent) to remove result with failed
     * permission check. key, val, dirent are whole array malloc'd,
     * buffers for key and val are one large malloc too so no leaks with
     * memory copies. this is not cheap but the best I could figur' */
    for( i = (s_op->u.getvalue.target_i+1); i < s_op->u.getvalue.count; i++)
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG,
                     "\t[GETVALUE]: i: %d, replacing %llu(%s|%s) with "
                     "%llu(%s|%s)\n", i, 
                     llu(s_op->resp.u.getvalue.dirent[i-1].handle),
                     (char *)(s_op->resp.u.getvalue.key[i-1].buffer + 
                        sizeof(PVFS_handle)),
                     (char *)s_op->resp.u.getvalue.val[i-1].buffer,
                     llu(s_op->resp.u.getvalue.dirent[i].handle),
                     (char *)(s_op->resp.u.getvalue.key[i].buffer + 
                        sizeof(PVFS_handle)),
                     (char *)s_op->resp.u.getvalue.val[i].buffer);
        memcpy( &(s_op->resp.u.getvalue.key[i-1]), 
                &(s_op->resp.u.getvalue.key[i]), sizeof(PVFS_ds_keyval) );
        memcpy( &(s_op->resp.u.getvalue.val[i-1]), 
                &(s_op->resp.u.getvalue.val[i]), sizeof(PVFS_ds_keyval) );
        memcpy( &(s_op->resp.u.getvalue.dirent[i-1]), 
                &(s_op->resp.u.getvalue.dirent[i]), sizeof(PVFS_dirent) );
    }

    /* zero out last item in array we just shifted (or are removing) */
    assert( (i-1) < s_op->u.getvalue.original_count );
    memset( &(s_op->resp.u.getvalue.key [ i-1 ]), 0,
            sizeof( PVFS_ds_keyval ) );
    memset( &(s_op->resp.u.getvalue.val [ i-1 ]), 0,
            sizeof( PVFS_ds_keyval ) );
    memset( &(s_op->resp.u.getvalue.dirent [ i-1 ]), 0,
            sizeof( PVFS_dirent ) );

    /* match count should never be less than 0 */
    if( s_op->u.getvalue.match_count > 0 )
    {
        s_op->u.getvalue.match_count--;
    }

    if( s_op->u.getvalue.count == 1 )
    {   /* removing last record */
        s_op->u.getvalue.count = 0;
        s_op->resp.u.getvalue.token = TROVE_ITERATE_END;
    }
    else
    {
        s_op->u.getvalue.count--;
    }

    js_p->error_code = 0;
    if( s_op->u.getvalue.target_i < s_op->u.getvalue.count )
    {
        js_p->error_code = MORE_TARGETS;
    }

    s_op->resp.u.getvalue.count = s_op->u.getvalue.count;
    s_op->resp.u.getvalue.match_count = s_op->u.getvalue.match_count;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: remove_result exit, target_i: %d, "
                 "count: %d\n", s_op->u.getvalue.target_i,
                 s_op->resp.u.getvalue.count);
    return SM_ACTION_COMPLETE;
}

/*
 * getvalue_setup_resp()
 * Set up the response - allocate needed resources
 */
static PINT_sm_action getvalue_setup_get_paths(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret=0, i=0;
    PINT_sm_msgpair_state *msg_p = NULL;
    PVFS_credentials creds;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *user_opts = get_server_config_struct();

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: setup_get_paths: enter\n");
    js_p->error_code = GET_PATHS;

    /* if the query doesn't want paths, save the effort */
    if( PVFS_KEYVAL_QUERY_UNMASK_PATHS(s_op->req->u.getvalue.query_type) == 
        PVFS_KEYVAL_RESULT_NO_PATHS )
    {
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }
    
    if( (s_op->u.getvalue.unknown_handle = calloc( s_op->resp.u.getvalue.count,
                                                  sizeof(TROVE_handle) )) == 0)
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    if( (s_op->u.getvalue.unknown_dirent = calloc( s_op->resp.u.getvalue.count,
                                                  sizeof(PVFS_dirent) )) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* move results into memory for get-path call */
    for( i=0; i < s_op->resp.u.getvalue.count; i++ )
    {
        s_op->u.getvalue.unknown_handle[i] = 
            s_op->resp.u.getvalue.dirent[i].handle;
        memcpy( &(s_op->u.getvalue.unknown_dirent[i]),
                &(s_op->resp.u.getvalue.dirent[i]), sizeof(PVFS_dirent) );
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: Setting %d to handle "
                     "%llu\n", i, llu(s_op->u.getvalue.unknown_handle[i]) );
    }

    /* prepare messages */
    PINT_msgpair_init(&s_op->msgarray_op);
    msg_p = &s_op->msgarray_op.msgpair;

    s_op->msgarray_op.params.job_timeout = user_opts->client_job_bmi_timeout;
    s_op->msgarray_op.params.retry_delay = user_opts->client_retry_delay_ms;
    s_op->msgarray_op.params.retry_limit = user_opts->client_retry_limit;
    s_op->msgarray_op.params.quiet_flag = 1;

    msg_p->fs_id = s_op->target_fs_id;
    msg_p->handle = s_op->u.getvalue.unknown_handle[0];
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = path_comp_fn;

    /* send initial request to meta server of handle */
    ret = PINT_cached_config_map_to_server( &msg_p->svr_addr, msg_p->handle,
                                             msg_p->fs_id );
    PINT_util_gen_credentials(&creds);
    PINT_SERVREQ_GETPATH_FILL( msg_p->req,
                               creds,
                               s_op->target_fs_id,
                               s_op->resp.u.getvalue.count,
                               s_op->u.getvalue.unknown_dirent,
                               NULL);

    PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: setup_get_paths: exit\n");
    return SM_ACTION_COMPLETE;
}


/* getvalue_cleanup()
 * free resources alloc'd by state machine
 */
static PINT_sm_action getvalue_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    free(s_op->u.getvalue.buffer);
    if( s_op->u.getvalue.unknown_handle )
        free(s_op->u.getvalue.unknown_handle);
    if( s_op->u.getvalue.unknown_dirent )
        free(s_op->u.getvalue.unknown_dirent);
    free(s_op->resp.u.getvalue.dirent);
    free(s_op->resp.u.getvalue.key);
    free(s_op->resp.u.getvalue.val);
    return(server_state_machine_complete(smcb));
}


/* path_comp_fn()
 *
 * msgpair completion function to handle processing batch create response i
 * from another server
 */
static int path_comp_fn(void *v_p,
                        struct PVFS_server_resp *resp_p,
                        int index)
{
    //PINT_smcb *smcb = v_p;
    //struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int i;
                
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: enter\n");

    assert(resp_p->op == PVFS_SERV_GETPATH);

    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: GETPATH returned "
                     "error: %d=n", resp_p->status);
        return resp_p->status;
    }

    for(i=0; i < resp_p->u.getpath.count; i++ )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]:  handle/path %d: "
                     "(%llu):(%s)\n", i, 
                     llu(resp_p->u.getpath.dirent[i].handle),
                     resp_p->u.getpath.dirent[i].d_name); 
    
    }
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: exit\n");
    return 0;
}


PINT_GET_OBJECT_REF_DEFINE(getvalue);

struct PINT_server_req_params pvfs2_get_value_params =
{
    .string_name = "getvalue",
    .perm = PINT_SERVER_CHECK_READ,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getvalue,
    .state_machine = &pvfs2_get_value_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

