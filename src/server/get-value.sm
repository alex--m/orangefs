/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_get_value_sm
 *
 * This state machine handles incoming server getvalue operations.  These
 * are the operations sent by PVFS_sys_getvalue().
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-perf-counter.h"
#include "pint-cached-config.h"
#include "dbpf-keyval.h"

#define FAILED_PERMS    100
#define EMPTY_RESULT    101
#define TARGET_ASSIGNED 102
#define MORE_TARGETS    103
#define GET_PATHS       104
#define MORE_QUERIES    105

/* if counts and tokens are equal we haven't worked it */
static inline int handled_query(PVFS_keyval_query o, PVFS_keyval_query q) 
{
    return ((o.count==q.count) && (o.token==q.token) &&
            (q.oper != PVFS_KEYVAL_QUERY_NOOP )) ? 0 : 1;
}

static int path_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
%%

machine pvfs2_get_value_sm
{
    state setup_resp
    {
        run getvalue_setup_resp;
        success => read_value;
        default => final_response;
    }

    state parse_query
    {
        run getvalue_parse_query;
        success => assign_target;
        MORE_QUERIES => read_value;
        default => final_response;
    }

    state read_value
    {
        run getvalue_read_value;
        success => parse_query;
        default => final_response;
    }

    state assign_target
    {
        run getvalue_assign_target;
        TARGET_ASSIGNED => perms;
        default => final_response;
    }

    state perms
    {
        jump pvfs2_prelude_attr_sm;
        default => check_perm_resp;
    }

    state check_perm_resp
    {
        run getvalue_check_perm_resp;
        FAILED_PERMS => remove_result;
        MORE_TARGETS => assign_target;
        default => setup_get_paths;
    }

    state remove_result
    {
      run getvalue_remove_result;
      MORE_TARGETS => assign_target;
      default => setup_get_paths;
    }

    state setup_get_paths
    {
        run getvalue_setup_get_paths;
        GET_PATHS => call_msgpairarray;
        default => final_response;
    }

    state call_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup   
    {
        run getvalue_cleanup;
        default => terminate;
    }
}

%%

/*
 * getvalue_setup_resp()
 * Set up the response - allocate needed resources
 */
static PINT_sm_action getvalue_setup_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret=0, i=0;
    js_p->error_code = 0;

    ret = job_req_sched_post(s_op->op, s_op->target_fs_id, s_op->target_handle,
                             s_op->access_type, s_op->sched_policy,
                             smcb, 0, js_p, 
                             &(s_op->scheduled_id), server_job_context);
    PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);

    /* copy query_p array over to resp struct */
    s_op->resp.u.getvalue.query_p = calloc( s_op->req->u.getvalue.count, 
        sizeof( PVFS_keyval_query ));
    memcpy( s_op->resp.u.getvalue.query_p, s_op->req->u.getvalue.query_p,
            s_op->req->u.getvalue.count * sizeof(PVFS_keyval_query) );

    /* allocate handle match array based on count value in query struct */
    for( i=0; i < s_op->req->u.getvalue.count; i++ )
    {
        if( (s_op->resp.u.getvalue.query_p[i].match = calloc(
             s_op->req->u.getvalue.query_p[i].count, sizeof(PVFS_handle))) == 0)
        {
            gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: malloc for "
                         "match failed for %u  handles\n",
                          s_op->req->u.getvalue.query_p[i].count);
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
    }
    return SM_ACTION_COMPLETE;
}

/*
 * parse query to break down into parts DBPF can handle
 */
static PINT_sm_action getvalue_parse_query(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i=0;
    js_p->error_code = 0;

    /* iterate down the query_p array until we've done work */
    for( i=0; i < s_op->req->u.getvalue.count; i++ )
    {
        if( ! handled_query(s_op->req->u.getvalue.query_p[i],
                            s_op->resp.u.getvalue.query_p[i]) )
        {
            s_op->u.getvalue.current_query = 
                &(s_op->resp.u.getvalue.query_p[i]);
            gossip_debug(GOSSIP_GETVALUE_DEBUG,
                         "[GETVALUE]: getvalue_parse_query: setting current_"
                         "query to index %d at %p\n", i, 
                         s_op->u.getvalue.current_query);
            break;
        }
    }

    if( s_op->u.getvalue.current_query == NULL )
    {
        return SM_ACTION_COMPLETE; /* done all queries that need dbpf work*/
    }

    /* reset key/val */
    memset( &(s_op->key), 0, sizeof(PVFS_ds_keyval) );
    memset( &(s_op->val), 0, sizeof(PVFS_ds_keyval) );

    /* if set operation bail without copying operands since they are the kids */
    if( (s_op->u.getvalue.current_query->oper == PVFS_KEYVAL_QUERY_AND) ||
        (s_op->u.getvalue.current_query->oper == PVFS_KEYVAL_QUERY_OR) )
    {
        js_p->error_code = MORE_QUERIES;
        return SM_ACTION_COMPLETE;
    
    }

    /* assert that children exist */
    assert( (2*i + 2) <= s_op->req->u.getvalue.count);

    /* set key as left operand, val as right */
    memcpy( &(s_op->key), &(s_op->req->u.getvalue.query_p[ (2*i)+1 ]), 
        sizeof( PVFS_ds_keyval) );
    memcpy( &(s_op->val), &(s_op->req->u.getvalue.query_p[ (2*i)+2 ]), 
        sizeof( PVFS_ds_keyval) );
    
    js_p->error_code = MORE_QUERIES;
    return SM_ACTION_COMPLETE;
}


/*
 * keyval call to handle query 
 */
static PINT_sm_action getvalue_read_value(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: enter\n");

    ret = job_trove_keyval_read_value_query(
        s_op->req->u.getvalue.fs_id,
        s_op->u.getvalue.current_query->token,
        s_op->u.getvalue.current_query->oper,
        &(s_op->key),
        &(s_op->val),
        s_op->u.getvalue.current_query->match,
        &(s_op->u.getvalue.current_query->count),
        0,
        NULL,
        smcb,
        0,
        js_p,
        &i,
        server_job_context, s_op->req->hints);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: exit\n");

    return ret;
}

/*
 * getvalue_assign_target
 * assign a single handle to s_op->targets so permissions can be checked 
 */
static PINT_sm_action getvalue_assign_target(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    //struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    js_p->error_code = 0;

    /* only store position after first time in state (if count is non-zero 
     * we'll be back */

/* TODO: need to look per query 
    if( s_op->resp.u.getvalue.count == 0 )
    {
        s_op->resp.u.getvalue.count = s_op->u.getvalue.count;
        s_op->resp.u.getvalue.match_count = 
            ( s_op->u.getvalue.match_count > s_op->u.getvalue.count) ? 
            ( s_op->u.getvalue.count ) : ( s_op->u.getvalue.match_count );
        s_op->resp.u.getvalue.token = js_p->position;
    }

    if( s_op->u.getvalue.count == 0 )
    {
        s_op->resp.u.getvalue.token = TROVE_ITERATE_END;
        return SM_ACTION_COMPLETE;
    }

    assert( s_op->u.getvalue.target_index < s_op->u.getvalue.count );

    s_op->target_handle = 
        s_op->resp.u.getvalue.dirent_p[ s_op->u.getvalue.target_index ].handle;
    s_op->target_fs_id = s_op->req->u.getvalue.fs_id;

*/

    js_p->error_code = TARGET_ASSIGNED;
    return SM_ACTION_COMPLETE;
}

/* 
 * getvalue_check_perm_resp()
 * look at error_code from permission check, set error_code appropriately
 */
static PINT_sm_action getvalue_check_perm_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    if( js_p->error_code != 0 )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                     "[GETVALUE]: Failed permission check on %llu, error: %d\n",
                     llu(s_op->target_handle), js_p->error_code);
        js_p->error_code =  FAILED_PERMS; 
    }
    else
    {
        /* if next result is, change error code to say so */
/*TODO
        if( ++s_op->u.getvalue.target_index < s_op->u.getvalue.count )
        {
            js_p->error_code = MORE_TARGETS;
        }
        else
        {
            js_p->error_code = 0;
        }
*/
    }
    return SM_ACTION_COMPLETE;
}

/*
 * getvalue_remove_result
 * remove a record, for permission check failure, from the result set shifting
 * pointers and counters as needed
 */
static PINT_sm_action getvalue_remove_result(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    //int i = 0;
    //struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_DBPF_KEYVAL_DEBUG,
                 "[DBPF KEYVAL]: remove_result: enter\n"); 

    js_p->error_code = 0;

    /* squish result array (dirent) to remove result with failed
     * permission check.
     * TODO: remove handle from query struct */
/*TODO
    for( i = (s_op->u.getvalue.target_index+1); i < s_op->u.getvalue.count; i++)
    {
        memcpy( &(s_op->resp.u.getvalue.dirent_p[i-1]), 
                &(s_op->resp.u.getvalue.dirent_p[i]), sizeof(PVFS_dirent) );
    }
*/
    /* zero out last item in array we just shifted (or are removing) */
/*TODO
    assert( (i-1) < s_op->u.getvalue.original_count );
    memset( &(s_op->resp.u.getvalue.dirent_p[ i-1 ]), 0,
            sizeof( PVFS_dirent ) );
*/
    /* match count should never be less than 0 */
/*    if( s_op->u.getvalue.match_count > 0 )
    {
        s_op->u.getvalue.match_count--;
    }
*/
    /* removing last record, set token appropriately, don't let count < 0 */
/*    if( s_op->u.getvalue.count <= 1 )
    { 
        s_op->u.getvalue.count = 0;
        s_op->resp.u.getvalue.token = TROVE_ITERATE_END;
    }
    else
    {
        s_op->u.getvalue.count--;
    }
*/
    /* more work to do, tell the state machine */
/*    if( s_op->u.getvalue.target_index < s_op->u.getvalue.count )
    {
        js_p->error_code = MORE_TARGETS;
    }
*/

    /* update the response here in the the event we're all done */
    /* TODO: per query struct */
/*    s_op->resp.u.getvalue.count = s_op->u.getvalue.count;
    s_op->resp.u.getvalue.match_count = s_op->u.getvalue.match_count;
*/
    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: remove_result: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * getvalue_setup_resp()
 * Set up the request to get path for the handle - allocate needed resources
 */
static PINT_sm_action getvalue_setup_get_paths(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret=0, i=0;
    PINT_sm_msgpair_state *msg_p = NULL;
    PVFS_credentials creds;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: setup_get_paths: enter\n");
    js_p->error_code = GET_PATHS;

    /* iterate over each query object to see 
     * 1) total handle count
     * 2) which queries want paths returned 
     */
/*
    if( PVFS_KEYVAL_QUERY_UNMASK_PATHS(s_op->req->u.getvalue.query_type) == 
        PVFS_KEYVAL_RESULT_NO_PATHS )
    {
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }
*/

    /* TODO calculate total number of handles matches in query structs */

    /* allocate memory specific to getting path information */
    if( (s_op->u.getvalue.unknown_handle = calloc( 
        s_op->resp.u.getvalue.dirent_count, sizeof(TROVE_handle) )) == 0)
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    if( (s_op->u.getvalue.unknown_dirent = calloc( 
        s_op->resp.u.getvalue.dirent_count, sizeof(PVFS_dirent) )) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* assign handle information for get-path call */
    for( i=0; i < s_op->resp.u.getvalue.dirent_count; i++ )
    {
        s_op->u.getvalue.unknown_handle[i] = 
            s_op->resp.u.getvalue.dirent_p[i].handle;
        s_op->u.getvalue.unknown_dirent[i].handle =
            s_op->resp.u.getvalue.dirent_p[i].handle;
    }

    /* prepare messages */
    PINT_msgpair_init(&s_op->msgarray_op);
    msg_p = &s_op->msgarray_op.msgpair;

    PINT_serv_init_msgarray_params(s_op, s_op->target_fs_id);

    msg_p->fs_id = s_op->target_fs_id;
    msg_p->handle = s_op->u.getvalue.unknown_handle[0];
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = path_comp_fn;

    /* send initial request to meta server of handle, just pick handle owner of
     * handle 0. */
    ret = PINT_cached_config_map_to_server( &msg_p->svr_addr, msg_p->handle,
                                             msg_p->fs_id );
    PINT_util_gen_credentials(&creds);
    PINT_SERVREQ_GETPATH_FILL( msg_p->req,
                               creds,
                               s_op->target_fs_id,
                               0,
                               s_op->resp.u.getvalue.query_count,
                               s_op->u.getvalue.unknown_dirent,
                               NULL);
    PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: setup_get_paths: exit\n");
    return SM_ACTION_COMPLETE;
}


/* getvalue_cleanup()
 * free resources alloc'd by state machine
 */
static PINT_sm_action getvalue_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    if( s_op->u.getvalue.unknown_handle )
        free(s_op->u.getvalue.unknown_handle);
    if( s_op->u.getvalue.unknown_dirent )
        free(s_op->u.getvalue.unknown_dirent);
    free(s_op->resp.u.getvalue.dirent_p);
    return(server_state_machine_complete(smcb));
}


/* path_comp_fn()
 *
 * msgpair completion function to handle processing batch create response i
 * from another server
 */
static int path_comp_fn(void *v_p,
                        struct PVFS_server_resp *resp_p,
                        int index)
{
    PINT_smcb *smcb = v_p;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int i;
                
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: enter\n");

    assert(resp_p->op == PVFS_SERV_GETPATH);

    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: GETPATH returned "
                     "error: %d\n", resp_p->status);
        return resp_p->status;
    }

    for(i=0; i < resp_p->u.getpath.count; i++ )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path response: "
                     "handle/path %d: (%llu):(%s)\n", i, 
                     llu(resp_p->u.getpath.dirent[i].handle),
                     resp_p->u.getpath.dirent[i].d_name); 
        memcpy(s_op->resp.u.getvalue.dirent_p[i].d_name,
               resp_p->u.getpath.dirent[i].d_name, PVFS_NAME_MAX + 1);
    }
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: exit\n");
    return 0;
}

PINT_GET_OBJECT_REF_DEFINE(getvalue);

struct PINT_server_req_params pvfs2_get_value_params =
{
    .string_name = "getvalue",
    .perm = PINT_SERVER_CHECK_READ,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getvalue,
    .state_machine = &pvfs2_get_value_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

