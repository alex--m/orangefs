/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_get_value_sm
 *
 * This state machine handles incoming server getvalue operations.  These
 * are the operations sent by PVFS_sys_getvalue().
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-perf-counter.h"
#include "pint-cached-config.h"
#include "dbpf-keyval.h"

#define FAILED_PERMS    100
#define TARGET_ASSIGNED 102
#define GET_PATHS       103
#define DBPF_QUERY    104
#define SET_QUERY     105

/* if counts and tokens are equal we haven't worked it */
static inline int handled_query(PVFS_keyval_query o, PVFS_keyval_query q) 
{
    return ((o.count==q.count) && (o.token==q.token) &&
            (q.oper != PVFS_KEYVAL_QUERY_NOOP )) ? 0 : 1;
}

static int path_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
%%

machine pvfs2_get_value_sm
{
    state setup_resp
    {
        run getvalue_setup_resp;
        success => parse_query;
        default => final_response;
    }

    state parse_query
    {
        run getvalue_parse_query;
        success => assign_target;
        DBPF_QUERY => read_value;
        SET_QUERY => set_operation;
        default => final_response;
    }

    state set_operation
    {
        run getvalue_set_operation;
        success => parse_query;
        default => final_response;
    }

    state read_value
    {
        run getvalue_read_value;
        success => parse_query;
        default => final_response;
    }

    state assign_target
    {
        run getvalue_assign_target;
        TARGET_ASSIGNED => perms;
        success => setup_get_paths;
        default => final_response;
    }

    state perms
    {
        jump pvfs2_prelude_attr_sm;
        default => check_perm_resp;
    }

    state check_perm_resp
    {
        run getvalue_check_perm_resp;
        FAILED_PERMS => remove_result;
        default => assign_target;
    }

    state remove_result
    {
      run getvalue_remove_result;
      default => assign_target;
    }

    state setup_get_paths
    {
        run getvalue_setup_get_paths;
        GET_PATHS => call_msgpairarray;
        default => final_response;
    }

    state call_msgpairarray
    {
        jump pvfs2_msgpairarray_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup   
    {
        run getvalue_cleanup;
        default => terminate;
    }
}

%%

/*
 * getvalue_setup_resp()
 * Set up the response - allocate needed resources
 */
static PINT_sm_action getvalue_setup_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret=0, i=0;
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_setup_resp: enter\n");
    ret = job_req_sched_post(s_op->op, s_op->target_fs_id, s_op->target_handle,
                             s_op->access_type, s_op->sched_policy,
                             smcb, 0, js_p, 
                             &(s_op->scheduled_id), server_job_context);
    PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: count: %u\n", s_op->req->u.getvalue.count);

    s_op->resp.u.getvalue.query_count = s_op->req->u.getvalue.count;
    /* copy query_p array over to resp struct */
    s_op->resp.u.getvalue.query_p = calloc( s_op->req->u.getvalue.count, 
        sizeof( PVFS_keyval_query ));
    memcpy( s_op->resp.u.getvalue.query_p, s_op->req->u.getvalue.query_p,
            s_op->req->u.getvalue.count * sizeof(PVFS_keyval_query) );

    /* allocate handle match array based on count value in query struct */
    for( i=0; i < s_op->req->u.getvalue.count; i++ )
    {
        if( (s_op->resp.u.getvalue.query_p[i].match = calloc(
             s_op->req->u.getvalue.query_p[i].count, sizeof(PVFS_handle))) == 0)
        {
            gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: malloc for "
                         "match failed for %u  handles\n",
                          s_op->req->u.getvalue.query_p[i].count);
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
    }

    /* dirent array is allocated in setup_get_paths so it's only allocated
     * if needed and only for the total number of handles we are looking up */

    s_op->resp.u.getvalue.dirent_count = 0;

    if( (s_op->key.buffer = calloc( DBPF_MAX_KEY_LENGTH, sizeof(char) ))==0 )
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    if( (s_op->val.buffer = calloc( DBPF_MAX_KEY_LENGTH, sizeof(char) ))==0 )
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }


    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: req: %p, fs_id: %d, "
                 "handle: %llu, count: %u, query_p: %p, key.buffer: %p, "
                 "val.buffer: %p\n",
                 s_op->req, s_op->req->u.getvalue.fs_id, 
                 llu(s_op->req->u.getvalue.handle), s_op->req->u.getvalue.count,
                 s_op->req->u.getvalue.query_p,
                 s_op->key.buffer, s_op->val.buffer);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: query_p: %p, token: %llu, "
                 "oper: %u, count: %u, match: %p, query: %s(%d)\n",
                 s_op->req->u.getvalue.query_p, 
                 llu(s_op->req->u.getvalue.query_p[0].token), 
                 s_op->req->u.getvalue.query_p[0].oper, 
                 s_op->req->u.getvalue.query_p[0].count, 
                 s_op->req->u.getvalue.query_p[0].match, 
                 (char *)s_op->req->u.getvalue.query_p[0].query.buffer,
                 s_op->req->u.getvalue.query_p[0].query.buffer_sz);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: query_p: %p, token: %llu, "
                 "oper: %u, count: %u, match: %p, query: %s(%d)\n",
                 s_op->req->u.getvalue.query_p, 
                 llu(s_op->req->u.getvalue.query_p[1].token), 
                 s_op->req->u.getvalue.query_p[1].oper, 
                 s_op->req->u.getvalue.query_p[1].count, 
                 s_op->req->u.getvalue.query_p[1].match, 
                 (char *)s_op->req->u.getvalue.query_p[1].query.buffer,
                 s_op->req->u.getvalue.query_p[1].query.buffer_sz);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: query_p: %p, token: %llu, "
                 "oper: %u, count: %u, match: %p, query: %s(%d)\n",
                 s_op->req->u.getvalue.query_p, 
                 llu(s_op->req->u.getvalue.query_p[2].token), 
                 s_op->req->u.getvalue.query_p[2].oper, 
                 s_op->req->u.getvalue.query_p[2].count, 
                 s_op->req->u.getvalue.query_p[2].match, 
                 (char *)s_op->req->u.getvalue.query_p[2].query.buffer,
                 s_op->req->u.getvalue.query_p[2].query.buffer_sz);

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_setup_resp: exit\n");

    return SM_ACTION_COMPLETE;
}

/*
 * parse query to break down into parts DBPF can handle
 */
static PINT_sm_action getvalue_parse_query(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i=0;
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_parse_query: enter\n");


    /* save ending position in last query struct before losing tabs on it */
    if( s_op->u.getvalue.current_query != NULL )
    {
        s_op->u.getvalue.current_query->token = js_p->position;
    }
    s_op->u.getvalue.current_query = NULL;

    /* iterate up the query_p array until we've done work */
    for( i=s_op->req->u.getvalue.count-1; i >= 0; i-- )
    {
        if( ! handled_query(s_op->req->u.getvalue.query_p[i],
                            s_op->resp.u.getvalue.query_p[i]) )
        {
            s_op->u.getvalue.current_query = 
                &(s_op->resp.u.getvalue.query_p[i]);
            gossip_debug(GOSSIP_GETVALUE_DEBUG,
                         "[GETVALUE]: getvalue_parse_query: setting current_"
                         "query to index %d at %p\n", i, 
                         s_op->u.getvalue.current_query);
            break;
        }
    }

    if( s_op->u.getvalue.current_query == NULL )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                     "[GETVALUE]: Couldn't find another query to execute\n");
        return SM_ACTION_COMPLETE; /* done all queries that need dbpf work*/
    }

    /* reset key/val */
    memset( s_op->key.buffer, 0, DBPF_MAX_KEY_LENGTH );
    memset( s_op->val.buffer, 0, DBPF_MAX_KEY_LENGTH );

    if((PVFS_KEYVAL_QUERY_UNMASK_QUERY(s_op->u.getvalue.current_query->oper) == 
        PVFS_KEYVAL_QUERY_AND) ||
       (PVFS_KEYVAL_QUERY_UNMASK_QUERY(s_op->u.getvalue.current_query->oper) == 
        PVFS_KEYVAL_QUERY_OR) )
    {
        js_p->error_code = SET_QUERY;
        return SM_ACTION_COMPLETE;
    }

    /* assert that children exist */
    assert( (2*i + 2) < s_op->req->u.getvalue.count);

    /* set key as left operand, val as right */
    memcpy( s_op->key.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+1 ].query.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+1 ].query.buffer_sz);
    s_op->key.buffer_sz = 
        s_op->req->u.getvalue.query_p[ (2*i)+1 ].query.buffer_sz;

    memcpy( s_op->val.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+2 ].query.buffer, 
            s_op->req->u.getvalue.query_p[ (2*i)+2 ].query.buffer_sz);
    s_op->val.buffer_sz = 
        s_op->req->u.getvalue.query_p[ (2*i)+2 ].query.buffer_sz;
    
    js_p->error_code = DBPF_QUERY;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_parse_query: exit\n");
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getvalue_set_operation(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_keyval_query *l=NULL, *r=NULL;
    uint32_t i=0, j=0, match_index=0;


    js_p->error_code = 0;
    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_set_operation: enter\n");

    for( i = 0; i < s_op->req->u.getvalue.count; i++ )
    {
        if( s_op->u.getvalue.current_query == 
            &(s_op->resp.u.getvalue.query_p[i]) )
        {
            gossip_debug(GOSSIP_GETVALUE_DEBUG,
                         "[GETVALUE]: getvalue_set_operation: set operation "
                         "query at index %d\n", i);
            break;
        }
    }

    l = &(s_op->resp.u.getvalue.query_p[(2*i)+1]);
    assert(l);
    r = &(s_op->resp.u.getvalue.query_p[(2*i)+2]);
    assert(r);

    if( l->token == PVFS_ITERATE_START || r->token == PVFS_ITERATE_START )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_set_operation: left or right operand "
                 "of set operation not completed (position at START)\n");
        js_p->error_code = -1;
        return SM_ACTION_COMPLETE;
    }

    if( l->count + r->count >= s_op->u.getvalue.current_query->count )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                     "[GETVALUE]: getvalue_set_operation: the left operand "
                     "allows %u matches, the right operand allows %u matches "
                     "but the parent only allows %u matches. We don't handle "
                     "that. Try again, increasing the parent's count.",
                     l->count, r->count, s_op->u.getvalue.current_query->count);
        js_p->error_code = PVFS_EINVAL;
        s_op->u.getvalue.current_query->count = 0;
        s_op->u.getvalue.current_query->token = PVFS_ITERATE_START;
        return SM_ACTION_COMPLETE;
    }

    if( PVFS_KEYVAL_QUERY_UNMASK_QUERY(s_op->u.getvalue.current_query->oper) ==
        PVFS_KEYVAL_QUERY_OR )
    {
        for(i=0; i < l->count; i++ )
        {
            s_op->u.getvalue.current_query->match[ match_index++ ] =
                l->match[i];
        }
        for(i=0; i < r->count; i++ )
        {
            for(j=0; j < match_index; j++ )
            {
                /* if copied item on left side, don't copy it here */
                if( r->match[i] == 
                    s_op->u.getvalue.current_query->match[match_index] )
                {
                    break;
                }
            }
    
            /* if iterated through left side without duplicate, add it */
            if( j == match_index )
            {
                s_op->u.getvalue.current_query->match[ match_index++ ] =
                    r->match[i];
            }
        }
    }

    else if(PVFS_KEYVAL_QUERY_UNMASK_QUERY(s_op->u.getvalue.current_query->oper)
        == PVFS_KEYVAL_QUERY_AND )
    {
        for( i=0; i < l->count; i++ )
        {
            for( j=0; j < r->count; j++ )
            {
                if( l->match[i] == r->match[j] )
                {
                    s_op->u.getvalue.current_query->match[ match_index++ ] =
                        r->match[j];
                }

            }
        }
    }

    s_op->u.getvalue.current_query->count = match_index;
    /* make sure we set the token to 0 (not meaningful) */
    js_p->position = 0;
    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_set_operation: copied (%u) handles to "
                 "result, set token to %llu\n", 
                 s_op->u.getvalue.current_query->count,
                 llu(s_op->u.getvalue.current_query->token));
    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_set_operation: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * keyval call to handle query 
 */
static PINT_sm_action getvalue_read_value(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: enter\n");

    ret = job_trove_keyval_read_value_query(
        s_op->req->u.getvalue.fs_id,
        s_op->u.getvalue.current_query->token,
        s_op->u.getvalue.current_query->oper,
        &(s_op->key),
        &(s_op->val),
        s_op->u.getvalue.current_query->match,
        &(s_op->u.getvalue.current_query->count),
        0,
        NULL,
        smcb,
        0,
        js_p,
        &i,
        server_job_context, s_op->req->hints);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_read_value: exit\n");

    return ret;
}

/*
 * getvalue_assign_target
 * assign a single handle to s_op->targets so permissions can be checked 
 * iterates through the query_p structs for any handle matches
 */
static PINT_sm_action getvalue_assign_target(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    uint32_t qindex = 0, hindex = 0;
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_assign_target: enter\n");

    qindex = s_op->u.getvalue.query_index;
    hindex = s_op->u.getvalue.handle_index;

    while( qindex < s_op->resp.u.getvalue.query_count )
    {
        if( hindex >= s_op->resp.u.getvalue.query_p[qindex].count )
        {
            hindex = 0;
            qindex++;
        }
        else if( PVFS_KEYVAL_QUERY_UNMASK_QUERY(
            s_op->resp.u.getvalue.query_p[qindex].oper) ==
            PVFS_KEYVAL_QUERY_NOOP )
        {
            qindex++;
        }
        else
        {
            break;
        }
    }

    /* all done once we've gone through all query structs */
    if( qindex >= s_op->resp.u.getvalue.query_count )
    {
        s_op->u.getvalue.query_index = qindex;
        s_op->u.getvalue.handle_index = hindex;
        return SM_ACTION_COMPLETE;
    }

    s_op->target_handle = 
        s_op->resp.u.getvalue.query_p[qindex].match[hindex];
    s_op->target_fs_id = s_op->req->u.getvalue.fs_id;

    s_op->u.getvalue.query_index = qindex;
    s_op->u.getvalue.handle_index = ++hindex;
    js_p->error_code = TARGET_ASSIGNED;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_assign_target: exit\n");

    return SM_ACTION_COMPLETE;
}

/* 
 * getvalue_check_perm_resp()
 * look at error_code from permission check, set error_code appropriately
 */
static PINT_sm_action getvalue_check_perm_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_check_perm_resp: enter\n");

    if( js_p->error_code != 0 )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                     "[GETVALUE]: Failed permission check on %llu, error: %d\n",
                     llu(s_op->target_handle), js_p->error_code);
        js_p->error_code =  FAILED_PERMS; 
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_check_perm_resp: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * getvalue_remove_result
 * remove a record, for permission check failure, from the result set shifting
 * pointers and counters as needed
 */
static PINT_sm_action getvalue_remove_result(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0, q_index=0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_remove_result: enter\n"); 

    js_p->error_code = 0;
    q_index = s_op->u.getvalue.query_index;
    assert( s_op->resp.u.getvalue.query_p[q_index].count > 0 );

    /* handle index is at the next value (see assign_target) so beginning there
     * move stuff forward */
    for( i = s_op->u.getvalue.handle_index; 
         i < s_op->resp.u.getvalue.query_p[q_index].count;
         i++ )
    {
        s_op->resp.u.getvalue.query_p[q_index].match[i-1] =
            s_op->resp.u.getvalue.query_p[q_index].match[i];
    }

    /* decrement count of handles, assign new empty item 0  as handle*/
    i = s_op->resp.u.getvalue.query_p[q_index].count--;
    s_op->resp.u.getvalue.query_p[q_index].match[i] = 0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_remove_result: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * getvalue_setup_resp()
 * Set up the request to get path for the handle - allocate needed resources
 */
static PINT_sm_action getvalue_setup_get_paths(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret=0;
    uint32_t i = 0;
    PINT_sm_msgpair_state *msg_p = NULL;
    PVFS_credentials creds;
    PVFS_handle root_handle;

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    
    uint32_t path = PVFS_KEYVAL_QUERY_UNMASK_PATHS(
        s_op->resp.u.getvalue.query_p[0].oper);

    if( path == PVFS_KEYVAL_RESULT_NO_PATHS )
    {
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_setup_get_paths: enter\n");
    js_p->error_code = GET_PATHS;

    PINT_cached_config_get_root_handle(s_op->target_fs_id, &(root_handle));
    s_op->target_handle = root_handle;

    s_op->u.getvalue.unknown_count = s_op->resp.u.getvalue.query_p[0].count;
    if( s_op->u.getvalue.unknown_count == 0 ) /* no results */
    {
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    if((s_op->u.getvalue.unknown_dirent = calloc(s_op->u.getvalue.unknown_count,
        sizeof(PVFS_dirent))) == 0)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    
    if((s_op->u.getvalue.unknown_handle = calloc(s_op->u.getvalue.unknown_count,
        sizeof(PVFS_handle))) == 0)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocate dirent array for pathing based on total count of handle */
    if( (s_op->resp.u.getvalue.dirent_p = calloc(
        s_op->u.getvalue.unknown_count, sizeof(PVFS_dirent))) == 0 )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: malloc for "
                     "dirent failed for %u handles\n",
                      s_op->u.getvalue.unknown_count);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    for(i=0; i < s_op->u.getvalue.unknown_count; i++ )
    {
        s_op->u.getvalue.unknown_handle[i] =
            s_op->resp.u.getvalue.query_p[0].match[i];
        s_op->u.getvalue.unknown_dirent[i].handle =
            s_op->resp.u.getvalue.query_p[0].match[i];
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: getvalue_setup_get_paths: "
                 "allocating room for %u dirents\n", 
                 s_op->u.getvalue.unknown_count);

    /* prepare messages */
    PINT_msgpair_init(&s_op->msgarray_op);
    msg_p = &s_op->msgarray_op.msgpair;

    PINT_serv_init_msgarray_params(s_op, s_op->target_fs_id);
    PINT_util_gen_credentials(&creds);
    PINT_SERVREQ_GETPATH_FILL( msg_p->req,
                               creds,
                               s_op->target_fs_id,
                               s_op->target_handle,
                               0,
                               s_op->u.getvalue.unknown_count,
                               s_op->u.getvalue.unknown_dirent,
                               NULL);

    msg_p->fs_id = s_op->target_fs_id;
    msg_p->handle = root_handle;
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn = path_comp_fn;

    ret = PINT_cached_config_map_to_server( &msg_p->svr_addr, msg_p->handle,
                                             msg_p->fs_id );

    if( ret )
    {
        gossip_err("Failed to map meta server addresses\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    PINT_sm_push_frame(smcb, 0, &s_op->msgarray_op);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, 
                 "[GETVALUE]: getvalue_setup_get_paths: exit\n");
    return SM_ACTION_COMPLETE;
}


/* getvalue_cleanup()
 * free resources alloc'd by state machine
 */
static PINT_sm_action getvalue_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    uint32_t i=0;

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_cleanup: enter\n");

    assert( s_op->resp.u.getvalue.query_p);
    for( i = 0; i < s_op->resp.u.getvalue.query_count; i++ )
    {
        if( s_op->resp.u.getvalue.query_p[i].match )
            free(s_op->resp.u.getvalue.query_p[i].match);
    }
    free(s_op->resp.u.getvalue.query_p);

    if( s_op->resp.u.getvalue.dirent_p )
        free(s_op->resp.u.getvalue.dirent_p);

    if( s_op->u.getvalue.unknown_handle )
        free(s_op->u.getvalue.unknown_handle);
    if( s_op->u.getvalue.unknown_dirent )
        free(s_op->u.getvalue.unknown_dirent);
   
    free(s_op->key.buffer);
    free(s_op->val.buffer);

    gossip_debug(GOSSIP_GETVALUE_DEBUG,
                 "[GETVALUE]: getvalue_cleanup: exit\n");

    return(server_state_machine_complete(smcb));
}


/* path_comp_fn()
 *
 * msgpair completion function to handle processing batch create response i
 * from another server
 */
static int path_comp_fn(void *v_p,
                        struct PVFS_server_resp *resp_p,
                        int index)
{
    PINT_smcb *smcb = v_p;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int i;
                
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: enter\n");

    assert(resp_p->op == PVFS_SERV_GETPATH);

    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: GETPATH returned "
                     "error: %d\n", resp_p->status);
        return resp_p->status;
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: get_path "
                 " must return with the same number dirents as we queried: "
                 " unknown (%u), resp count (%u)\n",
                 s_op->u.getvalue.unknown_count, resp_p->u.getpath.count);
    assert( s_op->u.getvalue.unknown_count == resp_p->u.getpath.count);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: handling "
                 "%u entries, current entries: %u\n", resp_p->u.getpath.count,
                 s_op->resp.u.getvalue.dirent_count);
    for(i=0; i < resp_p->u.getpath.count; i++ )
    {
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: "
                     "path response: handle/path %d: (%llu):(%s)\n", i, 
                     llu(resp_p->u.getpath.dirent[i].handle),
                     resp_p->u.getpath.dirent[i].d_name); 
        memcpy(s_op->resp.u.getvalue.dirent_p [i].d_name,
               resp_p->u.getpath.dirent[i].d_name, PVFS_NAME_MAX + 1);
        s_op->resp.u.getvalue.dirent_p[i].handle = 
            s_op->u.getvalue.unknown_handle[i];
        s_op->resp.u.getvalue.dirent_count++;
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: "
                     "copied to s_op->resp.u.getvalue.dirent_p[%d]\n", 
                     s_op->resp.u.getvalue.dirent_count-1);
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETVALUE]: path_comp_fn: exit\n");
    return 0;
}

PINT_GET_OBJECT_REF_DEFINE(getvalue);

struct PINT_server_req_params pvfs2_get_value_params =
{
    .string_name = "getvalue",
    .perm = PINT_SERVER_CHECK_READ,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getvalue,
    .state_machine = &pvfs2_get_value_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

