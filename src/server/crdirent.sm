/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <ctype.h>
#include <string.h>
#include <assert.h>
#include <math.h>

#include "pvfs2-config.h"
#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-util.h"
#include "pvfs2-internal.h"
#include "pint-util.h"
#include "pint-security.h"
#include "dist-dir-utils.h"
#include "pint-cached-config.h"
#include "pvfs2-dist-basic.h"
#include "security-util.h"
#include "pint-uid-map.h"
#include "sid.h"

int split_comp_fn(void *v_p, struct PVFS_server_resp *resp_p, int i);

enum
{
    SPLIT_REQUIRED = 131,
    SPLIT_FATAL_ERROR,
    REMOTE_METAHANDLE,
    REMOVE_ENTRIES_REQUIRED
};

%%

machine pvfs2_crdirent_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => get_bitmap_and_dirdata_handles;
        default => final_response;
    }

    /* these are used to validate the new entry */
    state get_bitmap_and_dirdata_handles
    {
        run crdirent_get_bitmap_and_dirdata_handles;
        success => validate;
        default => final_response;
    }

    state validate
    {
        run crdirent_validate;
        success => write_directory_entry;
        default => final_response;
    }

    state write_directory_entry
    {
        run crdirent_write_directory_entry;
        success => check_for_split;
        default => final_response;
    }

    state check_for_split
    {
        run crdirent_check_for_split;
        SPLIT_REQUIRED => do_split;
        default => update_dirdata_attr;
    }

    state do_split
    {
        /* state machine in dirent-split.sm */
        jump pvfs2_dirdata_split_sm;
        default => update_dirdata_attr;
    }

    state update_dirdata_attr
    {
        run crdirent_update_dirdata_attr;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run crdirent_cleanup;
        default => terminate;
    }
}

%%

#if 0
/* crdirent_setup_op()
 * 
 * prepare some state machine fields for later processing; mainly just
 * storing request structure fields in state machine so that nested
 * machines are not dependent on request type
 */
/* ECQ: Not sure why it is necessary to copy fields from the request structure.
 * This state machine is not itself nested and the only nested state machines
 * it calls are prelude_sm, pvfs2_msgpairarray_sm, and pvfs2_final_response_sm.
*/
static PINT_sm_action crdirent_setup_op(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t tmp_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_SERVER_DEBUG,
                      "crdirent entry: %s points to %s\n", 
                      s_op->req->u.crdirent.name,
                      PVFS_OID_str(&s_op->req->u.crdirent.new_handle));
    
    js_p->error_code = 0;
#if 0
    s_op->req->u.crdirent.credential = s_op->req->u.crdirent.credential;
    s_op->req->u.crdirent.name = s_op->req->u.crdirent.name;
    s_op->req->u.crdirent.new_handle = s_op->req->u.crdirent.new_handle;
    s_op->req->u.crdirent.parent_handle = s_op->req->u.crdirent.parent_handle;
    s_op->req->u.crdirent.dirdata_handle = s_op->req->u.crdirent.dirdata_handle;
    s_op->req->u.crdirent.fs_id = s_op->req->u.crdirent.fs_id;
#endif

    memset(&(s_op->u.crdirent.dirdata_ds_attr), 0, sizeof(PVFS_ds_attributes));
    memset(&s_op->u.crdirent.capability, 0, sizeof(PVFS_capability));

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "About to retrieve attributes for dirdata handle %s\n",
                 PVFS_OID_str(&s_op->req->u.crdirent.dirdata_handle));

    ret = job_trove_dspace_getattr(s_op->target_fs_id,
                                   s_op->req->u.crdirent.dirdata_handle,
                                   smcb,
                                   &(s_op->u.crdirent.dirdata_ds_attr),
                                   0,
                                   js_p,
                                   &tmp_id,
                                   server_job_context,
                                   s_op->req->hints);
    
    return ret;
}

/* crdirent_get_dist_dir_attr()
 * 
 * Retrieve basic distributed directory attributes for this dirent handle
 */
/* V3 distributed dir attributes are now part of the ds_attr struct and
 * are read during prelude so this lookup is obsolete
 */
static PINT_sm_action crdirent_get_dist_dir_attr(struct PINT_smcb *smcb,
                                                 job_status_s *js_p)
{   
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t j_id;
    
    /*
      first we translate the dirdata dspace attributes into a more convenient
      server use-able format.  i.e. a PVFS_object_attr
    */
    PVFS_objecct_attr_from_ds_attr(&s_op->u.crdirent.dirdata_attr,
                                   &s_op->u.crdirent.dirdata_ds_attr);
    s_op->u.crdirent.dirdata_attr.mask = PVFS_ATTR_COMMON_ALL;

    /* set up key and value structures for reading the dist_dir_attr */
    s_op->key.buffer = Trove_Common_Keys[DIST_DIR_ATTR_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[DIST_DIR_ATTR_KEY].size;
    if(s_op->free_val)
    {   
        free(s_op->val.buffer);
    }
    
    s_op->val.buffer = &s_op->attr.u.dirdata.dist_dir_attr;
    s_op->val.buffer_sz = sizeof(PVFS_dist_dir_attr);
    s_op->free_val = 0;
    
    js_p->error_code = 0;
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "  trying to read dist_dir_attr (coll_id = %d, "
                 "handle = %s, key = %s (%d), val_buf = %p (%d))\n",
                 s_op->req->u.crdirent.fs_id,
                 PVFS_OID_str(&s_op->u.crdirent.dirent_handle),
                 (char *)s_op->key.buffer, s_op->key.buffer_sz,
                 s_op->val.buffer, s_op->val.buffer_sz);
    
    ret = job_trove_keyval_read(s_op->req->u.crdirent.fs_id,
                                s_op->u.crdirent.dirent_handle,
                                &s_op->key,
                                &s_op->val,
                                0,
                                NULL,
                                smcb,
                                0,
                                js_p,
                                &j_id,
                                server_job_context,
                                s_op->req->hints);
    
    return ret;
}
#endif

/* crdirent_get_bitmap_and_dirdata_handles()
 * Retrieve the rest of the distributed directory attributes for this
 * dirent handle.
 * The size of the bitmap and the handles array was not known until the basic
 * distributed directory attributes had been retrieved.
 * V3 - size is now read with ds_attr by prelude
 */
static PINT_sm_action crdirent_get_bitmap_and_dirdata_handles(
                                              struct PINT_smcb *smcb,
                                              job_status_s *js_p)
{   
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL, i = 0;
    PVFS_object_attr *attr_p = NULL;
    job_id_t j_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_SERVER_DEBUG,
                      "crdirent entry: %s points to %s\n", 
                      s_op->req->u.crdirent.name,
                      PVFS_OID_str(&s_op->req->u.crdirent.new_handle));
    
    js_p->error_code = 0;

    memset(&(s_op->u.crdirent.dirdata_ds_attr), 0, sizeof(PVFS_ds_attributes));
    memset(&s_op->u.crdirent.capability, 0, sizeof(PVFS_capability));

    attr_p = &s_op->attr;

    assert(attr_p->u.dirdata.dist_dir_attr.dirdata_count > 0 &&
           attr_p->u.dirdata.dist_dir_attr.bitmap_size > 0);

    gossip_debug(GOSSIP_SERVER_DEBUG,
            "crdirent: get dist-dir-attr for dirdata handle %s "
            "with tree_height=%d, dirdata_count=%d, bitmap_size=%d, "
            "split_size=%d, server_no=%d and branch_level=%d\n",
            PVFS_OID_str(&s_op->req->u.crdirent.dirdata_handle),
            attr_p->u.dirdata.dist_dir_attr.tree_height,
            attr_p->u.dirdata.dist_dir_attr.dirdata_count,
            attr_p->u.dirdata.dist_dir_attr.bitmap_size,
            attr_p->u.dirdata.dist_dir_attr.split_size,
            attr_p->u.dirdata.dist_dir_attr.server_no,
            attr_p->u.dirdata.dist_dir_attr.branch_level);

    /* allocate space for bitmap and dirdata handles */
    attr_p->u.dirdata.dist_dir_bitmap =
                malloc(attr_p->u.dirdata.dist_dir_attr.bitmap_size *
                       sizeof(PVFS_dist_dir_bitmap_basetype));

    attr_p->u.dirdata.dirdata_handles = malloc(
                OSASZ(attr_p->u.dirdata.dist_dir_attr.dirdata_count, 
                      attr_p->u.dirdata.dist_dir_attr.sid_count));

    if(!attr_p->u.dirdata.dist_dir_bitmap || !attr_p->u.dirdata.dirdata_handles)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* set pointer for dirdata_sids */
    attr_p->u.dirdata.dirdata_sids =
               (PVFS_SID *)(attr_p->u.dirdata.dirdata_handles +
                            attr_p->u.dirdata.dist_dir_attr.dirdata_count);

    /* set up attr->mask */
    attr_p->mask |= PVFS_ATTR_DISTDIR_ATTR;

    /* total 2 keyvals, DIST_DIRDATA_BITMAP, DIST_DIRDATA_HANDLES */

    if (s_op->free_val)
    {
       free(s_op->val.buffer);
    }
    memset(&(s_op->key), 0, sizeof(s_op->key));
    memset(&(s_op->val), 0, sizeof(s_op->val));

    /* free up any leftover structures */
    for (i = 0; i < s_op->keyval_count; i++)
    {
        if (s_op->val_a && s_op->val_a[i].buffer && s_op->free_val)
        {
            free(s_op->val_a[i].buffer);
        }
    }
    if (s_op->val_a)
    {
        free(s_op->val_a);
        s_op->val_a = NULL;
    }
    if (s_op->key_a)
    {
        free(s_op->key_a);
        s_op->key_a = NULL;
    }
    if (s_op->error_a)
    {
       free(s_op->error_a);
       s_op->error_a = NULL;
    }
    s_op->free_val = 0;

   /* allocate space for keys and values */
   s_op->keyval_count = 2;
   s_op->key_a = s_op->val_a = NULL;
   s_op->error_a = NULL;

    s_op->key_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->val_a = calloc(s_op->keyval_count, sizeof(PVFS_ds_keyval));
    s_op->error_a = calloc(s_op->keyval_count, sizeof(PVFS_error));
    if(! s_op->key_a || ! s_op->val_a || ! s_op->error_a)
    {
        gossip_lerr("Cannot allocate memory for key/val/error.\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].size;
    s_op->key_a[0].buffer = Trove_Common_Keys[DIST_DIRDATA_BITMAP_KEY].key;

    s_op->val_a[0].buffer_sz = attr_p->u.dirdata.dist_dir_attr.bitmap_size *
                               sizeof(PVFS_dist_dir_bitmap_basetype);
    s_op->val_a[0].buffer = attr_p->u.dirdata.dist_dir_bitmap;

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].size;
    s_op->key_a[1].buffer = Trove_Common_Keys[DIST_DIRDATA_HANDLES_KEY].key;

    s_op->val_a[1].buffer_sz =
                   OSASZ(attr_p->u.dirdata.dist_dir_attr.dirdata_count, 
                         attr_p->u.dirdata.dist_dir_attr.sid_count);
    s_op->val_a[1].buffer = attr_p->u.dirdata.dirdata_handles;

    js_p->error_code = 0;
    ret = job_trove_keyval_read_list(s_op->req->u.crdirent.fs_id,
                                     s_op->req->u.crdirent.dirdata_handle,
                                     s_op->key_a,
                                     s_op->val_a,
                                     s_op->error_a,
                                     s_op->keyval_count,
                                     0,
                                     NULL,
                                     smcb,
                                     0,
                                     js_p,
                                     &j_id,
                                     server_job_context,
                                     s_op->req->hints);

    return ret;
}

/*
 * Function: crdirent_validate
 *
 * Synopsis: verifies that entry name and object type is valid,
 *           entry name belongs to the right dirdata object.
 */
static PINT_sm_action crdirent_validate(struct PINT_smcb *smcb,
                                        job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    char *ptr = NULL;
    int i = 0;
    unsigned char *c = NULL;
    PVFS_object_attr *attr_p = NULL;
    PVFS_dist_dir_hash_type dirdata_hash;
    int dirdata_server_index;
    
    attr_p = &s_op->attr;
    
    /* gossip bitmap, since jump from get_bitmap_and_dirdata_handles */
    gossip_debug(GOSSIP_SERVER_DEBUG, "crdirent: dist_dir_bitmap as:\n");

    for(i = attr_p->u.dirdata.dist_dir_attr.bitmap_size - 1; i >= 0 ; i--)
    {       
        c = (unsigned char *)(attr_p->u.dirdata.dist_dir_bitmap + i);
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     " i=%d : %02x %02x %02x %02x\n",
                     i, c[3], c[2], c[1], c[0]);
    }           
    gossip_debug(GOSSIP_SERVER_DEBUG, "\n");
    
    gossip_debug(GOSSIP_SERVER_DEBUG, "\t getattr: dirdata handles\n");
            
    for(i = 0; i < attr_p->u.dirdata.dist_dir_attr.dirdata_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "\t\tdirdata server %d: %s.\n",
                     i, PVFS_OID_str(&attr_p->u.dirdata.dirdata_handles[i]));
    }           
 
    /* verify name and handle are not NULL */
    if ((s_op->req->u.crdirent.name == NULL) ||
        (!PVFS_OID_cmp(&s_op->req->u.crdirent.parent_handle,
                       &PVFS_HANDLE_NULL)))
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "  got crdirent for %s (with handle %s) in %s\n",
                 s_op->req->u.crdirent.name,
                 PVFS_OID_str(&s_op->req->u.crdirent.new_handle),
                 PVFS_OID_str(&s_op->req->u.crdirent.parent_handle));

    /* check for invalid characters (ie "/") in name */
    ptr = s_op->req->u.crdirent.name;
    while (*ptr != '\0' && *ptr != '/' )
    {
        ptr++;
    }

    if (*ptr != '\0')
    {
        /* This assumes that some external code is responsible for
         * checking this name - either client-core or usrint or
         * something because we log a server error if this happens
         */
        /* found an invalid character -- report it and send error response */
        gossip_lerr("crdirent: error: invalid character (%s)"
                    "in name (%s); sending error response.\n",
                    ptr, s_op->req->u.crdirent.name);
        /* for parity with linux VFS, allow any character except / in 
         * filenames.   */
        
        js_p->error_code = -PVFS_EINVAL;

         /* Do not zero the scheduled_id, as this operation was
          * scheduled before we checked the filename */
        return SM_ACTION_COMPLETE;
    }

    /* make sure the entry belongs to this dirdata bucket */
    /* find the hash value and the dist dir bucket */
    dirdata_hash = PINT_encrypt_dirdata(s_op->req->u.crdirent.name);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "crdirent: encrypt dirent %s into hash value %llu.\n",
                 s_op->req->u.crdirent.name, llu(dirdata_hash));

    dirdata_server_index = PINT_find_dist_dir_bucket(
                                           dirdata_hash,
                                           &attr_p->u.dirdata.dist_dir_attr,
                                           attr_p->u.dirdata.dist_dir_bitmap);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "crdirent: selecting bucket No.%d from dist_dir_bitmap.\n",
                 dirdata_server_index);

    if(dirdata_server_index != attr_p->u.dirdata.dist_dir_attr.server_no)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "crdirent: error: "
                     "WRONG dirdata object for the dirent! Returning error.\n");

        js_p->error_code = -PVFS_EAGAIN;
        return SM_ACTION_COMPLETE;
    }
    else
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "crdirent: Correct dirdata object!\n");
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/*
 * Function: crdirent_write_directory_entry
 *
 * Params:   server_op *s_op, 
 *           job_status_s *js_p
 *
 * Pre:      s_op->u.crdirent.dirent_handle is the directory entry k/v space
 *           s_op->req->u.crdirent.name != NULL
 *           s_op->req->u.crdirent.new_handle != NULL
 *
 * Post:     key/val pair stored
 *
 * Returns:  int
 *
 * Synopsis: We are now ready to store the name/handle pair in the k/v
 *           space for directory handles.
 */
/* V3: Need to write backpointer to bucket.
 * The handle is the key. Need to think about how to store related SIDs. */
static PINT_sm_action crdirent_write_directory_entry(struct PINT_smcb *smcb,
                                                     job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t j_id;
    TROVE_ds_flags keyval_flags;

    assert(PVFS_OID_cmp(&s_op->req->u.crdirent.dirdata_handle,
                        &PVFS_HANDLE_NULL));

    js_p->error_code = 0;

    /* Set up a temporary buffer to store the new handle and SIDs in db */
    /* Copy handle and SIDs in to the new buffer */
    s_op->u.crdirent.keyval_temp_store =
                  (PVFS_ID *)malloc(OSASZ(1, s_op->req->u.crdirent.sid_count));

    s_op->u.crdirent.keyval_temp_store[0].oid =
                            s_op->req->u.crdirent.new_handle;

    memcpy(&(s_op->u.crdirent.keyval_temp_store[1]),
           s_op->req->u.crdirent.new_sid_array,
           SASZ(s_op->req->u.crdirent.sid_count));

    /* This buffer came from one of two places, either phase two of
     * creating the directory space when we wrote the value back to
     * trove, or from the initial read from trove.
     */

    /* this is the name for the parent entry */
    s_op->key.buffer_sz = strlen(s_op->req->u.crdirent.name) + 1;
    s_op->key.buffer = s_op->req->u.crdirent.name;

    s_op->val.buffer_sz = OSASZ(1, s_op->req->u.crdirent.sid_count);
    s_op->val.buffer = s_op->u.crdirent.keyval_temp_store;

    gossip_debug(GOSSIP_SERVER_DEBUG, "  writing new directory entry "
                 "for %s (handle = %s) to dirdata dspace %s\n",
                 s_op->req->u.crdirent.name,
                 PVFS_OID_str(&s_op->req->u.crdirent.new_handle),
                 PVFS_OID_str(&s_op->req->u.crdirent.dirdata_handle));

    keyval_flags = TROVE_SYNC;
        
    /* Specify that we want an error returned if the entry already exists.
     * This allows us to return an EEXIST error back to the client
     */
    keyval_flags |= TROVE_NOOVERWRITE;

    /* We also want to keep track of the keyval entries added on this
     * handle, which allows us to get the size of the directory later
     */
    keyval_flags |= TROVE_KEYVAL_HANDLE_COUNT | TROVE_KEYVAL_DIRECTORY_ENTRY;

    ret = job_trove_keyval_write(s_op->req->u.crdirent.fs_id,
                                 s_op->req->u.crdirent.dirdata_handle,
                                 &s_op->key,
                                 &s_op->val,
                                 keyval_flags,
                                 NULL,
                                 smcb,
                                 0,
                                 js_p,
                                 &j_id,
                                 server_job_context,
                                 s_op->req->hints);

    return ret;
}

#if 0
/*
 * Function: crdirent_get_dirent_count
 */
static PINT_sm_action crdirent_get_dirent_count(struct PINT_smcb *smcb,
                                                job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t tmp_id;

    ret = job_trove_keyval_get_handle_info(s_op->req->u.crdirent.fs_id,
                                           s_op->req->u.crdirent.dirdata_handle,
                                           TROVE_KEYVAL_HANDLE_COUNT,
                                           &s_op->u.crdirent.keyval_handle_info,
                                           smcb,
                                           0,
                                           js_p,
                                           &tmp_id,
                                           server_job_context,
                                           s_op->req->hints);

    return ret;
}
#endif

/*
 * Function: crdirent_check_for_split
 */
static PINT_sm_action crdirent_check_for_split(struct PINT_smcb *smcb,
                                               job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;
    PVFS_object_attr *attr_p = NULL;
    unsigned char *c = NULL;

    PINT_ACCESS_DEBUG(s_op,
                      GOSSIP_ACCESS_DEBUG,
                      "crdirent entry: %s points to %s\n",
                      s_op->req->u.crdirent.name,
                      PVFS_OID_str(&s_op->req->u.crdirent.new_handle));

    /* dirent count is in attrs */
    if (js_p->error_code != 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "write of new dirent failed.\n");
        PVFS_perror_gossip("retrieval of dirent count failed",
                           js_p->error_code);
        return SM_ACTION_COMPLETE;
    }

    /* write of dirent succeeded, so increment dirent_count */
    s_op->attr.u.dirdata.dirent_count++;

    gossip_debug(GOSSIP_SERVER_DEBUG, " dirent count = %d "
                 "split_size =%d, branch_level = %d\n",
                 /* s_op->u.crdirent.keyval_handle_info.count, */
                 s_op->attr.u.dirdata.dirent_count,
                 s_op->attr.u.dirdata.dist_dir_attr.split_size,
                 s_op->attr.u.dirdata.dist_dir_attr.branch_level);

    /* if (s_op->u.crdirent.keyval_handle_info.count >= */
    if (s_op->attr.u.dirdata.dirent_count >=
        s_op->attr.u.dirdata.dist_dir_attr.split_size)
    {
        /* Determine which node will get split entries. */
        s_op->u.crdirent.split_node = PINT_find_dist_dir_split_node(
                                          &s_op->attr.u.dirdata.dist_dir_attr,
                                          s_op->attr.u.dirdata.dist_dir_bitmap);

        if (s_op->u.crdirent.split_node < 0)
        {
            /* No new node can be found. No need to split. */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         " No new node found for split.\n");
            return SM_ACTION_COMPLETE;
        }

        js_p->error_code = SPLIT_REQUIRED;

        /* Save the current attrs in case we have 
         * to back out due to an error.
         */
        PINT_copy_object_attr(&s_op->u.crdirent.saved_attr, &s_op->attr);

        gossip_debug(GOSSIP_SERVER_DEBUG,
                     " split to node %d, new branch_level = %d\n",
                     s_op->u.crdirent.split_node,
                     s_op->attr.u.dirdata.dist_dir_attr.branch_level);
                     gossip_debug(GOSSIP_SERVER_DEBUG,
                     "crdirent: new dist_dir_bitmap as:\n");

        attr_p = &s_op->attr;
        for(i = attr_p->u.dirdata.dist_dir_attr.bitmap_size - 1; i >= 0 ; i--)
        {
            c = (unsigned char *)(attr_p->u.dirdata.dist_dir_bitmap + i);
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         " i=%d : %02x %02x %02x %02x\n",
                         i, c[3], c[2], c[1], c[0]);
        }
        gossip_debug(GOSSIP_SERVER_DEBUG, "\n");
    }
    return SM_ACTION_COMPLETE;
}

/*
 * Function: crdirent_update_dirdata_attr
 *
 * Write dirdata metadata to dspace, with updated time stamps and dirent
 * count and anything else modified after the crdirent and split if
 * there is one
 */
static PINT_sm_action crdirent_update_dirdata_attr(struct PINT_smcb *smcb,
                                                   job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;
    PVFS_object_attr *dspace_attr = NULL;
    PVFS_ds_attributes *ds_attr = NULL;

    /* dirdata attributes are in s_op->attr
     * Set Ctime and Mtime
     * If we had a split assume tree_height was updated
     * If we had a split then in the next state write back the bitmap
     */

    /* This contains the attrs read from the dirdata object */
    /* dspace_attr = &s_op->u.crdirent.dirdata_attr; */
    dspace_attr = &s_op->attr;

    /* This is a buffer for the ds_attrs */
    ds_attr = &(s_op->u.crdirent.dirdata_ds_attr);
    memset(ds_attr, 0, sizeof(PVFS_ds_attributes));

    dspace_attr->mtime = dspace_attr->ctime = time(NULL);

    /* copy and convert format */
    PVFS_ds_attr_from_object_attr(ds_attr, dspace_attr);

    /* dspace setattr simply writes all attr in ds_attr so any
     * mask effects must be handled before we write
     */
    /* update timestamps for the dirdata handle. */
    ret = job_trove_dspace_setattr(s_op->req->u.crdirent.fs_id,
                                   s_op->req->u.crdirent.dirdata_handle,
                                   ds_attr,
                                   TROVE_SYNC,
                                   smcb,
                                   0,
                                   js_p,
                                   &j_id,
                                   server_job_context,
                                   s_op->req->hints);

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 " crdirent: update timestamp, type is %d\n ",
                 ds_attr->type);
    return ret;
}

/*
 * Function: crdirent_cleanup
 */
static PINT_sm_action crdirent_cleanup(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;

    if (s_op->u.crdirent.read_all_directory_entries)
    {
        if (s_op->u.crdirent.entries_key_a)
        {
            free(s_op->u.crdirent.entries_key_a);
            s_op->u.crdirent.entries_key_a = NULL;
            s_op->u.crdirent.entries_val_a = NULL;
            s_op->u.crdirent.read_all_directory_entries = 0;
        }
    }
    if (s_op->free_val)
    {
       free(s_op->val.buffer);
    }
    if (s_op->u.crdirent.keyval_temp_store)
    {
        free(s_op->u.crdirent.keyval_temp_store);
    }

    memset(&(s_op->key),0,sizeof(s_op->key));
    memset(&(s_op->val),0,sizeof(s_op->val));

    for (i = 0; i < s_op->keyval_count; i++)
    {
        if (s_op->val_a && s_op->val_a[i].buffer && s_op->free_val)
        {
            free(s_op->val_a[i].buffer);
        }
    }
    if (s_op->val_a)
    {
        free(s_op->val_a);
        s_op->val_a = NULL;
    }
    if (s_op->key_a)
    {
        free(s_op->key_a);
        s_op->key_a = NULL;
    }
    if (s_op->error_a)
    {
       free(s_op->error_a);
       s_op->error_a = NULL;
    }
    s_op->free_val = 0;

    PINT_free_object_attr(&s_op->attr);
    PINT_free_object_attr(&s_op->u.crdirent.saved_attr);

    if (s_op->u.crdirent.entry_handles)
    {
        free(s_op->u.crdirent.entry_handles);
    }
    if (s_op->u.crdirent.entry_names)
    {
        free(s_op->u.crdirent.entry_names);
    }
    if (s_op->u.crdirent.msg_boundaries)
    {
        free(s_op->u.crdirent.msg_boundaries);
    }
    if (s_op->u.crdirent.split_status)
    {
        free(s_op->u.crdirent.split_status);
    }
    if (s_op->u.crdirent.dist)
    {
        PINT_dist_free(s_op->u.crdirent.dist);
    }

    PINT_cleanup_capability(&s_op->u.crdirent.capability);

    return(server_state_machine_complete(smcb));
}

/*
 * Function: perm_crdirent
 */
static int perm_crdirent(PINT_server_op *s_op)
{
    int ret;

    if (s_op->req->capability.op_mask & PINT_CAP_WRITE && 
        s_op->req->capability.op_mask & PINT_CAP_EXEC)
    {
        ret = 0;
    }
    else
    {
        ret = -PVFS_EACCES;
    }

    return ret;
}

static int PINT_get_object_ref_crdirent(struct PVFS_server_req *req,
                                        PVFS_fs_id *fs_id,
                                        PVFS_handle *handle) 
{                                    
    *fs_id = req->u.crdirent.fs_id; 
    *handle = req->u.crdirent.dirdata_handle;
    return 0;                       
}

struct PINT_server_req_params pvfs2_crdirent_params =
{
    .string_name = "crdirent",
    .perm = perm_crdirent,
    .access_type = PINT_server_req_modify,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_crdirent,
    .state_machine = &pvfs2_crdirent_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
