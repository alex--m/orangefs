/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pint-event.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"

static int check_fs_id(PVFS_fs_id fs_id);

%%

machine pvfs2_setparam_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => work;
        default => final_response;
    }

    state work
    {
        run setparam_work;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run setparam_cleanup;
        default => terminate;
    }
}

%%

/* temporary */
static PVFS_handle* test_handle_array = NULL;
static const char** test_server_array;

/* setparam_work()
 *
 * actually does the "work" involved in setting a runtime server parameter
 */
static PINT_sm_action setparam_work(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1, tmp_on = 0, old_event_on = 0;
    job_id_t tmp_id;
    uint64_t tmp_mask = 0;
    int32_t old_api_mask = 0, old_op_mask = 0;
    PVFS_handle tmp_handle = PVFS_HANDLE_NULL;
    struct server_configuration_s *user_opts;
    struct filesystem_configuration_s *fs_conf;
    char buf[16] = {0};
    int i;

    /* these are temporary */
    int test_precreate_count = 0;
 
    switch(s_op->req->u.mgmt_setparam.param)
    {
        case PVFS_SERV_PARAM_GOSSIP_MASK:
            gossip_get_debug_mask(&tmp_on, &tmp_mask);
            s_op->resp.u.mgmt_setparam.old_value = tmp_mask;
            gossip_set_debug_mask(
                1, s_op->req->u.mgmt_setparam.value);
            js_p->error_code = 0;
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_INVALID:
            gossip_lerr("Error: mgmt_setparam for unknown parameter %d.\n",
                (int)s_op->req->u.mgmt_setparam.param);
            js_p->error_code = -PVFS_ENOSYS;
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_FSID_CHECK:
            s_op->resp.u.mgmt_setparam.old_value = 0;
            js_p->error_code = check_fs_id(
                (PVFS_fs_id)s_op->req->u.mgmt_setparam.value);
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_ROOT_CHECK:
            tmp_handle = (PVFS_handle)s_op->req->u.mgmt_setparam.value;
            s_op->resp.u.mgmt_setparam.old_value = 0;
            gossip_debug(GOSSIP_SERVER_DEBUG, " - ROOT_CHECK looking for"
                         " handle %llu, on fs_id %d\n", llu(tmp_handle),
                         s_op->req->u.mgmt_setparam.fs_id);
            ret = job_trove_dspace_verify(
                s_op->req->u.mgmt_setparam.fs_id, tmp_handle,
                0, 
                smcb, 0, js_p, &tmp_id, server_job_context);
            return(ret);
        case PVFS_SERV_PARAM_EVENT_ON:
            ret = 0;
            PINT_event_get_masks(
                &old_event_on, &old_api_mask, &old_op_mask);
            PINT_event_set_masks(
                (int)s_op->req->u.mgmt_setparam.value,
                old_api_mask, old_op_mask);
            s_op->resp.u.mgmt_setparam.old_value = old_event_on;
            js_p->error_code = ret;
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_EVENT_MASKS:
            PINT_event_get_masks(
                &old_event_on, &old_api_mask, &old_op_mask);
            PINT_event_set_masks(old_event_on,
                (int32_t)(s_op->req->u.mgmt_setparam.value & 0x0FFFFFFFF),
                (int32_t)(s_op->req->u.mgmt_setparam.value >> 32));
            s_op->resp.u.mgmt_setparam.old_value = old_api_mask +
                ((int64_t)old_op_mask << 32);
            js_p->error_code = 0;
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_SYNC_META:
            user_opts = get_server_config_struct();
            fs_conf = PINT_config_find_fs_id(user_opts, 
                s_op->req->u.mgmt_setparam.fs_id);
            if(fs_conf)
            {
                if(s_op->req->u.mgmt_setparam.value)
                    fs_conf->trove_sync_meta = TROVE_SYNC;
                else
                    fs_conf->trove_sync_meta = 0;
            }
            js_p->error_code = 0;
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_SYNC_DATA:
            user_opts = get_server_config_struct();
            fs_conf = PINT_config_find_fs_id(user_opts, 
                s_op->req->u.mgmt_setparam.fs_id);
            if(fs_conf)
            {
                if(s_op->req->u.mgmt_setparam.value)
                {
                    snprintf(buf, 16, "%d,%d", s_op->req->u.mgmt_setparam.fs_id,
                             TROVE_SYNC);
                    PINT_flow_setinfo(NULL, FLOWPROTO_DATA_SYNC_MODE, buf);
                    fs_conf->trove_sync_data = TROVE_SYNC;
                }
                else
                {
                    snprintf(buf, 16, "%d,%d", s_op->req->u.mgmt_setparam.fs_id,
                             0);
                    PINT_flow_setinfo(NULL, FLOWPROTO_DATA_SYNC_MODE, buf);
                    fs_conf->trove_sync_data = 0;
                }
            }
            js_p->error_code = 0;
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_MODE:
            /* no work to do here; request scheduler has already handled */
            js_p->error_code = 0;
            return SM_ACTION_COMPLETE;
        case PVFS_SERV_PARAM_TEST_PRECREATE:
            user_opts = get_server_config_struct();
            s_op->resp.u.mgmt_setparam.old_value = 0;
            gossip_debug(GOSSIP_SERVER_DEBUG, " - TEST_PRECREATE "
                         "on fs_id %d\n", 
                         s_op->req->u.mgmt_setparam.fs_id);

            /* count how many I/O servers are in the file system */
            ret = PINT_cached_config_count_servers(
                user_opts,
                s_op->req->u.mgmt_setparam.fs_id,
                PINT_SERVER_TYPE_IO,
                &test_precreate_count);
            if(ret < 0)
            {
                js_p->error_code = ret;
                return(SM_ACTION_COMPLETE);
            }

            /* decrement by one (exclude this local server) */
            test_precreate_count--;

            /* allocate some storage for handles */
            if(test_handle_array)
            {
                free(test_handle_array);
            }
            test_handle_array = malloc(test_precreate_count*sizeof(PVFS_handle));
            if(!test_handle_array)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return(SM_ACTION_COMPLETE);
            }

            /* uncomment the block below to test specifying server layout */
#if 0
            if(test_server_array)
            {
                free(test_server_array);
            }
            test_server_array = malloc(test_precreate_count*sizeof(char*));
            if(!test_server_array)
            {
                js_p->error_code = -PVFS_ENOMEM;
                return(SM_ACTION_COMPLETE);
            }
            for(i=0; i<test_precreate_count; i++)
            {
                /* note; servers can't get handles for themselves, to this
                 * example will fail on the actual localhost:3335 machine
                 */
                test_server_array[i] = "tcp://localhost:3335";
            }
#endif

            /* try to get precreated handle */
            /* note that server strings can be set to NULL to just get
             * handles for default servers 
             */
            ret = job_precreate_pool_get_handles(
                s_op->req->u.mgmt_setparam.fs_id, 
                test_precreate_count,
                test_server_array,
                test_handle_array,
                smcb, 0, js_p, &tmp_id, server_job_context);
            return(ret);
    }

    gossip_lerr("Error: mgmt_setparam for unknown parameter %d.\n",
                (int)s_op->req->u.mgmt_setparam.param);

    js_p->error_code = -PVFS_ENOSYS;
    return SM_ACTION_COMPLETE;
}

/* setparam_cleanup()
 *
 * cleans up any resources consumed by this state machine and ends
 * execution of the machine
 */
static PINT_sm_action setparam_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    gossip_debug(GOSSIP_SERVER_DEBUG, " - setparam returning %d\n",
                 js_p->error_code);
    return(server_state_machine_complete(smcb));
}

/* check_fs_id()
 *
 * checks to see if a given fs id is valid
 *
 * returns 0 on success, -PVFS_error on failure
 */
static int check_fs_id(PVFS_fs_id fs_id)
{
    int ret = -PVFS_ENOENT, count = 1;
    TROVE_ds_position pos = TROVE_ITERATE_START;
    TROVE_keyval_s name;
    TROVE_coll_id tmp_coll;
    TROVE_op_id tmp_id;
    struct server_configuration_s * server_config;

    name.buffer = malloc(PVFS_NAME_MAX);
    if (!name.buffer)
    {
        ret = -PVFS_ENOMEM;
        goto check_failed;
    }
    name.buffer_sz = PVFS_NAME_MAX;

    server_config = get_server_config_struct();

    while(count == 1)
    {
        ret = trove_collection_iterate(
            server_config->trove_method,
            &pos, &name, &tmp_coll, &count, 0, 0, NULL, &tmp_id);

        if (ret == 0)
        {
            gossip_lerr("Error: unexpected trove behavior.\n");
            ret = -PVFS_EINVAL;
            goto free_name_buffer;
        }
        
        if (ret < 0)
        {
            goto free_name_buffer;
        }

        gossip_debug(GOSSIP_SERVER_DEBUG, "looking for fs_id: %d, "
                     "found %d.\n", (int)fs_id, (int)tmp_coll);

        if ((count > 0) && (tmp_coll == fs_id))
        {
            /* we found a matching collection */
            ret = 0;
            break;
        }
    }

free_name_buffer:
    free(name.buffer);
check_failed:

    return ret;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
