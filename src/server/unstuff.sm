/* 
 * (C) 2009 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-types-debug.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"
#include "pint-security.h"
#include "security-util.h"
#include "check.h"

enum {
    STATE_UNSTUFF = 33,
    STATE_CAPABILITY
};

%%

machine pvfs2_unstuff_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => getattr_setup;
        default => final_response;
    }

    state getattr_setup
    {
        run getattr_setup;
        success => getattr_do_work;
        default => final_response;
    }

    state getattr_do_work
    {
        jump pvfs2_get_attr_work_sm;
        default => getattr_interpret;
    }

    state getattr_interpret
    {
        run getattr_interpret;
        STATE_UNSTUFF => get_keyvals;
        default => final_response;
    }

    state get_keyvals
    {
        run get_keyvals;
        success => inspect_keyvals;
        default => final_response;
    }

    state inspect_keyvals
    {
        run inspect_keyvals;
        success => get_handles;
        default => final_response;
    }

    state get_handles
    {
        run get_handles;
        default => set_handles_on_object;
    }

    state set_handles_on_object
    {
        run set_handles_on_object;
        success => update_dfile_count;
        default => final_response;
    }

    state update_dfile_count
    {
        run update_dfile_count;
        success => remove_layout;
        default => final_response;
    }

    state remove_layout
    {
        run remove_layout;
        default => check_if_capability_required;
    }

    state check_if_capability_required
    {
        run check_if_capability_required;
        STATE_CAPABILITY => read_acl;
        default => final_response;
    }

    state read_acl
    {
        run read_acl;
        default => create_capability;
    }

    state create_capability
    {
        run create_capability;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run cleanup;
        default => terminate;
    }
}

%%

static PINT_sm_action get_keyvals(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int kind = 0;
    int ret;
    job_id_t job_id;

    s_op->keyval_count = 2;
    s_op->key_a = malloc(sizeof(*s_op->key_a) * s_op->keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        goto error_exit;
    }

    s_op->val_a = malloc(sizeof(*s_op->val_a) * s_op->keyval_count);
    if(!s_op->val_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        goto free_key_array;
    }

    s_op->error_a = malloc(sizeof(*s_op->error_a) * s_op->keyval_count);
    if(!s_op->error_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        goto free_val_array;
    }
    memset(s_op->error_a, 0, sizeof(*s_op->error_a) * s_op->keyval_count);

    s_op->u.unstuff.encoded_layout = malloc(PVFS_REQ_LIMIT_LAYOUT);
    if(!s_op->u.unstuff.encoded_layout)
    {
        js_p->error_code = -PVFS_ENOMEM;
        goto free_encoded_layout;
    }
    memset(s_op->u.unstuff.encoded_layout, 0, PVFS_REQ_LIMIT_LAYOUT);

    /* kind = 0 */
    s_op->key_a[kind].buffer = Trove_Common_Keys[METAFILE_LAYOUT_KEY].key;
    s_op->key_a[kind].buffer_sz = Trove_Common_Keys[METAFILE_LAYOUT_KEY].size;

    s_op->val_a[kind].buffer = s_op->u.unstuff.encoded_layout;
    s_op->val_a[kind].buffer_sz = PVFS_REQ_LIMIT_LAYOUT;

    ++kind;
    /* kind = 1 */
    s_op->key_a[kind].buffer = Trove_Common_Keys[NUM_DFILES_REQ_KEY].key;
    s_op->key_a[kind].buffer_sz = Trove_Common_Keys[NUM_DFILES_REQ_KEY].size;

    s_op->val_a[kind].buffer = &s_op->u.unstuff.num_dfiles_req;
    s_op->val_a[kind].buffer_sz = sizeof(s_op->u.unstuff.num_dfiles_req);

    ret = job_trove_keyval_read_list(
        s_op->req->u.unstuff.fs_id,
        s_op->req->u.unstuff.handle,
        s_op->key_a, s_op->val_a, s_op->error_a, s_op->keyval_count,
        0, NULL, smcb, 0, js_p, &job_id, server_job_context,
        s_op->req->hints);
    return ret;

free_encoded_layout:
    free(s_op->u.unstuff.encoded_layout);
    s_op->u.unstuff.encoded_layout = NULL;
free_val_array:
    free(s_op->val_a);
    s_op->val_a = NULL;
free_key_array:
    free(s_op->key_a);
    s_op->key_a = NULL;
error_exit:
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action inspect_keyvals(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    char* tmpbuf;

    if(js_p->error_code == 0)
    {
        /* check keys; we have a big problem if one of them is missing */
        if(s_op->error_a[0])
        {
            js_p->error_code = s_op->error_a[0];
        }
        else if(s_op->error_a[1])
        {
            js_p->error_code = s_op->error_a[1];
        }

        if(js_p->error_code == 0)
        {
        
            /* sanity check num dfiles */
            if(s_op->u.unstuff.num_dfiles_req < 1)
            {
                js_p->error_code = -PVFS_EINVAL;
            }

            /* decode layout information */
            tmpbuf = s_op->u.unstuff.encoded_layout;
            decode_PVFS_sys_layout(&tmpbuf, &s_op->u.unstuff.layout);
        }
    }

    /* pass along error code for next state to handle */
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action get_handles(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret;
    job_id_t j_id;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    if(s_op->u.unstuff.layout.algorithm != PVFS_SYS_LAYOUT_ROUND_ROBIN)
    {
        /* see create.sm; for now the only layout that we use stuffing on is
         * ROUND_ROBIN.  The storage format supports other layouts if we
         * want to add support for others later
         */
        gossip_err("Error: unstuff doesn't support layout algorithm: %d\n", 
            s_op->u.unstuff.layout.algorithm);
        js_p->error_code = -PVFS_ENOSYS;
        return SM_ACTION_COMPLETE;
    }

    /* allocate room for final number of handles we want */
    s_op->u.unstuff.dfile_array = 
        malloc(s_op->u.unstuff.num_dfiles_req * sizeof(PVFS_handle));
    if(!s_op->u.unstuff.dfile_array)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* the very first handle should be our current stuffed handle */
    s_op->u.unstuff.dfile_array[0] 
        = s_op->resp.u.unstuff.attr.u.meta.dfile_array[0];

    if(s_op->u.unstuff.num_dfiles_req == 1)
    {
        /* special case; we are unstuffing to 1 datafile.  There is no need
         * to retrieve any additional handles
         */
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    /* NOTE: we are leaving the existing resp attr structure alone until we
     * get a successful answer from get_handles() and commit to disk
     */
    ret = job_precreate_pool_get_handles(
        s_op->req->u.unstuff.fs_id,
        (s_op->u.unstuff.num_dfiles_req-1),
        NULL,
        &s_op->u.unstuff.dfile_array[1],
        0,
        smcb,
        0,
        js_p,
        &j_id,
        server_job_context,
        s_op->req->hints);
    return ret;
}

static PINT_sm_action set_handles_on_object(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t j_id;

    gossip_debug(GOSSIP_SERVER_DEBUG, "job_precreate_pool_get_handles() returned %d\n", js_p->error_code);

    if(js_p->error_code < 0)
    {
        /* we failed to retrieve any handles */
        if(s_op->u.unstuff.dfile_array)
        {
            free(s_op->u.unstuff.dfile_array);
            /* preserve error code */
            return SM_ACTION_COMPLETE;
        }
    }

    /* replace dfile information in attr structure */
    free(s_op->resp.u.unstuff.attr.u.meta.dfile_array);
    s_op->resp.u.unstuff.attr.u.meta.dfile_array 
        = s_op->u.unstuff.dfile_array;
    s_op->resp.u.unstuff.attr.u.meta.dfile_count 
        = s_op->u.unstuff.num_dfiles_req;

    /* write new datafile handles to disk */
    s_op->key.buffer = Trove_Common_Keys[METAFILE_HANDLES_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[METAFILE_HANDLES_KEY].size;

    s_op->val.buffer = 
        s_op->resp.u.unstuff.attr.u.meta.dfile_array; 
    s_op->val.buffer_sz =
        s_op->resp.u.unstuff.attr.u.meta.dfile_count * sizeof(PVFS_handle);

    return job_trove_keyval_write(
        s_op->req->u.unstuff.fs_id,
        s_op->req->u.unstuff.handle,
        &s_op->key,
        &s_op->val,
        0, NULL, smcb, 0, js_p, &j_id, server_job_context,
        s_op->req->hints);
}

static PINT_sm_action update_dfile_count(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t j_id;

    /* take the current on-disk attribute in object_attr form
     * (acquired from prelude) with the modified datafile array,
     * and convert it to the dspace form for writing.
     */
    PVFS_object_attr_to_ds_attr(&s_op->resp.u.unstuff.attr, &s_op->ds_attr);

    return job_trove_dspace_setattr(
        s_op->req->u.unstuff.fs_id, s_op->req->u.unstuff.handle,
        &s_op->ds_attr,
        TROVE_SYNC,
        smcb, 0, js_p, &j_id, server_job_context,
        s_op->req->hints);
}

static PINT_sm_action remove_layout(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t j_id;

    /* remove the layout and num_dfiles_req keyvals as the layout has
     * now been chosen.
     */
    return job_trove_keyval_remove_list(
        s_op->req->u.unstuff.fs_id, s_op->req->u.unstuff.handle,
        s_op->key_a,
        s_op->val_a,
        s_op->error_a,
        2,
        TROVE_SYNC, NULL,
        smcb, 0, js_p, &j_id, server_job_context,
        s_op->req->hints);
}

/* nlmills: TODO: replace all this messy capability code with
 * a call to the getattr nested state machine
 */

/* check_if_capability_required
 *
 * Branch point for capability creation.
 */
static PINT_sm_action check_if_capability_required(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* errors fall through */
    if (js_p->error_code < 0)
    {
        return SM_ACTION_COMPLETE;
    }

    if (s_op->resp.u.unstuff.attr.mask & PVFS_ATTR_CAPABILITY)
    {
        /* get rid of the old capability */
        PINT_cleanup_capability(&s_op->resp.u.unstuff.attr.capability);
        js_p->error_code = STATE_CAPABILITY;
    }
    else
    {
        js_p->error_code = 0;
    }

    return SM_ACTION_COMPLETE;
}

/* read_acl
 * 
 * Reads any ACL data from Trove if a capability is requested.
 */
static PINT_sm_action read_acl(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    job_id_t tmp_id;
    int ret;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (unstuff sm) state: read_acl\n",
                 s_op, PINT_map_server_op_to_string(s_op->req->op));

    assert(s_op->resp.u.unstuff.attr.mask & PVFS_ATTR_CAPABILITY);

    s_op->key.buffer = "system.posix_acl_access";
    s_op->key.buffer_sz = strlen(s_op->key.buffer) + 1;
    if(s_op->free_val)
    {
        free(s_op->val.buffer);
        s_op->free_val = 0;
    }
    s_op->val.buffer = malloc(PVFS_REQ_LIMIT_VAL_LEN);
    if (!s_op->val.buffer)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    s_op->val.buffer_sz = PVFS_REQ_LIMIT_VAL_LEN;
    s_op->free_val = 1;
    
    gossip_debug(GOSSIP_PERMISSIONS_DEBUG, "About to retrieve acl keyvals "
                     "for handle %llu\n", llu(s_op->target_handle));

    ret = job_trove_keyval_read(
        s_op->req->u.unstuff.fs_id,
        s_op->req->u.unstuff.handle,
        &s_op->key,
        &s_op->val,
        0,
        NULL,
        smcb,
        0,
        js_p,
        &tmp_id,
        server_job_context,
        s_op->req->hints);

    return ret;
}

/* create_capability
 * 
 */
static PINT_sm_action create_capability(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_object_attr *resp_attr = &s_op->resp.u.unstuff.attr;
    void *acl_buf;
    size_t acl_size;
    int ret;

    if (js_p->error_code == -TROVE_ENOENT)
    {
        acl_buf = NULL;
        acl_size = 0;
        js_p->error_code = 0;
    }
    else if (js_p->error_code < 0)
    {
        /* let fatal errors fall through */
        return SM_ACTION_COMPLETE;
    }
    else
    {
        acl_buf = s_op->val.buffer;
        acl_size = s_op->val.read_sz;
    }

    ret = PINT_init_capability(&resp_attr->capability);
    if (ret < 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "unstuff: capability init failed\n");
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    resp_attr->capability.num_handles = 1;

    if ((resp_attr->objtype == PVFS_TYPE_METAFILE) &&
        (resp_attr->mask & PVFS_ATTR_META_DFILES))
    {
        resp_attr->capability.num_handles += resp_attr->u.meta.dfile_count;
    }

    resp_attr->capability.handle_array = 
        calloc(resp_attr->capability.num_handles, sizeof(PVFS_handle));
    if (!resp_attr->capability.handle_array)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    resp_attr->capability.handle_array[0] = s_op->req->u.unstuff.handle;
    if ((resp_attr->objtype == PVFS_TYPE_METAFILE) &&
        (resp_attr->mask & PVFS_ATTR_META_DFILES))
    {
        /* copy datafile handles after the metafile handle */
        memcpy((resp_attr->capability.handle_array + 1),
               resp_attr->u.meta.dfile_array,
               resp_attr->u.meta.dfile_count * sizeof(PVFS_handle));
    }

    ret = PINT_get_capabilities(acl_buf,
                                acl_size,
                                s_op->req->u.unstuff.credential.userid,
                                s_op->req->u.unstuff.credential.group_array,
                                s_op->req->u.unstuff.credential.num_groups,
                                resp_attr,
                                &resp_attr->capability.op_mask);
    if (ret < 0)
    {
        PINT_cleanup_capability(&resp_attr->capability);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }
    
    resp_attr->capability.fsid = s_op->req->u.unstuff.fs_id;

    ret = PINT_sign_capability(&resp_attr->capability);
    if (ret < 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                     "unstuff: failed to sign capability\n");
        PINT_cleanup_capability(&resp_attr->capability);
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }
                                 
    resp_attr->mask |= PVFS_ATTR_CAPABILITY;

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    if(s_op->u.unstuff.layout.server_list.servers)
    {
        free(s_op->u.unstuff.layout.server_list.servers);
    }
    if(s_op->u.unstuff.encoded_layout)
    {
        free(s_op->u.unstuff.encoded_layout);
    }
    if(s_op->val_a)
    {
        free(s_op->val_a);
    }
    if(s_op->key_a)
    {
        free(s_op->key_a);
    }
    if(s_op->error_a)
    {
        free(s_op->error_a);
    }

    PINT_free_object_attr(&s_op->resp.u.getattr.attr);
    return (server_state_machine_complete(smcb));
}

static PINT_sm_action getattr_setup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *getattr_op;
    int ret;

    js_p->error_code = 0;

    getattr_op = malloc(sizeof(*getattr_op));
    if(!getattr_op)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(getattr_op, 0, sizeof(*getattr_op));

    /* TODO: can we come up with a way to clean up and nail down what has 
     * to be set in order to run this nested machine?  This seems fragile.
     */

    /* need attrs that the prelude read already */
    getattr_op->attr = s_op->attr;
    /* need a valid request structure for some generic features like access
     * logging 
     */
    getattr_op->req = s_op->req;
    /* need to fill in the input parameters to the getattr nested machine */
    getattr_op->u.getattr.fs_id = s_op->req->u.unstuff.fs_id;
    getattr_op->u.getattr.handle = s_op->req->u.unstuff.handle;
    getattr_op->u.getattr.attrmask = s_op->req->u.unstuff.attrmask;

    ret = PINT_sm_push_frame(smcb, 0, getattr_op);
    if(ret < 0)
    {
        js_p->error_code = ret;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action getattr_interpret(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *getattr_op;
    struct PINT_server_op *s_op;
    int task_id;
    int remaining;

    getattr_op = PINT_sm_pop_frame(smcb, &task_id, &js_p->error_code, 
        &remaining);
    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    s_op->resp.u.unstuff.attr = getattr_op->resp.u.getattr.attr;

    free(getattr_op);

    if(js_p->error_code)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
            "unstuff failed to retrieve existing attrs.\n");
        return(SM_ACTION_COMPLETE);
    }

    if(s_op->resp.u.unstuff.attr.mask & PVFS_ATTR_META_UNSTUFFED)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
            "unstuff found file already unstuffed; return existing attrs.\n");
        js_p->error_code = 0;
        return(SM_ACTION_COMPLETE);
    }

    gossip_debug(GOSSIP_SERVER_DEBUG,
        "unstuff found stuffed file.\n");
    js_p->error_code = STATE_UNSTUFF;
    return SM_ACTION_COMPLETE;
}

static int perm_unstuff(PINT_server_op *s_op)
{
    int ret;

    /* nlmills: TODO: probably just need write permission */
    if (s_op->req->capability.op_mask & PINT_CAP_SETATTR)
    {
        ret = 0;
    }
    else
    {
        ret = -PVFS_EACCES;
    }

    return ret;
}

PINT_GET_OBJECT_REF_DEFINE(unstuff);
PINT_GET_CREDENTIAL_DEFINE(unstuff);

struct PINT_server_req_params pvfs2_unstuff_params =
{
    .string_name = "unstuff",
    .perm = perm_unstuff,
    .access_type = PINT_server_req_modify,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_unstuff,
    .get_credential = PINT_get_credential_unstuff,
    .state_machine = &pvfs2_unstuff_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */

