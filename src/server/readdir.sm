/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <malloc.h>
#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "trove.h"

enum {
    STATE_ENOTDIR = 7
};

static int readdir_cleanup(PINT_server_op *s_op, job_status_s* js_p);
static int readdir_read_dirdata_handle(PINT_server_op *s_op, job_status_s* js_p);
static int readdir_iterate_on_entries(PINT_server_op *s_op, job_status_s* js_p);
static int readdir_verify_directory_metadata(PINT_server_op *s_op, job_status_s* js_p);
static int readdir_setup_resp(PINT_server_op *s_op, job_status_s* js_p);

extern PINT_server_trove_keys_s Trove_Common_Keys[];
extern job_context_id PINT_server_job_context;

%%

machine pvfs2_readdir_sm(prelude,
			 iterate_on_entries,
			 read_dirdata_handle,
			 verify_directory_metadata,
			 setup_resp,
			 final_response,
			 cleanup)
{
	state prelude
	{
		jump pvfs2_prelude_sm;
		success => verify_directory_metadata;
		default => final_response;
	}

	state verify_directory_metadata
	{
		run readdir_verify_directory_metadata;
		success => read_dirdata_handle;
		default => setup_resp;
	}

	state read_dirdata_handle
	{
		run readdir_read_dirdata_handle;
		success => iterate_on_entries;
		default => setup_resp;
	}

	state iterate_on_entries
	{
		run readdir_iterate_on_entries;
		default => setup_resp;
	}

	state setup_resp
	{
		run readdir_setup_resp;
		default => final_response;
	}

	state final_response 
	{
		jump pvfs2_final_response_sm;
		default => cleanup;
	}

	state cleanup
	{
		run readdir_cleanup;
		default => prelude;
	}
}

%%

/*
 * Function: readdir_verify_directory_metadata
 *
 * Synopsis: Examine the metadata returned from the keyval read.
 * If the metadata is for a directory, continue.  Otherwise prepare error.
 *
 * This function does not post an operation, but rather returns 1
 * immediately.
 */
static int readdir_verify_directory_metadata(PINT_server_op *s_op,
					     job_status_s* js_p)
{
    PVFS_object_attr *a_p;

    gossip_debug(SERVER_DEBUG, "readdir state: verify_directory_metadata\n");

    a_p = &s_op->attr;

    gossip_debug(SERVER_DEBUG,
		 "  attrs = (owner = %d, group = %d, perms = %o, type = %d)\n",
		 a_p->owner,
		 a_p->group,
		 a_p->perms,
		 a_p->objtype);

    if (a_p->objtype != PVFS_TYPE_DIRECTORY) {
	gossip_debug(SERVER_DEBUG, "  object is not a directory; halting readdir and sending response\n");
	js_p->error_code = STATE_ENOTDIR;
	return 1;
    }

    js_p->error_code = 0;
    return 1;
}


/*
 * Function: readdir_read_dirdata_handle
 *
 * Params:   server_op *s_op, 
 *           job_status_s* js_p
 *
 * Returns:  int
 *
 * Synopsis: read the handle of the dirdata space from the directory's keyval space
 *           
 */
static int readdir_read_dirdata_handle(PINT_server_op *s_op,
				       job_status_s* js_p)
{
    int ret;
    job_id_t i;

    gossip_debug(SERVER_DEBUG, "readdir state: read_dirdata handle\n");

    s_op->key.buffer    = Trove_Common_Keys[DIR_ENT_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[DIR_ENT_KEY].size;

    /* read handle into readdir scratch space */
    s_op->val.buffer    = &s_op->u.readdir.dirent_handle;
    s_op->val.buffer_sz = sizeof(PVFS_handle);

    gossip_debug(SERVER_DEBUG,
		 "  reading metadata (coll_id = 0x%x, handle = 0x%08Lx, key = %s (%d), val_buf = 0x%08x (%d))\n",
		 s_op->req->u.readdir.fs_id,
		 s_op->req->u.readdir.handle,
		 (char *) s_op->key.buffer,
		 s_op->key.buffer_sz,
		 (unsigned) s_op->val.buffer,
		 s_op->val.buffer_sz);

    ret = job_trove_keyval_read(s_op->req->u.readdir.fs_id,
					 s_op->req->u.readdir.handle,
					 &s_op->key,
					 &s_op->val,
					 0,
					 NULL,
					 s_op,
					 js_p,
					 &i,
					 PINT_server_job_context);
    return ret;
}

/*
 * Function: readdir_iterate_on_entries
 *
 * Params:   server_op *s_op, 
 *           job_status_s* js_p
 *
 * Returns:  int
 *
 * Synopsis: 
 *
 * NOTE: allocates a big chunk of memory, pointed to by s_op->key_a!
 */
static int readdir_iterate_on_entries(PINT_server_op *s_op,
				      job_status_s* js_p)
{
    int j;
    int memory_size, kv_array_size;
    char *memory_buffer;
    int ret;
    job_id_t j_id;

    gossip_debug(SERVER_DEBUG, "readdir state: iterate_on_entries\n");

    /* TODO: handle this error properly */
    assert(s_op->req->u.readdir.dirent_count <= PVFS_REQ_LIMIT_DIRENT_COUNT);

    /* calculate total memory needed:
     * - 2 * dirent_count keyval structures to pass to iterate function
     * - dirent_count dirent structures to hold the results
     */
    kv_array_size = s_op->req->u.readdir.dirent_count * sizeof(TROVE_keyval_s);
    memory_size = 2 * kv_array_size + s_op->req->u.readdir.dirent_count * sizeof(PVFS_dirent);

    memory_buffer = malloc(memory_size);
    assert(memory_buffer != NULL);

    /* set up all the pointers into the one big buffer */
    s_op->key_a = (TROVE_keyval_s *) memory_buffer;
    memory_buffer += kv_array_size;

    s_op->val_a = (TROVE_keyval_s *) memory_buffer;
    memory_buffer += kv_array_size;

    s_op->resp.u.readdir.dirent_array = (PVFS_dirent *) memory_buffer;

    /* fill in values into all keyval structures prior to iterate call */
    for (j = 0; j < s_op->req->u.readdir.dirent_count; j++)
    {
	s_op->key_a[j].buffer    = s_op->resp.u.readdir.dirent_array[j].d_name;
	s_op->key_a[j].buffer_sz = PVFS_NAME_MAX;

	s_op->val_a[j].buffer    = &(s_op->resp.u.readdir.dirent_array[j].handle);
	s_op->val_a[j].buffer_sz = sizeof(PVFS_handle);
    }

    gossip_debug(SERVER_DEBUG,
		 "  iterating over keyvals (coll_id = 0x%x, handle = 0x%08Lx, token = 0x%Lx, count = %d)\n",
		 s_op->req->u.readdir.fs_id,
		 s_op->u.readdir.dirent_handle,
		 (long long)s_op->req->u.readdir.token,
		 s_op->req->u.readdir.dirent_count);

    ret = job_trove_keyval_iterate(s_op->req->u.readdir.fs_id,
					    s_op->u.readdir.dirent_handle,
					    s_op->req->u.readdir.token,
					    s_op->key_a,
					    s_op->val_a,
					    s_op->req->u.readdir.dirent_count,
					    0,
					    NULL,
					    s_op,
					    js_p, 
					    &j_id,
					    PINT_server_job_context);
    return ret;
}


/* readdir_setup_resp()
 *
 * fills in the response structure based on results of earlier states
 */
static int readdir_setup_resp(PINT_server_op *s_op, job_status_s* js_p)
{

    gossip_debug(SERVER_DEBUG, "readdir state: setup_resp\n");

    if (js_p->error_code == STATE_ENOTDIR) {

	gossip_debug(SERVER_DEBUG,
		     "  handle didn't refer to a directory\n");

	js_p->error_code = -PVFS_EINVAL;
	return(1);
    }
    else if (js_p->error_code != 0) {
	/* for now let's assume this is an "empty" directory */

	gossip_debug(SERVER_DEBUG,
		     "  error code = %d; assuming empty directory\n",
		     js_p->error_code);

	s_op->resp.u.readdir.dirent_count = 0;
	js_p->error_code = 0;
	return(1);
    }
    else {
	s_op->resp.u.readdir.dirent_count = js_p->count;
	js_p->error_code = 0;
	return(1);
    }

}


/*
 * Function: readdir_cleanup
 *
 * Params:   server_op *b, 
 *           job_status_s* js_p
 *
 * Returns:  int
 *
 * Synopsis: free memory and return
 *           
 */
static int readdir_cleanup(PINT_server_op *s_op,
			   job_status_s* js_p)
{

    gossip_debug(SERVER_DEBUG, "readdir state: cleanup\n");

    /* free dynamically allocated space */
    if (s_op->key_a) free(s_op->key_a);

    return(PINT_state_machine_complete(s_op));
}


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */
