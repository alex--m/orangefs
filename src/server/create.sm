/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-config.h"
#include "pvfs2-attr.h"
#include "gossip.h"
#include "pvfs2-internal.h"
#include "pint-util.h"
#include "pint-cached-config.h"
#include "pint-perf-counter.h"
#include "pint-security.h"
#include "pint-uid-map.h"

#define REPLACE_DONE 100

%%

machine pvfs2_create_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => create_metafile;
        default => setup_final_response;
    }

    state create_metafile
    {
        run create_metafile;
        success => write_keyvals;
/*
        success => create_local_datafiles;
*/
        default => setup_final_response;
    }

/*
    state create_local_datafiles
    {
        run create_local_datafiles;
        success => write_keyvals;
        default => remove_metafile_object;
    }
*/

    state write_keyvals
    {
        run write_keyvals;
        success => write_metafile_attribs;
        default => remove_local_datafile_handles;
    }

    state write_metafile_attribs
    {
        run write_metafile_attribs;
        success => setobj_attribs_debug;
        default => remove_keyvals;
    }

    state setobj_attribs_debug
    {
        run setobj_attribs_debug;
        default => setup_final_response;
    }

    state remove_keyvals
    {
        run remove_keyvals;
        success => remove_local_datafile_handles;
        default => setup_final_response;
    }

    state remove_local_datafile_handles
    {
        run remove_local_datafile_handles;
        default => remove_metafile_object;
    }

    state remove_metafile_object
    {
        run remove_metafile_object;
        default => setup_final_response;
    }

    state setup_final_response
    {
        run setup_final_response;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run cleanup;
        default => terminate;
    }
}

%%

/***************** STATE ACTIONS *****************/

static int create_metafile(struct PINT_smcb *smcb, job_status_s *js_p)
{

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t tmp_id;

    /* This is the first true state action of the create SM so increment
     * the counter for create requests
     */
    PINT_perf_count(PINT_server_pc, PINT_PERF_CREATE, 1, PINT_PERF_ADD);

    /* first state to check in, make sure the attr mask contains the dist bit. 
     * it's required later (not sure if we have to require it) but if we don't
     * have it here, return an EINVAL
     */
    if( ! (s_op->req->u.create.attr.mask & PVFS_ATTR_META_DIST) )
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "%s: invalid create request, "
                     "attribute mask did not include the distribution\n",
                     __func__);
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    ret = job_trove_dspace_create(s_op->req->u.create.fs_id,
                                  s_op->req->u.create.handle,
                                  PVFS_TYPE_METAFILE,
                                  NULL, /* hint */
                                  0,    /* flags */
                                  smcb, /* user_ptr */
                                  0,    /* status_user_tag */
                                  js_p,
                                  &tmp_id,
                                  server_job_context,
                                  s_op->req->hints);

    return(ret);
}

/* V3 */
#if 0
static int check_stuffed(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int server_type;
    server_configuration_t *config = get_server_config_struct();
    struct filesystem_configuration_s *fs_conf;
    PVFS_BMI_addr_t myaddr;
    PVFS_sys_layout *layout;
    int ret;
    const char* svr_name;
    int i;

    /* V3 s_op->resp.u.create.metafile_handle = js_p->handle; */
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "Metafile handle created: %s\n",
                 PVFS_OID_str(&js_p->handle));

    assert(config);

    layout = &s_op->req->u.create.layout;

    if(layout->algorithm == PVFS_SYS_LAYOUT_LIST)
    {
        for(i = 0; i < layout->server_list.count; i++)
        {
            gossip_debug(GOSSIP_SERVER_DEBUG, "layout list server %d: %lld\n", 
                         i, lld(layout->server_list.servers[i])); 
        }
    }

    fs_conf = PINT_config_find_fs_id(config, s_op->req->u.create.fs_id);
    if(!fs_conf)
    {
        js_p->error_code = -PVFS_EINVAL;
        return(SM_ACTION_COMPLETE);
    }

    ret = BMI_addr_lookup(&myaddr, config->host_id);
    if(ret != 0)
    {
        /* we can't get our own address? */
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /* WBL V3 this must be replaced with a SID query 
     * to get the server type
     */
    /* is this metadata server also IO? */
    svr_name = PINT_cached_config_map_addr(s_op->req->u.create.fs_id,
                                           myaddr,
                                           &server_type);
    if(!svr_name)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /* 
     * V3 all files are created stuffed, which merely means
     * that we set a stuffed flag in the metadata and any write
     * past the threshold to a stuffed file must inform the meetadata
     * to clear the flag.  All handles and SIDs have already been
     * allocated and so will be set up just like any other file
     *
     * WBL V3 - file stuffing doesn't make sense any more
     * Actually all files can be "stuffed" if the meta server
     * is a data server - but we always allocate all handles
     * and SIDs
     */
    /* For now only support stuffing of ROUND_ROBIN layouts.
     * As a performance enhancement, don't create a stuffed 
     * file when the current environment only has one server.
     * This prevents unstuffing from being called by the client sys-io machine.
     */
    if((server_type & PINT_SERVER_TYPE_IO) &&
        fs_conf->file_stuffing &&
        layout->algorithm == PVFS_SYS_LAYOUT_ROUND_ROBIN &&
        s_op->req->u.create.num_dfiles_req > 1 )
    {    
        /* we can do a stuffed create here, only one datafile */
        s_op->req->u.create.attr.u.meta.dfile_count = 1;
        s_op->resp.u.create.datafile_count = 1;
        /* TJS: */
        s_op->resp.u.create.datafile_handles = malloc(sizeof(PVFS_handle));
        s_op->u.create.handle_array_local = malloc(sizeof(PVFS_handle));
        if(!s_op->resp.u.create.metafile_attrs.u.meta.dfile_array ||
           !s_op->u.create.handle_array_local)
        {
            js_p->error_code = -PVFS_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        s_op->resp.u.create.stuffed = 1;
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    s_op->u.create.num_io_servers = s_op->req->u.create.num_dfiles_req;

    /* TJS: */
    s_op->resp.u.create.datafile_handles = malloc(
                    s_op->req->u.create.datafile_count *
                    (sizeof(*s_op->req.u.create.datafile_handles) +
                     (s_op->req->u.create.sid_count *
                      sizeof(*s_op->req->u.create.sid_array))));
    s_op->u.create.handle_array_local = malloc(
                    (s_op->u.create.num_io_servers *
                     sizeof(*s_op->u.create.handle_array_local)));

    s_op->u.create.handle_array_remote = malloc(
                    sizeof(*s_op->u.create.handle_array_remote) *
                    s_op->u.create.num_io_servers);
    s_op->u.create.remote_io_servers = malloc(
                    sizeof(char *) *
                    s_op->u.create.num_io_servers);

    if(!s_op->resp.u.create.metafile_attrs.u.meta.dfile_array || 
        !s_op->u.create.handle_array_local ||
        !s_op->u.create.handle_array_remote ||
        !s_op->u.create.remote_io_servers)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* gather list of servers to use, may include local server */
    /* WBL V3 need to replace with a SID query */
    ret = PINT_cached_config_get_server_list(
                    s_op->req->u.create.fs_id,
                    s_op->req->u.create.attr.u.meta.dist,
                    s_op->req->u.create.num_dfiles_req,
                    &s_op->req->u.create.layout,
                    &s_op->u.create.io_servers,
                    &s_op->u.create.num_io_servers);
    if(ret < 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    /* layout may have adjusted number of datafiles */
    s_op->req->u.create.attr.u.meta.dfile_count = s_op->u.create.num_io_servers;
    s_op->resp.u.create.datafile_count = s_op->u.create.num_io_servers;

    for(i = 0; i < s_op->u.create.num_io_servers; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "io_server %d: %s\n", 
                     i, s_op->u.create.io_servers[i]); 
    }

    s_op->resp.u.create.stuffed = 0;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}
#endif

#if 0
static int create_local_datafiles(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t tmp_id;
    PVFS_handle *data_handle_array;
    server_configuration_t *config = get_server_config_struct();
    int i, j;
    int tmp_index = 0;

    s_op->u.create.handle_array_local = malloc(
                                  OASZ(s_op->req->u.create.datafile_count));
    if (!s_op->u.create.handle_array_local)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->u.create.handle_array_local,
            OASZ(s_op->req->u.create.datafile_count));

    /* figure out how many datafiles need to be local vs. remote */
    s_op->u.create.handle_array_local_count = 0;
    tmp_index = 0;
    for (i = 0; i < s_op->req->u.create.datafile_count; i++)
    {
        for (j = 0; j < s_op->req->u.create.sid_count; j++)
        {
            int sid_ix = (i * s_op->req->u.create.sid_count) + j;
            if (!PVFS_SID_cmp(&s_op->req->u.create.sid_array[sid_ix],
                              &config->host_sid))
            {
                s_op->u.create.handle_array_local_count++;
                s_op->u.create.handle_array_local[tmp_index] = 
                                        s_op->req->u.create.datafile_handles[i];
                tmp_index++;
                if ((i == 0) && (j == 0))
                {
                    /* V3 this is the old criterea for stuffed */
                    /* possibly upgrade to mask of dfiles that have */
                    /* local data */
                    s_op->attr.u.meta.stuffed = 1;
                }
            }
        }
    }

    gossip_debug(GOSSIP_SERVER_DEBUG, "creating %d local data files\n", 
                 s_op->u.create.handle_array_local_count);

    if(s_op->u.create.handle_array_local_count == 0)
    {
        /* no local work to do */
        js_p->error_code = 0;
        return(SM_ACTION_COMPLETE);
    }

    /* Create LOCAL datafiles.  Don't need a SID (they are local) and
     * any old OID will do so just pass in a list of NULL OIDs to Trove
     * and it will generate OIDs for us
     */

    data_handle_array = (PVFS_handle *)malloc(
                            OASZ(s_op->u.create.handle_array_local_count));
    if (!data_handle_array)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(data_handle_array, 
            OASZ(ls_op->u.create.handle_array_local_count));
    
    /* deliberately not setting SYNC flag, because both the attrs and
     * keyvals will be synced in later states
     */
    ret = job_trove_dspace_create_list(s_op->req->u.create.fs_id,
                                       data_handle_array,
                                       s_op->u.create.handle_array_local,
                                       s_op->u.create.handle_array_local_count,
                                       PVFS_TYPE_DATAFILE,
                                       NULL, /* hint */
                                       0,    /* flags */
                                       smcb, /* user_ptr */
                                       0,    /* status_user_tag */
                                       js_p,
                                       &tmp_id,
                                       server_job_context,
                                       s_op->req->hints);

    free(data_handle_array);

    return(ret);
}
#endif

/* Write keyval attributes of the metadata object
 * ADD BACKPOINTER V3
 */
static PINT_sm_action write_keyvals(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;

    /* start with 2 keyvals: the distribution and the datafile handles */
    int keyval_count = 3;

    s_op->key_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->key_a)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->key_a, (sizeof(PVFS_ds_keyval) * keyval_count));

    s_op->val_a = malloc(sizeof(PVFS_ds_keyval) * keyval_count);
    if(!s_op->val_a)
    {
        free(s_op->key_a);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a, sizeof((PVFS_ds_keyval) * keyval_count));

    s_op->key_a[0].buffer_sz = Trove_Common_Keys[METAFILE_HANDLES_KEY].size;
    s_op->key_a[0].buffer = Trove_Common_Keys[METAFILE_HANDLES_KEY].key;

    s_op->val_a[0].buffer_sz = OSASZ(s_op->req->u.create.datafile_count,
                                     s_op->req->u.create.sid_count);
    s_op->val_a[0].buffer = s_op->req->u.create.datafile_handles;

    s_op->key_a[1].buffer_sz = Trove_Common_Keys[METAFILE_DIST_KEY].size;
    s_op->key_a[1].buffer = Trove_Common_Keys[METAFILE_DIST_KEY].key;

    s_op->val_a[1].buffer_sz = s_op->req->u.create.attr.u.meta.dist_size;
    s_op->val_a[1].buffer = malloc(s_op->val_a[1].buffer_sz);

    s_op->key_a[2].buffer_sz = Trove_Common_Keys[OBJECT_PARENT_KEY].size;
    s_op->key_a[2].buffer = Trove_Common_Keys[OBJECT_PARENT_KEY].key;

    s_op->val_a[2].buffer_sz = OSASZ(1, s_op->req->u.create.sid_count);
    s_op->val_a[2].buffer = s_op->req->u.create.parent;

    if(!s_op->val_a[1].buffer)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    ZEROMEM(s_op->val_a[1].buffer, s_op->val_a[1].buffer_sz);

    PINT_dist_encode(s_op->val_a[1].buffer,
                     s_op->req->u.create.attr.u.meta.dist);

    ret = job_trove_keyval_write_list(s_op->req->u.create.fs_id,
                                      s_op->req->u.create.handle, /*metafile*/
                                      s_op->key_a,
                                      s_op->val_a,
                                      keyval_count,
                                      TROVE_SYNC, /* flags */
                                      NULL,       /* vtag */
                                      smcb,       /* user_ptr */
                                      0,          /* status_user_tag */
                                      js_p,
                                      &j_id,
                                      server_job_context,
                                      s_op->req->hints);
    return ret;
}

/*
 * writes the standard attributes to the metafile object in the dspace
 */
static PINT_sm_action write_metafile_attribs(struct PINT_smcb *smcb,
                                             job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;
    PVFS_object_attr *a_p = NULL;
    PVFS_object_attr *dspace_a_p = NULL;
    PVFS_ds_attributes *ds_attr = NULL;
#ifdef ENABLE_SECURITY_CERT    
    PVFS_uid uid;
    PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS];
    uint32_t num_groups;
#endif

    dspace_a_p = &s_op->attr;
    a_p = &s_op->req->u.create.attr;

#if 0
    /* 
     * Remember that mtime is versioned on disk! so convert it here..
     * It is better to do it here than change the "
     * PVFS_object_attr_overwrite_setable
     * macro, since there are many more users of it, I think.
     */
    if (a_p->mask & PVFS_ATTR_COMMON_MTIME_SET)
    {
        PVFS_time orig_mtime = a_p->mtime;
        a_p->mtime = PINT_util_mktime_version(orig_mtime);
        gossip_debug(GOSSIP_SETATTR_DEBUG, "setting version "
                     "to %llu\n\tmtime is %llu\n",
                     llu(a_p->mtime), llu(orig_mtime));
    }
#endif

    /*
     * we have the attribs stored in the dspace, as well as the
     * requested attribs to store.  overwrite the ones that are setable
     * and specified by the mask value in the request; macro defined in
     * pvfs2-storage.h
     */
    PVFS_object_attr_overwrite_setable(dspace_a_p, a_p);

    /* update fields passed in the request but stored in the dspace
     * attributes.
     * for whatever reason we aren't getting the time passed from the
     * user (client) there is no reason we can't set it here.
     */
    dspace_a_p->u.meta.dfile_count = s_op->req->u.create.datafile_count;
    dspace_a_p->u.meta.sid_count = s_op->req->u.create.sid_count;
    dspace_a_p->atime =
            dspace_a_p->ctime =
                      dspace_a_p->ntime = PINT_util_get_current_time();
    dspace_a_p->mtime = PINT_util_mktime_version(dspace_a_p->ntime);

#ifdef ENABLE_SECURITY_CERT
    /*                                                              
     * if owner info is missing, map from credential
     * note that user must have admin rights to set owner info
     * to another user (see perm_create() below)
     */
    num_groups = PVFS_REQ_LIMIT_GROUPS;

    ret = PINT_map_credential(&s_op->req->u.create.credential,
                              &uid,
                              &num_groups,
                              group_array);
    if (ret != 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    dspace_a_p->owner = uid;

    /* for cert mode we use a hint provided by the client */
    dspace_a_p->group = PINT_HINT_GET_OWNER_GID(s_op->req->hints);
    if (dspace_a_p->group == PVFS_GID_MAX)
    {
        gossip_err("%s: warning: no owner gid hint\n", __func__);
        dspace_a_p->group = group_array[0];
    }
#endif

    gossip_debug(
         GOSSIP_SERVER_DEBUG,
         "[STUFFED CREATE]: WRITING attrs: [owner = %d, group = %d\n\t"
         "perms = %o, type = %d, atime = %llu, mtime = %llu\n\t"
         "ctime = %llu | dfile_count = %d | dist_size = %d]\n",
         dspace_a_p->owner, dspace_a_p->group, dspace_a_p->perms,
         dspace_a_p->objtype, llu(dspace_a_p->atime),
         llu(PINT_util_mkversion_time(dspace_a_p->mtime)),
         llu(dspace_a_p->ctime),
         (int)dspace_a_p->u.meta.dfile_count,
         (int)dspace_a_p->u.meta.dist_size);

    /* translate attrs to storage attr format */
    ds_attr = &(s_op->ds_attr);
    PVFS_ds_attr_from_object_attr(ds_attr, dspace_a_p);

    ret = job_trove_dspace_setattr(s_op->req->u.create.fs_id,
                                   s_op->req->u.create.handle, /* metafile */
                                   ds_attr,
                                   TROVE_SYNC, /* flags */
                                   smcb,       /* user_ptr */
                                   0,          /* status_user_tag */
                                   js_p,
                                   &j_id,
                                   server_job_context,
                                   s_op->req->hints);

    return ret;
}

static PINT_sm_action setobj_attribs_debug(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{    
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* V3 add debugging of sids and soforth */
    if (js_p->error_code == 0)
    {
        PINT_ACCESS_DEBUG(s_op,
                          GOSSIP_ACCESS_DEBUG,
                          "create: new metadata handle: %s.\n",
                          PVFS_OID_str(&s_op->req->u.create.handle));
    }
 
    return SM_ACTION_COMPLETE;
}

/*
 * This state is run in case of an error
 */
static PINT_sm_action remove_metafile_object(struct PINT_smcb *smcb,
                                             job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;

    /* save the error code before we begin cleanup */
    if(!s_op->u.create.saved_error_code)
    {
        s_op->u.create.saved_error_code = js_p->error_code;
    }

    ret = job_trove_dspace_remove(s_op->req->u.create.fs_id,
                                  s_op->req->u.create.handle, /* metafile */
                                  0,
                                  smcb,
                                  0,
                                  js_p,
                                  &j_id,
                                  server_job_context,
                                  s_op->req->hints);
    return ret;
}

/*
 * This state is run in case of an error
 */
static PINT_sm_action remove_local_datafile_handles(struct PINT_smcb *smcb,
                                                    job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;

    /* save the error code before we begin cleanup */
    if(!s_op->u.create.saved_error_code)
    {
        s_op->u.create.saved_error_code = js_p->error_code;
    }

    if(s_op->u.create.handle_array_local_count == 0)
    {
        /* nothing to do */
        js_p->error_code = 0;
        return(SM_ACTION_COMPLETE);
    }

    ret = job_trove_dspace_remove_list(s_op->req->u.create.fs_id,
                                       s_op->u.create.handle_array_local,
                                       NULL,
                                       s_op->u.create.handle_array_local_count,
                                       0,
                                       smcb,
                                       0,
                                       js_p,
                                       &j_id,
                                       server_job_context,
                                       s_op->req->hints);

    return ret;
}

/*
 * This state is run in case of an error
 */
static PINT_sm_action remove_keyvals(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -1;
    job_id_t j_id;

    /* save the error code before we begin cleanup */
    if(!s_op->u.create.saved_error_code)
    {
        s_op->u.create.saved_error_code = js_p->error_code;
    }

    /* the keyval keys and vals should still be valid here */
    ret = job_trove_keyval_remove_list(s_op->req->u.create.fs_id,
                                       s_op->req->u.create.handle, /*metafile*/
                                       s_op->key_a,
                                       s_op->val_a,
                                       s_op->error_a,
                                       2,
                                       TROVE_SYNC,
                                       NULL,
                                       smcb,
                                       0,
                                       js_p,
                                       &j_id,
                                       server_job_context,
                                       s_op->req->hints);

    return ret;
}

/*
 * Set up the response message
 */
static PINT_sm_action setup_final_response(struct PINT_smcb *smcb,
                                           job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* retrieve original error code if present */
    if(s_op->u.create.saved_error_code)
    {
        js_p->error_code = s_op->u.create.saved_error_code;
    }

    /* otherwise propigate the js_p->error code */
    return(SM_ACTION_COMPLETE);
}

/*
 * Function: create_cleanup
 *
 * Synopsis: free memory and return
 *           
 */
static PINT_sm_action cleanup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    if(s_op->key_a)
    {
        free(s_op->key_a);
    }

    if(s_op->val_a)
    {
        if(s_op->val_a[1].buffer)
        {
            free(s_op->val_a[1].buffer);
        }
        free(s_op->val_a);
    }

    if(s_op->u.create.handle_array_local)
    {
        free(s_op->u.create.handle_array_local);
    }

    return(server_state_machine_complete(smcb));
}

/***************** HELPER FUNCTIONS *****************/

static int PINT_get_object_ref_create(struct PVFS_server_req *req,
                                      PVFS_fs_id *fs_id,
                                      PVFS_handle *handle)
{
    *fs_id = req->u.create.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

PINT_GET_CREDENTIAL_DEFINE(create);

static int perm_create(PINT_server_op *s_op)
{
#if 0
    /*** code not needed -- see below ***/
    PVFS_object_attr *attr = &s_op->req->u.create.attr;
    PVFS_credential *cred = &s_op->req->u.create.credential;
    PVFS_uid uid;
    PVFS_gid group_array[PVFS_REQ_LIMIT_GROUPS];
    uint32_t num_groups = PVFS_REQ_LIMIT_GROUPS, i;
    int ret;
#endif

    if (!(s_op->req->capability.op_mask & PINT_CAP_CREATE))
    {
        return -PVFS_EACCES;
    }

#if 0
    /*** currently the owner/group is always loaded from 
         the credential, so this code isn't needed ***/
    /* check if allowed to create file with different owner/group */
    if (attr->mask & (PVFS_ATTR_COMMON_UID|PVFS_ATTR_COMMON_GID) &&
        !(s_op->req->capability.op_mask & PINT_CAP_ADMIN))
    {
        /* map the credential to the user info */
        ret = PINT_map_credential(cred, &uid, &num_groups, group_array);
        if (ret != 0)
        {
            return ret;
        }

        /* verify that the user has permission to change the file's owner */
        if (attr->mask & PVFS_ATTR_COMMON_UID)
        {
            if (uid != attr->owner)
            {
                return -PVFS_EPERM;
            }
        }

        /* verify that the user has permission to change the file's group */
        if (attr->mask & PVFS_ATTR_COMMON_GID)
        {
            for (i = 0; i < num_groups; i++)
            {
                if (group_array[i] == attr->group)
                {
                    break;
                }
            }
            /* no group matches */
            if (i >= num_groups)
            {
                return -PVFS_EPERM;
            }
        }
    }
#endif /* #if 0 */

    return 0;
}

static void create_get_ctrl(struct PVFS_server_req *req,
                           struct PINT_server_req_ctrl *ctrl)
{
    /* this sets up a standard replication */
    /* generates a request to each of sid_count SIDs */
    /* all with the same UID */
    ctrl->fs_id = req->u.create.fs_id;
    ctrl->handles = &req->u.create.handle;
    ctrl->count = 1;
    ctrl->sids = req->u.create.sid_array;
    ctrl->sid_count = req->u.create.sid_count;
}

struct PINT_server_req_params pvfs2_create_params =
{
    .string_name = "create",
    .get_object_ref = PINT_get_object_ref_create,
    .get_credential = PINT_get_credential_create,
    .perm = perm_create,
    .get_ctrl = create_get_ctrl,
    .access_type = PINT_server_req_modify,
    .state_machine = &pvfs2_create_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
