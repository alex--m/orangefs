/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_get_path_sm
 *
 * This state machine handles incoming server getpath operations.  These
 * are the operations sent by PVFS_sys_getpath().
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-perf-counter.h"
#include "pint-cached-config.h"
#include "dbpf-keyval.h"

#define ALL_PATHS_COMPLETE 100

static int remote_resp_comp_fn( void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index );
static int remove_bmi_from_array( BMI_addr_t *addr, int count, 
                                  BMI_addr_t remove );

%%

machine pvfs2_get_path_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => setup_resp;
        default => final_response;
    }

    state setup_resp
    {
        run getpath_setup_resp;
        success => read_path;
        default => final_response;
    }

    state read_path
    {
        run getpath_read_path;
        success => check_for_work_remote;
        default => final_response;
    }

    state check_for_work_local
    {
        run getpath_check_for_work;
        ALL_PATHS_COMPLETE => check_resp;
        success => read_path;
        default => final_response;
    }

    state check_for_work_remote
    {
        run getpath_check_for_work;
        ALL_PATHS_COMPLETE => check_resp;
        success => prepare_remote_work;
        default => final_response;
    }

    state prepare_remote_work
    {
        run getpath_prepare_remote_work;
        success => send_remote_work;
        default => final_response;
    }

    state send_remote_work
    {
        jump pvfs2_msgpairarray_sm;
        default => remote_cleanup;
    }

    state remote_cleanup
    {
        run getpath_remote_cleanup;
        default => check_for_work_local;
    }

    state check_resp
    {
        run getpath_check_resp;
        default => final_response;
    }
    
    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup   
    {
        run getpath_cleanup;
        default => terminate;
    }
}

%%

/*
 * getpath_setup_resp()
 * Set up the response, allocate needed resources
 */
static PINT_sm_action getpath_setup_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret=0, i=0, meta_serv_num=0;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *server_config = get_server_config_struct();
    BMI_addr_t host = 0;

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_setup_resp: enter\n");

    js_p->error_code = 0;

    PINT_cached_config_get_root_handle(s_op->req->u.getpath.fs_id, 
        &(s_op->u.getpath.root_handle));

    /* assign values over from the request */
    s_op->u.getpath.count = s_op->req->u.getpath.count;
    s_op->resp.u.getpath.count = s_op->req->u.getpath.count;
    s_op->target_fs_id = s_op->req->u.getpath.fs_id;
    s_op->target_handle = s_op->u.getpath.root_handle;

    for( i=0; i < s_op->u.getpath.count; i++ )
    {
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_setup_resp: "
                     "got dirent_p[%d]: (%llu)(%s)\n", i, 
                     llu(s_op->req->u.getpath.dirent[i].handle),
                     s_op->req->u.getpath.dirent[i].d_name);
    }

    if( (s_op->u.getpath.dirent_p = calloc( s_op->u.getpath.count, 
                                            sizeof(PVFS_dirent))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memcpy(s_op->u.getpath.dirent_p, s_op->req->u.getpath.dirent,
        s_op->req->u.getpath.count * sizeof(PVFS_dirent));

    if( (s_op->u.getpath.handle_p = calloc( s_op->u.getpath.count, 
                                            sizeof(PVFS_handle))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* initialize handle_p to initial handle of query */
    for( i=0; i < s_op->u.getpath.count; i++ )
    {
        s_op->u.getpath.handle_p[i] = s_op->u.getpath.dirent_p[i].handle;
    }

    if( (s_op->resp.u.getpath.dirent = calloc( s_op->u.getpath.count, 
                                               sizeof(PVFS_dirent))) == 0)
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocate a per meta server dirent list to allow for targeting
     * queries based on who the parent is */
    PINT_cached_config_get_num_meta( s_op->target_fs_id, &(meta_serv_num) );

    /* will this always be on a meta server? make sure server side sends
     * it to a meta server in the get-value state machine */
    s_op->u.getpath.meta_num = meta_serv_num - 1; /* don't count this meta */

    if( (s_op->u.getpath.remote_dirent = calloc( s_op->u.getpath.meta_num, 
        sizeof(PVFS_dirent *))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* index to allow mapping between the local dirent array and what is sent
     * to a specific metadata server. this is necessary since a request to a
     * specific metadata server will only contain requests that metadata
     * server can handle */
    if( (s_op->u.getpath.remote_to_local = calloc( s_op->u.getpath.meta_num, 
                                                   sizeof(uint32_t *))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* initialize second dimension */
    for( i = 0; i < s_op->u.getpath.meta_num; i++ )
    {
        if( (s_op->u.getpath.remote_dirent[i] = calloc( s_op->u.getpath.count,
             sizeof(PVFS_dirent))) == 0 )
        {
            js_p->error_code = -TROVE_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        if( (s_op->u.getpath.remote_to_local[i] = calloc( s_op->u.getpath.count,
             sizeof(uint32_t))) == 0 )
        {
            js_p->error_code = -TROVE_ENOMEM;
            return SM_ACTION_COMPLETE;
        }
    }

    /* allocate a per meta server remote_count array to track number of 
     * dirents being sent to each metadata server */
    if( (s_op->u.getpath.remote_count = calloc( s_op->u.getpath.meta_num, 
        sizeof(uint32_t))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* create array to store addresses of metadata servers
     * add one to count for ourselves since we get everyone back */
    if( (s_op->u.getpath.remote_addr = calloc( s_op->u.getpath.meta_num+1, 
                                               sizeof(PVFS_BMI_addr_t))) == 0 )
    {
        gossip_err("get_path: failed to allocate remote_dirent_p\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    ret = PINT_cached_config_get_server_array( s_op->req->u.getpath.fs_id,
        PINT_SERVER_TYPE_META, s_op->u.getpath.remote_addr, &(meta_serv_num));
    if( ret != 0 )
    {
        gossip_err("get_path: failed to get meta server addresses\n");
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* now remove our address from the list */
    ret = BMI_addr_lookup( &host, server_config->host_id );
    if( ret != 0 )
    {
        gossip_err("get_path: failed to lookup address\n");
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* this metaserver from list of metaserver to send remote quests to */
    ret = remove_bmi_from_array( s_op->u.getpath.remote_addr, 
                                 s_op->u.getpath.meta_num, host );
    if( ret != 0 )
    {
        gossip_err("get_path: fail to remove BMI address from list\n");
        js_p->error_code = -PVFS_ENOMEM; /* only known error is from realloc */
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_setup_resp: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * getpath_read_path
 * resolves the path as far as possible using the local keyval database 
 */
static PINT_sm_action getpath_read_path(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
 
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_read_path: enter\n");
    js_p->error_code = 0;

    ret = job_trove_keyval_read_value_path(
        s_op->target_fs_id,
        s_op->target_handle,
        s_op->u.getpath.count,
        s_op->u.getpath.dirent_p,
        s_op->u.getpath.handle_p,
        0,
        NULL,
        smcb,
        0,
        js_p,
        &i,
        server_job_context, s_op->req->hints);

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_read_path: exit\n");
    return ret;
}

/*
 * getpath_check_for_work
 */
static PINT_sm_action getpath_check_for_work(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int i=0;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    
    js_p->error_code = 0;

    for( i = 0; i < s_op->u.getpath.count; i++ )
    {
        /* dirent_p will hold the handle we need to resolve to build the path. 
         * handle_p has the next handle up the path, which maps
         * to which server we need to ask to resolve dirent_p.handle.
         * we're done dirent_p.handle is at the root */

        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_check_for_work: "
                     " handle is: (%llu)\n", 
                    llu(s_op->u.getpath.dirent_p[i].handle));
        if( s_op->u.getpath.dirent_p[i].handle != s_op->u.getpath.root_handle )
        {
            return SM_ACTION_COMPLETE;
        }
    }
    
    /* didn't return above, all handles must be at the root handle */
    js_p->error_code = ALL_PATHS_COMPLETE;
    return SM_ACTION_COMPLETE;
}


/*
 * getpath_prepare_remote_work
 */
static PINT_sm_action getpath_prepare_remote_work(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_sm_msgpair_state *msg_p = NULL;
    int ret=0, i=0, j=0, index=0;
    PVFS_credentials creds;
    BMI_addr_t meta_addr = 0;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* array to track which meta servers have handles to query */
    int meta_with_handles[s_op->u.getpath.meta_num];

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_prepare_remote_work"
                 ": enter\n");

    s_op->target_handle = s_op->u.getpath.root_handle;

    /* iterate over handles, adding those that need work to appropriate meta
     * servers list. we now can actually tell what who owns the next
     * server. */
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_prepare_remote_work"
                 ": Begin assigning handles to meta server requests\n");
    for( i=0; i < s_op->u.getpath.count; i++ )
    {
        gossip_debug(GOSSIP_GETPATH_DEBUG, 
                     "[GETPATH]: getpath_prepare_remote_work: index %d, "
                     "with handle (%llu)\n", i, 
                     s_op->u.getpath.dirent_p[i].handle);

        /* only add item if still needs handle lookups */
        if( s_op->u.getpath.dirent_p[i].handle != s_op->u.getpath.root_handle )
        {
            /* assuming the request was routed to the correct metadata server
             * the trove keyval read should have populated handle_p with
             * the correct parent (next handle) to lookup. we now know which
             * metadata server to target */
            PINT_cached_config_map_to_server( &meta_addr,
                                              s_op->u.getpath.handle_p[i],
                                              s_op->target_fs_id);

            /* j is the state machine's index for this meta server's structs,
             * finds the index to the meta server by skipping meta servers
             * that don't have handles and won't have a msgpair. */
            for( j=0; j < s_op->u.getpath.meta_num; j++ )
            {
                gossip_debug(GOSSIP_GETPATH_DEBUG, "want: %llu, "
                             "j: %d, remote_addr: %llu\n", 
                             llu(meta_addr), j, 
                             llu(s_op->u.getpath.remote_addr[j]));
                if( s_op->u.getpath.remote_addr[j] == meta_addr )
                {
                    break;
                }
            }

            assert( j < s_op->u.getpath.meta_num );

            /* index to store next dirent in the per-meta server list of */
            index = s_op->u.getpath.remote_count[j];

            gossip_debug(GOSSIP_GETPATH_DEBUG,
                         "[GETPATH]: getpath_prepare_remote_work: targeting "
                         "handle (%llu) to addr (%lld), index (%d) for lookup "
                         "of (%llu)/(%s), in remote_dirent[%d][%d]\n", 
                         llu(s_op->u.getpath.handle_p[i]),
                         s_op->u.getpath.remote_addr[j], j,
                         llu(s_op->u.getpath.dirent_p[i].handle),
                         s_op->u.getpath.dirent_p[i].d_name,
                         j, index);

            gossip_debug(GOSSIP_GETPATH_DEBUG,
                         "[GETPATH]: getpath_prepare_remote_work: "
                         "dirent_p: %p, dirent.handle: %llu, "
                         "remote_dirent: %p, remote_dirent[%d]: %p\n",
                         s_op->u.getpath.dirent_p,
                         llu(s_op->u.getpath.dirent_p[i].handle),
                         s_op->u.getpath.remote_dirent,
                         j,
                         s_op->u.getpath.remote_dirent[j]);
            /* copy dirent from state machine to spot in meta server's array of
            * handles to query */
            memcpy( &(s_op->u.getpath.remote_dirent[j][index]),
                    &(s_op->u.getpath.dirent_p[i]),
                    sizeof(PVFS_dirent) );
            gossip_debug(GOSSIP_GETPATH_DEBUG,
                         "[GETPATH]: getpath_prepare_remote_work: after dirent "
                         "copy\n");

            /* store mapping of the dirent's index in the state machine's 
             * dirent_p array to the request to the meta server. */
            s_op->u.getpath.remote_to_local[j][index] = i;
            s_op->u.getpath.remote_count[j]++;
        }

        /* else no-op, handle already at root */
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: "
                     "getpath_prepare_remote_work: finished assigning %d, "
                     "handle (%llu)\n", i, s_op->u.getpath.dirent_p[i].handle);
    }
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_prepare_remote_work"
                 ": End assigning handles to meta server requests\n");


    /* count the number of meta servers that have > 0 handles to query 
     * store the index in state machine structs for that meta server.
     * this index will vary per-iteration depending on how many 
     * meta servers need to be queried to complete building paths */
    j = 0;  /* holds number of meta servers to send msgpair to */
    for( i=0; i < s_op->u.getpath.meta_num; i++ )
    {
        if( s_op->u.getpath.remote_count[i] > 0 )
        {
            meta_with_handles[j++] = i;
        }
    }

    /* all handles needing path help now reside in each metadata's server
     * getpath.remote_dirent[meta server] array. The number of dirents per 
     * metadata server is in getpath.remote_count[meta server].  
     * The number of meta servers with remote_count > 0 (in j) is the number
     * of msgpairs needed */
    ret = PINT_msgpairarray_init(&s_op->msgarray_op, j);
    if (ret)
    {
        gossip_err("get_path: failed to allocate msgarray with %d msgs\n", 
            s_op->u.getpath.meta_num);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: prepare_remote_work: "
                 "Sending out to %d meta servers\n", j);

    /* for each meta server, setup the message with the dirents and counts
     * in that servers array */
    PINT_serv_init_msgarray_params(s_op, s_op->target_fs_id);
    foreach_msgpair( &s_op->msgarray_op, msg_p, index )
    {
        /* map from msgpair index to state machine index, i is the state machine
        * array index, 'index' is the msgpair array index */
        i = meta_with_handles[index];
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: prepare_remote_work: "
                     "meta_with_handle[%d] = %d, address (%lld)\n", index, i, 
                     s_op->u.getpath.remote_addr[i] );

        PINT_util_gen_credentials(&creds);
        PINT_SERVREQ_GETPATH_FILL(
            msg_p->req,
            s_op->req->credentials,
            s_op->target_fs_id,
            s_op->target_handle,
            s_op->req->u.getpath.depth+1,
            s_op->u.getpath.remote_count[i],
            s_op->u.getpath.remote_dirent[i],
            NULL);

        msg_p->fs_id = s_op->target_fs_id;
        msg_p->handle = s_op->u.getpath.root_handle;
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = remote_resp_comp_fn; 
        memcpy( &(msg_p->svr_addr), &(s_op->u.getpath.remote_addr[i]), 
            sizeof(BMI_addr_t));
    }

    PINT_sm_push_frame(smcb, 0, &(s_op->msgarray_op));
    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_prepare_remote_work: exit\n");

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/* 
 * getpath_check_resp()
 * 
 */
static PINT_sm_action getpath_check_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;

    js_p->error_code = 0;
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_check_resp: "
                 "enter\n");

    /* move the path into the resp struct. set the response dirent handle to 
     * the next handle in building the path */
    for( i=0; i < s_op->req->u.getpath.count; i++ )
    {
        memcpy( &(s_op->resp.u.getpath.dirent[i]),
                &(s_op->u.getpath.dirent_p[i]), sizeof(PVFS_dirent) );

        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_check_resp: "
                     "response with path "
                     "(%s) for handle (%llu), next handle (%llu)\n",
                     s_op->resp.u.getpath.dirent[i].d_name,
                     s_op->resp.u.getpath.dirent[i].handle,
                     s_op->u.getpath.handle_p[i]);

        s_op->resp.u.getpath.dirent[i].handle = s_op->u.getpath.handle_p[i];
    }
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_check_resp: "
                 "exit\n");
    return SM_ACTION_COMPLETE;
}

/* 
 * getpath_remote_cleanup()
 * destroy the msgpairarray used to send the request for getpath 
 */
static PINT_sm_action getpath_remote_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int i=0;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    js_p->error_code = 0;
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_remote_cleanup: "
                 "enter\n");

    /* clear out remote_dirent, remote_to_local, and remote_count */
    for( i=0; i < s_op->u.getpath.meta_num; i++ )
    {
        memset(s_op->u.getpath.remote_to_local[i], 0, 
            (s_op->u.getpath.count * sizeof(uint32_t)) );

        memset(s_op->u.getpath.remote_dirent[i], 0, 
            (s_op->u.getpath.count * sizeof(PVFS_dirent)));
    }
    memset(s_op->u.getpath.remote_count, 0, 
        (s_op->u.getpath.meta_num * sizeof(uint32_t)));

    PINT_msgpairarray_destroy( &(s_op->msgarray_op) );

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_remote_cleanup: "
                 "exit\n");
    return SM_ACTION_COMPLETE;
}

/* 
 * getpath_cleanup()
 * free resources alloc'd by state machine
 */
static PINT_sm_action getpath_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;
    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_cleanup: enter\n");

    for( i=0; i < s_op->u.getpath.meta_num; i++ )
    {
        if( s_op->u.getpath.remote_dirent[i] )
            free( s_op->u.getpath.remote_dirent[i] );
        if( s_op->u.getpath.remote_to_local[i] )
            free( s_op->u.getpath.remote_to_local[i] );
    }

    free(s_op->u.getpath.remote_dirent); 
    free(s_op->u.getpath.remote_to_local);
    free(s_op->u.getpath.remote_addr); 
    free(s_op->u.getpath.remote_count); 

    free(s_op->u.getpath.handle_p); 
    free(s_op->u.getpath.dirent_p);
    free(s_op->resp.u.getpath.dirent); 
    
    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_cleanup: exit\n");
    return(server_state_machine_complete(smcb));
}

/* 
 * remote_resp_comp_fn 
 * move responses into the state machine's data structures
 */
static int remote_resp_comp_fn( void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index )
{
    PINT_smcb *smcb = v_p;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int i=0, j=0, meta_index=0;
                            
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                 "enter: index %d\n", index);

    /* should only be called for responses to getpath requests */
    assert(resp_p->op == PVFS_SERV_GETPATH);
    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                     "GETPATH to meta servers returned error: %d\n", 
                     resp_p->status);
        return resp_p->status;
    }

    /* the index we get is the msgpairarray index, not the index into the 
     * state machine's dirent/handle structures, figure that out again
     * j counts number of servers that had handles. */
    for( i = 0, j=0; (i < s_op->u.getpath.meta_num) && (j <= index); i++ )
    {
        /* if a metaserver doesn't have any handles, we didn't send it a msg */
        if( s_op->u.getpath.remote_count[i] > 0 )
        {
            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: "
                         "remote_resp_comp_fn: remote_count[%d]: %d\n",
                         i, s_op->u.getpath.remote_count[i]);
            if( j++ == index )
            { 
                meta_index = i;
                break; 
            }

        }
    }

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                 "response index (%d), meta server index (%d)\n",
                 index, meta_index);

    /* iterate over each handle in the response */
    for( i=0; i < resp_p->u.getpath.count; i++ )
    {
        /* sm_index maps the result back to the index in the dirent_p array.
         * paths at the root handle prior to the remote request were 
         * removed, this gives us the mapping back to the state machine's
         * dirent array */
        int sm_index = s_op->u.getpath.remote_to_local[meta_index][i];
        gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                     "sm_index: %d, meta_index: %d, i(resp iterator): %d\n", 
                     sm_index, meta_index, i);
        /* see if the handle was changed by the remote host (it should be). if
         * so, progress was made. Copy dirent and handle. */

        if( (resp_p->u.getpath.dirent[i].handle !=
            s_op->u.getpath.remote_dirent[meta_index][i].handle))
        {
            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_"
                         "fn: resp dirent_p (%llu)(%s), "
                         "handle_p (%llu)\n\t\t\t\tcurrrent dirent_p "
                         "(%llu)(%s), handle_p (%llu)\n",
                         resp_p->u.getpath.dirent[i].handle,
                         resp_p->u.getpath.dirent[i].d_name,
                         resp_p->u.getpath.dirent[i].handle,
                         llu( s_op->u.getpath.dirent_p[sm_index].handle ),
                         s_op->u.getpath.dirent_p[sm_index].d_name,
                         llu( s_op->u.getpath.handle_p[sm_index] ) );

            /* update dirent_p from response */
            memcpy( &(s_op->u.getpath.dirent_p[sm_index]),
                    &(resp_p->u.getpath.dirent[i]), sizeof(PVFS_dirent));
            s_op->u.getpath.handle_p[sm_index] =
                resp_p->u.getpath.dirent[i].handle;

            /* after a remote request dirent_p.handle and handle_p are equal */

            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_"
                         "fn: dirent_p (%llu)(%s), handle_p (%llu)\n",
                         llu( s_op->u.getpath.dirent_p[sm_index].handle ),
                         s_op->u.getpath.dirent_p[sm_index].d_name,
                         llu( s_op->u.getpath.handle_p[sm_index] ) );
        }
    }

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                 "exit\n");
    return 0;
}

/*
 * remove_bmi_from_array 
 * helper function to remove address 'remove' from array addr. count
 * is the number of BMI_addr_t entries in the addr pointer when
 * the function returns. assumes 'remove' is only present once in the array. */
static int remove_bmi_from_array( BMI_addr_t *addr, int count, 
                                  BMI_addr_t remove )
{
    int i=0, j=0;

    /* remove current host from array */
    for( i = 0, j=0; i < count+1; i++ )
    {
        /* j == i until we find the meta server remove in the list. after we
         * find out entry then i==(j-1) */
        if( (remove != addr[i]) && (j < i) )
        {
            /* need to move the address forward in the array*/
            memcpy( &(addr[j]), &(addr[i]), sizeof(BMI_addr_t));
            j++;
        }
        else if( (remove != addr[i]) && (j==i) )
        {
            j++;
        }
        else
        { /* no op */ }
    }
    assert( j == count ); /* should be 1 less than total number of metadata */

    /* realloc the space to the correct size */
    if( (addr = realloc( addr, count * sizeof(PVFS_BMI_addr_t))) == 0 )
    {
        gossip_err("get_path: failed to allocate remote_addr\n");
        return -PVFS_ENOMEM;
    }

    for( i=0; i < count; i++ )
    {
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remove address: %d, "
                     "%llu\n", i, addr[i]);
    }
                 

    return 0;
}

PINT_GET_OBJECT_REF_DEFINE(getpath);

struct PINT_server_req_params pvfs2_get_path_params =
{
    .string_name = "getpath",
    .perm = PINT_SERVER_CHECK_READ,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getpath,
    .state_machine = &pvfs2_get_path_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
