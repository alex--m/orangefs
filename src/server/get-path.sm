/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/* pvfs2_get_path_sm
 *
 * This state machine handles incoming server getpath operations.  These
 * are the operations sent by PVFS_sys_getpath().
 *
 * The pvfs2_prelude_sm is responsible for reading the actual metadata
 * to begin with, because it does this as part of the permission checking
 * process.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-types.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-perf-counter.h"
#include "pint-cached-config.h"
#include "dbpf-keyval.h"

#define ALL_PATHS_COMPLETE 100
#define NOT_HEAD 101
#define MORE_WORK 102

static int remote_resp_comp_fn( void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index );

%%

machine pvfs2_get_path_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => setup_resp;
        default => final_response;
    }

    state setup_resp
    {
        run getpath_setup_resp;
        success => read_path;
        default => final_response;
    }

    state read_path
    {
        run getpath_read_path;
        success => find_incomplete_paths;
        default => final_response;
    }

    state find_incomplete_paths
    {
        run getpath_find_incomplete_paths;
        ALL_PATHS_COMPLETE => check_for_work;
        NOT_HEAD => check_for_work;
        success => remote_query;
        default => final_response;
    }

    state remote_query
    {
        jump pvfs2_msgpairarray_sm;
        default => remote_cleanup;
    }

    state remote_cleanup
    {
        run getpath_remote_cleanup;
        default => check_for_work;
    }

    state check_for_work
    {
        run getpath_check_for_work;
        MORE_WORK => read_path;
        success => check_resp;
        default => final_response;
    }

    state check_resp
    {
        run getpath_check_resp;
        default => final_response;
    }
    
    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup   
    {
        run getpath_cleanup;
        default => terminate;
    }
}

%%

/*
 * getpath_setup_resp()
 * Set up the response - allocate needed resources
 */
static PINT_sm_action getpath_setup_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret=0, i=0, j=0, meta_serv_num=0;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *server_config = get_server_config_struct();
    BMI_addr_t host = 0;

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_setup_resp: enter\n");

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_setup_resp: "
                 "base: %d, count: %d\n", smcb->base_frame, smcb->frame_count);
    js_p->error_code = 0;
    ret = job_req_sched_post(s_op->op, s_op->target_fs_id, s_op->target_handle,
                             s_op->access_type, s_op->sched_policy,
                             smcb, 0, js_p, 
                             &(s_op->scheduled_id), server_job_context);
    PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);

    PINT_cached_config_get_root_handle(s_op->req->u.getpath.fs_id, 
        &(s_op->u.getpath.root_handle));


    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: root handle is %llu\n", 
                 llu(s_op->u.getpath.root_handle));

    s_op->u.getpath.count = s_op->req->u.getpath.count;
    s_op->resp.u.getpath.count = s_op->req->u.getpath.count;
    s_op->u.getpath.dirent_p = s_op->req->u.getpath.dirent;
    if( (s_op->u.getpath.handle_p = calloc( s_op->req->u.getpath.count, 
                                            sizeof(PVFS_handle))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    /* initialize handle_p to initial handle of query */
    for( i=0; i < s_op->u.getpath.count; i++ )
    {
        s_op->u.getpath.handle_p[i] = s_op->u.getpath.dirent_p[i].handle;
    }

    if( (s_op->resp.u.getpath.dirent = calloc( s_op->req->u.getpath.count, 
                                               sizeof(PVFS_dirent))) == 0)
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* allocate a per meta server dirent list */
    PINT_cached_config_get_num_meta( s_op->target_fs_id, &(meta_serv_num) );
    s_op->u.getpath.meta_num = meta_serv_num;
    s_op->u.getpath.meta_num--;

    if( (s_op->u.getpath.remote_dirent = calloc( s_op->u.getpath.meta_num, 
        sizeof(PVFS_dirent *))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    if( (s_op->u.getpath.remote_to_local = calloc( s_op->u.getpath.meta_num, 
                                                   sizeof(uint32_t *))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    for( i = 0; i < s_op->u.getpath.meta_num; i++ )
    {
        if( (s_op->u.getpath.remote_dirent[i] = calloc( s_op->u.getpath.count,
             sizeof(PVFS_dirent))) == 0 )
        {
            js_p->error_code = -TROVE_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        if( (s_op->u.getpath.remote_to_local[i] = calloc( s_op->u.getpath.count,
             sizeof(uint32_t))) == 0 )
        {
            js_p->error_code = -TROVE_ENOMEM;
            return SM_ACTION_COMPLETE;
        }

        for( j=0; j < s_op->u.getpath.count; j++ )
        {
            s_op->u.getpath.remote_to_local[i][j] = 0;
            s_op->u.getpath.remote_dirent[i][j].handle = 0;
        }
    }

    /* allocate a per meta server remote_count array */
    if( (s_op->u.getpath.remote_count = calloc( s_op->u.getpath.meta_num, 
        sizeof(uint32_t))) == 0 )
    {
        js_p->error_code = -TROVE_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_GETPATH_DEBUG,
                 "[GETPATH]: getpath_setup_resp: count: %u, dirent_p: %p, "
                 "handle_p: %p\n", s_op->req->u.getpath.count, 
                 s_op->u.getpath.dirent_p, s_op->u.getpath.handle_p );

    /* create array for remote addresses, add one to count for ourselves */
    if( (s_op->u.getpath.remote_addr = calloc( s_op->u.getpath.meta_num+1, 
                                               sizeof(PVFS_BMI_addr_t))) == 0 )
    {
        gossip_err("get_path: failed to allocate remote_dirent_p\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* get the addresses of the meta servers */
    ret = PINT_cached_config_get_server_array( s_op->req->u.getpath.fs_id,
        PINT_SERVER_TYPE_META, s_op->u.getpath.remote_addr, &(meta_serv_num));
    if( ret != 0 )
    {
        gossip_err("get_path: failed to get meta server addresses\n");
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* now remove our address from the list */
    ret = BMI_addr_lookup( &host, server_config->host_id );
    if( ret != 0 )
    {
        gossip_err("get_path: failed to lookup address\n");
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* remove current host from array */
    for( i = 0, j=0; i < s_op->u.getpath.meta_num+1; i++ )
    {
        if( (host != s_op->u.getpath.remote_addr[i])  && (j < i) )
        {
            memcpy( &(s_op->u.getpath.remote_addr[j]), 
                    &(s_op->u.getpath.remote_addr[i]), sizeof(BMI_addr_t));
            j++;
            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: Adding host "
                         "[%llu] to meta list\n", 
                         llu(s_op->u.getpath.remote_addr[i]) );
        }
        else if( (host != s_op->u.getpath.remote_addr[i]) && (j==i) )
        {
            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: Leaving host at "
                         "index (%llu) where it lies\n", 
                         llu(s_op->u.getpath.remote_addr[i]) );
            j++;
        }
        else
        {
            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: Removing host "
                         "%s [%llu] from meta list\n", server_config->host_id,
                         llu(s_op->u.getpath.remote_addr[i]) );
        }
    }
    assert( j == s_op->u.getpath.meta_num );

    /* realloc the space to the correct size */
    if( (s_op->u.getpath.remote_addr = realloc( s_op->u.getpath.remote_addr,
            (s_op->u.getpath.meta_num * sizeof(PVFS_BMI_addr_t)) )) == 0 )
    {
        gossip_err("get_path: failed to allocate remote_addr\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    s_op->target_fs_id = s_op->req->u.getpath.fs_id;

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_setup_resp: exit\n");
    return SM_ACTION_COMPLETE;
}

/*
 * getpath_read_path
 */
static PINT_sm_action getpath_read_path(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
 
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t i;

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_read_path: enter\n");
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_read_path: "
                 "base: %d, count: %d\n", smcb->base_frame, smcb->frame_count);
    ret = job_trove_keyval_read_value_path(
        s_op->req->u.getpath.fs_id,
        s_op->u.getpath.count,
        s_op->u.getpath.dirent_p,
        s_op->u.getpath.handle_p,
        0,
        NULL,
        smcb,
        0,
        js_p,
        &i,
        server_job_context, s_op->req->hints);

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_read_value: exit\n");
    return ret;
}

/*
 * getpath_find_incomplete_paths
 */
static PINT_sm_action getpath_find_incomplete_paths(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_sm_msgpair_state *msg_p = NULL;
    int ret=0, i=0, j=0, no_remote=0, idx=0;
    PVFS_credentials creds;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: find_incomplete_paths: "
                 "enter\n");
    js_p->error_code = 0;

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_find_incomplete_"
                 "paths: base: %d, count: %d\n", smcb->base_frame, 
                 smcb->frame_count);
    /* currently, only send requests from head node of query */
    if( s_op->req->u.getpath.depth > 0 )
    {
        js_p->error_code = NOT_HEAD;
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: find_incomplete_paths: "
                     "exit, NOT_HEAD\n");
        return SM_ACTION_COMPLETE;
    }

    /* make sure at least one handle still needs attention */
    for( i = 0; i < s_op->u.getpath.count; i++ )
    {
        if( s_op->u.getpath.handle_p[i] != s_op->u.getpath.root_handle )
        {
            no_remote++;
        }
    }
    if( no_remote == 0 )
    {
        js_p->error_code = ALL_PATHS_COMPLETE;
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: find_incomplete_paths: "
                 "exit: ALL_PATHS_COMPLETE\n");
        return SM_ACTION_COMPLETE;
    }

    /* reset remote counts */
    for( i=0; i < s_op->u.getpath.meta_num; i++ )
    {
        s_op->u.getpath.remote_count[i] = 0;
    }

    /* iterate over handles needing attention and add to appropriate meta
     * servers list(s) */
    for( i=0; i < s_op->u.getpath.count; i++ )
    {
        /* only add item if still needs handle lookups */
        if( s_op->u.getpath.handle_p[i] != s_op->u.getpath.root_handle )
        {
            for( j = 0; j < s_op->u.getpath.meta_num; j++ )
            {
                idx = s_op->u.getpath.remote_count[j];
                /* copy dirent to meta server's next free spot */
                memcpy( &(s_op->u.getpath.remote_dirent[j][idx]),
                        &(s_op->u.getpath.dirent_p[i]),
                        sizeof(PVFS_dirent) );

                s_op->u.getpath.remote_to_local[j][idx] = i;

                /* update handle sent to remote host to be the one we
                 * need them to lookup not the original one. we track that */
                s_op->u.getpath.remote_dirent[j][idx].handle = 
                    s_op->u.getpath.handle_p[i];
                s_op->u.getpath.remote_count[j]++;
            }
            gossip_debug(GOSSIP_GETPATH_DEBUG,
                         "[GETPATH]: Added handle (%llu)(%s) to "
                         "all meta data servers for (%llu)\n",
                         llu(s_op->u.getpath.handle_p[i]),
                         s_op->u.getpath.dirent_p[i].d_name,
                         llu(s_op->u.getpath.dirent_p[i].handle));
        }
    }

    /* all handles needing path resolution now reside in each metadata's server
     * getpath.remote_dirent array. The number per metadata server is in
     * getpath.remote_count. */

    /* setup the msgpairarray in case we need it */
    ret = PINT_msgpairarray_init(&s_op->msgarray_op, s_op->u.getpath.meta_num);
    if (ret)
    {
        gossip_err("get_path: failed to allocate msgarray with %d msgs\n", 
            s_op->u.getpath.meta_num);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: Sending out to %d meta "
                 "servers, msgarray_op->msgarray: %p, count: %d\n", 
                 s_op->u.getpath.meta_num, s_op->msgarray_op.msgarray,
                 s_op->msgarray_op.count);

    PINT_serv_init_msgarray_params(s_op, s_op->target_fs_id);

    /* for each meta server, setup the message with the remaining handles */
    foreach_msgpair( &s_op->msgarray_op, msg_p, i )
    {
        PINT_util_gen_credentials(&creds);
        PINT_SERVREQ_GETPATH_FILL(
            msg_p->req,
            s_op->req->credentials,
            s_op->target_fs_id,
            s_op->req->u.getpath.depth+1,
            s_op->u.getpath.remote_count[i],
            s_op->u.getpath.remote_dirent[i],
            NULL);

        msg_p->fs_id = s_op->target_fs_id;
        msg_p->handle = s_op->u.getpath.root_handle;
        msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
        msg_p->comp_fn = remote_resp_comp_fn; 
        memcpy( &(msg_p->svr_addr), &(s_op->u.getpath.remote_addr[i]), 
            sizeof(BMI_addr_t));
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: Sending msg %d to "
                     "%llu with %u handles\n", i, 
                     llu(s_op->u.getpath.remote_addr[i]), 
                     s_op->u.getpath.remote_count[i]);
    }

    PINT_sm_push_frame(smcb, 0, &(s_op->msgarray_op));
    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_find_incomplete_paths: exit\n");

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/* 
 * getpath_check_for_work()
 */
static PINT_sm_action getpath_check_for_work(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i=0, not_complete=0;
    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_check_for_work: enter\n");

    for( i=0; i < s_op->req->u.getpath.count; i++ )
    {
        if( s_op->u.getpath.handle_p[i] != s_op->u.getpath.root_handle )
        {
            not_complete++;
        }
    }

    js_p->error_code = 0;

    /* only the head node needs to keep working the problem */
    if( not_complete > 0 && s_op->req->u.getpath.depth == 0)
    {
        js_p->error_code = MORE_WORK;
    }

    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_check_for_work exit, %d left to do\n",
                 not_complete);
    return SM_ACTION_COMPLETE;
}

/* 
 * getpath_check_resp()
 */
static PINT_sm_action getpath_check_resp(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;

    js_p->error_code = 0;
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_check_resp: "
                 "enter\n");
    for( i=0; i < s_op->req->u.getpath.count; i++ )
    {
        memcpy( &(s_op->resp.u.getpath.dirent[i]),
                &(s_op->u.getpath.dirent_p[i]), sizeof(PVFS_dirent) );

        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: RESP\t (%s)(%llu) "
                     "next handle (%llu)\n",
                     s_op->resp.u.getpath.dirent[i].d_name,
                     s_op->resp.u.getpath.dirent[i].handle,
                     s_op->u.getpath.handle_p[i]);

        s_op->resp.u.getpath.dirent[i].handle = s_op->u.getpath.handle_p[i];
    }
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_check_resp: "
                 "exit\n");
    return SM_ACTION_COMPLETE;
}

/* 
 * getpath_remote_cleanup()
 */
static PINT_sm_action getpath_remote_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    js_p->error_code = 0;
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_remote_cleanup: "
                 "enter\n");
 
    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_remote_cleanup: "
                 "base: %d, count: %d\n", smcb->base_frame, smcb->frame_count);

    PINT_msgpairarray_destroy( &(s_op->msgarray_op) );

    gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: getpath_remote_cleanup: "
                 "exit\n");
    return SM_ACTION_COMPLETE;
}

/* 
 * getpath_cleanup()
 * free resources alloc'd by state machine
 */
static PINT_sm_action getpath_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i = 0;
    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_cleanup: enter\n");

    for( i=0; i < s_op->u.getpath.meta_num; i++ )
    {
        if( s_op->u.getpath.remote_dirent[i] )
            free( s_op->u.getpath.remote_dirent[i] );
    }

    free(s_op->u.getpath.remote_dirent); 
    free(s_op->u.getpath.remote_addr); 
    free(s_op->u.getpath.remote_count); 
    free(s_op->u.getpath.handle_p); 
    free(s_op->resp.u.getpath.dirent); 
    
    gossip_debug(GOSSIP_GETPATH_DEBUG, 
                 "[GETPATH]: getpath_cleanup: exit\n");
    return(server_state_machine_complete(smcb));
}

/* 
 * remote_resp_comp_fn 
 */
static int remote_resp_comp_fn( void *v_p,
                                struct PVFS_server_resp *resp_p,
                                int index )
{
    PINT_smcb *smcb = v_p;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int i=0;
                            
    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                 "enter: index %d\n", index);

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                 "resp->op: %d\n", resp_p->op );
    assert(resp_p->op == PVFS_SERV_GETPATH);
    if (resp_p->status != 0)
    {
        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                     "GETPATH to meta servers returned error: %d\n", 
                     resp_p->status);
        return resp_p->status;
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                 "before iteration with count: %d\n", resp_p->u.getpath.count);
    for( i=0; i < resp_p->u.getpath.count; i++ )
    {
        /* local_i maps the result back to the index in the dirent_p array
         * (things reaching the root handle were removed from remote_dirent */
        int local_i = s_op->u.getpath.remote_to_local[index][i];

        gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn:"
                     "resp dirent handle (%llu), remote_dirent handle (%llu)\n",
                     resp_p->u.getpath.dirent[i].handle,
                     s_op->u.getpath.remote_dirent[index][i].handle);

        /* next handle was changed by the remote host, so progress was made 
         * copy dirent and handle */
        if( resp_p->u.getpath.dirent[i].handle !=
            s_op->u.getpath.remote_dirent[index][i].handle )
        {
            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn:"
                         " meta [%d][%d] local_i[%d]\n", index, i, local_i);

            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn:"
                         "\tOld path: (%s), New path: (%s)\n",
                        s_op->u.getpath.dirent_p[local_i].d_name,
                        resp_p->u.getpath.dirent[i].d_name);

            gossip_debug(GOSSIP_GETPATH_DEBUG, "[GETPATH]: remote_resp_comp_fn:"
                         "\tInitial handle (%llu), Handle needed (%llu), "
                         "Next handle (%llu)\n\n", 
                         llu(s_op->u.getpath.dirent_p[local_i].handle),
                         llu(s_op->u.getpath.remote_dirent[index][i].handle),
                         llu(resp_p->u.getpath.dirent[i].handle));
            memcpy( s_op->u.getpath.dirent_p[local_i].d_name,
                    resp_p->u.getpath.dirent[i].d_name, PVFS_NAME_MAX+1);
            s_op->u.getpath.handle_p[local_i] =
                resp_p->u.getpath.dirent[i].handle;
        }
    }

    gossip_debug(GOSSIP_GETVALUE_DEBUG, "[GETPATH]: remote_resp_comp_fn: "
                 "enter: index %d\n", index);
    return 0;
}

PINT_GET_OBJECT_REF_DEFINE(getpath);

struct PINT_server_req_params pvfs2_get_path_params =
{
    .string_name = "getpath",
    .perm = PINT_SERVER_CHECK_READ,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_getpath,
    .state_machine = &pvfs2_get_path_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
