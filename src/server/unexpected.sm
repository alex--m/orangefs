/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#include "pvfs2-server.h"
#include "pvfs2-internal.h"
#include "pvfs2-debug.h"
#include "quicklist.h"

#define PFI()                                                                                              \
    do                                                                                                     \
    {                                                                                                      \
        gossip_debug(GOSSIP_SERVER_DEBUG, "function called: {%s}\n", __PRETTY_FUNCTION__);                 \
        fflush(stdout);                                                                                    \
    } while(0)

/* TODO are these enum values okay? */
enum {
    LOCAL_OPERATION = 2,
    REMOTE_OPERATION = 3,
    OP_CANCELLED = 4
};

%%

machine pvfs2_unexpected_sm
{
    state unexpected_post
    {
        run unexpected_post;
        default => unexpected_replace;
    }

    state unexpected_replace
    {
        run unexpected_replace;
        OP_CANCELLED => unexpected_terminate;
        default => unexpected_pjmp;
    }

    state unexpected_pjmp
    {
        pjmp unexpected_pjmp_setup
        {
            LOCAL_OPERATION => pvfs2_pjmp_unexpected_local_sm;
            REMOTE_OPERATION => pvfs2_pjmp_unexpected_remote_sm;
        }
        default => unexpected_pjmp_cleanup;
    }

    state unexpected_pjmp_cleanup
    {
        run unexpected_pjmp_cleanup;
        default => unexpected_map;
    }

    state unexpected_map
    {
        run unexpected_map;
        default => unexpected_terminate;
    }

    state unexpected_terminate
    {
        run unexpected_terminate;
        default => terminate;
    }
}

nested machine pvfs2_unexpected_local_sm
{
    state local_s1
    {
        run unexpected_work_do_nothing;
        default => return;
    }
}

nested machine pvfs2_unexpected_remote_sm
{
    state remote_s1
    {
        run unexpected_work_do_nothing;
        default => return;
    }
}

%%

/* TODO: determine if allocated memory must be zeroed or if instead every field will be set.
 * Utility function to calloc memory for server op and store the address in the referenced s_op.
 * Returns the ptr to allocated memory on success and NULL on failure.
 */
static struct PINT_server_op * init_op(struct PINT_server_op **s_op)
{
    *s_op = (struct PINT_server_op *) calloc(1, sizeof(struct PINT_server_op));
    if(*s_op == NULL)
    {
        gossip_lerr("init_op: failed to allocate memory for server op\n");
        /* TODO: WHAT TO RETURN HERE? */
        return NULL;
    }
    return *s_op;
}

/* unexpected_post()
 *
 * Post an unexpected receive
 */
static PINT_sm_action unexpected_post(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PFI();
    int ret = -PVFS_EINVAL;
    struct PINT_server_op *s_op =
            (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /*
       TODO: Consider the optimization of enabling immediate
       completion in this part of the code (see the mailing list
       thread from Feb. 2003 on pvfs2-internal).

       note: unexp_bmi_buff is really a struct that describes an
       unexpected message (it is an output parameter).
     */
    ret = job_bmi_unexp(&s_op->unexp_bmi_buff, smcb, 0,
                        js_p, &s_op->unexp_id, JOB_NO_IMMED_COMPLETE,
                        server_job_context);
    if(ret == SM_ACTION_COMPLETE)
    {
        PVFS_perror_gossip("Error: job_bmi_unexp failure", ret);
        return SM_ACTION_TERMINATE;
    }
    gossip_ldebug(GOSSIP_SERVER_DEBUG, "DEFERRING!\n");
    return SM_ACTION_DEFERRED;
}

/* unexpected_replace()
 *
 * Starts a replacement unexpected request
 */
static PINT_sm_action unexpected_replace(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    int ret = -PVFS_EINVAL;
    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    /* If op was cancelled, print WARNING */
    if (s_op->op_cancelled)
    {
        gossip_ldebug(GOSSIP_SERVER_DEBUG, "INFO: op_cancelled, terminating sm!\n");
        js_p->error_code = OP_CANCELLED;
        return SM_ACTION_COMPLETE;
    }

    /* start replacement unexpected recv */
    ret = server_post_unexpected_recv();
    if (ret < 0)
    {
        /* TODO: do something here, the return value was
         * not being checked for failure before.  I just
         * put something here to make it exit for the
         * moment.  -Phil
         */
        PVFS_perror_gossip("pvfs2_unexpected_sm.unexpected_map: server_post_unexpected_recv() returned an error: ",ret);
    }
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action unexpected_pjmp_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    struct PINT_server_op *local_op = (struct PINT_server_op *) NULL;
    struct PINT_server_op *remote_op = (struct PINT_server_op *) NULL;
    int ret = -PVFS_EINVAL;
    int remote_op_count = 0;
    int remote_op_counter = 0;

    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /* TODO Decode request */
    /* TODO setup remote operations*/

#if 0
    remote_op_count = 0;
    remote_op_count = 1;
    remote_op_count = 2;
#endif

    /* Setup 1 local op and remote ops for every remaining SID (V3) */
    init_op(&local_op);
    if(remote_op_count > 0)
    {
        /* malloc for each remote_op and push frame*/
        for(remote_op_counter = 0; remote_op_counter < remote_op_count; remote_op_counter++)
        {
            init_op(&remote_op);
            ret = PINT_sm_push_frame(smcb, REMOTE_OPERATION, remote_op);
            if(ret < 0)
            {
                gossip_lerr("unexpected_pjmp_setup failed to push frame for "
                            "remote_op where remote_op_counter = %d!\n",
                            remote_op_counter);
            }
        }
    }
    /* TODO Push local_op first or last or doesn't matter? */
    ret = PINT_sm_push_frame(smcb, LOCAL_OPERATION, local_op);
    if(ret < 0)
    {
        gossip_lerr("unexpected_pjmp_setup failed to push frame for "
                    "local_op!\n");
    }
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action unexpected_pjmp_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    struct PINT_server_op *popped_op = (struct PINT_server_op *) NULL;
    int ret = -PVFS_EINVAL;
    int task_id;
    int remaining = 1;
    PVFS_error tmp_err;
    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    do {
        popped_op = (struct PINT_server_op *) PINT_sm_pop_frame(smcb,
                                                                &task_id,
                                                                &tmp_err,
                                                                &remaining);
#if 0
#endif
        gossip_ldebug(GOSSIP_SERVER_DEBUG,
                      "unexpected_pjmp_cleanup: popping frame\n"
                      "\ttask_id = %d\n"
                      "\ttmp_err = %d\n"
                      "\tremaining = %d\n",
                      task_id, tmp_err, remaining);
        free(popped_op);
    } while(remaining > 1);
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/* unexpected_map()
 *
 * Change the state machine OP to that of the received request
 * This instance will continue execution in another state machine
 * Set up another unexpected receive
 */
static PINT_sm_action unexpected_map(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    int ret = 0;
    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    /* Remove s_op from posted_sop_list */
    qlist_del(&s_op->next);
    /* If op was cancelled, kill the SM */
    if (s_op->op_cancelled)
    {
        return SM_ACTION_TERMINATE;
    }
    /* Else move it to the inprogress_sop_list */
    qlist_add_tail(&s_op->next, &inprogress_sop_list);

    /* restart as new request state machine */
    memset(js_p, 0, sizeof(job_status_s));
    ret = server_state_machine_start(smcb, js_p);
    if (ret < 0)
    {
        PVFS_perror_gossip("Error: server_state_machine_start", ret);
        /* TODO: tell BMI to drop this address? */
        /* set return code to let this SM end
         */
        ret = SM_ACTION_TERMINATE;
    }

    return ret;
}

static PINT_sm_action unexpected_terminate(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PFI();
    return SM_ACTION_TERMINATE;
}

static PINT_sm_action unexpected_work_do_nothing(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PFI();
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
