/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */
#include <stdio.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

#include "pvfs2-server.h"
#include "pvfs2-internal.h"
#include "pvfs2-debug.h"
#include "quicklist.h"
#include "server-config.h"
#include "id-generator.h"

#define PFI()                                                                                              \
    do                                                                                                     \
    {                                                                                                      \
        gossip_debug(GOSSIP_SERVER_DEBUG, "function called: {%s}\n", __PRETTY_FUNCTION__);                 \
        fflush(stdout);                                                                                    \
    } while(0)

/* TODO are these enum values okay? */
enum {
    LOCAL_OPERATION = 2,
    REMOTE_OPERATION = 3,
    OP_CANCELLED = 4
};

%%

machine pvfs2_unexpected_sm
{
    state unexpected_post
    {
        run unexpected_post;
        default => unexpected_replace;
    }

    state unexpected_replace
    {
        run unexpected_replace;
        OP_CANCELLED => unexpected_terminate;
        default => unexpected_pjmp;
    }

    state unexpected_pjmp
    {
        pjmp unexpected_pjmp_setup
        {
            LOCAL_OPERATION => pvfs2_pjmp_unexpected_local_sm;
            REMOTE_OPERATION => pvfs2_pjmp_unexpected_remote_sm;
        }
        default => unexpected_pjmp_cleanup;
    }

    state unexpected_pjmp_cleanup
    {
        run unexpected_pjmp_cleanup;
        default => unexpected_terminate;
    }

    state unexpected_map
    {
        run unexpected_map;
        default => unexpected_terminate;
    }

    state unexpected_terminate
    {
        run unexpected_terminate;
        default => terminate;
    }
}

nested machine pvfs2_unexpected_local_sm
{
    state local_s1
    {
        run local_s1;
        default => local_s2;
    }

    state local_s2
    {
        switch;
        default => return;
    }
}

nested machine pvfs2_unexpected_remote_sm
{
    state remote_s1
    {
        run unexpected_work_do_nothing;
        default => return;
    }
}

%%

/* TODO: determine if allocated memory must be zeroed or if instead every field will be set.
 * Utility function to calloc memory for server op and store the address in the referenced s_op.
 * Returns the ptr to allocated memory on success and NULL on failure.
 */
static struct PINT_server_op * init_op(struct PINT_server_op **s_op)
{
    *s_op = (struct PINT_server_op *) calloc(1, sizeof(struct PINT_server_op));
    if(*s_op == NULL)
    {
        gossip_lerr("init_op: failed to allocate memory for server op\n");
        /* TODO: WHAT TO RETURN HERE? */
        return NULL;
    }
    return *s_op;
}

/* unexpected_post()
 *
 * Post an unexpected receive
 */
static PINT_sm_action unexpected_post(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PFI();
    int ret = -PVFS_EINVAL;
    struct PINT_server_op *s_op =
            (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    /*
       TODO: Consider the optimization of enabling immediate
       completion in this part of the code (see the mailing list
       thread from Feb. 2003 on pvfs2-internal).

       note: unexp_bmi_buff is really a struct that describes an
       unexpected message (it is an output parameter).
     */
    ret = job_bmi_unexp(&s_op->unexp_bmi_buff, smcb, 0,
                        js_p, &s_op->unexp_id, JOB_NO_IMMED_COMPLETE,
                        server_job_context);
    if(ret == SM_ACTION_COMPLETE)
    {
        PVFS_perror_gossip("Error: job_bmi_unexp failure", ret);
        return SM_ACTION_TERMINATE;
    }
    gossip_ldebug(GOSSIP_SERVER_DEBUG, "DEFERRING!\n");
    return SM_ACTION_DEFERRED;
}

/* unexpected_replace()
 *
 * Starts a replacement unexpected request
 */
static PINT_sm_action unexpected_replace(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    int ret = -PVFS_EINVAL;
    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    /* If op was cancelled, print WARNING */
    if (s_op->op_cancelled)
    {
        gossip_ldebug(GOSSIP_SERVER_DEBUG, "INFO: op_cancelled, terminating sm!\n");
        js_p->error_code = OP_CANCELLED;
        return SM_ACTION_COMPLETE;
    }

    /* start replacement unexpected recv */
    ret = server_post_unexpected_recv();
    if (ret < 0)
    {
        /* TODO: do something here, the return value was
         * not being checked for failure before.  I just
         * put something here to make it exit for the
         * moment.  -Phil
         */
        PVFS_perror_gossip("pvfs2_unexpected_sm.unexpected_map: server_post_unexpected_recv() returned an error: ",ret);
    }
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action unexpected_pjmp_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    struct PINT_server_op *local_op = (struct PINT_server_op *) NULL;
    struct PINT_server_op *remote_op = (struct PINT_server_op *) NULL;
    struct server_configuration_s *server_config_p = NULL;
    int ret = -PVFS_EINVAL;
    int remote_op_count = 0;
    int remote_op_counter = 0;

    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    server_config_p = get_server_config_struct();
    gossip_ldebug(GOSSIP_SERVER_DEBUG,
                  "server_config_p->host_index = %d\n",
                  server_config_p->host_index);

    /* Remove s_op from posted_sop_list */
    qlist_del(&s_op->next);

    /* If op was cancelled, kill the SM */
    if (s_op->op_cancelled)
    {
        return SM_ACTION_TERMINATE;
    }
#if 0
    /* Else move it to the inprogress_sop_list */
    qlist_add_tail(&s_op->next, &inprogress_sop_list);
#endif

    /* TODO Decode request */
    ret = PINT_decode(s_op->unexp_bmi_buff.buffer,
                      PINT_DECODE_REQ,
                      &s_op->decoded,
                      s_op->unexp_bmi_buff.addr,
                      s_op->unexp_bmi_buff.size);
    if (ret == -PVFS_EPROTONOSUPPORT)
    {
        /* we have a protocol mismatch of some sort; try to trigger a
         * response that gives a helpful error on client side even
         * though we can't interpret what the client was asking for
         */
        //ret = PINT_smcb_set_op(smcb, PVFS_SERV_PROTO_ERROR);
    }
    else if (ret == 0)
    {
        //TODO... remove next line
        //gossip_lerr("s_op->decoded.stub_dec.req.op = %d\n", s_op->decoded.stub_dec.req.op);
        s_op->req  = (struct PVFS_server_req *)s_op->decoded.buffer;
        /* PINT_smcb_set_op returns 1 when the op's state machine has correctly
         * been found and the first state has been set.
         */
        //ret = PINT_smcb_set_op(smcb, s_op->req->op);
        smcb->op = s_op->req->op;
        s_op->op = s_op->req->op;
        PVFS_hint_add(&s_op->req->hints, PVFS_HINT_SERVER_ID_NAME, sizeof(uint32_t), &server_config_p->host_index);
        PVFS_hint_add(&s_op->req->hints, PVFS_HINT_OP_ID_NAME,     sizeof(uint32_t), &s_op->req->op);
    }
    else
    {
        PVFS_perror_gossip("Error: PINT_decode failure", ret);
        return ret;
    }

    /* TODO setup remote operations */
#if 0
    remote_op_count = 0;
    remote_op_count = 1;
    remote_op_count = 2;
#endif

    /* Record how many frames should be popped
     * during cleanup. */
    s_op->unexpected_pjmp_frames = 1 + remote_op_count; /* +1 for the local op. */

    /* Setup 1 local op and remote ops for every remaining SID (V3) */
    init_op(&local_op); /* TODO: check return value... */
    memcpy(local_op, s_op, sizeof(PINT_server_op));
    if(remote_op_count > 0)
    {
        /* malloc for each remote_op and push frame*/
        for(remote_op_counter = 0; remote_op_counter < remote_op_count; remote_op_counter++)
        {
            init_op(&remote_op); /* TODO check return value... */
            memcpy(remote_op, s_op, sizeof(PINT_server_op));
            ret = PINT_sm_push_frame(smcb, REMOTE_OPERATION, remote_op);
            if(ret < 0)
            {
                gossip_lerr("unexpected_pjmp_setup failed to push frame for "
                            "remote_op where remote_op_counter = %d!\n",
                            remote_op_counter);
            }
        }
    }
    /* TODO Push local_op first or last or doesn't matter? */
    ret = PINT_sm_push_frame(smcb, LOCAL_OPERATION, local_op);
    if(ret < 0)
    {
        gossip_lerr("unexpected_pjmp_setup failed to push frame for "
                    "local_op!\n");
    }
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action unexpected_pjmp_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    struct PINT_server_op *popped_op = (struct PINT_server_op *) NULL;
    //int ret = -PVFS_EINVAL;
    int task_id;
    int remaining = 0;
    int popped_count = 0;
    PVFS_error tmp_err;
    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    gossip_ldebug(GOSSIP_SERVER_DEBUG,
                  "s_op->num_pjmp_frames = %d\n",
                  s_op->num_pjmp_frames);
    for(popped_count = 0; popped_count < s_op->unexpected_pjmp_frames; popped_count++)
    {
        popped_op = (struct PINT_server_op *) PINT_sm_pop_frame(smcb,
                                                                &task_id,
                                                                &tmp_err,
                                                                &remaining);
        gossip_ldebug(GOSSIP_SERVER_DEBUG,
                      "popping frame\n"
                      "\ttask_id = %d\n"
                      "\ttmp_err = %d\n"
                      "\tremaining = %d\n",
                      task_id, tmp_err, remaining);
        free(popped_op);
    }
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/* unexpected_map()
 *
 * Change the state machine OP to that of the received request
 * This instance will continue execution in another state machine
 * Set up another unexpected receive
 */
static PINT_sm_action unexpected_map(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    int ret = 0;
    PFI();
    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    /* Remove s_op from posted_sop_list */
    qlist_del(&s_op->next);
    /* If op was cancelled, kill the SM */
    if (s_op->op_cancelled)
    {
        return SM_ACTION_TERMINATE;
    }
    /* Else move it to the inprogress_sop_list */
    qlist_add_tail(&s_op->next, &inprogress_sop_list);

    /* restart as new request state machine */
    memset(js_p, 0, sizeof(job_status_s));
    ret = server_state_machine_start(smcb, js_p);
    if (ret < 0)
    {
        PVFS_perror_gossip("Error: server_state_machine_start", ret);
        /* TODO: tell BMI to drop this address? */
        /* set return code to let this SM end
         */
        ret = SM_ACTION_TERMINATE;
    }

    return ret;
}

static PINT_sm_action unexpected_terminate(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PFI();
    return SM_ACTION_TERMINATE;
}

static PINT_sm_action unexpected_work_do_nothing(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PFI();
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action local_s1(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PVFS_id_gen_t tmp_id;
    PINT_server_op *s_op = (struct PINT_server_op *) NULL;
    PFI();

    s_op = (struct PINT_server_op *) PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

#if 0
    qlist_del(&s_op->next);
#endif

    qlist_add_tail(&s_op->next, &inprogress_sop_list);

    /* set timestamp on the beginning of this state machine */
#if 0
    id_gen_fast_register(&tmp_id, s_op);
#endif

    if(s_op->req)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "client:%d, reqid:%d, rank:%d\n",
                     PINT_HINT_GET_CLIENT_ID(s_op->req->hints),
                     PINT_HINT_GET_REQUEST_ID(s_op->req->hints),
                     PINT_HINT_GET_RANK(s_op->req->hints));
        PINT_EVENT_START(PINT_sm_event_id, server_controlling_pid,
                         NULL, &s_op->event_id,
                         PINT_HINT_GET_CLIENT_ID(s_op->req->hints),
                         PINT_HINT_GET_REQUEST_ID(s_op->req->hints),
                         PINT_HINT_GET_RANK(s_op->req->hints),
                         PINT_HINT_GET_HANDLE(s_op->req->hints),
                         s_op->req->op);
        s_op->resp.op = s_op->req->op;
    }

    s_op->addr = s_op->unexp_bmi_buff.addr;
    s_op->tag  = s_op->unexp_bmi_buff.tag;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
