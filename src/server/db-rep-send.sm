/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "db.h"

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-debug.h"
#include "pvfs2-types.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-util.h"
#include "pvfs2-util.h"
#include "PINT-reqproto-encode.h"
#include "pvfs2-internal.h"

extern job_context_id dbpf_job_context;
extern struct server_configuration_s server_config;

static int msg_version = 0;

typedef struct PINT_db_rep_send_sm
{
    PVFS_fs_id fs_id;

    pthread_mutex_t mutex;
    pthread_cond_t cond;

    PVFS_error error_code;
    int comp_ct;

    PINT_sm_msgarray_op msgarray_op;

    PVFS_object_ref object_ref;
    PVFS_object_ref parent_ref;

    PVFS_ds_keyval *control;
    PVFS_ds_keyval *rec;
    PVFS_BMI_addr_t *svr_addr;
    int site_count;
    /*DB_ENV *dbenv;
    const DBT *control;
    const DBT *rec;
    const DB_LSN *lsnp;
    int eid;
    u_int32_t flags;
    dbpf_db_reptab_t *table;*/
}PINT_db_rep_send_sm;

static int db_rep_send_state_machine_terminate(struct PINT_smcb *smcb, job_status_s *js_p);
static struct PINT_state_machine_s *db_rep_send_state_get_machine(int op);

%%

machine pvfs2_db_rep_send_sm
{
    state setup_msgpairarray
    {
	run db_rep_setup_msgpairarray;
	success => xfer_msgpairarray;
        default => cleanup;
    }

    state xfer_msgpairarray
    {
	jump pvfs2_msgpairarray_sm;
        default => cleanup;
    }

    state cleanup
    {
	run db_rep_cleanup;
        default => terminate;
    }
}

%%

struct PINT_state_machine_s *db_rep_send_state_get_machine(int op)
{
    return &pvfs2_db_rep_send_sm;
}

int db_rep_send_state_machine_terminate(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    PINT_db_rep_send_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    pthread_mutex_lock(&sm_p->mutex);
    pthread_cond_signal(&sm_p->cond);
    pthread_mutex_unlock(&sm_p->mutex);
    return 0;
}

PVFS_error PVFS_db_rep_send(
    PVFS_fs_id fs_id,
    PVFS_ds_keyval *control,
    PVFS_ds_keyval *rec,
    u_int32_t flags,
    PVFS_BMI_addr_t *svr_addr,
    int site_count)
{
    PINT_smcb *smcb = NULL;
    PINT_db_rep_send_sm *sm_p = NULL;
    PINT_sm_msgpair_params *mpp;
    PINT_sm_action sm_ret;
    job_status_s js;
    static int maxsize = 0;
    //PVFS_error ret;

    gossip_debug(GOSSIP_DB_REP_DEBUG, 
		 "PVFS_db_rep_send entered\n");
    gossip_debug(GOSSIP_DB_REP_DEBUG,
		 "\tflags=%d\tcontrol.size=%d\trec.size=%d\tsite_count=%d\tversion=%d\n",
		 flags, control->buffer_sz, rec->buffer_sz, site_count, msg_version);

    if(rec->buffer_sz > maxsize)
    {
	maxsize = rec->buffer_sz;
	gossip_debug(GOSSIP_DB_REP_DEBUG, "******max size = %d*******\n", maxsize);
    }

    PINT_smcb_alloc(&smcb, 0, 
		    sizeof(struct PINT_db_rep_send_sm), 
		    db_rep_send_state_get_machine,
		    db_rep_send_state_machine_terminate,
		    dbpf_job_context);
    if(smcb == NULL)
    {
	return -PVFS_ENOMEM;
    }

    sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
		    
    /*init msgarray params*/
    mpp = &sm_p->msgarray_op.params;
    mpp->job_context = dbpf_job_context;
    mpp->job_timeout = PVFS2_CLIENT_JOB_BMI_TIMEOUT_DEFAULT;
    mpp->retry_limit = PVFS2_CLIENT_RETRY_LIMIT_DEFAULT;
    mpp->retry_delay = PVFS2_CLIENT_RETRY_DELAY_MS_DEFAULT;


    /*fill the sm*/
    pthread_mutex_init(&sm_p->mutex, NULL);
    pthread_cond_init(&sm_p->cond, NULL);
    sm_p->fs_id = fs_id;
    sm_p->control = control;
    sm_p->rec = rec;
    sm_p->svr_addr = svr_addr;
    sm_p->site_count = site_count;
    sm_p->error_code = 0;
    memset(&js, 0, sizeof(js));
    sm_ret = PINT_state_machine_start(smcb, &js);
    assert(SM_ACTION_ISVALID(sm_ret));
    if(PINT_smcb_complete(smcb))
    {
	assert(sm_ret == SM_ACTION_TERMINATE);
	PINT_smcb_free(smcb);
	gossip_debug(GOSSIP_DB_REP_DEBUG, "PVFS_db_rep_send sm terminated\n");
    }
    else if(flags & DB_REP_PERMANENT)
    {
	pthread_mutex_lock(&sm_p->mutex);
	pthread_cond_wait(&sm_p->cond, &sm_p->mutex);
	assert(PINT_smcb_complete(smcb));
	pthread_mutex_unlock(&sm_p->mutex);
	gossip_debug(GOSSIP_DB_REP_DEBUG, "PVFS_db_rep_send sm terminated after wait\n");
    }
    return js.error_code;
}

static PINT_sm_action db_rep_setup_msgpairarray(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_db_rep_send_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    PINT_sm_msgpair_state *msg_p;
    int index;

    js_p->error_code = 0;

    ret = PINT_msgpairarray_init(&sm_p->msgarray_op, sm_p->site_count);
    if(ret != 0)
    {
	gossip_err("Failed to initialize %d msgpairs\n", sm_p->site_count);
	js_p->error_code = ret;
	return SM_ACTION_COMPLETE;
    }
    foreach_msgpair(&sm_p->msgarray_op, msg_p, index)
    {
	assert(msg_p);
	PINT_SERVREQ_DBREP_FILL(msg_p->req, sm_p->fs_id, *sm_p->control, *sm_p->rec, msg_version);
	msg_p->fs_id = sm_p->fs_id;
	msg_p->handle = 0;
	msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
	msg_p->comp_fn = NULL;
	msg_p->svr_addr = sm_p->svr_addr[index];
    }
    msg_version++;
    PINT_sm_push_frame(smcb, 0, &sm_p->msgarray_op);
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action db_rep_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_db_rep_send_sm *sm_p = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    sm_p->error_code = js_p->error_code;
    free(sm_p->svr_addr);
    PINT_SET_OP_COMPLETE;
    return SM_ACTION_TERMINATE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
