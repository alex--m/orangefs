/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "src/server/request-scheduler/request-scheduler.h"
#include "trove.h"
#include "pint-util.h"
#include "pvfs2-internal.h"
#include "pint-perf-counter.h"
#include "check.h"

/* prelude state machine:
 * This is a nested state machine that performs initial setup 
 * steps that are common to many server operations.
 * - post the request to the request scheduler
 * - check permissions
 */
enum {
    PRELUDE_RUN_ACL_CHECKS = 1,
};

%%

nested machine pvfs2_prelude_work_sm
{
    state req_sched
    {
        run prelude_req_sched;
        success => getattr_if_needed;
        default => return;
    }

    state getattr_if_needed
    {
        run prelude_getattr_if_needed;
        default => validate;
    }

    state validate
    {
        run prelude_validate;
        default => return;
    }
}

nested machine pvfs2_prelude_sm
{
    state setup
    {
        run prelude_setup;
        default => prelude_work;
    }

    state prelude_work
    {
        jump pvfs2_prelude_work_sm;
        default => return;
    }
}

%%

static PINT_sm_action prelude_setup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    int ret;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    ret = PINT_server_req_get_object_ref(
        s_op->req, &s_op->target_fs_id, &s_op->target_handle);
    s_op->access_type = PINT_server_req_get_access_type(s_op->req);
    s_op->sched_policy = PINT_server_req_get_sched_policy(s_op->req);

    return SM_ACTION_COMPLETE;
}

/* prelude_req_sched()
 *
 * posts a request scheduler job
 */
static PINT_sm_action prelude_req_sched(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;

    gossip_debug(GOSSIP_SERVER_DEBUG,
        "(%p) %s (prelude sm) state: req_sched\n", s_op,
        PINT_map_server_op_to_string(s_op->req->op));

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "request\n");

    ret = job_req_sched_post(s_op->op, s_op->target_fs_id, s_op->target_handle,
                             s_op->access_type, s_op->sched_policy,
                             smcb, 0, js_p,
                             &(s_op->scheduled_id), server_job_context);

    PINT_perf_count(PINT_server_pc, PINT_PERF_REQSCHED, 1, PINT_PERF_ADD);
    return ret;
}

/* prelude_getattr_if_needed()
 *
 * reads basic attributes of target object, if there is a particular
 * target object for the operation
 */
static PINT_sm_action prelude_getattr_if_needed(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;
    job_id_t tmp_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "start\n");

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: getattr_if_needed\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    /* if the handle is 0, that indicates that the request does not
     * operate on a specific handle, so there is nothing we can do
     * here
     */
    if (s_op->target_handle == PVFS_HANDLE_NULL)
    {
        js_p->error_code = 0;
        return SM_ACTION_COMPLETE;
    }

    /* all other operations fall to this point and read basic
     * attribute information
     */
    memset(&(s_op->ds_attr), 0, sizeof(PVFS_ds_attributes));

    gossip_debug(GOSSIP_SERVER_DEBUG, "About to retrieve attributes "
                 "for handle %llu\n", llu(s_op->target_handle));

    ret = job_trove_dspace_getattr(
        s_op->target_fs_id, s_op->target_handle, smcb, &(s_op->ds_attr),
        0, js_p, &tmp_id, server_job_context);

    return ret;
}

static PINT_sm_action prelude_validate(struct PINT_smcb *smcb,
                                       job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = -PVFS_EINVAL;

    PVFS_ds_attr_to_object_attr(&s_op->ds_attr, &s_op->attr);
    s_op->attr.mask = PVFS_ATTR_COMMON_ALL;

    ret = PINT_verify_capability(&s_op->req->capability);
    if (ret)
    {
        /* TODO: perform actual permission check */
    }
    else
    {
        js_p->error_code = -PVFS_EACCES;
    }

    return SM_ACTION_COMPLETE;
}


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
