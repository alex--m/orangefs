/*
 * (C) 2001 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "src/server/request-scheduler/request-scheduler.h"
#include "trove.h"
#include "pint-util.h"
#include "pvfs2-internal.h"

/* prelude state machine:
 * This is a nested state machine that performs initial setup
 * steps that are common to many server operations.
 * - post the request to the request scheduler
 * - check permissions
 */
static int prelude_req_sched(
    PINT_server_op *s_op, job_status_s *js_p);
static int prelude_perm_check(
    PINT_server_op *s_op, job_status_s *js_p);
static int prelude_getattr_if_needed(
    PINT_server_op *s_op, job_status_s *js_p);
static int prelude_check_acls_if_needed(
    PINT_server_op *s_op, job_status_s *js_p);
static int prelude_check_acls(
    PINT_server_op *s_op, job_status_s *js_p);

enum {
    PRELUDE_RUN_ACL_CHECKS = 1,
};

%%

nested machine pvfs2_prelude_sm
{
    state req_sched
    {
        run prelude_req_sched;
        success => getattr_if_needed;
        default => return;
    }

    state getattr_if_needed
    {
        run prelude_getattr_if_needed;
        default => perm_check;
    }

    state perm_check
    {
        run prelude_perm_check;
        PRELUDE_RUN_ACL_CHECKS => check_acls_if_needed;
        default => return;
    }

    state check_acls_if_needed
    {
        run prelude_check_acls_if_needed;
        default => check_acls;
    }

    state check_acls
    {
        run prelude_check_acls;
        default => return;
    }
}

%%

/* prelude_req_sched()
 *
 * posts a request scheduler job
 */
static int prelude_req_sched(
    PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;

    gossip_debug(GOSSIP_SERVER_DEBUG,
        "(%p) %s (prelude sm) state: req_sched\n", s_op,
        PINT_map_server_op_to_string(s_op->req->op));

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "request\n");

    /* this is the first state for every normal pvfs2 server state
     * machine, so we get to do some housekeeping here.  In
     * particular, bump up the reference count on the bmi address that
     * we are using
     */
    BMI_set_info(s_op->addr, BMI_INC_ADDR_REF, NULL);

    /* this is a bit of a hack; if we are changing server mode we must
     * preserve the old mode value before calling req scheduler
     */
    if ((s_op->op == PVFS_SERV_MGMT_SETPARAM) &&
        (s_op->req->u.mgmt_setparam.param == PVFS_SERV_PARAM_MODE))
    {
        s_op->resp.u.mgmt_setparam.old_value = PINT_req_sched_get_mode();
    }

    ret = job_req_sched_post(s_op->req, 0, s_op, 0, js_p,
                             &(s_op->scheduled_id), server_job_context);

    return ret;
}

/* prelude_getattr_if_needed()
 *
 * reads basic attributes of target object, if there is a particular
 * target object for the operation
 */
static int prelude_getattr_if_needed(
    PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -PVFS_EINVAL, readonly_flag = 0;
    job_id_t tmp_id;

    PINT_ACCESS_DEBUG(s_op, GOSSIP_ACCESS_DETAIL_DEBUG, "start\n");

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: getattr_if_needed\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    /* first, run a request scheduler utility function that tells us
     * what handle this request will operate on
     */
    ret = PINT_req_sched_target_handle(
        s_op->req, 0, &s_op->target_handle,
        &s_op->target_fs_id, &readonly_flag);

    if (ret < 0)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "PINT_req_sched_target_handle "
                     "returned %d ret, skipping getattr on handle %llu\n",
                     ret, llu(s_op->target_handle));

        js_p->error_code = ret;
        return 1;
    }

    /* if the handle is 0, that indicates that the request does not
     * operate on a specific handle, so there is nothing we can do
     * here
     */
    if (s_op->target_handle == PVFS_HANDLE_NULL)
    {
        js_p->error_code = 0;
        return 1;
    }

    /* all other operations fall to this point and read basic
     * attribute information
     */
    memset(&(s_op->ds_attr), 0, sizeof(PVFS_ds_attributes));

    gossip_debug(GOSSIP_SERVER_DEBUG, "About to retrieve attributes "
                 "for handle %llu\n", llu(s_op->target_handle));

    ret = job_trove_dspace_getattr(
        s_op->target_fs_id, s_op->target_handle,
        s_op, &(s_op->ds_attr),
        0, js_p, &tmp_id, server_job_context);

    return ret;
}

static void get_fs_intent(struct PVFS_server_req *req, PVFS_fs_id *fsid, int *read_only)
{
    if (req == NULL)
    {
        *fsid = PVFS_FS_ID_NULL;
        *read_only = -1;
        return;
    }
    switch (req->op)
    {
        case PVFS_SERV_CREATE:
            *fsid = req->u.create.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_REMOVE:
            *fsid = req->u.remove.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_IO:
            *fsid = req->u.io.fs_id;
            *read_only = (req->u.io.io_type == PVFS_IO_READ) ? 1 : 0;
            break;
        case PVFS_SERV_GETATTR:
            *fsid = req->u.getattr.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_SETATTR:
            *fsid = req->u.setattr.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_LOOKUP_PATH:
            *fsid = req->u.lookup_path.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_CRDIRENT:
            *fsid = req->u.crdirent.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_RMDIRENT:
            *fsid = req->u.rmdirent.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_CHDIRENT:
            *fsid = req->u.chdirent.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_TRUNCATE:
            *fsid = req->u.truncate.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_MKDIR:
            *fsid = req->u.mkdir.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_READDIR:
            *fsid = req->u.readdir.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_FLUSH:
            *fsid = req->u.flush.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_MGMT_SETPARAM:
            *fsid = req->u.mgmt_setparam.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_STATFS:
            *fsid = req->u.statfs.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_MGMT_ITERATE_HANDLES:
            *fsid = req->u.mgmt_iterate_handles.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_MGMT_DSPACE_INFO_LIST:
            *fsid = req->u.mgmt_dspace_info_list.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_MGMT_REMOVE_OBJECT:
            *fsid = req->u.mgmt_remove_object.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_MGMT_REMOVE_DIRENT:
            *fsid = req->u.mgmt_remove_dirent.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_MGMT_GET_DIRDATA_HANDLE:
            *fsid = req->u.mgmt_get_dirdata_handle.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_GETEATTR:
            *fsid = req->u.geteattr.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_SETEATTR:
            *fsid = req->u.seteattr.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_DELEATTR:
            *fsid = req->u.deleattr.fs_id;
            *read_only = 0;
            break;
        case PVFS_SERV_LISTEATTR:
            *fsid = req->u.listeattr.fs_id;
            *read_only = 1;
            break;
        case PVFS_SERV_PROTO_ERROR:
        case PVFS_SERV_JOB_TIMER:
        case PVFS_SERV_MGMT_EVENT_MON:
        case PVFS_SERV_MGMT_PERF_MON:
        case PVFS_SERV_PERF_UPDATE:
        case PVFS_SERV_MGMT_NOOP:
        case PVFS_SERV_WRITE_COMPLETION:
        case PVFS_SERV_GETCONFIG:
        default:
            *fsid = PVFS_FS_ID_NULL;
            *read_only = -1;
            break;
    }
    return;
}

static void get_anon_ids(struct filesystem_configuration_s *fsconfig,
    PVFS_uid *uid, PVFS_gid *gid)
{
    *uid = fsconfig->exp_anon_uid;
    *gid = fsconfig->exp_anon_gid;
    return;
}

static int iterate_all_squash_wildcards(struct filesystem_configuration_s *fsconfig,
    PVFS_BMI_addr_t client_addr)
{
    int i;

    for (i = 0; i < fsconfig->all_squash_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "BMI_query_addr_range %lld, %s\n",
            lld(client_addr), fsconfig->all_squash_hosts[i]);
        if (BMI_query_addr_range(client_addr, fsconfig->all_squash_hosts[i],
                fsconfig->all_squash_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

static int iterate_root_squash_wildcards(struct filesystem_configuration_s *fsconfig,
    PVFS_BMI_addr_t client_addr)
{
    int i;

    for (i = 0; i < fsconfig->root_squash_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "BMI_query_addr_range %lld, %s\n",
            lld(client_addr), fsconfig->root_squash_hosts[i]);
        if (BMI_query_addr_range(client_addr, fsconfig->root_squash_hosts[i],
                fsconfig->root_squash_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

/* Translate_ids will return 1 if it did some uid/gid squashing, 0 otherwise */
static int translate_ids(PVFS_fs_id fsid, PVFS_uid uid, PVFS_gid gid,
    PVFS_uid *translated_uid, PVFS_gid *translated_gid, PVFS_BMI_addr_t client_addr)
{
    int exp_flags = 0;
    struct server_configuration_s *serv_config = NULL;
    struct filesystem_configuration_s * fsconfig = NULL;

    serv_config = PINT_get_server_config();
    fsconfig = PINT_config_find_fs_id(serv_config, fsid);

    if (fsconfig == NULL)
    {
        return 0;
    }
    exp_flags = fsconfig->exp_flags;
    /* If all squash was set */
    if (exp_flags & TROVE_EXP_ALL_SQUASH)
    {
        if (iterate_all_squash_wildcards(fsconfig, client_addr) == 1)
        {
            get_anon_ids(fsconfig, translated_uid, translated_gid);
            gossip_debug(GOSSIP_SERVER_DEBUG,
                "Translated ids from <%u:%u> to <%u:%u>\n",
                uid, gid, *translated_uid, *translated_gid);
            return 1;
        }
    }
    /* if only root squash was set translate uids for root alone*/
    if (exp_flags & TROVE_EXP_ROOT_SQUASH)
    {
        if (uid == 0 || gid == 0)
        {
            if (iterate_root_squash_wildcards(fsconfig, client_addr) == 1)
            {
                get_anon_ids(fsconfig, translated_uid, translated_gid);
                gossip_debug(GOSSIP_SERVER_DEBUG,
                    "Translated ids from <%u:%u> to <%u:%u>\n",
                    uid, gid, *translated_uid, *translated_gid);
                return 1;
            }
        }
    }
    /* no such translation required! */
    *translated_uid = uid;
    *translated_gid = gid;
    return 0;
}

static int iterate_ro_wildcards(struct filesystem_configuration_s *fsconfig, PVFS_BMI_addr_t client_addr)
{
    int i;

    for (i = 0; i < fsconfig->ro_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG, "BMI_query_addr_range %lld, %s\n",
            lld(client_addr), fsconfig->ro_hosts[i]);
        /* Does the client address match the wildcard specification and/or the netmask specification? */
        if (BMI_query_addr_range(client_addr, fsconfig->ro_hosts[i],
                fsconfig->ro_netmasks[i]) == 1)
        {
            return 1;
        }
    }
    return 0;
}

static int permit_operation(PVFS_fs_id fsid, int read_only, PVFS_BMI_addr_t client_addr)
{
    int exp_flags = 0;
    struct server_configuration_s *serv_config = NULL;
    struct filesystem_configuration_s * fsconfig = NULL;

    if (read_only == 1)
    {
        return 0;
    }
    serv_config = PINT_get_server_config();
    fsconfig = PINT_config_find_fs_id(serv_config, fsid);

    if (fsconfig == NULL)
    {
        return 0;
    }
    exp_flags = fsconfig->exp_flags;

    /* cheap test to see if ReadOnly was even specified in the exportoptions */
    if (!(exp_flags & TROVE_EXP_READ_ONLY))
    {
        return 0;
    }
    /* Drat. Iterate thru the list of wildcards specified in server_configuration and see
     * the client address matches. if yes, then we deny permission
     */
    if (iterate_ro_wildcards(fsconfig, client_addr) == 1)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
            "Disallowing read-write operation on a read-only exported file-system\n");
        return -EROFS;
    }
    return 0;
}

/* prelude_perm_check()
 *
 * this really just marks the spot where we would want to do
 * permission checking, it will be replaced by a couple of states that
 * actually perform this task later
 */
static int prelude_perm_check(
    PINT_server_op *s_op, job_status_s *js_p)
{
    PVFS_object_attr *obj_attr = NULL;
    PVFS_ds_attributes *ds_attr = NULL;
    PVFS_uid translated_uid = s_op->req->credentials.uid;
    PVFS_gid translated_gid = s_op->req->credentials.gid;
    PVFS_fs_id  fsid;
    int  rdonly = -1;

    /* moved gossip server debug output to end of state, so we can report
     * resulting status value.
     */

    /*
      first we translate the dspace attributes into a more convenient
      server use-able format.  i.e. a PVFS_object_attr
    */
    ds_attr = &s_op->ds_attr;
    obj_attr = &s_op->attr;
    PVFS_ds_attr_to_object_attr(ds_attr, obj_attr);
    s_op->attr.mask = PVFS_ATTR_COMMON_ALL;
    /* Set the target object attribute pointer.. used later by the acl check */
    s_op->target_object_attr = obj_attr;

    /* Commenting out the below block for now.  I think this code is
     * deprecated?  Even if not all of the attributes have been filled in
     * yet, we should still be able to read them after the object has been
     * created.  If this change seems stable then we need to also come back
     * and remove the PINT_SERVER_ATTRIBS_NOT_REQUIRED flag. -Phil 4-13-2006
     */
#if 0
    /* the next thing we need to do is interpret the error code from
     * reading the attributes.  Normally it is an error if that step
     * failed, but we have to look for the special case in which we
     * set attributes on a file that did not have attributes
     * previously.
     */
    if (PINT_server_req_table[s_op->req->op].attrib_flags ==
        PINT_SERVER_ATTRIBS_NOT_REQUIRED)
    {
        js_p->error_code = 0;
    }
#endif
    get_fs_intent(s_op->req, &fsid, &rdonly);
    if (fsid != PVFS_FS_ID_NULL)
    {
        /*
         * if we are exporting a volume readonly, disallow any operation that modifies
         * the state of the file-system.
         */
        if (permit_operation(fsid, rdonly, s_op->addr) < 0)
        {
            js_p->error_code = -PVFS_EROFS;
            return 1;
        }
        else
        {
            /* Translate the uid and gid's in case we need to do some squashing based on the export and the client address */
            if (translate_ids(fsid, s_op->req->credentials.uid, s_op->req->credentials.gid,
                &translated_uid, &translated_gid, s_op->addr) == 1)
            {
                s_op->req->credentials.uid = translated_uid;
                s_op->req->credentials.gid = translated_gid;
                /* in the case of a setattr, translate the ids as well right here */
                if (s_op->req->op == PVFS_SERV_SETATTR)
                {
                    s_op->req->u.setattr.attr.owner = translated_uid;
                    s_op->req->u.setattr.attr.group = translated_gid;
                }
                else if (s_op->req->op == PVFS_SERV_MKDIR)
                {
                    s_op->req->u.mkdir.attr.owner = translated_uid;
                    s_op->req->u.mkdir.attr.group = translated_gid;
                }
            }
       }
    }

    /* anything else we treat as a real error */
    if (js_p->error_code)
    {
        js_p->error_code = -PVFS_ERROR_CODE(-js_p->error_code);
        return(1);
    }

    gossip_debug(
        GOSSIP_PERMISSIONS_DEBUG, "PVFS operation \"%s\" got "
        "attr mask %d\n\t(attr_uid_valid? %s, attr_owner = "
        "%d, credentials_uid = %d)\n\t(attr_gid_valid? %s, attr_group = "
        "%d, credentials.gid = %d)\n",
        PINT_map_server_op_to_string(s_op->req->op), s_op->attr.mask,
        ((s_op->attr.mask & PVFS_ATTR_COMMON_UID) ? "yes" : "no"),
        s_op->attr.owner, translated_uid,
        ((s_op->attr.mask & PVFS_ATTR_COMMON_GID) ? "yes" : "no"),
        s_op->attr.group, translated_gid);

    switch(PINT_server_req_table[s_op->req->op].perm)
    {
        case PINT_SERVER_CHECK_WRITE:
            js_p->error_code = PINT_check_mode(
                &(s_op->attr), translated_uid,
                translated_gid, PINT_ACCESS_WRITABLE);
            break;
        case PINT_SERVER_CHECK_READ:
            js_p->error_code = PINT_check_mode(
                &(s_op->attr), translated_uid,
                translated_gid, PINT_ACCESS_READABLE);
            break;
        case PINT_SERVER_CHECK_CRDIRENT:
            /* must also check executable after writable */
            js_p->error_code = PINT_check_mode(
                &(s_op->attr), translated_uid,
                translated_gid, PINT_ACCESS_WRITABLE);
            if(js_p->error_code == 0)
            {
                js_p->error_code = PINT_check_mode(
                    &(s_op->attr), translated_uid,
                    translated_gid, PINT_ACCESS_EXECUTABLE);
            }
            break;
        case PINT_SERVER_CHECK_ATTR:
            /* let datafiles pass through the attr check */
            if (s_op->attr.objtype == PVFS_TYPE_DATAFILE)
            {
                js_p->error_code = 0;
            }
            /* for now we'll assume extended attribs are treated
             * the same as regular attribs as far as permissions
             */
	    else if (s_op->req->op == PVFS_SERV_GETATTR ||
                    s_op->req->op == PVFS_SERV_GETEATTR ||
                    s_op->req->op == PVFS_SERV_LISTEATTR)
	    {
		/* getting or listing attributes is always ok -- permission
		 * is checked on the parent directory at read time
		 */
		js_p->error_code = 0;
	    }
            else /* setattr, seteattr, seteattr_list */
            {
                /*
                  NOTE: on other file systems, setattr doesn't
                  seem to require read permissions by the user, group
                  OR other, so long as the user or group matches (or
                  is root)
                */
                if (((s_op->attr.mask & PVFS_ATTR_COMMON_UID) &&
                     ((s_op->attr.owner == 0) ||
                      (s_op->attr.owner == translated_uid))) ||
                    (((s_op->attr.mask & PVFS_ATTR_COMMON_GID) &&
                      ((s_op->attr.group == 0) ||
                       (s_op->attr.group == translated_gid)))) ||
                    (translated_uid == 0))
                {
                    js_p->error_code = 0;
                }
                else
                {
                    js_p->error_code = -PVFS_EACCES;
                }
            }
            break;
        case PINT_SERVER_CHECK_NONE:
            js_p->error_code = 0;
            break;
        case PINT_SERVER_CHECK_INVALID:
            js_p->error_code = -PVFS_EINVAL;
            break;
    }

    gossip_debug(
        GOSSIP_PERMISSIONS_DEBUG, "Final permission check for \"%s\" set "
        "error code to %d\n", PINT_map_server_op_to_string(s_op->req->op),
        js_p->error_code);

    gossip_debug(GOSSIP_SERVER_DEBUG,
        "(%p) %s (prelude sm) state: perm_check (status = %d)\n",
	s_op,
        PINT_map_server_op_to_string(s_op->req->op),
	js_p->error_code);
    /* If regular checks fail, we need to run acl checks */
    if (js_p->error_code == -PVFS_EACCES)
        js_p->error_code = PRELUDE_RUN_ACL_CHECKS;
    return 1;
}


static int prelude_check_acls_if_needed(
    PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -PVFS_EINVAL;
    job_id_t i;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "(%p) %s (prelude sm) state: prelude_check_acls_if_needed\n", s_op,
                 PINT_map_server_op_to_string(s_op->req->op));

    /* If we get here with an invalid fsid and handle, we have to
     * return -PVFS_EACCESS
     */
    if (s_op->target_fs_id == PVFS_FS_ID_NULL
        || s_op->target_handle == PVFS_HANDLE_NULL)
    {
        js_p->error_code = -PVFS_EACCES;
        return 1;
    }
    js_p->error_code = 0;

    memset(&s_op->key, 0, sizeof(PVFS_ds_keyval));
    memset(&s_op->val, 0, sizeof(PVFS_ds_keyval));
    s_op->key.buffer = "system.posix_acl_access";
    s_op->key.buffer_sz = strlen(s_op->key.buffer) + 1;
    s_op->val.buffer = (char *) malloc(PVFS_REQ_LIMIT_VAL_LEN);
    if (!s_op->val.buffer)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return 1;
    }
    s_op->val.buffer_sz = PVFS_REQ_LIMIT_VAL_LEN;

    gossip_debug(GOSSIP_PERMISSIONS_DEBUG, "About to retrieve acl keyvals "
                 "for handle %llu\n", llu(s_op->target_handle));

    /* Read acl keys */
    ret = job_trove_keyval_read(
        s_op->target_fs_id,
        s_op->target_handle,
        &s_op->key,
        &s_op->val,
        0,
        NULL,
        s_op,
        0,
        js_p,
        &i,
        server_job_context);
    return ret;
}

static int prelude_check_acls(
    PINT_server_op *s_op, job_status_s *js_p)
{
    PVFS_object_attr *obj_attr = NULL;
    int want = 0;

    /* The dspace attr must have been read at this point */
    obj_attr = s_op->target_object_attr;
    assert(obj_attr);

    /* anything non-zero we treat as a real error */
    if (js_p->error_code)
    {
        goto cleanup;
    }
    /* make sure that we hit here only for metafiles, dirs and symlink objects */
    if (obj_attr->objtype != PVFS_TYPE_METAFILE
        && obj_attr->objtype != PVFS_TYPE_DIRECTORY
        && obj_attr->objtype != PVFS_TYPE_SYMLINK)
    {
        gossip_err("prelude_check_acls hit invalid object type %d\n",
            obj_attr->objtype);
        js_p->error_code = -PVFS_EINVAL;
        goto cleanup;
    }
    switch (PINT_server_req_table[s_op->req->op].perm)
    {
        case PINT_SERVER_CHECK_WRITE:
        default:
            want = PVFS2_ACL_WRITE;
            break;
        case PINT_SERVER_CHECK_READ:
            want = PVFS2_ACL_READ;
            break;
        case PINT_SERVER_CHECK_CRDIRENT:
            want = PVFS2_ACL_WRITE | PVFS2_ACL_EXECUTE;
            break;
        case PINT_SERVER_CHECK_NONE:
            want = 0;
            break;
        case PINT_SERVER_CHECK_INVALID:
            js_p->error_code = -PVFS_EINVAL;
            goto cleanup;
    }
    js_p->error_code = PINT_check_acls(s_op->val.buffer,
                        s_op->val.read_sz,
                        obj_attr,
                        s_op->req->credentials.uid,
                        s_op->req->credentials.gid,
                        want);
cleanup:
    gossip_debug(
        GOSSIP_PERMISSIONS_DEBUG, "Final permission check (after acls) \"%s\" set "
        "error code to %d (want %x)\n",
            PINT_map_server_op_to_string(s_op->req->op),
            js_p->error_code, want);

    if (s_op->val.buffer)
        free(s_op->val.buffer);
    memset(&s_op->key, 0, sizeof(PVFS_ds_keyval));
    memset(&s_op->val, 0, sizeof(PVFS_ds_keyval));
    return 1;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
