/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */


#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "request-scheduler.h"
#include "trove.h"

/* prelude state machine:
 * This is a nested state machine that performs initial setup 
 * steps that are common to many server operations.
 * - post the request to the request scheduler
 * - check permissions
 */

/* TODO: document pre and post conditions (what server_op fields do we
 * require, and which ones do we modify?
 */

static int prelude_req_sched(PINT_server_op *s_op, job_status_s *js_p);
static int prelude_perm_check(PINT_server_op *s_op, job_status_s *js_p);
static int prelude_getattr_if_needed(PINT_server_op *s_op, job_status_s *js_p);

extern PINT_server_trove_keys_s Trove_Common_Keys[];
extern job_context_id PINT_server_job_context;

%%

nested machine pvfs2_prelude_sm(req_sched, getattr_if_needed, perm_check)
{
    state req_sched
    {
	run prelude_req_sched;
	success => getattr_if_needed;
	default => return;
    }

    state getattr_if_needed
    {
	run prelude_getattr_if_needed;
	default => perm_check;
    }

    state perm_check
    {
	run prelude_perm_check;
	default => return;
    }
}


%%

/* prelude_req_sched()
 *
 * posts a request scheduler job
 */
static int prelude_req_sched(PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -1;

    gossip_debug(SERVER_DEBUG, "(%p) prelude state: req_sched\n", s_op);

    ret = job_req_sched_post(s_op->req,
	s_op,
	js_p,
	&(s_op->scheduled_id),
	PINT_server_job_context);

    return(ret);
}

/* prelude_getattr_if_needed()
 *
 * reads basic attributes of target object, if there is a particular target
 * object for the operation
 */
static int prelude_getattr_if_needed(PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -1;
    PVFS_handle target_handle = 0;
    PVFS_fs_id target_fs_id = 0;
    job_id_t tmp_id;

    gossip_debug(SERVER_DEBUG, "(%p) prelude state: getattr_if_needed\n", s_op);

    /* first, run a request scheduler utility function that tells us
     * what handle this request will operate on
     */
    ret = PINT_req_sched_target_handle(s_op->req, &target_handle, 
	&target_fs_id);
    if(ret < 0)
    {
	js_p->error_code = ret;
	return(1);
    }

    /* if the handle is 0, that indicates that the request does not
     * operate on a specific handle, so there is nothing we can do here
     */
    if(target_handle == 0)
    {
	js_p->error_code = 0;
	return(1);
    }

    /* all other operations fall to this point and read basic attribute
     * information 
     */
    s_op->key.buffer    = Trove_Common_Keys[METADATA_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[METADATA_KEY].size;
    s_op->val.buffer    = &s_op->attr;
    s_op->val.buffer_sz = sizeof(PVFS_object_attr);

    ret = job_trove_keyval_read(target_fs_id,
	target_handle,
	&(s_op->key),
	&(s_op->val),
	0,
	NULL,
	s_op,
	js_p,
	&tmp_id,
	PINT_server_job_context);

    return(ret);
}

/* prelude_perm_check()
 *
 * this really just marks the spot where we would want to do permission checking,
 * it will be replaced by a couple of states that actually perform this task
 * later
 */
static int prelude_perm_check(PINT_server_op *s_op, job_status_s *js_p)
{
    gossip_debug(SERVER_DEBUG, "(%p) prelude state: perm_check\n", s_op);

    /* the first thing we need to do is interpret the error code from reading
     * the attributes.  Normally it is an error if that step failed, but we 
     * have to look for the special case in which we set attributes on a file
     * that did not have attributes previously.  
     */
    /* also, we aren't storing any attributes with datafiles yet */
    if((js_p->error_code == -TROVE_ENOENT) && 
	(s_op->req->op == PVFS_SERV_SETATTR || s_op->req->op == PVFS_SERV_IO))
    {
	js_p->error_code = 0;
    }

    /* anything else we treat as a real error */
    if(js_p->error_code)
    {
	/* convert to a PVFS error code; we don't have any special semantics
	 * for error codes at this particular spot, so just remove trove mask
	 */
	js_p->error_code = -js_p->error_code;
	js_p->error_code &= ~PVFS_ERROR_TROVE;
	js_p->error_code = -js_p->error_code;
	return(1);
    }
	
    /* TODO: actually check permissions, now that we have all the info
     * that we need 
     */
    gossip_debug(SERVER_DEBUG, "(%p) warning: not really checking permissions.\n", s_op);

    js_p->error_code = 0;
    return(1);
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */

