/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */


#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "request-scheduler.h"
#include "trove.h"

/* prelude state machine:
 * This is a nested state machine that performs initial setup 
 * steps that are common to many server operations.
 * - post the request to the request scheduler
 * - check permissions
 */

/* TODO: document pre and post conditions (what server_op fields do we
 * require, and which ones do we modify?) 
 * TODO: don't forget in particular to document what we do with the 
 * s_op->attr structure, so other state machines know how to use it
 */

static int prelude_req_sched(PINT_server_op *s_op, job_status_s *js_p);
static int prelude_perm_check(PINT_server_op *s_op, job_status_s *js_p);
static int prelude_getattr_if_needed(PINT_server_op *s_op, job_status_s *js_p);

static int check_mode(PVFS_object_attr* attr, PVFS_uid uid, PVFS_gid gid,
    PVFS_permissions mode);

extern PINT_server_trove_keys_s Trove_Common_Keys[];
extern job_context_id PINT_server_job_context;

%%

nested machine pvfs2_prelude_sm(req_sched, getattr_if_needed, perm_check)
{
    state req_sched
    {
	run prelude_req_sched;
	success => getattr_if_needed;
	default => return;
    }

    state getattr_if_needed
    {
	run prelude_getattr_if_needed;
	default => perm_check;
    }

    state perm_check
    {
	run prelude_perm_check;
	default => return;
    }
}


%%

/* prelude_req_sched()
 *
 * posts a request scheduler job
 */
static int prelude_req_sched(PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -1;

    gossip_debug(SERVER_DEBUG, "(%p) prelude state: req_sched\n", s_op);

    ret = job_req_sched_post(s_op->req,
	s_op,
	js_p,
	&(s_op->scheduled_id),
	PINT_server_job_context);

    return(ret);
}

/* prelude_getattr_if_needed()
 *
 * reads basic attributes of target object, if there is a particular target
 * object for the operation
 */
static int prelude_getattr_if_needed(PINT_server_op *s_op, job_status_s *js_p)
{
    int ret = -1;
    PVFS_handle target_handle = 0;
    PVFS_fs_id target_fs_id = 0;
    job_id_t tmp_id;

    gossip_debug(SERVER_DEBUG, "(%p) prelude state: getattr_if_needed\n", s_op);

    /* first, run a request scheduler utility function that tells us
     * what handle this request will operate on
     */
    ret = PINT_req_sched_target_handle(s_op->req, &target_handle, 
	&target_fs_id);
    if(ret < 0)
    {
	js_p->error_code = ret;
	return(1);
    }

    /* if the handle is 0, that indicates that the request does not
     * operate on a specific handle, so there is nothing we can do here
     */
    if(target_handle == 0)
    {
	js_p->error_code = 0;
	return(1);
    }

    /* all other operations fall to this point and read basic attribute
     * information 
     */
    s_op->key.buffer    = Trove_Common_Keys[METADATA_KEY].key;
    s_op->key.buffer_sz = Trove_Common_Keys[METADATA_KEY].size;
    s_op->val.buffer    = &s_op->attr;
    s_op->val.buffer_sz = sizeof(PVFS_object_attr);

    ret = job_trove_keyval_read(target_fs_id,
	target_handle,
	&(s_op->key),
	&(s_op->val),
	0,
	NULL,
	s_op,
	js_p,
	&tmp_id,
	PINT_server_job_context);

    return(ret);
}

/* prelude_perm_check()
 *
 * this really just marks the spot where we would want to do permission checking,
 * it will be replaced by a couple of states that actually perform this task
 * later
 */
static int prelude_perm_check(PINT_server_op *s_op, job_status_s *js_p)
{
    gossip_debug(SERVER_DEBUG, "(%p) prelude state: perm_check\n", s_op);

    /* the first thing we need to do is interpret the error code from reading
     * the attributes.  Normally it is an error if that step failed, but we 
     * have to look for the special case in which we set attributes on a file
     * that did not have attributes previously.  
     */
    /* also, we aren't storing any attributes with datafiles yet */
    if((js_p->error_code == -TROVE_ENOENT) && 
	(s_op->req->op == PVFS_SERV_SETATTR || s_op->req->op == PVFS_SERV_IO))
    {
	js_p->error_code = 0;
    }

    /* anything else we treat as a real error */
    if(js_p->error_code)
    {
	/* convert to a PVFS error code; we don't have any special semantics
	 * for error codes at this particular spot, so just remove trove mask
	 */
	js_p->error_code = -js_p->error_code;
	js_p->error_code &= ~PVFS_ERROR_TROVE;
	js_p->error_code = -js_p->error_code;
	return(1);
    }

    /* lets clean up the mask to insure that later states don't accidentally
     * use fields that they shouldn't (really the attr structure should 
     * already be stored on disk like this)
     */
     s_op->attr.mask &= PVFS_ATTR_COMMON_ALL;
	
    /* decide what kind of permission checking to do based on the 
     * request type:
     */
    switch(s_op->req->op)
    {
	/* things that need read permissions */
	case PVFS_SERV_GETATTR:
	case PVFS_SERV_READDIR:
	    /* TODO: figure out something cleaner looking than using 
	     * PVFS_U_READ here to indicate we need read access; its 
	     * misleading
	     */
	    js_p->error_code = check_mode(&(s_op->attr), 
		s_op->req->credentials.uid,
		s_op->req->credentials.gid,
		PVFS_U_READ);
	    break;

	/* things that need write permissions */
	case PVFS_SERV_CREATEDIRENT:
	case PVFS_SERV_RMDIRENT:
	    /* TODO: figure out something cleaner looking than using 
	     * PVFS_U_WRITE here to indicate we need read access; its 
	     * misleading
	     */
	    js_p->error_code = check_mode(&(s_op->attr), 
		s_op->req->credentials.uid,
		s_op->req->credentials.gid,
		PVFS_U_WRITE);
	    break;
	/* special case: we only check permissions on setattr if it 
	 * already has attributes
	 */
	case PVFS_SERV_SETATTR:
	    if(s_op->attr.mask == 0)
	    {
		js_p->error_code = 0;
	    }
	    else
	    {
		js_p->error_code = check_mode(&(s_op->attr), 
		    s_op->req->credentials.uid,
		    s_op->req->credentials.gid,
		    PVFS_U_WRITE);
	    }
	    break;

	/* things we don't check permissions on */
	case PVFS_SERV_CREATE:
	case PVFS_SERV_REMOVE:
	case PVFS_SERV_IO:
	case PVFS_SERV_LOOKUP_PATH:
	case PVFS_SERV_TRUNCATE:
	case PVFS_SERV_MKDIR:
	case PVFS_SERV_GETCONFIG:
	    js_p->error_code = 0;
	    break;

	/* things we shouldn't see here */
	case PVFS_SERV_INVALID: 
	case PVFS_SERV_WRITE_COMPLETION:
	    assert(0);
	    js_p->error_code = -PVFS_EINVAL;
	    break;
    }

    return(1);
}


/* check_mode()
 *
 * checks permissions based on desired mode
 *
 * returns 0 on success, -PVFS_EPERM on failure
 */
static int check_mode(PVFS_object_attr* attr, PVFS_uid uid, PVFS_gid gid,
    PVFS_permissions mode)
{
    uint32_t perm_mask = PVFS_ATTR_COMMON_UID | PVFS_ATTR_COMMON_GID |
	PVFS_ATTR_COMMON_PERM;

    /* if we don't have masks for the permission information that we need,
     * then the system is broken 
     */
    assert((attr->mask & perm_mask) == perm_mask);

    /* give root permissions, no matter what */
    if(attr->owner == 0)
	return(0);
    /* uid test */
    if((attr->owner == uid) && (((attr->perms >> 6) & mode) == mode))
	return(0);
    /* gid test */
    if((attr->group == gid) && (((attr->perms >> 3) & mode) == mode))
	return(0);
    /* other test */
    if((attr->perms & mode) == mode)
	return(0);

    /* access denied */
    return(-PVFS_EPERM);
}


/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 noexpandtab
 */

