/* 
 * (C) 2008 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "extent-utils.h"

#define	MAX_PARTITIONS	2

enum
{
    LOCAL_OPERATION = 2,
    REMOTE_OPERATION = 3
};

/* completion function prototypes */
static int tree_get_file_size_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index);

%%

machine pvfs2_tree_remove_sm
{
    state tree_remove_do_work
    {
        jump pvfs2_tree_remove_work_sm;
        default => tree_remove_final_response;
    }

    state tree_remove_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_remove_cleanup;
    }

    state tree_remove_cleanup
    {
        run tree_remove_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_remove_work_sm
{
    state tree_remove_work_do_work
    {
        pjmp tree_remove_setup
        {
            REMOTE_OPERATION => pvfs2_call_msgpairarray_sm;
            LOCAL_OPERATION => pvfs2_remove_work_sm;
        }
        default => tree_remove_work_cleanup;
    }

    state tree_remove_work_cleanup
    {
        run tree_remove_work_cleanup;
        default => return;
    }
}

machine pvfs2_tree_get_file_size_sm
{
    state tree_get_file_size_do_work
    {
        jump pvfs2_tree_get_file_size_work_sm;
        default => tree_get_file_size_final_response;
    }

    state tree_get_file_size_final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_get_file_size_cleanup;
    }

    state tree_get_file_size_cleanup
    {
        run tree_get_file_size_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_get_file_size_work_sm
{
    state tree_get_file_size_work_do_work
    {
        pjmp tree_get_file_size_setup
        {
            REMOTE_OPERATION => pvfs2_call_msgpairarray_sm;
            LOCAL_OPERATION => pvfs2_get_attr_with_prelude_sm;
        }
        default => tree_get_file_size_work_cleanup;
    }

    state tree_get_file_size_work_cleanup
    {
        run tree_get_file_size_work_cleanup;
        default => return;
    }
}

%%

static PINT_sm_action tree_communicate_partition_handles(struct PINT_smcb *smcb, job_status_s *js_p,
    int num_data_files, PVFS_fs_id fs_id, enum PVFS_server_op operation,
    PVFS_handle *handle_array)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *tree_communicate_s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int num_partitions, num_files_per_server;
    int i;
    char server_name[1024];
    struct server_configuration_s *server_config = get_server_config_struct();
    int ret = -PVFS_EINVAL;
    struct PVFS_server_req *req = NULL;

    s_op->u.tree_communicate.handle_array_local = calloc(
        num_data_files, sizeof(*s_op->u.tree_communicate.handle_array_local));
    s_op->u.tree_communicate.handle_array_remote = calloc(
        num_data_files, sizeof(*s_op->u.tree_communicate.handle_array_remote));
    if (!s_op->u.tree_communicate.handle_array_local ||
        !s_op->u.tree_communicate.handle_array_remote)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* Separate the handles into local and remote. */
    for (i = 0; i < num_data_files; i++)
    {
        PINT_cached_config_get_server_name(server_name, 1024, handle_array[i], fs_id);
        if (! strcmp(server_config->host_id, server_name)) /* this one is local */
        {
            gossip_debug(GOSSIP_SERVER_DEBUG,
                     "tree_communicate_partition_handles: local handle = %llu\n",
                     llu(handle_array[i]));
            s_op->u.tree_communicate.handle_array_local[
                 s_op->u.tree_communicate.handle_array_local_count] = handle_array[i];
            s_op->u.tree_communicate.handle_array_local_count++;
        }
        else
        {
            gossip_debug(GOSSIP_SERVER_DEBUG,
                     "tree_communicate_partition_handles: remote handle = %llu\n",
                     llu(handle_array[i]));
            s_op->u.tree_communicate.handle_array_remote[
                 s_op->u.tree_communicate.handle_array_remote_count] = handle_array[i];
            s_op->u.tree_communicate.handle_array_remote_count++;
        }
    }

    if (s_op->u.tree_communicate.handle_array_local_count > 0) {
        /* Create a stack frame for the local operation. */
        s_op->num_pjmp_frames++;
        js_p->error_code = LOCAL_OPERATION;

        PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, tree_communicate_s_op,
            s_op->u.tree_communicate.handle_array_local[0],
            fs_id, js_p->error_code, req, LOCAL_OPERATION);

        switch (operation)
        {
            case PVFS_SERV_TREE_REMOVE:
            {
/* TODO: Need to pass along hints. */
                PINT_SERVREQ_REMOVE_FILL(
                    *req,
                    s_op->req->credentials,
                    fs_id,
                    s_op->u.tree_communicate.handle_array_local[0],
                    NULL);

                break;
            }

            case PVFS_SERV_TREE_GET_FILE_SIZE:
            {
/* TODO: Need to pass along hints. */
                PINT_SERVREQ_GETATTR_FILL(
                    *req,
                    s_op->req->credentials,
                    fs_id,
                    s_op->u.tree_communicate.handle_array_local[0],
                    PVFS_ATTR_DATA_SIZE,
                    NULL);

                break;
            }

            default:
                break;
        }
    }

    if (s_op->u.tree_communicate.handle_array_remote_count > 0) {
      /* Decide how to divide the remote handles. If there are only a few (MAX_PARTITIONS or
         fewer) then go ahead and send to each remaining server individually. */
      if (s_op->u.tree_communicate.handle_array_remote_count > MAX_PARTITIONS)
      {
          num_partitions = MAX_PARTITIONS;
          num_files_per_server = s_op->u.tree_communicate.handle_array_remote_count /
                   MAX_PARTITIONS;
          if (num_partitions * num_files_per_server <
                   s_op->u.tree_communicate.handle_array_remote_count) {
              num_files_per_server++;
          }
      }
      else
      {
          num_partitions = s_op->u.tree_communicate.handle_array_remote_count;
          num_files_per_server = 1;
      }

    gossip_debug(GOSSIP_SERVER_DEBUG,
        "tree_communicate_partition_handles: num_data_files = %d, num_remote_handles = %d, num_partitions = %d, num_files_per_server = %d\n",
        num_data_files, s_op->u.tree_communicate.handle_array_remote_count, num_partitions, num_files_per_server);

        /* We need to send tree-based messages to other servers */
        js_p->error_code = REMOTE_OPERATION;
        s_op->num_pjmp_frames++;

        /* Prepare the stack for pjmp. */
        PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, tree_communicate_s_op,
           s_op->u.tree_communicate.handle_array_remote[0],
           fs_id, js_p->error_code, req, REMOTE_OPERATION);

        s_op->u.tree_communicate.num_partitions = num_partitions;
        ret = PINT_msgpairarray_init(&tree_communicate_s_op->msgarray_op, num_partitions);
        if (ret)
        {
            gossip_lerr("tree_communicate: failed to allocate msgarray\n");
            return -PVFS_ENOMEM;
        }
        /* Fill in the msgarray. */
        for (i = 0; i < num_partitions; i++)
        {
            PINT_sm_msgpair_state *msg_p;
            int num_data_files_for_this_server;

            /* Handle the case where the last partition has fewer files than the other partitions. */
            for (num_data_files_for_this_server = num_files_per_server;
                 i*num_files_per_server + num_data_files_for_this_server >
                 s_op->u.tree_communicate.handle_array_remote_count;
                 num_data_files_for_this_server--)
            {
                /* Do nothing; */ ;
            }

            msg_p = &tree_communicate_s_op->msgarray_op.msgarray[i];

            switch (operation)
            {
                case PVFS_SERV_TREE_REMOVE:
                {
/* TODO: Need to pass along hints. */
                    PINT_SERVREQ_TREE_REMOVE_FILL(
                        msg_p->req,
                        s_op->req->credentials,
                        fs_id,
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server],
                        NULL);
                    msg_p->comp_fn = NULL;
                    break;
                }
    
                case PVFS_SERV_TREE_GET_FILE_SIZE:
                {

/* TODO: Need to pass along hints. */
                    PINT_SERVREQ_TREE_GET_FILE_SIZE_FILL(
                        msg_p->req,
                        s_op->req->credentials,
                        fs_id,
                        (i-1)*num_files_per_server+1,
                        num_data_files_for_this_server,
                        &s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server],
                        NULL);
                    msg_p->comp_fn = tree_get_file_size_comp_fn;
                    break;
                }

                default:
                    break;
            }

            msg_p->fs_id = fs_id;
            msg_p->handle =
            s_op->u.tree_communicate.handle_array_remote[i*num_files_per_server];
            msg_p->retry_flag = PVFS_MSGPAIR_RETRY;

            ret = PINT_cached_config_map_to_server(&msg_p->svr_addr, msg_p->handle,
                 msg_p->fs_id);
            if (ret)
            {
                gossip_err("Failed to map server address\n");
            }
        }
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action tree_remove_setup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);

    return (tree_communicate_partition_handles(smcb, js_p, s_op->req->u.tree_remove.num_data_files,
        s_op->req->u.tree_remove.fs_id, PVFS_SERV_TREE_REMOVE,
        s_op->req->u.tree_remove.handle_array));
}

static int tree_remove_work_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i, task_id, error_code;
    PINT_server_op *old_frame;

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);
    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (task_id == REMOTE_OPERATION) {
           PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        free(old_frame);
    }

    return SM_ACTION_COMPLETE;
}
 
static int tree_remove_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    return(server_state_machine_complete(smcb));
}
 
static PINT_sm_action tree_get_file_size_setup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    assert(s_op->req->op == PVFS_SERV_TREE_GET_FILE_SIZE);

    s_op->resp.u.tree_get_file_size.caller_handle_index =
            s_op->req->u.tree_get_file_size.caller_handle_index;
    s_op->resp.u.tree_get_file_size.handle_count =
            s_op->req->u.tree_get_file_size.num_data_files;

    /* allocate response arrays */
    s_op->resp.u.tree_get_file_size.error = (PVFS_error *)
        calloc(s_op->req->u.tree_get_file_size.num_data_files, sizeof(PVFS_error));
    s_op->resp.u.tree_get_file_size.size = (PVFS_size *)
        calloc(s_op->req->u.tree_get_file_size.num_data_files, sizeof(PVFS_size));
    if (! s_op->resp.u.tree_get_file_size.error ||
        ! s_op->resp.u.tree_get_file_size.size)
    {
        gossip_err("tree_get_file_size: failed to allocate arrays\n");
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    return (tree_communicate_partition_handles(smcb, js_p,
        s_op->req->u.tree_get_file_size.num_data_files,
        s_op->req->u.tree_get_file_size.fs_id, PVFS_SERV_TREE_GET_FILE_SIZE,
        s_op->req->u.tree_get_file_size.handle_array));
}

static int tree_get_file_size_comp_fn(
    void *v_p, struct PVFS_server_resp *resp_p, int index)
{
    PINT_smcb *smcb = v_p;
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    int i;

    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_get_file_size_comp_fn[%d], caller_handle_index = %d\n",
                 index, resp_p->u.tree_get_file_size.caller_handle_index);

    assert(resp_p->op == PVFS_SERV_TREE_GET_FILE_SIZE);

    if (resp_p->status != 0)
    {
        PVFS_perror_gossip("Get file size failure", resp_p->status);
        return resp_p->status;
    }

    /* stash the sizes and error codes for each file handle */
    gossip_debug(GOSSIP_SERVER_DEBUG,
             "tree_get_file_size_comp_fn: resp_p->u.tree_get_file_size.handle_count is %d\n",
             resp_p->u.tree_get_file_size.handle_count);

    memset(&(s_op->resp), 0, sizeof(s_op->resp));
    s_op->resp.u.tree_get_file_size.caller_handle_index = 
        resp_p->u.tree_get_file_size.caller_handle_index;
    s_op->resp.u.tree_get_file_size.handle_count = resp_p->u.tree_get_file_size.handle_count;

    s_op->resp.u.tree_get_file_size.error = (PVFS_error *)
        calloc(resp_p->u.tree_get_file_size.handle_count, sizeof(PVFS_error));
    s_op->resp.u.tree_get_file_size.size = (PVFS_size *)
        calloc(resp_p->u.tree_get_file_size.handle_count, sizeof(PVFS_size));
    if (! s_op->resp.u.tree_get_file_size.error ||
        ! s_op->resp.u.tree_get_file_size.size)
    {
        gossip_err("tree_get_file_size_comp_fn: failed to allocate arrays\n");
        return(-PVFS_ENOMEM);
    }

    for (i = 0; i < resp_p->u.tree_get_file_size.handle_count; i++)
    {
        gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_get_file_size_comp_fn: size of datafile %d is %lld\n",
                 i, lld(resp_p->u.tree_get_file_size.size[i]));
        s_op->resp.u.tree_get_file_size.size[i] =
                        resp_p->u.tree_get_file_size.size[i];

        gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_get_file_size_comp_fn: error code for datafile %d is %d\n",
                 i, resp_p->u.tree_get_file_size.error[i]);
        s_op->resp.u.tree_get_file_size.error[i] =
                        resp_p->u.tree_get_file_size.error[i];
    }

    return 0;
}

static int tree_get_file_size_work_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i, j, task_id, error_code;
    PINT_server_op *old_frame;

    assert(s_op->req->op == PVFS_SERV_TREE_GET_FILE_SIZE);
    gossip_debug(GOSSIP_SERVER_DEBUG,
                 "tree_get_file_size_work_cleanup: num_pjmp_frames = %d\n", s_op->num_pjmp_frames);
    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (task_id == REMOTE_OPERATION) {
            for (j = 0; j < old_frame->resp.u.tree_get_file_size.handle_count; j++)
            {
                gossip_debug(GOSSIP_SERVER_DEBUG,
                            "tree_get_file_size_work_cleanup: size of remote datafile %d is %lld\n",
                            j, lld(old_frame->resp.u.tree_get_file_size.size[j]));
                s_op->resp.u.tree_get_file_size.size
                      [old_frame->resp.u.tree_get_file_size.caller_handle_index+j +
                       s_op->u.tree_communicate.handle_array_local_count]
                   = old_frame->resp.u.tree_get_file_size.size[j];
                s_op->resp.u.tree_get_file_size.error
                      [old_frame->resp.u.tree_get_file_size.caller_handle_index+j +
                       s_op->u.tree_communicate.handle_array_local_count]
                   = old_frame->resp.u.tree_get_file_size.error[j];
            }
            free(old_frame->resp.u.tree_get_file_size.size);
            free(old_frame->resp.u.tree_get_file_size.error);
            PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        else {
/* TODO: Determine correct location to store result if there is more than one local file. */
            gossip_debug(GOSSIP_SERVER_DEBUG,
                         "tree_get_file_size_work_cleanup: size of local datafile is %lld\n",
                         lld(old_frame->resp.u.getattr.attr.u.data.size));
            s_op->resp.u.tree_get_file_size.caller_handle_index = 0;
            s_op->resp.u.tree_get_file_size.size[0] = old_frame->resp.u.getattr.attr.u.data.size;
            s_op->resp.u.tree_get_file_size.error[0] = error_code;
         }
        free(old_frame);
    }

    return SM_ACTION_COMPLETE;
}
 
static int tree_get_file_size_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    return(server_state_machine_complete(smcb));
}

static inline int PINT_get_object_ref_tree_remove(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.tree_remove.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

struct PINT_server_req_params pvfs2_tree_remove_params =
{
    .string_name = "tree_remove",
    .get_object_ref = PINT_get_object_ref_tree_remove,
    .perm = PINT_SERVER_CHECK_NONE,
    .access_type = PINT_server_req_modify,
    .state_machine = &pvfs2_tree_remove_sm
};

static inline int PINT_get_object_ref_tree_get_file_size(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.tree_get_file_size.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

struct PINT_server_req_params pvfs2_tree_get_file_size_params =
{
    .string_name = "tree_get_file_size",
    .get_object_ref = PINT_get_object_ref_tree_get_file_size,
    .perm = PINT_SERVER_CHECK_NONE,
    .access_type = PINT_server_req_readonly,
    .state_machine = &pvfs2_tree_get_file_size_sm
};

