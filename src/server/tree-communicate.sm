/* 
 * (C) 2008 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 */

/** \file
 *  \ingroup sysint
 *
 *  PVFS2 system interface routines for creating files.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"

#include "client-state-machine.h"
#include "pvfs2-debug.h"
#include "pvfs2-dist-simple-stripe.h"
#include "job.h"
#include "gossip.h"
#include "str-utils.h"
#include "pint-cached-config.h"
#include "pint-distribution.h"
#include "PINT-reqproto-encode.h"
#include "pint-util.h"
#include "pint-dist-utils.h"
#include "ncache.h"
#include "pvfs2-internal.h"
#include "extent-utils.h"

#define	MAX_PARTITIONS	2

enum
{
    LOCAL_OPERATION = 2,
    REMOTE_OPERATION = 3
};

%%

machine pvfs2_tree_remove_sm
{
    state do_work
    {
        jump pvfs2_tree_remove_work_sm;
        default => final_response;
    }

    state final_response
    {
        jump pvfs2_final_response_sm;
        default => tree_remove_cleanup;
    }

    state tree_remove_cleanup
    {
        run tree_remove_cleanup;
        default => terminate;
    }
}

nested machine pvfs2_tree_remove_work_sm
{
    state tree_remove_do_work
    {
        pjmp tree_remove_setup
        {
            REMOTE_OPERATION => pvfs2_call_msgpairarray_sm;
            LOCAL_OPERATION => pvfs2_remove_work_sm;
        }
        success => tree_remove_work_cleanup;
/* TODO: need error handline */
        default => return;
    }

    state tree_remove_work_cleanup
    {
        run tree_remove_work_cleanup;
        default => return;
    }
}

%%

static PINT_sm_action tree_communicate_partition_handles(struct PINT_smcb *smcb, job_status_s *js_p,
    int num_data_files, PVFS_fs_id fs_id, enum PVFS_server_op operation,
    PVFS_handle *handle_array)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *tree_communicate_s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int num_partitions, num_files_per_server;
    int i;
    char server_name[1024];
    struct server_configuration_s *server_config = get_server_config_struct();
    int ret = -PVFS_EINVAL;
//    PINT_sm_msgpair_state *msg_p = NULL;
    struct PVFS_server_req *req;

    gossip_debug(GOSSIP_SERVER_DEBUG, "tree_communicate_partition_handles entered\n");
    s_op->u.tree_remove.handle_array_local = malloc(
        sizeof(*s_op->u.tree_remove.handle_array_local) * num_data_files);
    s_op->u.tree_remove.handle_array_remote = malloc(
        sizeof(*s_op->u.tree_remove.handle_array_remote) * num_data_files);
    if (!s_op->u.tree_remove.handle_array_local ||
        !s_op->u.tree_remove.handle_array_remote)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    /* Separate the handles into local and remote. */
    for (i = 0; i < num_data_files; i++)
    {
        PINT_cached_config_get_server_name(server_name, 1024, handle_array[i], fs_id);
        if (! strcmp(server_config->host_id, server_name)) /* this one is local */
        {
            gossip_debug(GOSSIP_SERVER_DEBUG,
                     "tree_communicate_partition_handles: local handle = %llu\n",
                     llu(handle_array[i]));
            s_op->u.tree_remove.handle_array_local[
                 s_op->u.tree_remove.handle_array_local_count] = handle_array[i];
            s_op->u.tree_remove.handle_array_local_count++;
        }
        else
        {
            gossip_debug(GOSSIP_SERVER_DEBUG,
                     "tree_communicate_partition_handles: remote handle = %llu\n",
                     llu(handle_array[i]));
            s_op->u.tree_remove.handle_array_remote[
                 s_op->u.tree_remove.handle_array_remote_count] = handle_array[i];
            s_op->u.tree_remove.handle_array_remote_count++;
        }
    }

    if (s_op->u.tree_remove.handle_array_local_count > 0) {
      /* Create a stack frame for the local operation. */
      s_op->num_pjmp_frames++;
      js_p->error_code = LOCAL_OPERATION;

      PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, tree_communicate_s_op,
          s_op->u.tree_remove.handle_array_local[0],
          fs_id, js_p->error_code, req, LOCAL_OPERATION);

/* TODO: Need to pass along hints. */
      PINT_SERVREQ_REMOVE_FILL(
          *req,
          s_op->req->credentials,
          fs_id,
          s_op->u.tree_remove.handle_array_local[0],
          NULL);
    }

    if (s_op->u.tree_remove.handle_array_remote_count > 0) {
      /* Decide how to divide the remote handles. If there are only a few (MAX_PARTITIONS or
         fewer) then go ahead and send to each remaining server individually. */
      if (s_op->u.tree_remove.handle_array_remote_count > MAX_PARTITIONS)
      {
          num_partitions = MAX_PARTITIONS;
          num_files_per_server = s_op->u.tree_remove.handle_array_remote_count /
                   MAX_PARTITIONS;
          if (num_partitions * num_files_per_server <
                   s_op->u.tree_remove.handle_array_remote_count) {
              num_files_per_server++;
          }
      }
      else
      {
          num_partitions = s_op->u.tree_remove.handle_array_remote_count;
          num_files_per_server = 1;
      }

    gossip_debug(GOSSIP_SERVER_DEBUG,
        "tree_communicate_partition_handles: num_data_files = %d, num_remote_handles = %d, num_partitions = %d, num_files_per_server = %d\n",
        num_data_files, s_op->u.tree_remove.handle_array_remote_count, num_partitions, num_files_per_server);

        /* We need to send tree-based messages to other servers */
        js_p->error_code = REMOTE_OPERATION;
        s_op->num_pjmp_frames++;

        /* Prepare the stack for pjmp. */
        PINT_CREATE_SUBORDINATE_SERVER_FRAME(smcb, tree_communicate_s_op,
           s_op->u.tree_remove.handle_array_remote[0],
           fs_id, js_p->error_code, req, REMOTE_OPERATION);

        ret = PINT_msgpairarray_init(&tree_communicate_s_op->msgarray_op, num_partitions);
        if (ret)
        {
            gossip_lerr("tree_communicate: failed to allocate msgarray\n");
            return -PVFS_ENOMEM;
        }
        /* Fill in the msgarray. */
        for (i = 0; i < num_partitions; i++)
        {
            PINT_sm_msgpair_state *msg_p;
            int num_data_files_for_this_server;

            /* Handle the case where the last partition has fewer files than the other partitions. */
            for (num_data_files_for_this_server = num_files_per_server;
                 i*num_files_per_server + num_data_files_for_this_server >
                 s_op->u.tree_remove.handle_array_remote_count;
                 num_data_files_for_this_server--)
            {
                /* Do nothing; */ ;
            }

            msg_p = &tree_communicate_s_op->msgarray_op.msgarray[i];

            switch (operation)
            {
                case PVFS_SERV_TREE_REMOVE:
                {
/* TODO: Need to pass along hints. */
                    PINT_SERVREQ_TREE_REMOVE_FILL(
                        msg_p->req,
                        s_op->req->credentials,
                        fs_id,
                        num_data_files_for_this_server,
                        &s_op->u.tree_remove.handle_array_remote[i*num_files_per_server],
                        NULL);
                    msg_p->fs_id = fs_id;
                    msg_p->handle =
                        s_op->u.tree_remove.handle_array_remote[i*num_files_per_server];
                    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                    msg_p->comp_fn = NULL;
                    break;
                }
    
                default:
                    break;
            }

            ret = PINT_cached_config_map_to_server(&msg_p->svr_addr, msg_p->handle,
                 msg_p->fs_id);
            if (ret)
            {
                gossip_err("Failed to map server address\n");
            }
        }
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action tree_remove_setup(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i;

    gossip_debug(GOSSIP_SERVER_DEBUG, "tree_remove_setup entered\n");

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);
    gossip_debug(GOSSIP_SERVER_DEBUG, "tree_remove_setup: num_data_files = %d\n", s_op->req->u.tree_remove.num_data_files);
    for (i = 0; i < s_op->req->u.tree_remove.num_data_files; i++) {
        gossip_debug(GOSSIP_SERVER_DEBUG,
            "tree_remove_setup: handle[%d] %llu\n",
            i, llu(s_op->req->u.tree_remove.handle_array[i]));
    }

    return (tree_communicate_partition_handles(smcb, js_p, s_op->req->u.tree_remove.num_data_files,
        s_op->req->u.tree_remove.fs_id, PVFS_SERV_TREE_REMOVE,
        s_op->req->u.tree_remove.handle_array));
}

static int tree_remove_work_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    /* get frame from bottom of stack */
    PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i, task_id, error_code;
    PINT_server_op *old_frame;

    assert(s_op->req->op == PVFS_SERV_TREE_REMOVE);
    /* for each state machine spawned, pop a frame */
    for (i = 0; i < s_op->num_pjmp_frames; i++)
    {
        old_frame = PINT_sm_pop_frame(smcb, &task_id, &error_code, NULL);
        if (task_id == REMOTE_OPERATION) {
           PINT_msgpairarray_destroy(&old_frame->msgarray_op);
        }
        free(old_frame);
    }

    return SM_ACTION_COMPLETE;
}
 
static int tree_remove_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    return(server_state_machine_complete(smcb));
}
 

static inline int PINT_get_object_ref_tree_remove(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id = req->u.tree_remove.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

struct PINT_server_req_params pvfs2_tree_remove_params =
{
    .string_name = "tree_remove",
    .get_object_ref = PINT_get_object_ref_tree_remove,
    .perm = PINT_SERVER_CHECK_NONE,
    .access_type = PINT_server_req_modify,
    .state_machine = &pvfs2_tree_remove_sm
};

