/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

/*
 *  PVFS2 server state machine for driving read I/O operations.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-request.h"
#include "pint-distribution.h"
#include "pint-request.h"
#include "pvfs2-internal.h"
#include "pint-cached-config.h"
#include "trove.h"

#define CONTINUE_ALLREDUCE 201

%%

nested machine pvfs2_allreduce_sm
{
    state allreduce
    {
        run allreduce_fn;
        default => check_allreduce;
    }

    state check_allreduce
    {
	run check_allreduce_done;
	CONTINUE_ALLREDUCE => allreduce;
	default => return;
    }
}

%%

/*
 */
static PINT_sm_action allreduce_fn(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *user_opts = get_server_config_struct();
    job_id_t tmp_id;
    int ret;
    int myRank = s_op->u.allreduce.myRank, newRank;
    PVFS_handle new_rank_handle;
    PVFS_BMI_addr_t svr_addr;
    double *tmp = s_op->u.allreduce.send_buf;
    PVFS_msg_tag_t session_tag;

    js_p->error_code = 0;

    newRank = myRank^(s_op->u.allreduce.mask);
    gossip_debug(GOSSIP_IO_DEBUG, "myRank=%d, newRank=%d\n", myRank, newRank);
    new_rank_handle = s_op->u.allreduce.dfile_array[newRank];
    gossip_debug(GOSSIP_IO_DEBUG, "new_rank_handle=%llu\n", llu(new_rank_handle));
    ret = PINT_cached_config_map_to_server(&svr_addr,
					   new_rank_handle,
					   s_op->u.allreduce.fs_id);

    if(ret < 0) {
	gossip_err("Failed to map meta server address\n");
	js_p->error_code = ret;
	return SM_ACTION_COMPLETE;
    }

    session_tag = 3333;

    /* RECV */
    if(s_op->u.allreduce.type == 1) {
	gossip_debug(GOSSIP_IO_DEBUG, "RECV from addr=%llu\n", llu(svr_addr));
	ret = job_bmi_recv(svr_addr,
			   (void*)s_op->u.allreduce.recv_buf,
			   5*sizeof(double),
			   session_tag,
			   BMI_PRE_ALLOC,
			   smcb,
			   0,
			   js_p,
			   &tmp_id,
			   server_job_context,
			   user_opts->server_job_bmi_timeout,
			   (bmi_hint)s_op->u.allreduce.hints);
	
	if(ret == 1) {
	    js_p->error_code = ret;
	    return SM_ACTION_COMPLETE;
	}
	
	if(ret == 0) {
	    js_p->error_code = ret;
	    return SM_ACTION_DEFERRED;
	}
    }
    /* SEND */
    else if(s_op->u.allreduce.type == 0) {
	gossip_debug(GOSSIP_IO_DEBUG, "SEND to addr=%llu: tmp=%f\n", 
		     llu(svr_addr), *tmp);
	ret = job_bmi_send(svr_addr,
			   (void*)s_op->u.allreduce.send_buf,
			   5*sizeof(double),
			   session_tag,
			   BMI_PRE_ALLOC,
			   0, /* 1: send_unexpected */
			   smcb,
			   0,
			   js_p,
			   &tmp_id,
			   server_job_context,
			   user_opts->server_job_bmi_timeout,
			   (bmi_hint)s_op->u.allreduce.hints);
	
	if(ret == 1) {
	    js_p->error_code = ret;
	    return SM_ACTION_COMPLETE;
	}
	
	if(ret == 0) {
	    js_p->error_code = ret;
	    return SM_ACTION_DEFERRED;
	}
    }
	
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action check_allreduce_done(struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    double *a = s_op->u.allreduce.send_buf;
    double *b = s_op->u.allreduce.recv_buf;

    s_op->u.allreduce.current_depth++;
    s_op->u.allreduce.mask = s_op->u.allreduce.mask << 1;

    a[0] = a[0] + b[0];
    memcpy(s_op->u.allreduce.send_buf, (void*)a, sizeof(double));

    gossip_debug(GOSSIP_IO_DEBUG, "received=%lf\n", *b);
    gossip_debug(GOSSIP_IO_DEBUG, "current_depth=%d, tree_depth=%d\n",
		 s_op->u.allreduce.current_depth, 
		 s_op->u.allreduce.tree_depth);
    if(s_op->u.allreduce.current_depth < s_op->u.allreduce.tree_depth)
	js_p->error_code = CONTINUE_ALLREDUCE;
    else
	js_p->error_code = 0;

    gossip_debug(GOSSIP_IO_DEBUG, "%s: reduced result=%lf\n", 
		 __func__, *a);

    return SM_ACTION_COMPLETE;
}

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
