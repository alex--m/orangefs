/*
 * (C) 2001 Clemson University and The University of Chicago
 *
 * See COPYING in top-level directory.
 *
 */
#include <assert.h>

#include "pvfs2-server.h"
#include "pvfs2-types.h"
#include "request-scheduler/request-scheduler.h"
#include "thread-mgr.h"
#include "gossip.h"
#include "pint-util.h"
#include "server-config.h"
#include "trove-handle-mgmt/trove-extentlist.h"
#include "pint-cached-config.h"
#include "pvfs2-util.h"
#include "trove-dbpf/dbpf.h"

/*
 * Enums for use in state machine control
 */
enum
{
    FSCK_SM_ACTION_START = 170,
    FSCK_SM_ACTION_STOP,
    FSCK_SM_ACTION_REPORT,
    FSCK_SM_ACTION_REMOTE,
    FSCK_SM_ACTION_CANCEL,
    FSCK_SM_ACTION_EMPTY,
    FSCK_SM_ACTION_REPAIR,
    FSCK_SM_ACTION_RETRY,
    FSCK_SM_ACTION_COMPLETE
};

/*
 * fsck control structure
 *
 * This structure is store in the db and maintains
 * the state of a running fsck.
 */
typedef struct fsck_control_s
{
    PVFS_ds_position position;
    int              state;
    int              phase;
    int              uid;
    char             logpath[PATH_MAX];
    struct timeval   stime;
    struct timeval   etime;
    uint64_t         ttime_s;
    uint64_t         ttime_us;
} fsck_control;

/*
 * Repair List structure
 */
typedef struct repair_item_s
{
    struct qlist_head     link;
    PVFS_mgmt_fsck_repair repair;
} repair_item;

/*
 * Prototypes
 */
static int fsck_get_control(PVFS_fs_id coll_id, fsck_control *ctrl);
static int fsck_put_control(PVFS_fs_id coll_id, fsck_control *ctrl);

static int fsck_init_repair (const char *path);
static int fsck_get_repair (
    PVFS_ds_position *position,
    uint64_t *count,
    PVFS_mgmt_fsck_repair *repair_list,
    fsck_control *ctrl);
static int fsck_put_repair (
    PVFS_handle parent,
    PVFS_fsck_op operation,
    PVFS_handle child);
static void fsck_flush_repair (
    fsck_control *ctrl);

static PINT_sm_action fsck_sm_phase_1_callback(
    void *v_p, struct PVFS_server_resp *resp_p, int index);
static PINT_sm_action fsck_sm_phase_2_callback(
    void *v_p, struct PVFS_server_resp *resp_p, int index);

void extentlist_load(struct TROVE_handle_extentlist *elist,
                     PVFS_handle_extent_array *earray);
void extentlist_dump(struct TROVE_handle_extentlist *elist);

/*
 * Globals
 */
QLIST_HEAD(repair_q);
struct TROVE_handle_extentlist parent_list = { 0 };

/*
 * State Machines
 */

%%

/*
 * pvfs2_fsck_phase_1_sm
 *   This machine validates that all child handles exist for metafiles,
 *   directories and dirdata handles. The child handles are logged in
 *   a remote handle list that is used in phase 2.
 *   This machine also clears the maintenace bit for each handle.
 */
nested machine pvfs2_fsck_phase_1_sm
{
    state phase_1_init
    {
        run fsck_sm_phase_1_init;
        success => phase_1_lookup;
        default => return;
    }

    state phase_1_lookup
    {
        run fsck_sm_phase_1_lookup;
        success => phase_1_prepare_msgpair;
        default => phase_1_clear_flag;
    }

    state phase_1_prepare_msgpair
    {
        run fsck_sm_phase_1_prepare_msgpair;
        success => phase_1_post;
        default => phase_1_result;
    }

    state phase_1_post
    {
        jump pvfs2_msgpairarray_sm;
        default => phase_1_result; 
    }

    state phase_1_result
    {
        run fsck_sm_phase_1_result;
        default => phase_1_clear_flag;
    }

    state phase_1_clear_flag
    {
        run fsck_sm_phase_1_clear_flag;
        default => return;
    }
}

/*
 * pvfs2_fsck_phase_2_update_sm
 *   This machine sets the maintenance bit to indicate the handle has
 *   a parent handle.
 *   One machine per handle.
 */
nested machine pvfs2_fsck_phase_2_update_sm
{
    state phase_2_update_getattr
    {
        run fsck_sm_phase_2_update_getattr;
        success => phase_2_update_setattr;
        default => phase_2_update_cleanup;
    }

   state phase_2_update_setattr
   {
       run fsck_sm_phase_2_update_setattr;
       default => phase_2_update_cleanup;
   }

   state phase_2_update_cleanup
   {
       run fsck_sm_phase_2_update_cleanup;
       default => return;
   }
}

/*
 * pvfs2_fsck_phase_2_sm
 *   This machine handles checking for orphan handles
 *   Requests the set of remote handles from each server (including itself)
 *   and marks each local handle that was referenced on a server.
 *   One machine is running per server.
 */
nested machine pvfs2_fsck_phase_2_sm
{
    state phase_2_init
    {
        run fsck_sm_phase_2_init;
        default => phase_2_prepare_msgpair;
    }
  
    state phase_2_prepare_msgpair
    {
        run fsck_sm_phase_2_prepare_msgpair;
        success => phase_2_post;
        default => phase_2_result;
    }

    state phase_2_post
    {
        jump pvfs2_msgpairarray_sm;
        default => phase_2_result;
    }

    state phase_2_result
    {
        run fsck_sm_phase_2_result;
        FSCK_SM_ACTION_RETRY => phase_2_prepare_msgpair;
        FSCK_SM_ACTION_COMPLETE => return;
        success => phase_2_process;
        default => return;
    }

    state phase_2_process
    {
        pjmp fsck_sm_phase_2_pjmp_init
        {
            success => pvfs2_fsck_phase_2_update_sm;
        }
        default => phase_2_cleanup;
    }

    state phase_2_cleanup
    {
        run fsck_sm_phase_2_pjmp_cleanup;
        default => return;
    }
}

/*
 * pvfs2_fsck_phase_2_analyze_sm
 *   This machine will scan all the handles and post a repair operation
 *   for any handle that wasn't marked during the phase 2 processing.
 *   One machine per handle.
 */
nested machine pvfs2_fsck_phase_2_analyze_sm
{
    state phase_2_analyze_init
    {
        run fsck_sm_phase_2_analyze_init;
        success => phase_2_analyze_result;
        default => return;
    }

    state phase_2_analyze_result
    {
        run fsck_sm_phase_2_analyze_result;
        default => return;
    }
}

/*
 * pvfs2_fsck_repair_sm
 */
nested machine pvfs2_fsck_repair_sm
{
    state repair_init
    {
        run fsck_sm_noop;
        default => return;
    }
}

/*
 * pvfs2_fsck_validate_and_repair_sm
 *   This machine drives the primary verification process
 *   The nested part of this machine has no functional purpose 
 */
nested machine pvfs2_fsck_validate_and_repair_sm
{
    state vnr_init
    {
        run fsck_sm_vnr_init;
        success => vnr_get_handles;
        default => return;
    }

    state vnr_get_handles
    {
        run fsck_sm_vnr_get_handles;
        success => vnr_phase_1;
        FSCK_SM_ACTION_EMPTY => vnr_phase_1_precreate_init; 
        default => return;
    }

    state vnr_phase_1
    {
        pjmp fsck_sm_vnr_phase_1
        {
            success => pvfs2_fsck_phase_1_sm;
        }
        default => vnr_phase_1_cleanup;
    }

    state vnr_phase_1_cleanup
    {
        run fsck_sm_vnr_phase_1_cleanup;
        success => vnr_get_handles;
        default => vnr_phase_1_precreate_init;
    }

    state vnr_phase_1_precreate_init
    {
        run fsck_sm_vnr_phase_1_precreate_init;
        success => vnr_phase_1_precreate_request;
        default => vnr_phase_2_init;
    }

    state vnr_phase_1_precreate_request
    {
        run fsck_sm_vnr_phase_1_precreate_request;
        success => vnr_phase_1_precreate_process;
        default => vnr_phase_2_init;
    }

    state vnr_phase_1_precreate_process
    {
        run fsck_sm_vnr_phase_1_precreate_process;
        FSCK_SM_ACTION_COMPLETE => vnr_phase_2_init;
        default => vnr_phase_1_precreate_request;
    }

    state vnr_phase_2_init
    {
        run fsck_sm_vnr_phase_2_init;
        default => vnr_phase_2_process;
    }

    state vnr_phase_2_process
    {
        pjmp fsck_sm_vnr_phase_2_process
        {
            success => pvfs2_fsck_phase_2_sm;
        }
        default => vnr_phase_2_cleanup;
    }

    state vnr_phase_2_cleanup
    {
        run fsck_sm_vnr_phase_2_cleanup;
        default => vnr_phase_2_analyze_init;
    }

    state vnr_phase_2_analyze_init
    {
        run fsck_sm_vnr_phase_2_analyze_init;
        FSCK_SM_ACTION_COMPLETE => vnr_complete;
        default => vnr_phase_2_analyze;
    }

    state vnr_phase_2_analyze
    {
        pjmp fsck_sm_vnr_phase_2_analyze_pjmp_init
        {
            success => pvfs2_fsck_phase_2_analyze_sm;
        }
        default => vnr_phase_2_analyze_cleanup;
    }

    state vnr_phase_2_analyze_cleanup
    {
        run fsck_sm_vnr_phase_2_analyze_cleanup;
        default => vnr_phase_2_analyze_init;
    }

    state vnr_complete
    {
        run fsck_sm_vnr_complete;
        default => return;
    }
}

/*
 * Main State Machine
 *   entry point for all fsck commands
 *   each command has it's own state
 *   state command/state will respond but continues running the fsck
 *   One machine per client invocation.
 */
machine pvfs2_fsck_sm
{
    state fsck_prelude
    {
        jump pvfs2_prelude_sm;
        success => fsck_command;
        default => fsck_response;
    }

    state fsck_command
    {
        run fsck_sm_command;
        FSCK_SM_ACTION_START => fsck_start;
        FSCK_SM_ACTION_STOP => fsck_stop;
        FSCK_SM_ACTION_REPORT => fsck_report;
        FSCK_SM_ACTION_REMOTE => fsck_remote_handles;
        FSCK_SM_ACTION_REPAIR => fsck_start_repair;
        default => fsck_response;
    }

    state fsck_start
    {
        run fsck_sm_start;
        success => fsck_start_response;
        default => fsck_response;
    }

    state fsck_start_response
    {
        jump pvfs2_final_response_sm;
        success => fsck_check;
        default => fsck_cleanup;
    }

    state fsck_check
    {
        jump pvfs2_fsck_validate_and_repair_sm;
        default => fsck_cleanup;
    }

    state fsck_stop
    {
        run fsck_sm_stop;
        default => fsck_response;
    }

    state fsck_report
    {
        run fsck_sm_report;
        default => fsck_response;
    }

    state fsck_remote_handles
    {
        run fsck_sm_remote_handles;
        default => fsck_response;
    }

    state fsck_start_repair
    {
        run fsck_sm_start_repair;
        success => fsck_repair_response;
        default => fsck_response;
    }

    state fsck_repair_response
    {
        jump pvfs2_final_response_sm;
        success => fsck_repair;
        default => fsck_cleanup;
    }

    state fsck_repair
    {
        jump pvfs2_fsck_repair_sm;
        default => fsck_cleanup;
    }

    state fsck_response
    {
        jump pvfs2_final_response_sm;
        default => fsck_cleanup;
    }

    state fsck_cleanup
    {
        run fsck_sm_cleanup;
        default => terminate;
    }
}

%%

/*
 * pvfs2_fsck_sm
 */

/*
 * fsck_command
 *
 * Determine which command was requested
 *   validate the state is acceptable for the request
 *   start the request
 */
static PINT_sm_action fsck_sm_command(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;

    assert(s_op->op == PVFS_SERV_MGMT_FSCK);

    switch (s_op->req->u.mgmt_fsck.operation)
    {
        case FSCK_NOOP:
            s_op->resp.u.mgmt_fsck.state    = FSCK_IDLE;
            s_op->resp.u.mgmt_fsck.phase    = FSCK_COMPLETE;
            s_op->resp.u.mgmt_fsck.position = PVFS_ITERATE_END;
            s_op->resp.u.mgmt_fsck.count    = 0;
            s_op->resp.u.mgmt_fsck.log      = NULL;
            js_p->error_code = 0;
            ret = SM_ACTION_COMPLETE;
            break;
        case FSCK_START:
            js_p->error_code = FSCK_SM_ACTION_START;
            ret = SM_ACTION_COMPLETE;
            break;
        case FSCK_STOP:
            js_p->error_code = FSCK_SM_ACTION_STOP;
            ret = SM_ACTION_COMPLETE;
            break;
        case FSCK_REPORT:
            js_p->error_code = FSCK_SM_ACTION_REPORT;
            ret = SM_ACTION_COMPLETE;
            break;
        case FSCK_REMOTE:
            js_p->error_code = FSCK_SM_ACTION_REMOTE;
            ret = SM_ACTION_COMPLETE;
            break;
        default:
            s_op->resp.u.mgmt_fsck.state     = 0;
            s_op->resp.u.mgmt_fsck.phase     = FSCK_ERROR;
            s_op->resp.u.mgmt_fsck.position  = PVFS_ITERATE_END;
            s_op->resp.u.mgmt_fsck.count     = 0;
            s_op->resp.u.mgmt_fsck.log       = NULL;
            js_p->error_code = -PVFS_EINVAL;
            ret = SM_ACTION_COMPLETE;
            break;
    }

    return ret;
}

static PINT_sm_action fsck_sm_start(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct server_configuration_s *config;
    PINT_sm_action ret;
    fsck_control  ctrl;
    struct tm local_tm;
    time_t uid;
    int r;
    char stopath[PATH_MAX];
    char datestr[PATH_MAX];

    /* get info from db */
    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = r;
        return SM_ACTION_COMPLETE;
    }

    /* verify fsck is idle */
    if (ctrl.state == FSCK_IP)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* verify admin mode is set */
    if (PINT_req_sched_get_mode() != PVFS_SERVER_ADMIN_MODE)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* start fsck */
    ctrl.state     = FSCK_IP;
    ctrl.phase     = FSCK_PHASE_CHECK;
    ctrl.uid       = s_op->req->u.mgmt_fsck.uid;
    ctrl.position  = PVFS_ITERATE_START;

    /* initialize repair log */
    uid = ctrl.uid;
    config = get_server_config_struct();
    DBPF_GET_STORAGE_DIRNAME(stopath, sizeof(stopath), config->storage_path);
    localtime_r(&uid, &local_tm);
    strftime(datestr, sizeof(datestr), "%Y-%m-%d-%H-%M-%S", &local_tm);
    snprintf(ctrl.logpath, sizeof(ctrl.logpath),
        "%s/fsck-%s.log", stopath, datestr);

    r = fsck_put_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = r;
        gossip_err("fsck_sm_start: failed: %d\n", r);
        return SM_ACTION_COMPLETE;
    }

    /* Clear previous parent_list if fsck was run before */
    if (parent_list.num_extents > 0)
    {
        extentlist_free(&parent_list);
    }
    else
    {
        extentlist_init(&parent_list);
    }

    js_p->error_code = fsck_init_repair(ctrl.logpath);
    ret = SM_ACTION_COMPLETE;

    return ret;
}

static PINT_sm_action fsck_sm_stop(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    fsck_control ctrl;
    int r;

    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* verify fsck is in-progress */
    if (ctrl.state == FSCK_IDLE)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    ctrl.state = FSCK_CANCEL; 

    r = fsck_put_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    s_op->resp.u.mgmt_fsck.state    = ctrl.state;
    s_op->resp.u.mgmt_fsck.phase    = ctrl.phase;
    s_op->resp.u.mgmt_fsck.position = PVFS_ITERATE_END;
    s_op->resp.u.mgmt_fsck.count    = 0;
    s_op->resp.u.mgmt_fsck.log      = NULL;

    ret = SM_ACTION_COMPLETE;
    js_p->error_code = 0;

    return ret;
}

static PINT_sm_action fsck_sm_report(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    TROVE_coll_id   coll_id;
    PVFS_ds_position pos;
    uint64_t         cnt;
    fsck_control ctrl;
    int r;

    coll_id = s_op->target_fs_id;

    r = fsck_get_control(coll_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        gossip_err("fsck_get_control: r=%d\n", r);
        return SM_ACTION_COMPLETE;
    }

    pos = s_op->req->u.mgmt_fsck.position;
    cnt = s_op->req->u.mgmt_fsck.count;

    /* allocate return message */
    s_op->resp.u.mgmt_fsck.log = 
        malloc(cnt*sizeof(PVFS_mgmt_fsck_repair));
    if (!s_op->resp.u.mgmt_fsck.log)
    {
        js_p->error_code = -PVFS_ENOMEM;
        gossip_err("malloc failed");
        return SM_ACTION_COMPLETE;
    }

    fsck_get_repair(&pos, &cnt, s_op->resp.u.mgmt_fsck.log, &ctrl);

    s_op->resp.u.mgmt_fsck.state    = ctrl.state;
    s_op->resp.u.mgmt_fsck.phase    = ctrl.phase;
    s_op->resp.u.mgmt_fsck.position = pos;
    s_op->resp.u.mgmt_fsck.count    = cnt; 
    s_op->resp.u.mgmt_fsck.time_s   = ctrl.ttime_s;
    s_op->resp.u.mgmt_fsck.time_us  = ctrl.ttime_us;

    js_p->error_code = 0;

    return SM_ACTION_COMPLETE;
}

/*
 * fsck_sm_remote_handles
 * 
 * TODO: Note this assumes that all handles can be sent in one message,
 *       need to fix it so that it can iterate.
 */
static PINT_sm_action fsck_sm_remote_handles(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    fsck_control ctrl;
    PVFS_ds_position pos;
    PVFS_ds_position i;
    int r;

    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /*
     * Not ready to provide a result
     */
    if (ctrl.phase <= FSCK_PHASE_CHECK)
    {
        js_p->error_code = -PVFS_ENODATA;
        return SM_ACTION_COMPLETE;
    }

    s_op->resp.u.mgmt_fsck.state = ctrl.state;
    s_op->resp.u.mgmt_fsck.phase = ctrl.phase;
    s_op->resp.u.mgmt_fsck.count = 0;

    pos = s_op->resp.u.mgmt_fsck.position;

    if (pos == PVFS_ITERATE_START)
    {
        i = 0;
    }
    else
    {
        i = pos;
    }

    s_op->resp.u.mgmt_fsck.remote_handles.extent_count = 
        parent_list.num_extents;
    s_op->resp.u.mgmt_fsck.remote_handles.extent_array = 
        malloc(sizeof(PVFS_handle_extent)*PVFS_REQ_LIMIT_MAX_EXTENTS);

    if (!s_op->resp.u.mgmt_fsck.remote_handles.extent_array)
    {
        gossip_err("%s: malloc failed\n", __func__);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_FSCK_DEBUG,
        "%s: num=%llu\n", __func__, llu(parent_list.num_extents));

    extentlist_load(&parent_list, &s_op->resp.u.mgmt_fsck.remote_handles);

    if (pos >= parent_list.num_extents)
    {
        pos = PVFS_ITERATE_END;
    }
    else
    {
        pos = i;
    }

    s_op->resp.u.mgmt_fsck.position = pos;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_start_repair(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    fsck_control ctrl;
    int r;

    /* verify normal mode is set */
    if (PINT_req_sched_get_mode() != PVFS_SERVER_NORMAL_MODE)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* get info from db */
    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = r;
        return SM_ACTION_COMPLETE;
    }

    /* verify fsck is idle */
    if (ctrl.state == FSCK_IDLE)
    {
        js_p->error_code = -PVFS_EINVAL;
        return SM_ACTION_COMPLETE;
    }

    /* start repair */
    ctrl.state     = FSCK_IP;
    ctrl.phase     = FSCK_PHASE_REPAIR;
    ctrl.uid       = s_op->req->u.mgmt_fsck.uid;
    ctrl.position  = PVFS_ITERATE_START;

    r = fsck_put_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = r;
        gossip_err("%s: failed: %d\n", __func__, r);
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;

    (void) s_op;
    ret = server_state_machine_complete(smcb);

    return ret;
}

/*
 * pvfs2_fsck_validate_and_repair_sm actions
 */

static PINT_sm_action fsck_sm_vnr_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    fsck_control           ctrl;
    int                    r;

    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        gossip_err("fsck_get_control: r=%d\n", r);
        return SM_ACTION_COMPLETE;
    }

    (void) gettimeofday(&ctrl.stime, NULL);

    r = fsck_put_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        gossip_err("%s: fsck_put_control failed\n", __func__);
    }

    s_op->u.fsck.position     = ctrl.position;
    s_op->u.fsck.parallel_sm  = 0;
    s_op->u.fsck.handle       = 0;
    s_op->u.fsck.handle_count = 1000;
    s_op->u.fsck.handle_array = malloc(s_op->u.fsck.handle_count*
                                       sizeof(PVFS_handle));
    s_op->u.fsck.error_array  = malloc(s_op->u.fsck.handle_count*
                                       sizeof(PVFS_handle));
    if (!s_op->u.fsck.handle_array || !s_op->u.fsck.error_array)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_get_handles(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    PVFS_fs_id             fs_id;
    fsck_control           ctrl;
    PVFS_ds_position       position;
    PVFS_handle           *handle_array;
    int                    handle_count;
    int                    r;
    job_id_t               job_id;

    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    fs_id        = s_op->target_fs_id;
    position     = s_op->u.fsck.position;
    handle_array = s_op->u.fsck.handle_array;
    handle_count = s_op->u.fsck.handle_count;

    r = fsck_get_control(fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        gossip_err("fsck_get_control: r=%d\n", r);
        return SM_ACTION_COMPLETE;
    }

    fsck_flush_repair(&ctrl);

    if (ctrl.state == FSCK_CANCEL)
    {
        js_p->error_code = FSCK_SM_ACTION_CANCEL;
        return SM_ACTION_COMPLETE;
    }

    gossip_debug(GOSSIP_FSCK_DEBUG, "fsid:%llu pos:%llu count:%d\n",
        llu(s_op->target_fs_id), llu(position), handle_count);

    if (position != PVFS_ITERATE_END)
    {
        r = job_trove_dspace_iterate_handles(fs_id, position,
                handle_array, handle_count, 0, NULL, smcb, 0, js_p,
                &job_id, server_job_context);
    }
    else
    {
        /* all handles have been processed */
        js_p->error_code = FSCK_SM_ACTION_EMPTY;
        r = SM_ACTION_COMPLETE;
    }

    return r;
}

static PINT_sm_action fsck_sm_vnr_phase_1(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    struct PINT_server_op *p_op;
    int ret;
    int i;

    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    s_op->u.fsck.handle_count = js_p->count;
    s_op->u.fsck.position     = js_p->position;

    s_op->u.fsck.parallel_sm = 0;
    for (i=0; i<s_op->u.fsck.handle_count; i++)
    {
        p_op = malloc(sizeof(*p_op));
        if (!p_op)
        {
            p_op->u.fsck.error_array[i] = -PVFS_ENOMEM;
            continue;
        }
        memcpy(p_op, s_op, sizeof(*s_op)); 
        p_op->u.fsck.handle = s_op->u.fsck.handle_array[i];
        p_op->target_handle = s_op->u.fsck.handle_array[i];

        ret = PINT_sm_push_frame(smcb, 0, p_op);
        if (ret < 0)
        {
            s_op->u.fsck.error_array[i] = -PVFS_ENOMEM;
            continue;
        }
        s_op->u.fsck.parallel_sm++;
    }

    if (s_op->u.fsck.parallel_sm < 1)
    {
        js_p->error_code = s_op->u.fsck.error_array[0];
    }
    else
    {
        js_p->error_code = 0;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_phase_1_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *p_op;
    PVFS_error             tmp_error;
    int                    i;
    int                    task_id;
    int                    remaining;

    for (i=0; i<s_op->u.fsck.parallel_sm; i++)
    {
        p_op = PINT_sm_pop_frame(smcb, &task_id, &tmp_error, &remaining);
        free(p_op);
    }

    /* pass previous error code through */
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_phase_1_precreate_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    fsck_control ctrl;
    int r;

    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        gossip_err("%s: fsck_get_control failed\n", __func__);
    }

    ctrl.phase    = FSCK_PHASE_PRECREATE;
    ctrl.position = PVFS_ITERATE_START;

    r = fsck_put_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        gossip_err("%s: fsck_put_control failed\n", __func__);
    }

    s_op->u.fsck.position = ctrl.position;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_phase_1_precreate_request(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    job_id_t tmp_id;

    s_op->u.fsck.handle_count = 1000;

    js_p->error_code = 0;
    ret = job_precreate_pool_iterate_handles(
            s_op->target_fs_id,
            s_op->u.fsck.position,
            s_op->u.fsck.handle_array,
            s_op->u.fsck.handle_count,
            0,
            NULL,
            smcb,
            0,
            js_p,
            &tmp_id, 
            server_job_context,
            s_op->req->hints);

    return ret;
}

static PINT_sm_action fsck_sm_vnr_phase_1_precreate_process(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i;

    s_op->u.fsck.handle_count = js_p->count;
    s_op->u.fsck.position     = js_p->position;

    gossip_debug(GOSSIP_FSCK_DEBUG, "%s: count:%d pos:%llu\n", __func__,
        s_op->u.fsck.handle_count, llu(s_op->u.fsck.position));

    for (i=0; i<s_op->u.fsck.handle_count; i++)
    {
        extentlist_addextent(&parent_list,
            s_op->u.fsck.handle_array[i],
            s_op->u.fsck.handle_array[i]);
    }

    if (s_op->u.fsck.position == PVFS_ITERATE_END)
    {
        js_p->error_code = FSCK_SM_ACTION_COMPLETE;
    }
    else
    {
        js_p->error_code = 0;
    }

    return SM_ACTION_COMPLETE; 
}

static PINT_sm_action fsck_sm_vnr_phase_2_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    fsck_control ctrl;
    int r;

    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        gossip_err("%s: fsck_get_control failed\n", __func__);
    }

    ctrl.phase    = FSCK_PHASE_ORPHAN;
    ctrl.position = PVFS_ITERATE_START;

    r = fsck_put_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        gossip_err("%s: fsck_put_control failed\n", __func__);
    }

    extentlist_dump(&parent_list); 

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_phase_2_process(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    struct PINT_server_op *p_op;
    server_configuration_s *config;
    PVFS_BMI_addr_t *addr_array;
    PVFS_BMI_addr_t  local_addr;
    int server_count;
    int ret;
    int i;

    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    config = get_server_config_struct();
    ret = BMI_addr_lookup(&local_addr, config->host_id);
    if (ret < 0)
    {
        gossip_err("%s: BMI_addr_lookup failed: %d\n",
            __func__, ret);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    ret = PINT_cached_config_count_servers(
              s_op->target_fs_id, 
              PVFS_MGMT_IO_SERVER|PVFS_MGMT_META_SERVER,
              &server_count);
    if (ret < 0)
    {
        gossip_err("%s: PINT_cached_config_count_servers failed: %d\n",
            __func__, ret);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    addr_array = malloc(server_count*sizeof(PVFS_BMI_addr_t));
    if (!addr_array)
    {
         gossip_err("%s: malloc failed: %d\n", __func__, errno);
         js_p->error_code = -PVFS_ENOMEM;
         return SM_ACTION_COMPLETE;
    }

    ret = PINT_cached_config_get_server_array(
              s_op->target_fs_id,
              PVFS_MGMT_IO_SERVER|PVFS_MGMT_META_SERVER,
              addr_array,
              &server_count);
    if (ret < 0)
    {
        gossip_err("%s: PINT_cached_config_count_servers failed: %d\n",
            __func__, ret);
        free(addr_array);
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    s_op->u.fsck.parallel_sm = 0;
    for (i=0; i<server_count; i++)
    {
        p_op = malloc(sizeof(*p_op));
        if (!p_op)
        {
            p_op->u.fsck.error_array[i] = -PVFS_ENOMEM;
            continue;
        }
        memcpy(p_op, s_op, sizeof(*s_op)); 

        p_op->u.fsck.server_addr = addr_array[i];

        ret = PINT_sm_push_frame(smcb, 0, p_op);
        if (ret < 0)
        {
            s_op->u.fsck.error_array[i] = -PVFS_ENOMEM;
            continue;
        }
        s_op->u.fsck.parallel_sm++;
    }

    /* check if there was more than on server */
    if (s_op->u.fsck.parallel_sm < 1)
    {
        js_p->error_code = FSCK_SM_ACTION_COMPLETE;
    }
    else
    {
        js_p->error_code = 0;
    }

    free(addr_array);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_phase_2_analyze_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    job_id_t tmp_id; 

    if (s_op->u.fsck.position == PVFS_ITERATE_END)
    {
        js_p->error_code = FSCK_SM_ACTION_COMPLETE;
        return SM_ACTION_COMPLETE;
    }

    s_op->u.fsck.handle_count = 1000;
    s_op->u.fsck.handle_array = malloc(sizeof(PVFS_handle)*
                                       s_op->u.fsck.handle_count);
    if (!s_op->u.fsck.handle_array)
    {
        gossip_err("%s: malloc failed\n", __func__);
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = 0;
    ret = job_trove_dspace_iterate_handles(
              s_op->target_fs_id,
              s_op->u.fsck.position,
              s_op->u.fsck.handle_array,
              s_op->u.fsck.handle_count,
              0,
              NULL,
              smcb,
              0,
              js_p,
              &tmp_id,
              server_job_context);

    return ret;
}


static PINT_sm_action fsck_sm_vnr_phase_2_analyze_pjmp_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *p_op;
    PINT_sm_action ret;
    int i;

    s_op->u.fsck.handle_count = js_p->count;
    s_op->u.fsck.position     = js_p->position;

    s_op->u.fsck.parallel_sm=0;

    for (i=0; i<s_op->u.fsck.handle_count; i++)
    {
        p_op = malloc(sizeof(*p_op));
        assert(p_op);

        memcpy(p_op, s_op, sizeof(*s_op));
        p_op->target_handle = s_op->u.fsck.handle_array[i];

        ret = PINT_sm_push_frame(smcb, 0, p_op);
        if (ret < 0)
        {
            gossip_err("%s: PINT_sm_push_frame failed\n", __func__);
            continue;
        }
        s_op->u.fsck.parallel_sm++;
    }

    if (s_op->u.fsck.parallel_sm < 1)
    {
        js_p->error_code = -PVFS_EINVAL;
    }
    else
    {
        js_p->error_code = 0;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_phase_2_analyze_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *p_op;
    PVFS_error             tmp_error;
    fsck_control           ctrl;
    int                    i;
    int                    task_id;
    int                    remaining;
    int                    r;

    for (i=0; i<s_op->u.fsck.parallel_sm; i++)
    {
        p_op = PINT_sm_pop_frame(smcb, &task_id, &tmp_error, &remaining);
        free(p_op);
    }

    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = r;
        return SM_ACTION_COMPLETE;
    }
    else
    {
        fsck_flush_repair(&ctrl);
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_vnr_phase_2_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *p_op;
    PVFS_error             tmp_error;
    int                    i;
    int                    task_id;
    int                    remaining;

    for (i=0; i<s_op->u.fsck.parallel_sm; i++)
    {
        p_op = PINT_sm_pop_frame(smcb, &task_id, &tmp_error, &remaining);
        free(p_op);
    }

    s_op->u.fsck.position = PVFS_ITERATE_START;

    /* pass previous error code through */
    return SM_ACTION_COMPLETE;
}


static PINT_sm_action fsck_sm_vnr_complete(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op;
    fsck_control           ctrl;
    int                    r;

    s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    r = fsck_get_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        gossip_err("fsck_get_control: r=%d\n", r);
        return SM_ACTION_COMPLETE;
    }

    ctrl.state = FSCK_IDLE;
    ctrl.phase = FSCK_COMPLETE;

    (void) gettimeofday(&ctrl.etime, NULL);
    ctrl.ttime_s  = (ctrl.etime.tv_sec - ctrl.stime.tv_sec);
    ctrl.ttime_us = (ctrl.etime.tv_usec - ctrl.stime.tv_usec);
    gossip_err("%s: s:%ld e:%ld\n", __func__, ctrl.stime.tv_sec, ctrl.etime.tv_sec);

    r = fsck_put_control(s_op->target_fs_id, &ctrl);
    if (r != 1)
    {
        js_p->error_code = -PVFS_EINVAL;
        gossip_err("fsck_put_control: r=%d\n", r);
        return SM_ACTION_COMPLETE;
    }

    if (s_op->u.fsck.handle_array) free(s_op->u.fsck.handle_array);
    if (s_op->u.fsck.error_array) free(s_op->u.fsck.error_array);

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/*
 * pvfs2_fsck_phase_1_sm
 */

static PINT_sm_action fsck_sm_phase_1_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    job_id_t tmp_id;

    ret = job_trove_dspace_getattr(
        s_op->target_fs_id, s_op->target_handle, smcb, &(s_op->ds_attr),
        0, js_p, &tmp_id, server_job_context, s_op->req->hints);

    return ret;
}

static PINT_sm_action fsck_sm_phase_1_lookup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    PVFS_ds_position token = PVFS_ITERATE_START;
    job_id_t j_id;
    int dirdata_count;
    int i;

    gossip_debug(GOSSIP_FSCK_DEBUG, "fsid:%llu handle:%llu type:%d\n",
        llu(s_op->target_fs_id), llu(s_op->target_handle), s_op->ds_attr.type);

    switch(s_op->ds_attr.type)
    {
        case PVFS_TYPE_METAFILE:
            if (s_op->ds_attr.u.metafile.dfile_count > 0)
            {
                s_op->u.fsck.status_array = malloc(
                    s_op->ds_attr.u.metafile.dfile_count*sizeof(PVFS_error));
                s_op->u.fsck.dfile_array = malloc(
                    s_op->ds_attr.u.metafile.dfile_count*sizeof(PVFS_handle));
                if ((!s_op->u.fsck.dfile_array) || (!s_op->u.fsck.status_array))
                {
                    ret = SM_ACTION_COMPLETE;
                    js_p->error_code = -PVFS_ENOMEM;
                }
                s_op->key.buffer  = Trove_Common_Keys[METAFILE_HANDLES_KEY].key;
                s_op->key.buffer_sz = Trove_Common_Keys[METAFILE_HANDLES_KEY].size;
                s_op->val.buffer  = s_op->u.fsck.dfile_array;
                s_op->val.buffer_sz = s_op->ds_attr.u.metafile.dfile_count*sizeof(PVFS_handle);

                ret = job_trove_keyval_read(
                          s_op->target_fs_id,
                          s_op->target_handle,
                          &s_op->key, &s_op->val,
                          0, NULL, smcb, 0, js_p,
                          &j_id, server_job_context, s_op->req->hints);
            }
            else
            {
                js_p->error_code = FSCK_SM_ACTION_EMPTY;
                ret = SM_ACTION_COMPLETE;
            }
            break;
        case PVFS_TYPE_DIRDATA:
            dirdata_count = 1000;
            s_op->u.fsck.status_array =
                malloc(dirdata_count*sizeof(PVFS_error));
            s_op->u.fsck.dirent_array =
                malloc(dirdata_count*sizeof(PVFS_dirent));
            s_op->key_a =
                malloc(dirdata_count*sizeof(PVFS_ds_keyval));
            s_op->val_a =
                malloc(dirdata_count*sizeof(PVFS_ds_keyval));
            if (!s_op->key_a ||
                !s_op->val_a ||
                !s_op->u.fsck.dirent_array ||
                !s_op->u.fsck.status_array)
            {
                ret = SM_ACTION_COMPLETE;
                js_p->error_code = -PVFS_ENOMEM;
            }

            for (i=0; i < dirdata_count; i++)
            {
                s_op->key_a[i].buffer =
                    s_op->u.fsck.dirent_array[i].d_name;
                s_op->key_a[i].buffer_sz = PVFS_NAME_MAX;
                s_op->val_a[i].buffer =
                    &s_op->u.fsck.dirent_array[i].handle;
                s_op->val_a[i].buffer_sz = sizeof(PVFS_handle);
            }

            js_p->error_code = 0;
            ret = job_trove_keyval_iterate(
                      s_op->target_fs_id,
                      s_op->target_handle,
                      token,
                      s_op->key_a,
                      s_op->val_a,
                      dirdata_count,
                      0, NULL, smcb, 0, js_p, &j_id,
                      server_job_context, s_op->req->hints);

            break;
        case PVFS_TYPE_DIRECTORY:
            s_op->key.buffer    = Trove_Common_Keys[DIR_ENT_KEY].key;
            s_op->key.buffer_sz = Trove_Common_Keys[DIR_ENT_KEY].size;
            s_op->val.buffer    = &s_op->u.fsck.dirdata_handle;
            s_op->val.buffer_sz = sizeof(PVFS_handle);

            s_op->u.fsck.status_array = malloc(1*sizeof(PVFS_error));

            ret = job_trove_keyval_read(
                      s_op->target_fs_id,
                      s_op->target_handle,
                      &s_op->key, &s_op->val,
                      0, NULL, smcb, 0, js_p,
                      &j_id, server_job_context, s_op->req->hints);
            break;
        case PVFS_TYPE_DATAFILE:
            js_p->error_code = 0;
            ret = SM_ACTION_COMPLETE;
            break;
        case PVFS_TYPE_SYMLINK:
        case PVFS_TYPE_NONE:
        case PVFS_TYPE_INTERNAL:
        default:
            ret = SM_ACTION_COMPLETE;
            js_p->error_code = -1;
            break;
    }

    return ret;
}

static PINT_sm_action fsck_sm_phase_1_prepare_msgpair(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_fsck_op *fsck_p = &s_op->u.fsck;
    PVFS_credentials creds;
    PINT_sm_msgpair_state *msg_p;
    PINT_sm_action ret = SM_ACTION_COMPLETE;
    server_configuration_s *config;
    BMI_addr_t local_addr;
    int index;
    int r;

    config = get_server_config_struct();
    ret = BMI_addr_lookup(&local_addr, config->host_id);
    assert(ret == 0);

    PINT_util_gen_credentials(&creds);

    switch(s_op->ds_attr.type)
    {
        case PVFS_TYPE_METAFILE:
            ret = PINT_msgpairarray_init(
                &fsck_p->msgarray_op,
                s_op->ds_attr.u.metafile.dfile_count);
            if (ret != 0)
            {
                js_p->error_code = ret;
                return SM_ACTION_COMPLETE;
            }

            fsck_p->msgarray_op.params.job_timeout =
                config->client_job_bmi_timeout;
            fsck_p->msgarray_op.params.retry_delay =
                config->client_retry_delay_ms;
            fsck_p->msgarray_op.params.retry_limit =
                config->client_retry_limit;
            fsck_p->msgarray_op.params.quiet_flag = 1;

            foreach_msgpair(&fsck_p->msgarray_op, msg_p, index)
            {
                assert(msg_p);

                PINT_SERVREQ_GETATTR_FILL(
                    msg_p->req,
                    creds,
                    s_op->target_fs_id,
                    fsck_p->dfile_array[index],
                    PVFS_ATTR_DATA_SIZE,
                    s_op->req->hints);
           
                msg_p->fs_id      = s_op->target_fs_id;
                msg_p->handle     = fsck_p->dfile_array[index];
                msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                msg_p->comp_fn    = fsck_sm_phase_1_callback;
            }

            ret = PINT_serv_msgpairarray_resolve_addrs(&fsck_p->msgarray_op);
            if (ret < 0)
            {
                gossip_lerr("failed to resolve server addresses.\n");
                js_p->error_code = ret;
            }

            /* record remote handles */
            foreach_msgpair(&fsck_p->msgarray_op, msg_p, index)
            {
                r = extentlist_addextent(&parent_list,
                        fsck_p->dfile_array[index],
                        fsck_p->dfile_array[index]);
                assert(r==0);
            }

            PINT_sm_push_frame(smcb, 0, &fsck_p->msgarray_op);
            js_p->error_code = 0;
            ret = SM_ACTION_COMPLETE;
            break;
        case PVFS_TYPE_DIRDATA:
            assert(js_p->position == PVFS_ITERATE_END);

            fsck_p->dirent_count = js_p->count;
            js_p->error_code = 0;

            if (fsck_p->dirent_count > 0)
            {
                ret = PINT_msgpairarray_init(&fsck_p->msgarray_op,
                          fsck_p->dirent_count);
                if (ret != 0)
                {
                    js_p->error_code = ret;
                    return SM_ACTION_COMPLETE;
                }

                fsck_p->msgarray_op.params.job_timeout =
                    config->client_job_bmi_timeout;
                fsck_p->msgarray_op.params.retry_delay =
                    config->client_retry_delay_ms;
                fsck_p->msgarray_op.params.retry_limit =
                    config->client_retry_limit;
                fsck_p->msgarray_op.params.quiet_flag = 1;

                foreach_msgpair(&fsck_p->msgarray_op, msg_p, index)
                {
                    assert(msg_p);

                    PINT_SERVREQ_GETATTR_FILL(
                        msg_p->req,
                        creds,
                        s_op->target_fs_id,
                        fsck_p->dirent_array[index].handle,
                        PVFS_ATTR_DATA_SIZE,
                        s_op->req->hints);
           
                    msg_p->fs_id      = s_op->target_fs_id;
                    msg_p->handle     = fsck_p->dirent_array[index].handle;
                    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                    msg_p->comp_fn    = fsck_sm_phase_1_callback;

                    /* record remote handles */
                    r = extentlist_addextent(&parent_list,
                            fsck_p->dirent_array[index].handle,
                            fsck_p->dirent_array[index].handle);
                    assert(r==0);
                }

                ret=PINT_serv_msgpairarray_resolve_addrs(&fsck_p->msgarray_op);
                if (ret < 0)
                {
                    gossip_err("failed to resolve server addresses\n");
                    js_p->error_code = ret;
                }

                PINT_sm_push_frame(smcb, 0, &fsck_p->msgarray_op);
            }
            else
            {
                js_p->error_code = FSCK_SM_ACTION_COMPLETE;
            }
            ret = SM_ACTION_COMPLETE;
            break;
        case PVFS_TYPE_DIRECTORY:
            ret = PINT_msgpairarray_init(
                &fsck_p->msgarray_op,
                1);
            if (ret != 0)
            {
                js_p->error_code = ret;
                return SM_ACTION_COMPLETE;
            }

            fsck_p->msgarray_op.params.job_timeout =
                config->client_job_bmi_timeout;
            fsck_p->msgarray_op.params.retry_delay =
                config->client_retry_delay_ms;
            fsck_p->msgarray_op.params.retry_limit =
                config->client_retry_limit;
            fsck_p->msgarray_op.params.quiet_flag = 1;

            foreach_msgpair(&fsck_p->msgarray_op, msg_p, index)
            {
                assert(msg_p);

                PINT_SERVREQ_GETATTR_FILL(
                    msg_p->req,
                    creds,
                    s_op->target_fs_id,
                    fsck_p->dirdata_handle,
                    PVFS_ATTR_DATA_SIZE,
                    s_op->req->hints);
           
                msg_p->fs_id      = s_op->target_fs_id;
                msg_p->handle     = fsck_p->dirdata_handle;
                msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
                msg_p->comp_fn    = fsck_sm_phase_1_callback;

                /* record remote handles */
                r = extentlist_addextent(&parent_list,
                        fsck_p->dirdata_handle,
                        fsck_p->dirdata_handle);
                assert(r==0);
            }

            ret = PINT_serv_msgpairarray_resolve_addrs(&fsck_p->msgarray_op);
            if (ret < 0)
            {
                gossip_err("failed to resolve server addresses.\n");
                js_p->error_code = ret;
            }

            PINT_sm_push_frame(smcb, 0, &fsck_p->msgarray_op);
            js_p->error_code = 0;
            ret = SM_ACTION_COMPLETE;
            break;
        case PVFS_TYPE_DATAFILE:
            js_p->error_code = FSCK_SM_ACTION_COMPLETE;
            ret = SM_ACTION_COMPLETE;
            break;
        case PVFS_TYPE_SYMLINK:
        case PVFS_TYPE_NONE:
        case PVFS_TYPE_INTERNAL:
            js_p->error_code = 0;
            ret = SM_ACTION_COMPLETE;
            break;
    }

    return ret;
}

static PINT_sm_action fsck_sm_phase_1_result(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_fsck_op *fsck_p = &s_op->u.fsck;
    int fault = 0;
    int i;

    if ((js_p->error_code != 0) &&
        (js_p->error_code != FSCK_SM_ACTION_COMPLETE))
    {
        return SM_ACTION_COMPLETE;
    }

    /* decide if we need to repair */
    switch (s_op->ds_attr.type)
    {
        case PVFS_TYPE_METAFILE:
            for (i=0; i<s_op->ds_attr.u.metafile.dfile_count; i++)
            {
                if (fsck_p->status_array[i] == -PVFS_ENOENT)
                {
                    fault=1;
                    fsck_put_repair(s_op->target_handle,
                                    FSCK_OP_DELETE,
                                    fsck_p->dfile_array[i]);
                } 
                else if (fsck_p->status_array[i] != 0)
                {
                    gossip_err("log for retry: handle:%llu ret=%d\n",
                               llu(s_op->target_handle),
                               fsck_p->error_array[i]);
                }
            }
            if (fault)
            {
                fsck_put_repair(s_op->target_handle,
                                FSCK_OP_MOVE,
                                s_op->target_handle);
            }
            if (s_op->u.fsck.dfile_array) free(s_op->u.fsck.dfile_array);
            break;
        case PVFS_TYPE_DIRECTORY:
            if (fsck_p->status_array[0] == -PVFS_ENOENT)
            {
                fsck_put_repair(s_op->target_handle,
                                FSCK_OP_MOVE,
                                s_op->target_handle);
                fsck_put_repair(s_op->target_handle,
                                FSCK_OP_CREATE,
                                0);
            }
            break;
        case PVFS_TYPE_DIRDATA:
            for (i=0; i<fsck_p->dirent_count; i++)
            {
                if (fsck_p->status_array[i] == -PVFS_ENOENT)
                {
                    fsck_put_repair(s_op->target_handle,
                                    FSCK_OP_DELETE, 
                                    fsck_p->dirent_array[i].handle);
                } 
                else if (fsck_p->status_array[i] != 0)
                {
                    gossip_err("log for retry: handle:%llu ret=%d\n",
                               llu(s_op->target_handle),
                               fsck_p->error_array[i]);
                }
            }
            if (s_op->key_a) free(s_op->key_a);    
            if (s_op->val_a) free(s_op->val_a);
            if (s_op->u.fsck.dirent_array) free(s_op->u.fsck.dirent_array);
            break;
        case PVFS_TYPE_DATAFILE: 
        {
            struct server_configuration_s *config;
            struct stat stat_data;
            char filename[PATH_MAX];
            int r;

            if (s_op->ds_attr.u.datafile.b_size > 0)
            {
                config = get_server_config_struct();
                DBPF_GET_BSTREAM_FILENAME(filename,
                                          PATH_MAX,
                                          config->storage_path,
                                          s_op->target_fs_id,
                                          llu(s_op->target_handle));
                r = stat(filename, &stat_data);
                if (r != 0)
                {
                    fsck_put_repair(s_op->target_handle,
                                    FSCK_OP_BCREATE,
                                    s_op->target_handle);
                }
            }
            break;
        }
        case PVFS_TYPE_SYMLINK:
        case PVFS_TYPE_NONE:
        case PVFS_TYPE_INTERNAL:
            break;
    }
 
    if (s_op->u.fsck.status_array) free(s_op->u.fsck.status_array);

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_phase_1_clear_flag(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    job_id_t tmp_id;

    /* clear the fsck flag for phase 2 operations */
    s_op->ds_attr.maintenance &= ~DS_MAINT_FSCK;

    gossip_debug(GOSSIP_FSCK_DEBUG,
        "%s: handle:%llu maint:0x%x\n", __func__,
        llu(s_op->target_handle), s_op->ds_attr.maintenance);

    js_p->error_code = 0;

    ret = job_trove_dspace_setattr(
              s_op->target_fs_id,
              s_op->target_handle,
              &s_op->ds_attr,
              TROVE_SYNC,
              smcb,
              0,
              js_p,
              &tmp_id,
              server_job_context,
              s_op->req->hints);

    return ret;
}

static PINT_sm_action fsck_sm_phase_1_callback(
    void *v_p, struct PVFS_server_resp *resp_p, int index)
{
    PINT_smcb *smcb = v_p;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    
    assert(resp_p->op == PVFS_SERV_GETATTR);

    s_op->u.fsck.status_array[index] = resp_p->status;

    return 0;
}

/*
 * pvfs2_fsck_phase_2_sm
 */

static PINT_sm_action fsck_sm_phase_2_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    gossip_debug(GOSSIP_FSCK_DEBUG, "%s: server=%llu\n",
        __func__, llu(s_op->u.fsck.server_addr));

    s_op->u.fsck.position = PVFS_ITERATE_START;
    s_op->u.fsck.remote_handles.extent_array =
        malloc(sizeof(PVFS_handle_extent)*PVFS_REQ_LIMIT_MAX_EXTENTS);

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_phase_2_prepare_msgpair(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_msgpair_state *msg_p;
    struct PINT_server_fsck_op *fsck_p = &s_op->u.fsck;
    server_configuration_s *config;
    PVFS_credentials creds;
    PINT_sm_action ret;

    PINT_util_gen_credentials(&creds);

    s_op->u.fsck.status_array = malloc(1*sizeof(PVFS_error));

    config = get_server_config_struct();

    ret = PINT_msgpairarray_init(&fsck_p->msgarray_op, 1);
    if (ret != 0)
    {
        js_p->error_code = ret;
        return SM_ACTION_COMPLETE;
    }

    fsck_p->msgarray_op.params.job_timeout =
        config->client_job_bmi_timeout;
    fsck_p->msgarray_op.params.retry_delay =
        config->client_retry_delay_ms;
    fsck_p->msgarray_op.params.retry_limit =
        config->client_retry_limit;
    fsck_p->msgarray_op.params.quiet_flag = 1;

    msg_p = &fsck_p->msgarray_op.msgarray[0];

    PINT_SERVREQ_MGMT_FSCK_FILL(msg_p->req,
                                creds,
                                s_op->target_fs_id,
                                FSCK_REMOTE,
                                0,
                                s_op->u.fsck.position,
                                0,
                                s_op->req->hints);

    msg_p->fs_id      = s_op->target_fs_id;
    msg_p->handle     = PVFS_HANDLE_NULL;
    msg_p->retry_flag = PVFS_MSGPAIR_RETRY;
    msg_p->comp_fn    = fsck_sm_phase_2_callback;
    msg_p->svr_addr   = fsck_p->server_addr;

    PINT_sm_push_frame(smcb, 0, &fsck_p->msgarray_op);

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_phase_2_result(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    
    gossip_debug(GOSSIP_FSCK_DEBUG,
        "%s: status:%d extent_handle=%llu extent_index=%d\n",
        __func__,
        s_op->u.fsck.status_array[0],
        llu(s_op->u.fsck.extent_handle),
        s_op->u.fsck.extent_index);

    js_p->error_code = 0;

    /*
     * Verify server was able to provide data
     */
    if (s_op->u.fsck.status_array[0] != 0)
    {
        js_p->error_code = FSCK_SM_ACTION_RETRY;
        return SM_ACTION_COMPLETE;
    }

    /* no handles to process */
    if (s_op->u.fsck.remote_handles.extent_count == 0)
    {
        js_p->error_code = FSCK_SM_ACTION_COMPLETE;
        return SM_ACTION_COMPLETE;
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}


static PINT_sm_action fsck_sm_phase_2_pjmp_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *p_op;
    PINT_sm_action ret;
    PVFS_handle_extent *extent;
    PVFS_handle handle;
    PVFS_handle error;
    int i;

    s_op->u.fsck.parallel_sm = 0;
    for (i=0; i<s_op->u.fsck.remote_handles.extent_count; i++)
    {
        extent = &s_op->u.fsck.remote_handles.extent_array[i];
        for (handle=extent->first; handle<=extent->last; handle++)
        {
            p_op = malloc(sizeof(*s_op));
            assert(p_op);

            memcpy(p_op, s_op, sizeof(*s_op));

            p_op->target_handle = handle;

            ret = PINT_sm_push_frame(smcb, 0, p_op);
            if (ret < 0)
            {
                error = handle;
                continue;
            }
            s_op->u.fsck.parallel_sm++;
        }
    }

    if (s_op->u.fsck.parallel_sm < 1)
    {
        js_p->error_code = -PVFS_EINVAL;
    }
    else
    {
        js_p->error_code = 0;
    }

    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_phase_2_pjmp_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    struct PINT_server_op *p_op;
    int task_id, tmp_error, remaining;
    int i; 

    for (i=0; i<s_op->u.fsck.parallel_sm; i++)
    {
        p_op = PINT_sm_pop_frame(smcb, &task_id, &tmp_error, &remaining);
        free(p_op);
    }

    if (s_op->u.fsck.status_array) free(s_op->u.fsck.status_array);

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}
static PINT_sm_action fsck_sm_phase_2_callback(
    void *v_p, struct PVFS_server_resp *resp_p, int index)
{
    PINT_smcb *smcb = v_p;
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_MSGPAIR_PARENT_SM);
    
    assert(resp_p->op == PVFS_SERV_MGMT_FSCK);

    s_op->u.fsck.status_array[index] = resp_p->status;

    if (resp_p->status == 0)
    {
        s_op->u.fsck.remote_handles.extent_count =
            resp_p->u.mgmt_fsck.remote_handles.extent_count;
        memcpy(s_op->u.fsck.remote_handles.extent_array,
           resp_p->u.mgmt_fsck.remote_handles.extent_array,
           sizeof(PVFS_handle_extent)*
               resp_p->u.mgmt_fsck.remote_handles.extent_count);
    }

    return 0;
}

/*
 * pvfs2_fsck_phase_2_update_sm
 */

static PINT_sm_action fsck_sm_phase_2_update_getattr(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    job_id_t tmp_id;

    js_p->error_code = 0;

    ret = job_trove_dspace_getattr(
                  s_op->target_fs_id,
                  s_op->target_handle,
                  smcb,
                  &s_op->ds_attr,
                  0,
                  js_p,
                  &tmp_id,
                  server_job_context,
                  s_op->req->hints);
    return ret;
}

static PINT_sm_action fsck_sm_phase_2_update_setattr(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    job_id_t tmp_id;

    js_p->error_code = 0;

    s_op->ds_attr.maintenance |= DS_MAINT_FSCK;

    gossip_debug(GOSSIP_FSCK_DEBUG,
        "%s: found handle:%llu maint:0x%x\n",
        __func__,
        llu(s_op->target_handle),
        s_op->ds_attr.maintenance);

    ret = job_trove_dspace_setattr(
              s_op->target_fs_id,
              s_op->target_handle,
              &s_op->ds_attr,
              TROVE_SYNC,
              smcb,
              0,
              js_p,
              &tmp_id,
              server_job_context,
              s_op->req->hints);
    return ret;
}

static PINT_sm_action fsck_sm_phase_2_update_cleanup(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);

    (void) s_op;

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_phase_2_analyze_init(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PINT_sm_action ret;
    job_id_t tmp_id;

    js_p->error_code = 0;

    ret = job_trove_dspace_getattr(
              s_op->target_fs_id,
              s_op->target_handle,
              smcb,
              &(s_op->ds_attr),
              0,
              js_p,
              &tmp_id,
              server_job_context,
              s_op->req->hints);

    return ret;
}

static PINT_sm_action fsck_sm_phase_2_analyze_result(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    PVFS_handle root_handle = PVFS_HANDLE_NULL;

    (void) PINT_cached_config_get_root_handle(s_op->target_fs_id, &root_handle);

    gossip_debug(GOSSIP_FSCK_DEBUG,
        "%s: handle:%llu maint:0x%x\n", __func__,
        llu(s_op->target_handle), s_op->ds_attr.maintenance);

    if (((s_op->ds_attr.maintenance & DS_MAINT_FSCK) != DS_MAINT_FSCK) &&
        (s_op->target_handle != root_handle) &&
        ((s_op->ds_attr.type == PVFS_TYPE_METAFILE) ||
         (s_op->ds_attr.type == PVFS_TYPE_DATAFILE) ||
         (s_op->ds_attr.type == PVFS_TYPE_DIRDATA)  ||
         (s_op->ds_attr.type == PVFS_TYPE_SYMLINK)  ||
         (s_op->ds_attr.type == PVFS_TYPE_DIRECTORY)))
    {
        fsck_put_repair(s_op->target_handle,
                        FSCK_OP_MOVE,
                        s_op->target_handle);
    }

    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

static PINT_sm_action fsck_sm_noop(
    struct PINT_smcb *smcb, job_status_s *js_p)
{
    js_p->error_code = 0;
    return SM_ACTION_COMPLETE;
}

/*
 * Support Functions
 */

static int fsck_get_control(PVFS_fs_id coll_id, fsck_control *ctrl)
{
    TROVE_keyval_s  key;
    TROVE_keyval_s  val;
    TROVE_op_id     op_id;
    PVFS_context_id context_id;
    int             trove_completion;
    int             ret;
    int             op_count = 1;

    key.buffer    = TROVE_FSCK_KEYSTR;
    key.buffer_sz = strlen(TROVE_FSCK_KEYSTR);
    val.buffer    = ctrl;
    val.buffer_sz = sizeof(fsck_control);

    ret = trove_open_context(coll_id, &context_id);
    if (ret < 0)
    {
        gossip_err("trove_open_context failed: ret=%d coll=%llu cntx=%llu\n",
                   ret, llu(coll_id), llu(context_id));
        return ret;
    }

    /* force immediate completion for these ops */
    trove_completion=1;
    ret = trove_collection_setinfo(coll_id, context_id,
                                   TROVE_COLLECTION_IMMEDIATE_COMPLETION,
                                   &trove_completion);
    if (ret < 0)
    {
        gossip_err("trove_collection_setinfo failed: "
                   "ret=%d coll=%llu cntx=%llu\n",
                   ret, llu(coll_id), llu(context_id));
        goto complete;
    }

    ret = trove_collection_geteattr(coll_id, &key, &val, 0,
              NULL, context_id, &op_id);
    if (ret == -TROVE_ENOENT)
    {
        /* create default state */
        ctrl->state     = FSCK_IDLE;
        ctrl->phase     = FSCK_ERROR;
        ctrl->uid       = 0;
        ret = 1;
    }
    else if (ret < 0)
    {
        gossip_err("trove_collection_geteattr failed: err=%d coll=%d \
                   op=%llu context=%llu count=%d\n",
                   ret, coll_id, llu(op_id), llu(context_id),
                   op_count);
    }

complete:
    (void) trove_close_context(coll_id, context_id);

    return ret;
}

static int fsck_put_control(PVFS_fs_id coll_id, fsck_control *ctrl)
{
    TROVE_keyval_s  key;
    TROVE_keyval_s  val;
    TROVE_op_id     op_id;
    TROVE_ds_state  state;
    PVFS_context_id context_id;
    int             ret;
    int             op_count = 1;

    key.buffer    = TROVE_FSCK_KEYSTR;
    key.buffer_sz = strlen(TROVE_FSCK_KEYSTR);
    val.buffer    = ctrl;
    val.buffer_sz = sizeof(fsck_control);

    ret = trove_open_context(coll_id, &context_id);
    if (ret < 0)
    {
        gossip_err("trove_open_context failed: ret=%d coll=%llu cntx=%llu\n",
                   ret, llu(coll_id), llu(context_id));
        return ret;
    }

    ret = trove_collection_seteattr(coll_id, &key, &val, TROVE_SYNC,
              NULL, context_id, &op_id);
    while (ret == 0)
    {
        ret = trove_dspace_test(coll_id, op_id, context_id, &op_count,
                  NULL, NULL, &state, TROVE_DEFAULT_TEST_TIMEOUT);
    }
    if (ret < 0)
    {
        gossip_err("trove failed: err=%d coll=%d \
                   op=%llu context=%llu count=%d state=%d\n",
                   ret, coll_id, llu(op_id), llu(context_id),
                   op_count, state);
    }

    (void) trove_close_context(coll_id, context_id);

    return ret;
}

static int fsck_init_repair(const char *file_path)
{
    FILE *f;
    int ret = 0;

    f = fopen (file_path, "w");
    if (f)
    {
        fclose(f);
    }
    else
    {
        ret = 1;
        gossip_err("failed to create repair log: %s\n", file_path);
    }

    return ret;
}

static int fsck_get_repair (
    PVFS_ds_position *position,
    uint64_t *count,
    PVFS_mgmt_fsck_repair *repair_list,
    fsck_control *ctrl)
{
    FILE  *f;
    size_t offset;
    size_t n_read;

    if (*position == PVFS_ITERATE_START) *position = 0;

    offset = (*position)*sizeof(*repair_list);

    f = fopen(ctrl->logpath, "r");
    if (f)
    {
        (void) fseek(f, offset, SEEK_SET);
        n_read = fread(repair_list, sizeof(*repair_list), *count, f);
        if (n_read < 0)
        {
            gossip_err("%s: read error: %d\n", __func__, errno);
        }
        *count = n_read;
        if (feof(f))
        {
            *position = PVFS_ITERATE_END;
        }
        else
        {
            *position += n_read;
        }
        fclose(f);
    }
    else
    {
        *position = PVFS_ITERATE_START;
        *count    = 0;
    }

    return 0;
}

#define fsck_repair_op2str(op) \
  ((op) == FSCK_OP_DELETE) ? "delete" : \
   (((op) == FSCK_OP_CREATE ? "create" : \
    (((op) == FSCK_OP_MOVE) ? "move" : "unknown")))

static int fsck_put_repair (
    PVFS_handle parent, PVFS_fsck_op operation, PVFS_handle child)
{
    repair_item        *item;

    gossip_debug(GOSSIP_FSCK_DEBUG,
        "repair: parent:%llu op:%s target:%llu\n",
            llu(parent), fsck_repair_op2str(operation), llu(child));

    item = malloc(sizeof(*item));
    if (!item)
    {
        gossip_err("%s: malloc failed: size=%ld\n", __func__, sizeof(*item));
    }

    item->repair.parent    = parent;
    item->repair.child     = child;
    item->repair.operation = operation;

    qlist_add_tail(&item->link, &repair_q);


    return 0;
}

static void fsck_flush_repair (fsck_control *ctrl)
{
    FILE *f;
    repair_item *item;
    size_t b_write;

    f = fopen(ctrl->logpath, "a");
    if (!f)
    {
        gossip_err("%s: open failed: errno=%d path=%s\n",
            __func__, errno, ctrl->logpath);
        return;
    }

    while (!qlist_empty(&repair_q))
    {
        item = (repair_item *) qlist_pop(&repair_q);
        b_write = fwrite(&item->repair, sizeof(item->repair), 1, f);
        if (b_write != 1)
        {
            gossip_err("%s: write failed: size=%ld\n", __func__, b_write);
        }
        free(item);
    }
    fclose(f);

    return;
}

/*
 * extentlist_load
 *
 * Copies a TROVE_handle_extentlist into a PVFS_handle_extent_array.
 * This is useful for send the TROVE_handle_extentlist over the wire.
 */
static void extentlist_load_df(
    struct avlnode *node, TROVE_handle_extent_array *earray)
{
    struct TROVE_handle_extent *e;

    if (!node) return;
    e = (struct TROVE_handle_extent *)(node->d);
    extentlist_load_df(node->left, earray);
    earray->extent_array[earray->extent_count].first = e->first;
    earray->extent_array[earray->extent_count].last  = e->last;
    earray->extent_count++;
    extentlist_load_df(node->right, earray);

    return;
}
void extentlist_load(struct TROVE_handle_extentlist *elist,
                     PVFS_handle_extent_array *earray)
{
    earray->extent_count = 0;
    extentlist_load_df(elist->index, earray);
    return;
}

/*
 * extentlist_dump
 *
 * Dumps out the extent entries in the TROVE_handle_extentlist structure
 * in depth first order.
 */
static void extentlist_dump_df(struct avlnode *node)
{
    struct TROVE_handle_extent *e;

    if (!node) return;
    e = (struct TROVE_handle_extent *)(node->d);
    extentlist_dump_df(node->left);
    gossip_debug(GOSSIP_FSCK_DEBUG,
        "first:%llu last:%llu\n",
         llu(e->first), llu(e->last));
    extentlist_dump_df(node->right);

    return;
}
void extentlist_dump(struct TROVE_handle_extentlist *elist)
{
    uint64_t mask;
    int      status;

    gossip_get_debug_mask(&status, &mask);
    if ((status) && (mask & GOSSIP_FSCK_DEBUG))
    {
        extentlist_dump_df(elist->index);
    }
    return;
}

/*
 * Server State Machine Hooks
 */

static inline int PINT_get_object_ref_fsck(
    struct PVFS_server_req *req, PVFS_fs_id *fs_id, PVFS_handle *handle)
{
    *fs_id  = req->u.mgmt_fsck.fs_id;
    *handle = PVFS_HANDLE_NULL;
    return 0;
};

struct PINT_server_req_params pvfs2_fsck_params =
{
    .string_name    = "fsck",
    .perm           = PINT_SERVER_CHECK_NONE,
    .access_type    = PINT_server_req_readonly,
    .sched_policy   = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_fsck,
    .state_machine  = &pvfs2_fsck_sm
};

/*
 * Local variables:
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ts=8 sts=4 sw=4 expandtab
 */
