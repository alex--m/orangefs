/* 
 * (C) 2001 Clemson University and The University of Chicago 
 *
 * See COPYING in top-level directory.
 */

#include <string.h>
#include <assert.h>

#include "server-config.h"
#include "pvfs2-server.h"
#include "pvfs2-attr.h"
#include "pvfs2-internal.h"
#include "pvfs2-util.h"
#include "pint-util.h"
#include "pint-eattr.h"


enum {
   PVFS2_MAKE_IMMUTABLE_COPIES = 200,
   CREATE_IMM_COPIES = 300
};

%%

machine pvfs2_set_eattr_sm
{
    state prelude
    {
        jump pvfs2_prelude_sm;
        success => verify_eattrib;
        default => final_response;
    }

    state verify_eattrib
    {
        run seteattr_verify_eattribs;
        success => setobj_eattrib;
        default => final_response;
    }

    state setobj_eattrib
    {
        run seteattr_setobj_eattribs;
        success => check_immutable;
        default => final_response;
    }

    state check_immutable
    {
        run check_immutable;
        PVFS2_MAKE_IMMUTABLE_COPIES => generate_copies;
        default => final_response;
    }

    state generate_copies
    {
        pjmp setup_create_immutable_copies
        {
           CREATE_IMM_COPIES => pvfs2_create_immutable_copies_sm;
        }
        success => inspect_imm_copies;
        default => final_response;
    }

    state inspect_imm_copies
    {
         run inspect_imm_copies;
         default => final_response;
    }


    state final_response
    {
        jump pvfs2_final_response_sm;
        default => cleanup;
    }

    state cleanup
    {
        run seteattr_cleanup;
        default => terminate;
    }
}

%%

/*
 * This routine checks keys to confirm that the name spaces are valid and to see
 * if the immutable flag is set for the user.pvfs2.meta_hint namespace.
 * It also prints debugging information.
 */
static int seteattr_verify_eattribs(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i; 

    gossip_debug(GOSSIP_MIRROR_DEBUG,"Current Frame Pointer in set-eattr.sm "
                                     "is %p.\n",s_op);       

    PVFS_object_attr *a_p = NULL;
    a_p = &s_op->attr;

    js_p->error_code = 0;

    gossip_debug(GOSSIP_SETEATTR_DEBUG,
                 "  ext attr list write to handle %llu refers to a %s\n\t"
                 "[owner = %d, group = %d, perms = %o, type = %d]\n",
                 llu(s_op->req->u.seteattr.handle),
                 PINT_util_get_object_type(a_p->objtype),
                 a_p->owner, a_p->group, a_p->perms, a_p->objtype);

    /* iterate through the keys that are being written */
    int j = 0;
    char *valBuf = NULL;
    for (i = 0; i < s_op->req->u.seteattr.nkey; i++)
    {
        gossip_debug(GOSSIP_MIRROR_DEBUG
                    ,"\tkey:%s\n"
                    ,(char *)s_op->req->u.seteattr.key[i].buffer);
        valBuf = (char *)s_op->req->u.seteattr.val[i].buffer;
        for (j=0; j<s_op->req->u.seteattr.val[i].buffer_sz; j++)
            gossip_debug(GOSSIP_MIRROR_DEBUG,"\tval[%d]=%#x\n"
                                            ,j
                                            ,(unsigned int)valBuf[j]);
        js_p->error_code = PINT_eattr_namespace_verify(
            &s_op->req->u.seteattr.key[i],
            &s_op->req->u.seteattr.val[i]);

        if(js_p->error_code)
        {
            return SM_ACTION_COMPLETE;
        }

    } /*end for*/


    return SM_ACTION_COMPLETE;
}

/*
 * This is where the actual extended attrib gets written.
 * Not much to this, its pretty straight-forward.
 * 
 * NOTE: we need to check the value of s_op->req->u.seteattr.flags to determine
 * the following:
 *
 * if (flags & PVFS_XATTR_CREATE)
 *  we need to make sure that the attribute does not exist. (pure create)
 * else if (flags & PVFS_XATTR_REPLACE)
 *  we need to make sure that the attribute does exist. (pure replace)
 * else it is default operation as before.
 * We translate this to an internal trove flag 
 *  (TROVE_NOOVERWRITE, TROVE_ONLYOVERWRITE)
 */
static int seteattr_setobj_eattribs(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int ret = 0;
    PVFS_ds_flags trove_flags = 0;
    job_id_t j_id;

    gossip_debug(
        GOSSIP_SETEATTR_DEBUG,
        "  writing keylist [%llu,%d,len %d flags %d]\n",
        llu(s_op->req->u.seteattr.handle),
        s_op->req->u.seteattr.fs_id,
        s_op->req->u.seteattr.nkey, s_op->req->u.seteattr.flags);

    if (s_op->req->u.seteattr.flags & PVFS_XATTR_CREATE)
    {
        trove_flags = TROVE_NOOVERWRITE;
    }
    else if (s_op->req->u.seteattr.flags & PVFS_XATTR_REPLACE)
    {
        trove_flags = TROVE_ONLYOVERWRITE;
    }
    trove_flags |= TROVE_SYNC;

    ret = job_trove_keyval_write_list(
        s_op->req->u.seteattr.fs_id,
        s_op->req->u.seteattr.handle,
        s_op->req->u.seteattr.key,
        s_op->req->u.seteattr.val,
        s_op->req->u.seteattr.nkey,
        trove_flags,
        NULL,
        smcb,
        0,
        js_p,
        &j_id,
        server_job_context, s_op->req->hints);

    return ret;
}

static PINT_sm_action setup_create_immutable_copies(struct PINT_smcb *smcb
                                                   ,job_status_s *js_p)
{
    gossip_debug(GOSSIP_MIRROR_DEBUG,"Executing setup_create_immutable_copies.."
                                     "\n");
    struct PINT_server_op *s_op = PINT_sm_frame(smcb,PINT_FRAME_CURRENT);
    int ret;
  
    js_p->error_code = 0;

    struct PINT_server_op *new_op = malloc(sizeof(struct PINT_server_op));
    if (!new_op)
    {
        js_p->error_code = -PVFS_ENOMEM;
        return SM_ACTION_COMPLETE;
    }
    memset(new_op,0,sizeof(struct PINT_server_op));

    PVFS_SERVOP_IMM_COPIES_FILL(new_op,s_op);

    ret = PINT_sm_push_frame(smcb,CREATE_IMM_COPIES,new_op);
    if (ret != 0)
    {
       gossip_debug(GOSSIP_MIRROR_DEBUG,"\tseteattr: failed to setup "
                                        "nested sm.\n");
       js_p->error_code = ret;
    }

    gossip_debug(GOSSIP_MIRROR_DEBUG,"\tseteattr:s_op:%p "
                                     "\tnew_op:%p\n",s_op,new_op);
    return SM_ACTION_COMPLETE;
}/*end action setup_create_immutable_copies*/


static PINT_sm_action inspect_imm_copies(struct PINT_smcb *smcb
                                        ,job_status_s *js_p)
{
    gossip_debug(GOSSIP_MIRROR_DEBUG,"Executing inspect_imm_copies....\n");

    struct PINT_server_op *s_op   = PINT_sm_frame(smcb,PINT_FRAME_CURRENT)
                         ,*imm_op = NULL;
    int task_id, error_code, remaining;

    /*js_p->error_code will be zero upon entering this function*/

    /*error_code will have the value returned in js_p->error_code via the */
    /*cleanup function in create-immutable-copies.sm                      */
    imm_op = PINT_sm_pop_frame(smcb, &task_id, &error_code, &remaining);

    assert(imm_op->op == PVFS_SERV_IMM_COPIES);

    /*check error codes from mirror copies*/
    gossip_debug(GOSSIP_MIRROR_DEBUG,"\tstatus of copies:%d\n",error_code);    

    if ( PVFS_get_errno_mapping(error_code) == EPERM )
    {
        /*If EPERM, then create-immutable-copies detected that the  */
        /*mirror mode is NO_MIRRORING or the mode didn't exist.     */
        js_p->error_code = 0;
    } else {
      /*set error_code based on return from copies.                   */
      /*this error_code will then be passed to the caller of set-eattr*/
      js_p->error_code = error_code;
    }

    gossip_debug(GOSSIP_MIRROR_DEBUG,"\tfrom pop, imm_op:%p\n"
                                    ,imm_op);

    gossip_debug(GOSSIP_MIRROR_DEBUG,"\tcurrent, s_op:%p\n",s_op);

    if (js_p->error_code)
    {
       gossip_err("File NOT mirrored successfully(%d)\n",js_p->error_code);
    }
    else
    {
       gossip_err("File successfully mirrored.\n");
    }

    return SM_ACTION_COMPLETE;
}/*end action inspect_imm_copies*/




/*
 * Function: check_immutable
 *
 * Params:   server_op *b, 
 *           job_status_s *js_p
 *
 * Returns:  SM_action
 *
 * Synopsis: If the immutable flag is set, then make a mirror.
 *           
 */
static PINT_sm_action check_immutable(struct PINT_smcb *smcb
                                         ,job_status_s *js_p)
{
    gossip_debug(GOSSIP_MIRROR_DEBUG,"Executing check_immutable....\n");

    struct PINT_server_op *s_op = PINT_sm_frame(smcb, PINT_FRAME_CURRENT);
    int i; 

    PVFS_flags         immutable_is_on = 0;
    PVFS_metafile_hint hint;
    PVFS_ds_keyval    *k=NULL, *v=NULL;

    js_p->error_code = 0;
   
    for (i = 0; i < s_op->req->u.seteattr.nkey; i++)
    {
        v = &s_op->req->u.seteattr.val[i];
        k = &s_op->req->u.seteattr.key[i];

        /* Are we working with the correct namespace?  The immutable flag is */
        /* a hint that can be set in the "user.pvfs2.meta_hint" namespace.   */
        if (strcmp(k->buffer,"user.pvfs2.meta_hint") != 0){
            continue;
        }

        memset(&hint, 0, sizeof(hint));
        memcpy(&hint, v->buffer, sizeof(v->buffer));

        gossip_debug(GOSSIP_MIRROR_DEBUG,"My converted buffer is %llu.\n"
                                        ,llu(hint.flags));

        immutable_is_on = hint.flags & PVFS_IMMUTABLE_FL;

        gossip_debug(GOSSIP_MIRROR_DEBUG
                     ,"My key is %s.  My key value is %llu"
                      "\n"
                      "PVFS_IMMUTABLE_FL is %llu.\n"
                     ,(char *)k->buffer
                     ,llu(hint.flags)
                     ,llu(PVFS_IMMUTABLE_FL) );
        gossip_debug(GOSSIP_MIRROR_DEBUG,"immutable_is_on is %llu.\n"
                                        ,llu(immutable_is_on));
        gossip_debug(GOSSIP_MIRROR_DEBUG,"IMMUTABLE is %s.\n",
                                          immutable_is_on ? "ON" : "OFF");

        if (immutable_is_on){
            js_p->error_code = PVFS2_MAKE_IMMUTABLE_COPIES;
            break; 
        }
    } /*end for*/

    return SM_ACTION_COMPLETE;
}/*end action check_immutable*/




/*
 * Function: setattr_cleanup
 *
 * Params:   server_op *b, 
 *           job_status_s *js_p
 *
 * Returns:  int
 *
 * Synopsis: free memory and return
 *           
 */
static int seteattr_cleanup(
        struct PINT_smcb *smcb, job_status_s *js_p)
{
    /* do I need to free memory from decoding key and val?*/
    return(server_state_machine_complete(smcb));
}

PINT_GET_OBJECT_REF_DEFINE(seteattr);

struct PINT_server_req_params pvfs2_set_eattr_params =
{
    .string_name = "set_eattr",
    .perm = PINT_SERVER_CHECK_ATTR,
    .access_type = PINT_server_req_modify,
    .sched_policy = PINT_SERVER_REQ_SCHEDULE,
    .get_object_ref = PINT_get_object_ref_seteattr,
    .state_machine = &pvfs2_set_eattr_sm
};

/*
 * Local variables:
 *  mode: c
 *  c-indent-level: 4
 *  c-basic-offset: 4
 * End:
 *
 * vim: ft=c ts=8 sts=4 sw=4 expandtab
 */
