%
% job design
%

\documentclass[11pt, letterpaper]{article} % FORMAT CHANGE
\usepackage[dvips]{graphicx}
\usepackage{times}
\usepackage{float}

\graphicspath{{./}{figs/}} 

\restylefloat{table}

\pagestyle{plain}

\addtolength{\hoffset}{-2cm}
\addtolength{\textwidth}{4cm}

\addtolength{\voffset}{-1.5cm}
\addtolength{\textheight}{3cm}

% \setlength{\parindent}{0pt}
% \setlength{\parskip}{12pt}

\title{PVFS 2 Server Request Protocol Design Document}
\author{PVFS Development Team}
\date{June 2002}

\begin{document}

\maketitle
\tableofcontents
\newpage

\section{Introduction}

This document describes the request protocol for use between the system
interface and server daemons of PVFS version 2.

Messages from the client to the server are generally called
\emph{requests} (because they request some action from the server).
Messages from the server to the client are called either
\emph{responses} or \emph{acknowledgements}.

\section{Network encoding}

In this document, the protocol is described in terms of structs and
data types.  However, the actual request packets transmitted over the network
will be encoded to and decoded from a packet or ``wire format''.  
The wire format is beyond the scope of this document.  It will actually 
define the order and packing of any protocol messages.

An interface will be built for encoding and decoding request protocol
messages.  This will hopefully make this step transparent to the system
interface or server code.  The system interface and server code will
only need to be aware of the protocol as defined at the structure level
given in this document.

Since this interface does not exist yet, however, the client code is
manually packing request and acknowledgement structures as needed in a
case by case basis.  For now this high level representation is doubling
as a wire protocol specification, with the exception that strings are
stored as contiguous buffers following messages, rather than as
pointers.

\section{Basic request structure}

Most communications between the PVFS2 server and client will make use of
the \emph{server request structure} (Table \ref{tab:req_s}) or the
\emph{server response structure} (Table \ref{tab:resp_s}).   The most
notable exception is the raw data transfer that occurs during I/O
operations (the format of data communication is determined by the flow
interface).

The server request and response structures contain generic information
about the message.  They also contain a union of information about each
of the supported types of requests.  The information pertaining to
particular requests will be outlined in later subsections.

\subsection{Credentials}

Notice that a \emph{credentials}\footnote{Not yet implemented} field is included in the general
request structure.  This is provided so that the PVFS2 servers may
implement server side object level permission checking.  The
credentials use normal, Unix style parameters (uid, gid, and permission
bits).  No attempt is made in this protocol to provide wire level
security.  In this scheme there is nothing to stop a rogue client from
forging packets with arbitrary creditial values. 

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
op & PVFS\_server\_op & integer enumeration value describing what type 
of request this is\\
\hline
rsize & PVFS\_size & total size of request\\
\hline 
credentials & PVFS\_credentials & permissions information (for server
side permission checking); see table \ref{tab:credentials}\\
\hline
u & union & union of structs; one unique entry for each type of request in the protocol\\
\hline
\end{tabular}
\caption{struct PVFS\_server\_req\_s \label{tab:req_s}}
\end{table}


\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
op & PVFS\_server\_op & integer enumeration value describing what type 
of response this is\\
\hline
rsize & PVFS\_size & total size of response\\
\hline
status & PVFS\_error & error code returned by server for this operation
(0 for success)\\
\hline
u & union & union of structs; one unique entry for each type of response in the protocol\\
\hline
\end{tabular}
\caption{struct PVFS\_server\_resp\_s \label{tab:resp_s}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
uid & PVFS\_uid & user id\\
\hline
gid & PVFS\_gid & group id\\
\hline
perms & PVFS\_permissions & Unix style permissions\\
\hline
\end{tabular}
\caption{struct PVFS\_credentials \label{tab:credentials}}
\end{table}

\subsection{Getconfig}

The getconfig\footnote{current implementation is out of sync with this
document} request is used by clients at initialization time to retrieve
configuration information about mounted file systems.  It may be issued
to any meta server for a given file system.

The request includes the name of the file systems to mount (this will
probably be represented as the path to the Trove collections holding
data).  The response includes an fsid (integer identifier for the file
system), the root handle, and bucket table information which is
used to map between handles and servers.

Note that mounting multiple file systems will require exchanging
multiple requests for now.  We may come back later and implement a
mechanism for configuring an array of file systems.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
fs\_name & PVFS\_string & name of file system to get configuration info for\\ 
\hline
max\_strsize & PVFS\_count & maximum size allowed in response for
each\\
 & & table of bucket mappings (meta and I/O servers)\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_getconfig\_s
\label{tab:reqgetconfig}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
fs\_id & PVFS\_fs\_id & file system identifier\\
\hline
root\_handle & PVFS\_handle & root handle for the file system\\
\hline
maskbits & PVFS\_handle & number of most significant bits representing buckets\\
\hline
meta\_server\_count & PVFS\_count32 & number of meta servers in the file
system\\
\hline
io\_server\_count & PVFS\_count32 & number of I/O servers in the file
system\\
\hline
meta\_server\_mapping & PVFS\_string & textual representation of
meta server bucket mapping\\
\hline
io\_server\_mapping & PVFS\_string & textual representation of
I/O server bucket mapping\\
\hline
\end{tabular}
\caption{struct PVFS\_servresp\_getconfig\_s
\label{tab:respgetconfig}}
\end{table}


\subsection{Lookup\_path}

A lookup\_path operation is used by a client to resolve the text
representation of a file name into an opaque PVFS2 handle.  This handle
can then be used to reference the file for later operations.  An
additional value known as the fs\_id is
used to indicate which file system the file resides on.

The lookup\_path operation may be used to attempt to lookup
all segments of a path in a single operation.  There is no
guarantee that all of the information about a full path resides on a
single server, and therefore no guarantee that lookup\_path will
actually succeed when used in this manner.  It is simply an optimization that will reduce
the number of network operations in cases in which a single meta server
can handle all of the lookup steps for a full path.  

The lookup\_path request contains a parent handle, and a string
representing the path that should be looked up relative to that
handle.  The response contains a set of handles, one for each
segment of the path that was successfully looked up.  A successful
response may return between 1 and N handles, where N is the number
of segments contained in the requested path.  If less handles are
returned than was expected, the lookup\_path request must be
repeated, using the last successful handle as the starting point
for the next request.

Note that a first cut implementation only needs to handle one path
segment at a time for correct behavior.

\subsubsection{Implications for permission checking}

The PVFS2 client implementation (the system interface) will be doing
full path permission checking at lookup time.  That means that for each
segment on which a lookup is performed, we must return permission
information along with the handle information.  This is done by
returning credentials with each ack.  Once the client has collected
credentials for each segment of the path, it may enforce full path
permission checking by looking at each credential in the path in order. 

\subsubsection{Attributes included with lookup requests}

The client may request that attribute information be returned with
lookup responses.  This is an optimization that assumes that the client
is likely to access attributes associated with recently looked up
objects.  If we return this attribute information with the lookup
response, then it may avoid an expensive additional network
transaction that would be needed to retrieve it later.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
path & PVFS\_string & full path of entity to lookup\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system\\
\hline
starting\_handle & PVFS\_handle & handle of handle of starting directory
for path given above\\
\hline 
attrmask & PVFS\_bitfield & bitmask used to restrict the set of
additional attributes returned in the response\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_lookuppath\_s
\label{tab:reqlookuppath}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
handle\_array & PVFS\_handle* & ordered array of handles for path segments (as looked up by server)\\
\hline
attr\_array & PVFS\_object\_attr* & ordered array of attributes
associated with each segment\\
\hline 
count & PVFS\_count32 & number of handles that were successfully
returned\\
\hline
\end{tabular}
\caption{struct PVFS\_servresp\_lookuppath\_s \label{tab:resplookuppath}}
\end{table}


\subsection{Getattr}
\label{sec:getattr}

This part of the request protocol is used for retrieving attributes for
PVFS2 objects (which include metadata files, data files, directories,
and symlinks).  The request and response structures are shown in tables
\ref{tab:reqgetattr} and \ref{tab:respgetattr}, respectively.

\subsubsection{Attribute masks}
Several values will be used to determine which fields should be
queried in a given getattr or setattr request.  
These values will be enumerated as powers
of two so that they may be bitwise or'd to express combinations of
attributes to get or set.  

The first list of these mask values applies equally well to metadata,
file data, directories, or symlinks.  The fields that they represent
are generic for each type of object.

\begin{itemize}
\item ATTR\_UID
\item ATTR\_GID
\item ATTR\_PERM
\item ATTR\_ATIME
\item ATTR\_MTIME
\item ATTR\_CTIME
\item ATTR\_TYPE
\item ATTR\_SIZE
\item ATTR\_EXTENDED
\end{itemize}

The following values may also be or'd with the above masks to
request attributes that are unique to a specific type of
object.   Only one of the following list may be queried or set at a
time.  Also note that requesting ATTR\_META, for example, results
in a query of all of the parameters that are specific to
metadata.  See table \ref{tab:attr}; the attributes specific to
each object type are contained in a union within the attributes
structure.

\begin{itemize}
\item ATTR\_META
\item ATTR\_DATA
\item ATTR\_DIR
\item ATTR\_SYM
\end{itemize}

\subsubsection{Structure definitions}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
handle & PVFS\_handle & handle of the file to get attributes of\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system containing the file\\
\hline
attrmask & PVFS\_bitfield & bitmask used to restrict the set of
attribute fields that are returned\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_getattr\_s \label{tab:reqgetattr}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
attr & PVFS\_object\_attr & structure containing attributes (see table
\ref{tab:attr})\\
\hline
extended & PVFS\_attr\_extended & structure containing extended
attributes\\
\hline
\end{tabular}
\caption{struct PVFS\_servresp\_getattr\_s \label{tab:respgetattr}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
owner & PVFS\_uid & UID of file owner\\
\hline
group & PVFS\_gid & GID of file group\\
\hline
perms & PVFS\_permissions & file permissions\\
\hline
atime & PVFS\_time & access time\\
\hline
mtime & PVFS\_time & last modification time\\
\hline
ctime & PVFS\_time & creation time\\
\hline
objtype & int & type of object described by this structure\\
\hline
u & union & union of structs describing meta, data, dir, and sym
attributes\\ 
 & & (see tables \ref{tab:meta}, \ref{tab:data}, \ref{tab:dir}, \ref{tab:sym})\\
\hline
\end{tabular}
\caption{struct PVFS\_object\_attr \label{tab:attr}}
\end{table}


\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
dist & PVFS\_dist & struct containing file distribution information (see
table \ref{tab:dist})\\
\hline
dfh & PVFS\_handle* & array of data file handles associated with
the logical file\\
\hline
nr\_datafiles & PVFS\_count32 & number of datafiles associated
with the logical file\\
\hline
\end{tabular}
\caption{struct PVFS\_metafile\_attr\_s \label{tab:meta}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
size & PVFS\_size & size of this datafile\\
\hline
dfh & PVFS\_handle & handle of this datafile\\
\hline
\end{tabular}
\caption{struct PVFS\_datafile\_attr\_s \label{tab:data}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
[ EMPTY ] & & \\
\hline
\end{tabular}
\caption{struct PVFS\_directory\_attr\_s \label{tab:dir}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
[ EMPTY ] & & \\
\hline
\end{tabular}
\caption{struct PVFS\_symlink\_attr\_s \label{tab:sym}}
\end{table}

Issues:
\begin{itemize}
\item \emph{NOTE:}\footnote{This is a recent modification.}
For now we assume that the client will be responsible
for querying data servers for datafile sizes and computing the overall
logical size when needed.  When a client requests size information, N
getattr requests for size will be sent out to data servers.  Once the
size information has been gathered, a distribution function will be used
to determine what the overall file size is.

In the future, meta servers may be responsible for calculating logical
size by sending inter-server requests or using collective operations.
For now, however, the burden will rest on the client.

\item \emph{NOTE:}  For now we assume that both regular and extended
attributes are serviced with the same request.   Extended attributes
have not yet been defined.
\end{itemize}

\subsubsection{Distribution parameters (deprecated)}

These structures have been used temporarily to describe file
distributions until the real distribution code is mature.  This portion of
the request protocol will be revisited later.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
type & PVFS\_dist\_type & type of this distribution\\
\hline
u & union & union of structures describing the different types of
distributions\\
 & & (see tables \ref{tab:single}, \ref{tab:striped}, and
\ref{tab:extension})\\
\hline
\end{tabular}
\caption{struct PVFS\_dist\_s \label{tab:dist}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
dfh & PVFS\_handle & handle of the data file\\
\hline
\end{tabular}
\caption{struct PVFS\_dist\_single\_s \label{tab:single}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
base & int32\_t & base node for start of striping\\
\hline
pcount & PVFS\_count32 & number of I/O servers\\
\hline
ssize & PVFS\_size & stripe size\\
\hline
\end{tabular}
\caption{struct PVFS\_dist\_striped\_s \label{tab:striped}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
[ EMPTY ] & & \\
\hline
\end{tabular}
\caption{struct PVFS\_dist\_extension\_s \label{tab:extension}}
\end{table}

\subsection{Mkdir}

Makes a new directory entry.  Request and response format are outlined
in tables \ref{tab:reqmkdir} and \ref{tab:respmkdir}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
bucket & PVFS\_handle & bucket to create new directory in\\
\hline
handle\_mask & PVFS\_handle & mask to specify number of most significant
bits that indicate the bucket ID\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system to place it on\\
\hline
attr & PVFS\_object\_attr & attributes to set on directory (see table
\ref{tab:attr})\\
\hline
attrmask & PVFS\_bitfield & mask of attribute fields to actually set\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_mkdir\_s \label{tab:reqmkdir}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
handle & PVFS\_handle & handle of newly created directory object\\
\hline
\end{tabular}
\caption{struct PVFS\_servresp\_mkdir\_s \label{tab:respmkdir}}
\end{table}

\subsection{Createdirent}

Creates a new entry in an existing directory\footnote{The implementation
is not in sync with what is listed here (see handle fields).}   The request and response
format are outlined in table \ref{tab:reqcreatedirent}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
name & PVFS\_string & name of entry to create\\
\hline
new\_handle & PVFS\_handle & handle of new entry\\
\hline
parent\_handle & PVFS\_handle & handle of directory object to add entry to\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system containing the directory\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_createdirent\_s \label{tab:reqcreatedirent}}
\end{table}

Issues:
\begin{itemize}
\item \emph{NOTE:}  Even though there is no response structure defined specific
to the createdirent operation, we must still receive a generic ack
structure in order to check the status returned by the server.
\end{itemize}

\subsection{Readdir}

The readdir request is used to read directory entries.  The request and
response structures are outlined in tables \ref{tab:reqreaddir} and
\ref{tab:respreaddir}.  Note that we use a ``token'' to keep up with the
current position when reading directory entries.  This is an opaque type
generated by the server, but it should have at least two special values
known to the client that indicate begining and end.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
handle & PVFS\_handle & handle of directory to read entries from\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system containing directory\\
\hline
token & PVFS\_token & opaque token used to represent current position in
directory\\
\hline
pvfs\_dirent\_count & PVFS\_count32 & count of the number of dirent
structures that the client is\\
 & & willing to read\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_readdir\_s \label{tab:reqreaddir}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
token & PVFS\_token & updated opaque token from server for current
directory offset\\
\hline
pvfs\_dirent\_count & PVFS\_count32 & count of the number of directory
entries returned by the server\\
 & & in this response\\
\hline
pvfs\_dirent\_array & PVFS\_dirent* & pointer to the directory entries\\
\hline
\end{tabular}
\caption{struct PVFS\_servresp\_readdir\_s \label{tab:respreaddir}}
\end{table}

Issues:
\begin{itemize}
\item \emph{NOTE:} We may need to modify this operation to provide
correct consistency.  Maybe we need a vtag to handle situations in which
the entries change between readdir operations (see fs semantics doc)?
\item \emph{NOTE:} For now we are returning fixed size dirent structures
with static character arrays to represent the names of the entries.
There may be a more compact representation that we can pursue later.
\end{itemize}


\subsection{Rmdir}

Removes a directory.  Outlined in table \ref{tab:reqrmdir}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
handle & PVFS\_handle & handle of directory to remove\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system containing directory\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_rmdir\_s \label{tab:reqrmdir}}
\end{table}

Issues:
\begin{itemize}
\item \emph{NOTE:} Even though there is no specific response structure
for the rmdir request, we must still receive a generic response
structure in order to verify the status of the operation from the server.
\item do we really need a special rmdir as opposed to just using remove?
\end{itemize}

\subsection{Rmdirent}

Removes a directory entry\footnote{The entry field is new here,
may be missing from current implementation} Outlined in table
\ref{tab:reqrmdirent}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
entry & PVFS\_string & entry to remove\\
\hline
parent\_handle & PVFS\_handle & handle of directory to remove entry from\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system containing directory\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_rmdirent\_s \label{tab:reqrmdirent}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
entry\_handle & PVFS\_handle & handle of entry removed\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_rmdirent\_s \label{tab:reqrmdirent}}
\end{table}

\subsection{Revlookup}

\emph{This request is depreicated and should be removed from the
system.}

\subsection{Setattr}

Sets attributes on existing PVFS2 objects.  Outlined in table
\ref{tab:reqsetattr}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
handle & PVFS\_handle & handle of object to set attributes on\\
\hline
fs\_id & PVFS\_fs\_id & fs id of file system containing handle\\
\hline 
attr & PVFS\_object\_attr & attributes to set (see getattr for
description)\\
\hline
attrmask & PVFS\_bitfield & bitmask used to specify which attributes
should be set\\
\hline
extended & PVFS\_attr\_extended & extended attributes\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_setattr\_s \label{tab:reqsetattr}}
\end{table}

Issues:
\begin{itemize}
\item \emph{NOTE:} for now we are assuming that both the regular and
extended attributes may be serviced with the same request structure.
\item \emph{NOTE:} even though there is no specific response structure
for this request, we must still receive a generic acknowledgement
structure in order to check the status field reported by the server.
\end{itemize}

\subsection{Statfs}

Returns statistics about a file system.  Outlined in tables
\ref{tab:reqstatfs} and \ref{tab:respstatfs}\footnote{The header files are
probably not in sync with the fields listed here}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
server\_type & int & type of server information we wish to request\\
\hline
fs\_id & PVFS\_fs\_id & id of file system to query\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_statfs\_s \label{tab:reqstatfs}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
server\_type & int & type of server information being reported\\
\hline
stat & PVFS\_serv\_statfs & struct containing stat information (see
table \ref{tab:servstatfs})\\
\hline
\end{tabular}
\caption{struct PVFS\_servresp\_statfs\_s \label{tab:respstatfs}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
u & union & union of mserv\_stat and ioserv\_stat (see tables
\ref{tab:mservstat} and \ref{tab:ioservstat})\\
\hline
\end{tabular}
\caption{struct PVFS\_serv\_statfs\_s \label{tab:servstatfs}}
\end{table}


\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
filetotal & PVFS\_count32 & number of files present\\
\hline
\end{tabular}
\caption{struct PVFS\_mserv\_stat\_s \label{tab:mservstat}}
\end{table}


\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
blksize & PVFS\_size & file system block size\\
\hline
blkfree & PVFS\_count64 & number of free blocks\\
\hline
blktotal & PVFS\_count64 & total number of blocks available\\
\hline
filetotal & PVFS\_count64 & maximum number of files\\
\hline
filefree & PVFS\_count64 & number of free files\\
\hline
\end{tabular}
\caption{struct PVFS\_ioserv\_stat\_s \label{tab:ioservstat}}
\end{table}

Issues:
\begin{itemize}
\item probably could use better names for fields in
PVFS\_ioserv\_stat\_s structure.
\end{itemize}

\subsection{Create}

The create request\footnote{This request is not yet defined properly in
the code.}
is used to create new file system objects (meta
files, data files, directories, or symlinks).  The type of object to be
created is determined by the \emph{objtype} field in the attributes.
The protocol structures
are defined in tables \ref{tab:reqcreate} and \ref{tab:respcreate}.

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
bucket & PVFS\_handle & bucket to create new PVFS object in\\
\hline
handle\_mask & PVFS\_handle & mask to specify number of most significant
bits that indicate bucket ID\\
\hline
fs\_id & PVFS\_fs\_id & id of file system to create new object on\\
\hline
object\_type & int & PVFS file system object type\\
\hline
\end{tabular}
\caption{struct PVFS\_servreq\_create\_s \label{tab:reqcreate}}
\end{table}

\begin{table}[H]
\begin{tabular}{|l|l|l|}
\hline
Field & Type & Description \\
\hline
\hline
handle & PVFS\_handle & handle of newly created object\\
\hline
\end{tabular}
\caption{struct PVFS\_servresp\_create\_s \label{tab:respcreate}}
\end{table}


\subsection{Getdist}

This operation is depricated\footnote{It is probably still listed in
the request protocol header files but it needs to be removed}.  File
distribution information can be obtained by using the getattr request
(see section \ref{sec:getattr}) with a proper attribute mask set.

\section{Undefined request types}

The requests listed in this section have not yet been defined properly.

\subsection{Noop}

No op request.  Probably just used for determining if a server is
responding or not.

\subsection{Allocate}

Preallocate storage space for a file.  May be used as a hint to let the
server perform optimizations for certain file sizes.

\subsection{Truncate}

Used to set the size on an existing file.

\subsection{IO}

Used to request read or write operations.  This will probably be covered
in a seperate document which includes or I/O description mechanism.

\subsection{Batch}

Batch operations are a mechanism for requesting more than one operation
with a single network message.  Will not be implemented at first, but
may be used as an optimization later.

\subsection{Remove}

Removes an existing file system object.

\section{Encoding request protocol messages}

\emph{TODO: Talk about the interface we wish to build for encoding
and decoding messages.}

\end{document}







