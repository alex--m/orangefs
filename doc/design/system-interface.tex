%
%
\documentclass[11pt, letterpaper]{article}
\usepackage[dvips]{graphicx}
\usepackage{psfig}
\usepackage{rotating}
\pagestyle{empty}

\graphicspath{{./}{figs/}} 

%
% GET THE MARGINS RIGHT, THE UGLY WAY
%
\topmargin 0.0in
\textwidth 6.5in
\textheight 9.0in
\columnsep 0.25in
\oddsidemargin 0.0in
\evensidemargin 0.0in
\headsep 0.0in
\headheight 0.0in

\title{System Interface Design Notes}
\author{ PVFS Development Team }
\date{ June 2002 }

%
% BEGINNING OF DOCUMENT
%
\begin{document}
\maketitle

\tableofcontents

\newpage

\thispagestyle{empty}

\section{Introduction}

This document covers design notes for the PVFS 2 system interface.  The
system interface is a client side interface made up of functions that
interact with the PVFS file system.  It is intended to be the low level
interface that components such as the PVFS library and PVFS
VFS interface are built on top of.  As such, it is not a direct mapping of UNIX file system calls, but consists of something rather
close to it that is more flexible and provides lower level control.

In order to understand the PVFS system interface, we will also
need to discuss a few other concepts and components.  The first such
concept is the PVFS object.   PVFS objects are entities that are used to 
represent the file system organization and data at a system level.
These objects describe meta data, file data, directories, and symbolic
links.  Objects are stored persistently on PVFS servers.

Next we will discuss the actual system interface in terms of the data
structures that it uses and the functions that are necessary to interact
with it.  The discussion of functions will include brief walkthroughs of
how each one will cary out its task. 

\section{Related documents}

\begin{itemize}
\item pvfs2-design-reqproto: covers the request protocol that is used
for communication between PVFS clients and servers.  It is essentially
the next abstraction layer \emph{below} the system interface.
\item pvfs2-design-fs-semantics: covers consistency and general
semantics issues for PVFS2.  Much of this applies directly to the
behavior of the system interface described here.
\item pvfs2-design-sysint-usage: explains the system interface from the
point of view of someone implementing a layer on top of the system
interface
\item modify notes for each function to include bucket table steps
\end{itemize}

\section{System objects}

Here we discuss the fundamental objects upon which PVFS builds a coherent
parallel file system.  There are four such object types which we use as
a starting point.  Additional object types may be added in the future as
research components or to support new functionality.

%
% FILES
%
\subsection{MetaFiles}

In PVFS, the constructs we traditionally call ``files'' are stored in a
distributed way using some distribution function.  Data describing such
files is normally called metadata, and in PVFS the metadata for a single
file is stored in an object we term a {\em MetaFile}.

\subsubsection{MetaFile Attributes}

Metafiles have several attributes associated with them.  This includes
``standard'' file attributes, such as permissions, owner, and time
stamps.  It also includes PVFS2 specific attributes, such as file
distribution parameters and lists of datafiles stored on different
servers.

\subsubsection{Semantics of Access}

From the system interface point of view, metafiles and their attributes
can only be altered through the use of the server request protocol.  The
client cannot directly access (ie. read or write particular offsets or
fields) metadata information.

%
% DIRECTORIES
%
\subsection{Directories}

The file system paradigm relies on directories as the sole mechanism for
organizing objects into a hierarchy.  The directory is the second
component provided in the PVFS system and is used to collect names
together.

\subsubsection{Directory Attributes}

Directory attributes include much of the standard Unix attributes,
including permissions.

\subsubsection{Semantics of Access}

Directory access is performed in terms of directory entries that can be
manipulated using specific server request protocol operations.  No
direct I/O is allowed on directories.

%
% DATAFILES
%
\subsection{DataFiles}

Where a metafile holds the metadata for a given file, a {\em DataFile}
holds some portion of the data for that file along with a subset of the
attributes necessary for acting on the datafile.  There may be several
datafiles (each most likely stored on a different server) for a given
logical file.

\subsubsection{DataFile Attributes}

Datafiles will have permission and ownership attributes.  This will
allow servers to perform permission checking on I/O operations.

\subsubsection{Semantics of Access}

Access to datafiles can be described in a variety of ways, using the
complex I/O description and data distribution mechanisms understood by
PVFS2 servers.  This is beyond the scope of this document.

%
% SYMBOLIC LINKS
%
\subsection{Symbolic Links}

Undefined thus far.

\section{Important data structures and terminology}

In order to make the discussion of the system interface clearer, we will
first describe the most important data structures that it interacts
with.

\subsection{Handles and Buckets}

\emph{Please see pvfs2-design-handle-bucket for details.}

\subsection{Fsid}

An fsid is a \emph{file system identifier}.  This is a integer
identifier that can be used to uniquely identify file systems.  In
particular, if a client has mounted more than one file system, then each
one will have a different fsid.  When a client mounts a file system, it
will contact a meta server, who will then convert the server side file
system path into an fsid.  The fsid will then be used as a compact
representation of that particular file system.

\subsection{Credentials}

The term \emph{credentials} refers to the collection of
information that describes the ownership and permission information
related to an object.  Credentials will be described in a
\emph{PVFS\_credentials} struct, which contains the UID, GID, and
permission bits.  See section \ref{sec:permission} for more information
on how the credentials structure will be used.

\subsection{Pinodes}

The purpose of the pinode structure is to provide a mechanism for
associating information with a handle within the system interface.
It can be thought of as a cache for attributes of files and
directories, somewhat analogous to an inode in the Linux kernel.
Pinodes allow the system interface to fill in information about a handle
over time so that it can reuse the information and hopeful reduce overhead
in performing multiple system interface operations on the same object.

Each pinode will refer to exactly one handle, and therefore exactly one
object.  No handle will ever have more than one pinode associated with
it.  Pinodes may be created, destroyed, or refreshed over time, however.

Pinodes will not be associated with data files.  They will only be used
for metadata files, directories, and symbolic links.  

Pinodes contain the following elements:
\begin{itemize}
\item \textbf{pinode\_ref}: An opaque reference that uniquely
identfies each pinode.
\item \textbf{pinode\_mutex}: A mutex lock for the individual pinode.
It is only manipulated through PINT\_pinode\_lock() and
PINT\_pinode\_unlock().
\item \textbf{object\_name}: Name of the PVFS object (but \_not\_
the full path); mainly useful for debugging.
\item \textbf{attr}:  This is the structure containing
attributes for the object refered to by this pinode.  
\item \textbf{tstamp\_attr}:  Time stamp value used to determine
when the attributes must be revalidated.
\item \textbf{tstamp\_handle}:  Time stamp value used to determine
when the handle must be revalidated to determine if it was reused
by the server.
\item \textbf{tstamp\_size}:  Time stamp value used to determine
when the size field must be recalculated.
\end{itemize}

Keep in mind that a pinode does not necessarily need to have all of
these fields filled in at any given time.  It will be filled as needed
and maintained so that repeated operations on the same inode do not have
to duplicate effort.

Pinodes are not exposed to the system interface user; they are
strictly for use within the system interface.  The
pinode\_reference, however, is exposed.  This is an opaque type
that can be used to refer to the pinode.  Most system interface
operations will be carried out with respect to pinode references.

\subsubsection{Pinode references}

As mentioned in the preceding section, pinode references are opaque
references that identify a given pinode and are exposed to the
system interface user.  The system interface user is
not allowed to manipulate pinode references, but these references
do contain fields that are internally useful to the system interface.

From the system interfaces's point of view, pinode references are
small structs that contain the handle and fsid of the object
refered to by the pinode.  This means that the reference by itself
contains enough information to make it possible to contact a
server and recover any related pinode information, even after
the original pinode structure has been destroyed.

\subsubsection{Pinode cache management}

The system interface code will need an internal mechanism for
caching
pinode structures.  This section will outline the functions necessary to
support this.  The interface here purposely does not expose what type of
data structure is used to store the pinodes.  This will allow us to
optimize pinode storage without breaking other parts of the code.  

Note that for now pinodes are stored in a simple linked list that is
linearly searched as needed to retrieve pinodes.  Later on we may wish
to use a more advanced mechanism for storing pinodes that makes
retrieval more efficient, such as a hash table or tree.

\begin{itemize}
	\item \textbf{PINT\_pinode\_storage\_init(void)}:  initializes
the pinode storage interface
	\item \textbf{PINT\_pinode\_storage\_finalize(void)}:  shuts
down the pinode storage interface
	\item \textbf{PINT\_pinode\_storage\_add\_new(pinode\_ptr)}:
adds a new pinode 
	\item \textbf{PINT\_pinode\_storage\_get(pinode\_reference)}:
retrieves an existing pinode; returns NULL if not found 
	\item \textbf{PINT\_pinode\_rem(pinode\_no)}: removes an
existing pinode
	\item \textbf{PINT\_pinode\_lock(struct pinode)}: locks an
existing pinode structure
	\item \textbf{PINT\_pinode\_unlock(struct pinode)}: unlocks an
existing pinode structure 
	\item \textbf{PINT\_pinode\_alloc()}: allocates a pinode 
	\item \textbf{PINT\_pinode\_dealloc(pinode\_ptr)}: destroys a
pinode 
\end{itemize}

\emph{TODO: We have not yet defined the caching policy for pinodes.  Probably
we will need to periodically discard unused ones...}

\section{Directory cache}

The directory cache is a mechanism (internal to the system
interface) that is used to cache directory entries.  It is
completely seperate from the pinode cache mechanism.  Each entry
in the cache has a time stamp associated with it, and they are
discarded if they are accessed after expiration.  The directory
cache entries are not exposed outside of the interface; instead,
the interface operates directly on entry names and pinode references.

\begin{itemize}
\item \textbf{int pint\_dinitialize(struct timeval timeout)}:
initializes the directory cache interface
\item \textbf{int pint\_dfinalize()}:  shuts down the directory
cache interface
\item \textbf{int pint\_dlookup(char *name,
pinode\_reference parent, pinode\_reference* entry)}:  looks up a pinode reference based on
the entry name and the reference to its parent.  Returns null if
entry not found in cache.
\item \textbf{int pint\_dinsert(char *name,pinode\_reference
entry,pinode\_reference parent)}:  adds a new entry to the cache
\item \textbf{int pint\_dflush(char *name,pinode\_reference
parent)}:  flushes all entries from the cache
\item \textbf{int pint\_dremove(char *name,pinode\_reference
parent)}:  removes a single entry from the cache
t
\end{itemize}

\section{Bucket tables}

\emph{Please see pvfs2-design-handle-bucket for details.}

\section{Consistency model}

This document describes a system interface design that does not utilize
locks or inter-client communication.  It caches metadata locally using
pinode structures, which must be revalidated occasionally to maintain
consistency.  These timeouts will be as conservative as possible, but
inconsistency is still possible for some access patterns.

\subsection{Tunable consistency semantics}

We would like to be able to tune consistency semantics at runtime, if
possible.  This would let administrators decide what level of
consistency is needed depending on application access patterns.  In this
particular system interface design, tuning will primarily consist of
modifying the timeout values associated with pinodes.  This will impact
how often clients must communicate with servers in order to update
locally cached information.  If extremely precise consistency is
required, then a user or administrator may set timeouts to zero to
indicate the object information should be cached as little as possible.

\subsection{Pinode revalidation}

We briefly discuss the motivation for pinode revalidation, the system 
interface functions that may need to perform revalidation during their
execution and finally the pseudocode for revalidate is listed.

\subsubsection{Classes of inconsistent information in the pinode}

As mentioned in the file system semantics document, there are
three
classes of metadata cached using the pinode system, each with its
independent timeout values.

\begin{itemize}
\item \textbf{Traditional metadata such as permissions, access time etc}
These become inconsistent because some other process has modified 
the metadata

\item \textbf{Reuse of handle (whether the handle refers to the correct
object or not)}
This could become inconsistent because (against all odds) another process
has deleted the object, but the server reused the handle and put a 
different object in its place

\item \textbf{Logical file size} The size becomes inconsistent
because another process has modified the target file.  Size is
handled seperately from the metadata because it is more expensive
to calculate and therefore requires finer grained control of
caching to avoid excess overhead.
\end{itemize}

It is proposed to use a timeout to handle each of the classes of
information that may become inconsistent. In our case, that would mean
three timeouts. The idea is to let the user specify the "window of time"
during which the information would be consistent and once the window
is exceeded a refresh(revalidate) operation would be performed.

\subsubsection{System Interface Functions that need to revalidate a pinode}

\emph{TODO: do we need to add any more notes in the following
subsections concerning the size caching and timeout? (added
7-16-2002)}

As long as metadata revalidation is concerned,only functions that "read"
metadata would need to revalidate(refresh). It appears that we may need 
to revalidate handles almost for all functions in order to handle various
error cases. A table summarizing the revalidation needed for each function
is shown below.\\ 

\begin{table}
\begin{tabular}{|l|c|c|}
\hline
Function & Handle reuse & Metadata reuse \\
\hline
\hline
lookup & yes & yes \\
getattr & yes & yes \\           
setattr & yes &  no \\ 
mkdir & yes & no \\         
rmdir & yes & no \\
readdir & yes & no \\
statfs & no & no \\
create & yes & no \\
remove & yes & no \\
read & yes & no \\
write & yes & no \\ 
\hline
\end{tabular}
\end{table}

In addition to the table, we also discuss briefly why/how each system interface
function may call revalidate. This is by no means "perfect" and only serves
as a starting point for further discussion.

\subsubsection{Motivation for system interface functions to revalidate}
\begin{itemize}
\item \textbf{lookup:} dcache layer will pass it the pinode no and it should
revalidate info before use.\\ 
\item \textbf{getattr:} similar to lookup.\\
\item \textbf{setattr:} handle needs to be revalidated but not the 
attributes. Just grab a lock before modification, update the information
and then release the lock. If the wrong handle was passed in the first 
place the server should(hopefully) return an error?\\
\item \textbf{mkdir:} needs handle of parent directory during crdirent to
add handle of new entry. So revalidates handle.\\
\item \textbf{readdir:} handle needs to be revalidated. \\
\item \textbf{rmdir:} somehow destroy/remove the pinode for the last object
in the path. Of course, we get the lock first to ensure nobody's messing
with it. Handle of parent needs to be revalidated.\\ 
\item \textbf{rename:} needs handle of parent directory during rmdirent
/crdirent to be revalidated.\\
\item \textbf{read:} handle(s) need to be revalidated. Are we talking of data handles
or metahandles?\\
\item \textbf{write:} handle(s) need to be revalidated. Are we talking of
data handles or metahandles?\\
\item \textbf{statfs:} handle needs to be revalidated.\\
\item \textbf{create:} yes, there would be createdirent operations at some
stage so we would need revalidation at some stage.\\
\item \textbf{remove:} there would be rmdirent operations so I am guessing
that we would need revalidation at some stage.\\

\end{itemize}

Regarding the remaining functions, their exact purpose has not been 
decided and hence we will not bother for now about their interaction with
pinodes.

\subsubsection{Issues regarding pinode revalidation}
\begin{itemize}

\item{What happens when the handle timeout expires?}

Revalidate is triggered and a getattr is done. After that the 
newly fetched attributes are matched to the cached attributes 
to determine whether they belong to different PVFS objects.
If they match, then the handle is affirmed valid else the handle
now points to a new PVFS object. In this case, a new lookup needs
to be done so return an error.

\item{What happens when the attribute timeout expires and the handle 
timeout does not?} 

Revalidate is triggered and getattr is done. The newly fetched
attributes overwrite the old ones and a success is returned. 

\item{What should a revalidate error mean?} 

This would mean the pinode has not been refreshed successfully.
In this case, the pinode probably should be destroyed and the 
error code returned to the caller. Anything else? 

\item{What should happen if an error occurs. Do we try 
to make explicit requests again to obtain the metadata?}

Refer to question above.
\end{itemize}

Note: It may be that the actual pinode interface may not contain the
revalidate functionality. The revalidate may be part of an outer layer
that only uses the pinode interface to access the pinode list!

\subsubsection{Pseudo code for pinode revalidate}
\textit{pnode:} pinode to be refreshed \\
\textit{flags:} specifies which timeout needs to be checked \\

\begin{verbatim}
int pinode_revalidate(pinode_ptr *pnode, int32_t flags...)
{
   ...
   struct timeval cur_time; 

   /* get current time */
   gettimeofday(&cur_time,NULL);
   
   /* Does the handle need to be revalidated? */
   if (flags & HANDLE_REUSE)
   {
      /* Check for handle expiry using the handle timestamp value */
      if (cur_time > pnode->to_handle)
      { // If true,means handle has expired

         /* handle could have changed */
         pcache_refresh_pinode(); /* makes a server getattr request */
			
         /* check if most attributes(maybe a few select attributes)
          match with those earlier for the PVFS  object */
         if (match)
            return(0);	/* safe to use the pinode values */
         else 
         /* Handle has probably changed, need to redo 
          * lookup 
          */
         return(-1); /* handle info has changed */
       }
    }
		
    /* Do the attributes need to be revalidated? */
    if (flags & ATTRIBUTE_REUSE)
    {
       /* Check for attribute expiry using attribute timestamp value */  
       if (cur_time > pnode->to_attr) 
       {
          /* Attributes may have become inconsistent, so fill up
           * pinode again
           */
           pcache_refresh_pinode();/* makes a server getattr request */	
           if error
              return(-1);
           else 
              return(0);
       }
    }

  	 /* Pinode need not be updated. So return success */
    return(0);
}
\end{verbatim}
		 
\emph{TODO: how does size fit into this?  Do we want an extra flag that
indicates if we are interested in the size or not?  It falls into the
attribute category, but is sortof a special case since it is so much
more expensive to update than the other attributes.}

\subsection{Missing pinodes}

It is possible for a system interface function to be called for a
particular pinode reference which does not exist in the pinode
cache.  The most likely cause of this scenario is that the pinode
became old and was discarded from the cache while an upper
software layer still maintained a reference to the file.

In this scenario, we must recreate the pinode.  Since the pinode
reference contains the handle and fsid of the object, a getattr
operation should be sufficient to reconstruct the missing pinode
information and add it to the cache.

\section{System interface}

This section is going to describe the system interface and how it will
be implemented.  It is a fairly high level overview.  All function names given
below should be
prepended with some sort of identifier that associates them with the
system interface. 

\subsection{Thread safety}

The system interface should be thread safe (ie, multithreaded clients
should be able to access it without any restrictions).  This could be
done in several ways.  

In particular, the system interface must take care to protect
the pinode structures, as multiple threads could attempt to access them
at the same time.  

\emph{TODO: fill in with more information as it becomes available}

\subsection{Permission checking}
\label{sec:permission}

Every system interface function will take as input a set of credentials
(UID, GID, and permission bits) that will be used to check wether or not the
caller has enough priviledges to carry out the operation.  On the
majority of operations, these credentials will be passed along to the
server (through the server request protocol), and the server will
be responsible for performing object level permission checks.  
The server will have no knowledge of how directory permission that are 
associated with an object.  Therefore, directory permissions will not be
enforced in these cases.

The exception to this scheme is the system interface lookup function.
This is the only function in which full directory permissions will be
enforced, and it will be the system interface's responsibility to
enforce them.  This is a convenient place to do full path permissions
because the path is already being traversed as part of the lookup, and
lookups normally occur when a higher level interface opens a file (which
is a good time to enforce strict permissions).

During the lookup function, the system interface must contact the server
to retrieve a handle for each segment of the path.  This is done with
the lookup\_single or lookup\_path server request (see reqproto design
document).  In addition to the handle, the lookup also returns credentials 
for each path segment.  The client then compares the credentials passed
in by the caller to the credentials associated with each path segment to
make sure that directory and object permissions are satisfied before
returning successfully.

\subsection{Interface Overview}

In this section we will list each interface function, give a brief
description of its purpose, and then give a high level list of the steps
it must perform in order to successfully complete.    

\subsubsection{Assumptions}

For many of these operations (unless stated otherwise), the implied
first step is to find a pinode associated with the object to act upon.
If that pinode cannot be found, create a new one and fill it in with any
information that is updated in the course of performing the requested
operation.

\subsubsection{Initialize}

This is the startup function for the system
interface.  It is assumed that the initial metaserver and other basic
parameters have already been parsed out of a pvfstab file or from the
mount command line by a higher level interface.  The init function 
will perform the following actions:

\begin{itemize}
\item build any necessary internal data structures needed by
the system interface
\item initialize the BMI, Flow, and other internal interfaces
\item send a GETCONFIG request to a meta server for each file system to
mount- this returns fsid, bucket table mappings, and root
handle for the file system 
\item create a pinode for the root directory
\item store any other configuration data given by the server
\end{itemize}

Initialize should be called before any other system interface operations
are attempted. 
\subsubsection{Finalize}
Finalize is used to shut down the system interface.  It should be
called once all system interface operations have been completed.

\begin{itemize}
\item abort any pending operations
\item free any resources held by the client interface
\item shutdown lower level interfaces, including flows,
BMI, bucket table, pinode cache, directory cache, etc.
\end{itemize}

\subsubsection{Lookup}

Converts a path name into a pinode reference and performs full path
permission checking.

\begin{itemize}
\item traverse the path, use cached pinodes if available
\begin{itemize}
\item if cached pinode found, revalidate 
\item if cached pinode not found, issue a LOOKUP\_PATH server request
to retrieve the handle, permissions, and create a new pinode
\end{itemize}
\item compare credentials passed in by user to credentials in pinode
\begin{itemize}
\item if permissions not granted (at any point), return -EPERM
\item if permissions granted, continue on to next path segment
(issuing another LOOKUP\_PATH if needed)
\end{itemize}
\item once path has been traversed and permissions granted, return
pinode reference to caller
\end{itemize}

\emph{Implementation note}:  The LOOKUP\_PATH request is capable
of looking up multiple segments in one request.  This is an
optimistic approach, which assumes that a single meta server may
hold more than one (or even all) of the path segments in a single
location.  This, of course, is not always the case.  If LOOKUP\_PATH
does not succeed in looking up all segments, it must be repeated.
The prototype implementation of the lookup operation will probably be
able to retrieve only one segment at a time regardlesss; support for
multiple segments will be added as the implementation progresses.

\subsubsection{Getattr}

Acquires attributes associated with a file, directory, or symlink.  The
mask may be used to query for only particular attributes (which may
reduce overhead in some cases).

\begin{itemize}
	\item see if existing pinode has attributes populated
	\item if so:
	\begin{itemize}
		\item revalidate pinode
	\end{itemize}
	\item if not:
	\begin{itemize}
		\item send a GETATTR request to meta server for object with appropriate
		mask set (include distribution info in mask if size was requested
		by caller)
		\item if size attribute requested (and size timestamp has
		expired):
		\begin{itemize}
			\item send a GETATTR to each server that holds a datafile to collect
			sizes
			\item calculate total file size using appropriate distribution function
			and sizes reported by I/O servers
		\end{itemize}
	\end{itemize}
\end{itemize}

\emph{Alternative approaches to computing size}:
Note that in this scenario, the burden of computing file size falls onto
the client.  Another approach would be to make meta servers responsible
for computing size.  If that were done, the client would not need to
contact I/O servers to compute size, and server would have opportunity
to perform collective operations to compute size and could manage
consistency more easily for overall file size.

\subsubsection{setattr}

Sets file attributes for a file, directory, or symlink.  Takes a full
attributes structure as an argument, but a mask value may be used to
limit the number of fields that are updated with this call.

\begin{itemize}
\item revalidate
\item send SETATTR request to meta server for the object
\item remove pinode from cache
\item update attributes in pinode structure
\item add pinode to cache
\end{itemize}

\subsubsection{remove}

Removes an existing file.

\begin{itemize}
\item find pinode for parent (perform lookup if needed)
\item revalidate parent
\item issue a RMDIRENT request to remove directory entry in parent
\begin{itemize}
	\item issue a GETMETA to retrieve distribution information if not
	already available in pinode
	\item issue a REMOVE request to all I/O servers holding data files
\end{itemize}
\item issue a REMOVE request to meta server to destroy metadata object
\item destroy old pinode
\end{itemize}

\subsubsection{create}

Creates a new file.

\begin{itemize}
\item query a meta server to get a list of active I/O servers in the
file system
\item check to make sure that no pinode for a file, directory, or
symlink of this name already exists
\begin{itemize}
\item if old pinode found, destroy it
\end{itemize}
\item find parent pinode or do a lookup (with full path traverasl if needed) 
to create new parent pinode
\item revalidate parent
\item query the bucket table interface to determine the initial meta server for
the new file
\item send a CREATE request to the meta server responsible for new file
to create metafile
\item send a MKDIRENT request to the parent meta server
\item if MKDIRENT fails:
\begin{itemize}
\item issue REMOVE request to meta server to destroy metafile previously
created by this client
\item if MKDIRENT fails with EALREADY:
\begin{itemize}
\item perform lookup on new file name, fill in new pinode, and return 
info about existing file to caller
\end{itemize}
\item if MKDIRENT fails with some other error:
\begin{itemize}
\item return error
\end{itemize}
\end{itemize}
\item if MKDIRENT successful:
\begin{itemize}
\item query bucket table interface to find list of I/O servers to
use
\item send a CREATE request to each of the I/O servers to create
datafiles
\item send a SETATTR request to meta server to fill in list of data file
handles and distribution information
\item create a pinode for new file and fill in whatever information is
handy
\item if any of the above steps fail:
\begin{itemize}
\item go back and remove any directory entries, data files, or meta
files that were created
\end{itemize}
\end{itemize}
\end{itemize}


\emph{Alternative approaches}: This is another operation that could
conceivably be handled by the meta server in the future.  It could 
preserve consistency in concurrent create cases and take advantage of
collective operations if available.

\subsubsection{mkdir}

Creates a new directory.

\begin{itemize}
\item check to make sure that no pinode for a file, directory, or
symlink of this name already exists
\begin{itemize}
\item if old pinode found, destroy it
\end{itemize}
\item find parent pinode or do a lookup (with full path traverasl if needed) 
to create new parent pinode
\item revalidate parent
\item query the bucket table to determine the initial meta server for
the new directory
\item send a MKDIR request to the server
\item send a MKDIRENT request to the server of the parent directory
\item if MKDIRENT fails:
\begin{itemize}
\item send an RMDIR request to cleanup directory that was previously
created
\end{itemize}
\end{itemize}

\subsubsection{rmdir}

Removes a directory.

\begin{itemize}
\item find pinode for parent (lookup if needed)
\item revalidate parent
\item issue a RMDIRENT request to remove directory entry in parent
\item issue a RMDIR request to meta server to destroy metadata object
\begin{itemize}
\item if RMDIR fails, send a MKDIRENT to replace directory entry in
parent that was previously destroyed
\end{itemize}
\item destroy old pinode
\end{itemize}

\subsubsection{readdir}

Reads directory entries.  Caller provides a buffer to hold the entries
and indicates the location and size of that buffer.  System interface
returns a count of how many entries were filled in and a token that can
be used to pickup where it left off on successive calls.  Note that the
token has special values (understood by the caller) that indicate
beginning and end.

\begin{itemize}
\item revalidate directory pinode
\item issue READDIR request to meta server with specified token
\item fill in caller's directory entry buffer and pass back token
provided by server
\end{itemize}

\emph{TODO: how do vtags fit in here?}

\subsubsection{rename}

Renames an existing file or directory.

\begin{itemize}
\item find pinode for parent of old name (lookup if needed)
\item find pinode for parent of new name (lookup if needed)
\item revalidate parents 
\item send a RMDIRENT request to remove old directory entry
\item send a MKDIRENT request to create the new entry
\item if above step fails:
\begin{itemize}
\item send a MKDIRENT to put the original entry back
\end{itemize}
\item change name in pinode
\end{itemize}

\subsubsection{read}

Reads contiguous data from an existing file.  

\begin{itemize}
\item revalidate pinode
\item send a GETATTRIB request to meta server if distribution info is not
already available in pinode
\item use one of the distribution functions to determine which subset of
I/O servers needs to be contacted to carry out the I/O
\item send IO requests to I/O servers (concurrently)
\item setup flows to each of the I/O servers (concurrently)
\end{itemize}

\subsubsection{write}

Writes contiguous data to an existing file. 

\begin{itemize}
\item revalidate pinode
\item send a GETATTRIB request to meta server if distribution info is not
already available in pinode
\item use one of the distribution functions to determine which subset of
I/O servers needs to be contacted to carry out the I/O
\item send IO requests to I/O servers (concurrently)
\item setup flows to each of the I/O servers (concurrently)
\end{itemize}

\subsubsection{statfs}

Gathers statistics about a specific file system.

\begin{itemize}
\item send a request to get list of all I/O servers in file system from
a meta server \emph{TODO: is this correct?}
\item send STATFS request to all meta and I/O servers for the specified
file system
\item combine results
\end{itemize}

\subsubsection{allocate}
\emph{Unimplemented}

\subsubsection{duplicate}
\emph{Unimplemented}

\subsubsection{symlink}
\emph{Unimplemented}

\subsubsection{readlink}
\emph{Unimplemented}

\subsubsection{lock}
\emph{Unimplemented}

\subsubsection{unlock}
\emph{Unimplemented}

\subsubsection{extension}
\emph{Unimplemented}

\subsection{Nonblocking I/O}

Eventually we should add a set of functions to the system interface for
doing nonblocking I/O.  This is not necessary in the first cut, however.

\emph{TODO: what should the nonblocking I/O interface look like?}

\end{document}


