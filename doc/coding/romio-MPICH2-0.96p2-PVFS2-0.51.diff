Index: romio/Makefile.in
diff -u romio/Makefile.in:1.34 romio/Makefile.in:1.35
--- romio/Makefile.in:1.34	Mon Dec  1 15:52:57 2003
+++ romio/Makefile.in	Tue Jan 27 17:27:35 2004
@@ -164,3 +164,10 @@
 	(cd mpi-io && $(MAKE) htmldoc )
 latexdoc:
 	(cd mpi-io && $(MAKE) latexdoc )
+
+
+tags: TAGS
+TAGS:
+	for dir in mpi-io adio/common - ; do \
+		if [ "$$dir" = "-" ] ; then break ; fi ; \
+		(cd $$dir && ${MAKE} TAGS ; ) ; done
Index: romio/aclocal.m4
diff -u romio/aclocal.m4:1.30 romio/aclocal.m4:1.31
--- romio/aclocal.m4:1.30	Mon Oct  6 11:04:45 2003
+++ romio/aclocal.m4	Thu Jan  8 16:41:16 2004
@@ -324,7 +324,7 @@
   $CC $USER_CFLAGS -I$MPI_INCLUDE_DIR -o conftest mpitest.c $MPI_LIB > /dev/null 2>&1
   if test -x conftest ; then
       AC_MSG_RESULT(yes)
-      AC_DEFINE(HAVE_MPI_INFO,,[Define if MPI_Info available])
+      AC_DEFINE(HAVE_MPI_INFO,1,[Define if MPI_Info available])
       HAVE_MPI_INFO="#define HAVE_MPI_INFO"
       MPI_FINFO1="!"
       MPI_FINFO2="!"
Index: romio/configure.in
diff -u romio/configure.in:1.98 romio/configure.in:1.110
--- romio/configure.in:1.98	Wed Dec 10 16:44:11 2003
+++ romio/configure.in	Wed May 12 11:29:30 2004
@@ -81,6 +81,12 @@
 MPIO_EXTRA_TMP_POBJECTS="get_errh.p set_errh.p"
 MPIO_EXTRA_REAL_POBJECTS="_get_errh.o _set_errh.o"
 #
+# Completion routines for MPIO_Requests.  MPI Implementations with
+# generalized requests do not need these
+MPIO_REQOBJECTS="iotest.o iotestall.o iotestany.o iotestsome.o iowait.o iowaitall.o iowaitany.o iowaitsome.o ioreq_c2f.o ioreq_f2c.o"
+MPIO_REQ_TMP_POBJECTS="iotest.p iowait.p iowaitall.p iowaitany.p iotestall.p iotestany.p iowaitsome.p iotestsome.p"
+MPIO_REQ_REAL_POBJECTS="_iotest.o _iowait.o _iowaitall.o _iowaitany.o _iotestall.o _iotestany.o _iowaitsome.o _iotestsome.o"
+#
 have_aio=no
 #
 known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs"
@@ -285,7 +291,7 @@
 #
 C_DEBUG_FLAG="-g"
 F77_DEBUG_FLAG="-g"
-C_OPT_FLAG="-O"
+C_OPT_FLAG=${CFLAGS:-"-O"}
 case $ARCH in 
      sun4)
      CC=${CC:-gcc}
@@ -889,6 +895,10 @@
 
 AC_HAVE_FUNCS(memalign)
 
+#
+# Question: Should ROMIO under MPICH2 ignore the Fortran tests, since 
+# MPICH2 provides all of the Fortran interface routines?
+#
 if test $NOF77 = 0 ; then
     echo "checking Fortran external names"
     PAC_GET_FORTNAMES
@@ -1017,9 +1027,14 @@
 #
 # check if darray and subarray constructors are defined in the MPI 
 # implementation 
-if test $WITHIN_KNOWN_MPI_IMPL = no -o $FROM_MPICH2 != no ; then
+if test $WITHIN_KNOWN_MPI_IMPL = no ; then
    PAC_MPI_DARRAY_SUBARRAY
-else
+fi
+if test $FROM_MPICH2 = yes ; then
+   dnl Made this a message instead of a warning because the warning is
+   dnl likely to confuse users.
+   AC_MSG_RESULT("Overriding Array test for MPICH2")
+   unset BUILD_MPI_ARRAY
    AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,1,[Define if Darray is available])
    HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
    MPI_FARRAY1="!"
@@ -1046,24 +1061,29 @@
 if test $TRY_WEAK_SYMBOLS = 1 ; then
   AC_MSG_CHECKING([for weak symbol support])
   AC_TRY_LINK([
-extern int Foo(int);
+extern int PFoo(int);
 #pragma weak PFoo = Foo
-int Foo(a) { return a; }
+int Foo(int a) { return a; }
 ],[return PFoo(1);],has_pragma_weak=1)
   #
   # Some systems (Linux ia64 and ecc, for example), support weak symbols
   # only within a single object file!  This tests that case.
-  if test "$has_pragma_weak" = 1 ; then
+  # Note that there is an extern int PFoo declaration before the
+  # pragma.  Some compilers require this in order to make the weak symbol
+  # extenally visible.  
+if test "$has_pragma_weak" = 1 ; then
     AC_MSG_RESULT([pragma weak])
     AC_MSG_CHECKING([that weak symbols are visible to other files])
     rm -f conftest*
     cat >>conftest1.c <<EOF
-extern int Foo(int);
+extern int PFoo(int);
 #pragma weak PFoo = Foo
-int Foo(a) { return a; }
+int Foo(int);
+int Foo(int a) { return a; }
 EOF
     cat >>conftest2.c <<EOF
-int main() {
+extern int PFoo(int);
+int main(int argc, char **argv) {
 return PFoo(0);}
 EOF
     ac_link2='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest1.c conftest2.c $LIBS >conftest.out 2>&1'
@@ -1085,8 +1105,9 @@
     AC_DEFINE(HAVE_PRAGMA_WEAK,1,[Define if pragma weak available])
   else
     AC_TRY_LINK([
+extern int PFoo(int);
 #pragma _HP_SECONDARY_DEF Foo PFoo
-int Foo(a) { return a; }
+int Foo(int a) { return a; }
 ],[return PFoo(1);],has_pragma_hp_secondary=1)
     if test "$has_pragma_hp_secondary" = 1 ; then 
         AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
@@ -1094,8 +1115,9 @@
         AC_DEFINE(HAVE_PRAGMA_HP_SEC_DEF,1,[Define for HP weak pragma])
     else
         AC_TRY_LINK([
+extern int PFoo(int);
 #pragma _CRI duplicate PFoo as Foo
-int Foo(a) { return a; }
+int Foo(int a) { return a; }
 ],[return PFoo(1);],has_pragma_cri_duplicate=1)
         if test "$has_pragma_cri_duplicate" = 1 ; then
 	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
@@ -1150,35 +1172,10 @@
 
 if test -n "$file_system_nfs" ; then
    # Check for problems with locks
-   AC_MSG_CHECKING([whether file locks work with NFS])
-   AC_TRY_RUN([
-#include <fcntl.h>
-#include <errno.h>
-#include <unistd.h>
-
-int main()
-{
-    struct flock lock;
-    int fd, err;
-
-    lock.l_type = F_WRLCK;
-    lock.l_start = 0;
-    lock.l_whence = SEEK_SET;
-    lock.l_len = 100;
-
-    fd = open("conftest.dat", O_RDWR | O_CREAT, 0644);
-
-    err = fcntl(fd, F_SETLKW, &lock);
-
-   /* printf("err = %d, errno = %d\n", err, errno); */
-    close(fd);
-    return err;
-}],nfs_locks_work=yes,nfs_locks_work=no,nfs_locks_work=unknown)
-    AC_MSG_RESULT($nfs_locks_work)
-    if test "$nfs_locks_work" != "yes" ; then
-        AC_MSG_WARN([File locks do not work with NFS.  See the Installation and
-users manual for instructions on fixing this])
-    fi
+   # We no longer do this within the configure test.  Instead,
+   # we suggest tha the user run maint/nfslock.c
+   AC_MSG_WARN([File locks may not work with NFS.  See the Installation and
+users manual for instructions on testing and if necessary fixing this])
 fi
 if test -n "$file_system_nfs"; then
     AC_DEFINE(NFS,1,[Define for NFS])
@@ -1279,6 +1276,14 @@
     fi
 fi
 AC_SUBST(master_top_srcdir)
+#
+# Get the master builddir (which may be imported from above)
+if test -z "$master_top_builddir" ; then
+    master_top_builddir=`pwd`
+fi
+export master_top_builddir
+AC_SUBST(master_top_builddir)
+
 # The following definitions are needed within adio/common/status_setb.c
 if test "$FROM_MPICH" = yes ; then
    AC_DEFINE(MPICH,1,[Define if compiling within MPICH])
@@ -1314,11 +1319,17 @@
     MPIO_EXTRA_OBJECTS=
     MPIO_EXTRA_TMP_POBJECTS=
     MPIO_EXTRA_REAL_POBJECTS=
+    # Use generalized request to get the multiple-completion routines
+    MPIO_REQOBJECTS=
+    MPIO_REQ_TMP_POBJECTS=
+    MPIO_REQ_REAL_POBJECTS=
 fi
 AC_SUBST(MPIO_EXTRA_OBJECTS)
 AC_SUBST(MPIO_EXTRA_TMP_POBJECTS)
 AC_SUBST(MPIO_EXTRA_REAL_POBJECTS)
-
+AC_SUBST(MPIO_REQOBJECTS)
+AC_SUBST(MPIO_REQ_TMP_POBJECTS)
+AC_SUBST(MPIO_REQ_REAL_POBJECTS)
 #
 if test $NOF77 = 1 ; then
    F77=":"
@@ -1360,7 +1371,14 @@
       TEST_F77=$MPI_BIN_DIR/mpif77
    fi
    CC=$MPI_BIN_DIR/mpicc
-   EXTRA_DIRS="mpi-io/fortran mpi2-other/info mpi2-other/info/fortran mpi2-other/array mpi2-other/array/fortran"
+#   if test $FROM_MPICH2 != yes ; then
+#       BUILD_MPI_ARRAY=1
+#       BUILD_MPI_INFO=1
+#   fi
+   # A later test will insert the mpi2-other/info and array directories based
+   # on the value of BUILD_MPI_xxxx.  This lets MPICH2 turn these off,
+   # since MPICH2 provides these routines elsewhere
+   EXTRA_DIRS="mpi-io/fortran"
    # Some older implementations of the ADI do not include the 
    # MPID_Status_set_bytes routine.   This uses either the 
    # environment variable ADI3_WITHOUT_SET_BYTES or the
@@ -1526,6 +1544,7 @@
 AC_SUBST(MPI_FARRAY7)
 AC_SUBST(MPI_OFFSET_KIND1)
 AC_SUBST(MPI_OFFSET_KIND2)
+AC_SUBST(MPIO_REQOBJECTS)
 AC_SUBST(TEST_CC)
 AC_SUBST(TEST_F77)
 AC_SUBST(ROMIO_INCLUDE)
@@ -1546,6 +1565,7 @@
 fi
 AC_SUBST(ENABLE_SHLIB)
 AC_SUBST(CC_SHL)
+AC_SUBST(LIBTOOL)
 # Remove the .a from the library file name (so that we can use .so or
 # other appropriate suffix)
 SHLIBNAME=`echo $LIBNAME | sed 's/\.a//'`
Index: romio/configure2.in
diff -u romio/configure2.in:1.36 romio/configure2.in:removed
--- romio/configure2.in:1.36	Wed Oct  8 09:59:50 2003
+++ romio/configure2.in	Thu May 20 15:51:14 2004
@@ -1,1471 +0,0 @@
-# build with
-# autoconf -output=configure2 --localdir=../confdb configure2.in
-# (or wherever the confdb is)
-# The following usage message is out-of-date
-# It is retained only to remind us which options were defined.
-
-usage_msg="
-Usage: ${progname} [-file_system=FILE_SYSTEM] [-arch=ARCH_TYPE] [-mpi=MPI_IMPL]
-                [-mpilib=MPI_LIBRARY]
-		[-mpibindir=MPI_BIN_DIR]
-                [-cc=C_COMPILER] [-fc=FORTRAN_COMPILER] [-nof77] 
-                [-cflags=CFLAGS] [-fflags=FFLAGS] [-f90=F90_COMPILER] [-debug] 
-                [-mpiolib=MPIO_LIBRARY] [-ar_nolocal] 
-                [-noranlib] [-ar=AR_COMMAND] [-prefix=INSTALL_DIR]  
-                [-longlongsize=LONGLONGSIZE] [-disable-weak-symbols]
-
-where
-   FILE_SYSTEM  = the file system(s) for which ROMIO is to be configured.
-                  Valid values are pfs, piofs, hfs, xfs, sfs, pvfs, ufs,
-                  and nfs (case-sensitive). They correspond to Intel's PFS, 
-                  IBM's PIOFS, HP/Convex's HFS, SGI's XFS, NEC's SFS, 
-                  Clemson University's PVFS (for Linux clusters), any Unix 
-                  file system, and NFS. 
-                  To configure for multiple file systems, use "+" as a 
-                  separator; e.g., ufs+nfs
-   ARCH_TYPE    = the type of machine for which ROMIO is to be configured.
-                  Not needed on most machines, because ROMIO can usually
-                  find the arch_type on its own. Needed if you are 
-                  cross-compiling for a different architecture.
-                  Valid values are sun4, solaris, solaris86, rs6000,
-                  paragon, hpux, sppux, IRIX, IRIX32, IRIXN32, IRIX64, SX4, 
-                  alpha, freebsd, LINUX, and LINUX_ALPHA.  (case-sensitive)
-   MPI_IMPL     = the MPI implementation with which ROMIO will be used
-                  Valid values are mpich, sgi, hp. (case-sensitive)
-                  Valid implementations are MPICH 1.1.1 or higher,
-                  SGI's MPI 3.1 or higher, HP MPI 1.3 or higher, LAM, 
-                  and Cray MPI.
-   MPI_INCLUDE_DIR = the full path of the directory where mpi.h is located.
-                  Not needed if the directory is in the compiler's 
-                  default include path
-   MPI_LIBRARY  = name of the file containing the MPI library (full path).
-                  Not needed if the library is in the compiler's default
-                  list of libraries
-   MPI_BIN_DIR  = the full path of the directory that contains the MPI
-                  versions of the compilers, such as mpicc and mpif77.
-                  Use only if the ROMIO configure cannot find the
-                  necessary commands
-   C_COMPILER   = the C compiler to use. If not specified, ROMIO uses a 
-                  default compiler depending on the machine.
-   FORTRAN_COMPILER = the Fortran compiler to use. If not specified, ROMIO 
-                  uses a default compiler depending on the machine.
-   CFLAGS       = flags to give to the C compiler
-   FFLAGS       = flags to give to the Fortran compiler
-   F90_COMPILER = the Fortran 90 compiler to use. If not specified, 
-                  ROMIO uses f90.
-   MPIO_LIBRARY = name of the MPI-IO library to be built (full path).
-                  Default is "this_directory"/lib/ARCH_TYPE/libmpio.a.
-   AR_COMMAND   = an alternate archiver (ar) command to use.
-   INSTALL_DIR  = directory where ROMIO is to be installed
-   LONGLONGSIZE = size of long long in bytes.
- 
-The option '-nof77' prevents the compilation of routines that require a
-Fortran compiler.  If you select this option, you cannot use the
-Fortran interface of MPI-IO.
-
-If '-debug' is used, ROMIO will be configured with the '-g' compiler option
-for debugging.
-
-The option '-ar_nolocal' prevents the library archive command from
-attempting to use the local directory for temporary space.  This option
-should be used when (a) there isn't much space (less than 10 MB)
-available in the partition where ROMIO resides and (b) there is enough
-space in /tmp (or wherever ar places temporary files by default).
-
-The option '-noranlib' causes the 'ranlib' step (needed on some systems
-to build an object library) to be skipped.  This is particularly useful
-on systems where 'ranlib' is optional (allowed but not needed; because it
-is allowed, configure chooses to use it just in case) but can fail (some
-'ranlib's are implemented as scripts using 'ar'; if they don't use the
-local directory, they can fail (destroying the library in the process) if
-the temporary directory (usually '/tmp') does not have enough space.
-
-The option -disable-weak-symbols disables the use of weak symbols, even if 
-available, for building the profiling interface.
-"
-#
-AC_INIT(adio/include/romioconf.h.in)
-echo " "
-echo "Configuring ROMIO Version 1.2.6"
-echo " "
-CONFIGURE_ARGS="$*"
-if test -n "$CONFIGURE_ARGS" ; then
-    echo "Configuring with args $CONFIGURE_ARGS"
-fi
-
-print_error() {
-    echo "*# $*" 2>&1 ;
-}
-
-AC_CONFIG_HEADER(adio/include/romioconf.h)
-dnl
-NOF77=0
-ARCH=""
-arch_IRIX=""
-MPI=""
-MPI_INCLUDE_DIR=""
-ROMIO_INCLUDE=""
-MPI_LIB=""
-LIBNAME=""
-TEST_LIBNAME=""
-FILE_SYSTEM=""
-DEBUG=no
-MIPS=0
-BITS=0
-FROM_MPICH=${FROM_MPICH:-0}
-FROM_MPICH2=${FROM_MPICH2:-0}
-CFLAGS=${CFLAGS:-""}
-LL="\%lld"
-AR_LOCAL=l
-HAVE_MPI_INFO=""
-BUILD_MPI_INFO=""
-MPI_FINFO1=""
-MPI_FINFO2=""
-MPI_FINFO3=""
-MPI_FINFO4=""
-MPI_FARRAY1=""
-MPI_FARRAY2=""
-MPI_FARRAY3=""
-MPI_FARRAY4=""
-MPI_FARRAY5=""
-MPI_FARRAY6=""
-MPI_FARRAY7=""
-DEFS=""
-ROMIO_LFLAGS=""
-ROMIO_LIBLIST=""
-ROMIO_TCFLAGS=""
-ROMIO_TCPPFLAGS=""
-ROMIO_TFFLAGS=""
-NOPROFILE=0
-MPIRUN=""
-FORTRAN_TEST=""
-MAKE=${MAKE:-"make"}
-# foll. needed for f77 test programs
-F77GETARG="call getarg(i,str)"
-F77IARGC="iargc()"
-F77MPIOINC=""
-FTESTDEFINE=""
-FORTRAN_MPI_OFFSET=""
-MPIOF_H_INCLUDED=0
-MPI_OFFSET_KIND1="!"
-MPI_OFFSET_KIND2="!"
-F90=""
-TEST_CC=""
-TEST_F77=""
-TRY_WEAK_SYMBOLS=1
-#
-known_filesystems="nfs ufs pfs piofs pvfs pvfs2 testfs xfs hfs sfs"
-known_mpi_impls="mpich_mpi sgi_mpi hp_mpi cray_mpi lam_mpi"
-#
-# Defaults
-AC_ARG_ENABLE(aio,[
---enable-aio - Request use of asynchronous I/O routines],,enable_aio=notgiven)
-AC_ARG_ENABLE(echo, 
-[--enable-echo  - Turn on strong echoing. The default is enable=no.] ,set -x)
-AC_ARG_ENABLE(f77,
-[--enable-f77 - Turn on support for Fortran 77 (default)],,enable_f77=yes)
-AC_ARG_WITH(file-system,[
---with-file-system=name - Build with support for the named file systems],,)
-AC_ARG_WITH(mpi,[
---with-mpi=name - Specify MPI implementation to build ROMIO for],,)
-dnl
-if test "$enable_f77" != "yes" ; then
-   NOF77=1
-fi
-MPI=$with_mpi
-FILE_SYSTEM=$with_file_system
-#
-for arg
-do
-case $arg in
-  -arch=* | --arch=*)
-     ARCH=`echo $arg|sed 's/-*arch=//'`
-     eval "arch_`echo $ARCH`=1"
-     ;;
-
-  -debug | --debug | --enable-g | -enable-g)
-     echo "Configuring for a debugging version"
-     DEBUG=yes
-     ;;
-  -from_mpich | --from_mpich)
-     FROM_MPICH=1
-     ;;
-
-  -noprofile | --noprofile | --disable-profile | -disable-profile )
-     echo "profiling interface will not be built"
-     NOPROFILE=1
-     ;;
-
-  -disable-weak-symbols|--disable-weak-symbols)
-     TRY_WEAK_SYMBOLS=0
-     ;;
-esac
-done
-#
-AC_CONFIG_AUX_DIR(../../../confdb)
-dnl PAC_ARG_CACHING
-
-rm -f config.log
-#
-# Check that an arch was set
-# If it wasn't set, try to guess using "util/tarch"
-#
-if test -z "$ARCH" -a -x $srcdir/util/tarch ; then
-    AC_MSG_CHECKING(for architecture)
-    ARCH=`$srcdir/util/tarch | sed s/-/_/g`
-    if test -z "$ARCH" ; then
-       AC_MSG_RESULT(Unknown!)
-       AC_MSG_ERROR([Error: Couldn't guess target architecture, you must
-set an architecture type with -arch=<value>])
-    fi
-    eval "arch_$ARCH=1"
-    AC_MSG_RESULT($ARCH)
-fi
-#
-# check for valid architecture.  Use __ so that _ALPHA_ does not match
-# LINUX_ALPHA_
-#### WE SHOULD REMOVE THIS SOON
-grep __"$ARCH"_ $srcdir/.config_params > /dev/null 2>&1
-if test $? != 0 ; then
-   AC_MSG_WARN([Unknown architecture $arch... proceeding anyway])
-fi
-#
-#
-#
-# Find the home directory if not specified
-if test "X$srcdir" != "X." -a -s $srcdir/mpi-io/Makefile.in ; then 
-    ROMIO_HOME_TRIAL=$srcdir
-else
-    # Take advantage of autoconf2 features
-    ROMIO_HOME_TRIAL=$ac_srcdir
-    dnl PAC_GETWD(ROMIO_HOME_TRIAL,mpi-io/Makefile.in)
-fi
-echo "ROMIO home directory is $ROMIO_HOME_TRIAL"
-ROMIO_HOME=$ROMIO_HOME_TRIAL
-#
-# Create the "autoconf" style directory names...
-#
-# mandir is the root for the man pages
-if test -z "$mandir" ; then mandir='${prefix}/man' ; fi
-AC_SUBST(mandir)
-if test -z "$docdir" ; then docdir='${prefix}/doc' ; fi
-AC_SUBST(docdir)
-if test -z "$htmldir" ; then htmldir='${prefix}/www' ; fi
-AC_SUBST(htmldir) 
-#
-# check for valid file system
-if test -n "$FILE_SYSTEM" ; then
-   # if multiple filesystems are passed in, they are '+'-delimited
-   # we could set the IFS to tokenize FILE_SYSTEM, but the FILE_SYSTEM env var
-   # is used in multiple places in the build system: get rid of the '+'s so we
-   # can use the 'for x in $FILE_SYSTEM ...' idiom 
-   FILE_SYSTEM=`echo $FILE_SYSTEM|sed -e 's/\+/ /g'`
-   for x in $FILE_SYSTEM
-   do
-      found=no
-      # We could also do test -d "ad_$y" to test for known file systems
-      # based on having access to the adio code.  Then adding a file 
-      # system would not require changing configure to change known_filesystems
-      for y in $known_filesystems ; do 
-          if test $x = $y ; then
-	      found=yes
-	      eval "file_system_`echo $x`=1"
-	      break
-	  fi
-      done
-      if test "$found" = "no" ; then
-         AC_MSG_WARN([Unknown file system $x... proceeding anyway])
-      fi
-   done
-fi
-#
-# check for valid MPI implementation
-if test -n "$MPI" ; then
-   found=no
-   for mpi in $known_mpi_impls ; do
-      if test "${MPI}_mpi" = "$mpi" ; then
-          found=yes
-	  break
-      fi
-   done
-   if test $found = no ; then
-      AC_MSG_WARN([Unknown MPI implementation $MPI... proceeding anyway])
-   fi
-fi
-#
-# check for valid MPI include directory if specified
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   if test -n "$MPI_INCLUDE_DIR"; then
-      if test ! -f "$MPI_INCLUDE_DIR/mpi.h" ; then
-         AC_MSG_ERROR([Include file $MPI_INCLUDE_DIR/mpi.h not found])
-      fi
-   else
-#     assume that mpi.h is in the default path
-#     set MPI_INCLUDE_DIR to ".", so that it translates to -I. in the
-#     compile command. Some compilers complain if it's only -I
-      MPI_INCLUDE_DIR=.
-   fi
-else 
-   MPI_INCLUDE_DIR=.
-fi
-#
-# check for valid MPI library if specified
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   if test -n "$MPI_LIB" ; then
-      if test ! -f "$MPI_LIB" ; then
-         AC_MSG_ERROR([MPI library $MPI_LIB not found])
-      fi
-   fi
-fi
-#
-#
-AR="${AR:-ar} cr$AR_LOCAL"
-if test -z "$RANLIB" ; then
-    AC_PROG_RANLIB
-fi
-MAKE=${MAKE:-make}
-#
-# USER_CFLAGS and USER_FFLAGS are used only in test/Makefile.in
-if test $DEBUG = "yes"; then
-    USER_CFLAGS="$CFLAGS -g"
-    USER_FFLAGS="$FFLAGS -g"
-else
-    USER_CFLAGS="$CFLAGS -O"
-    USER_FFLAGS="$FFLAGS -O"
-fi
-#
-if test -n "$arch_sun4" ; then 
-    CC=${CC:-gcc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-	if test "$CC" = "gcc"; then
-           CFLAGS="$CFLAGS -g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
-	else
-           CFLAGS="$CFLAGS -g"
-        fi
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    if test "$enable_aio" != "no" ; then
-        # Check for aio
-	AC_SEARCH_LIBS(aiowrite,aio rt)
-	if test "$ac_cv_search_aiowrite" = "no" ; then
-	    enable_aio=no
-	elif test "$ac_cv_search_aiowrite" != "none required" ; then
-	    ROMIO_LIBLIST="$ROMIO_LIBLIST $ac_cv_search_aiowrite"
-        fi
-    fi
-    if test "$enable_aio" = "no" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else 
-        AC_DEFINE(AIO_SUN,,[Define for SUN0S 4])
-    fi
-
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-fi
-#
-if test -n "$arch_solaris" || test -n "$arch_solaris86" ; then
-    CC=${CC:-cc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-        if test "$CC" = "gcc" ; then
-            CFLAGS="$CFLAGS -g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
-        else 
-            CFLAGS="$CFLAGS -g -v"
-        fi
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    if test "$enable_aio" != "no" ; then
-        # Check for aio
-	AC_SEARCH_LIBS(aiowrite,aio rt)
-	if test "$ac_cv_search_aiowrite" = "no" ; then
-	    enable_aio=no
-	elif test "$ac_cv_search_aiowrite" != "none required" ; then
-	    ROMIO_LIBLIST="$ROMIO_LIBLIST $ac_cv_search_aiowrite"
-	    MPI_LIB="$MPI_LIB -laio"
-        fi
-    fi
-    if test "$enable_aio" = "no" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else 
-        AC_DEFINE(AIO_SUN,,[Define for SUN0S 4])
-    fi
-
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-    AC_DEFINE(SOLARIS,,[Define for Solaris])
-    if test $MPI = "mpich" ; then
-        TEST_CC=mpicc
-        TEST_F77=mpif77
-    else
-        TEST_CC="$CC"
-        TEST_F77="$F77"
-    fi
-    AR="ar cr"
-# solaris does not have l option to ar
-# solaris f90 does not have 8-byte integer type
-# (it does now!!!! 11/29/01)
-fi
-#
-if test -n "$arch_rs6000"; then
-    F77=$FC
-    if test -z "$CC"; then
-       AC_PROGRAMS_CHECK(CC, mpcc, cc)
-       echo "Using $CC"
-    fi
-    if test $NOF77 = 0 && test -z "$FC"; then 
-       AC_PROGRAMS_CHECK(F77, mpxlf, f77)
-       echo "Using $F77"
-    fi
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    # Check that aio is available (many systems appear to have aio
-    # either installed improperly or turned off).
-    # The test is the following: if not cross compiling, try to run a 
-    # program that includes a *reference* to aio_write but does not call it
-    # If the libraries are not set up correctly, then this will fail.
-    AC_MSG_CHECKING([whether aio routines can be used])
-    AC_TRY_RUN([
-int main( int argc, char **argv )
-{
-    if (argc > 10) aio_write();
-    return 0;
-}
-],aio_runs=yes,aio_runs=no,aio_runs=unknown)
-    AC_MSG_RESULT($aio_runs)						 
-    if test "$enable_aio" != "no" -a "$aio_runs" = "no" ; then
-        enable_aio=no
-    fi
-    if test "$enable_aio" = "no" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else
-        AC_DEFINE(NO_FD_IN_AIOCB,,[Define for no fd in the aiocb])
-        AC_DEFINE(AIO_HANDLE_IN_AIOCB,,[Define for aio handle in aiocb])
-    fi
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        if test "$CC" = "mpcc" || test "$CC" = "mpCC" ; then
-            file_system_piofs=1
-            FILE_SYSTEM="piofs"
-            AC_MSG_RESULT([configuring for file systems piofs, ufs, and nfs])
-        else 
-            AC_MSG_RESULT([configuring for file systems ufs and nfs])
-        fi
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="$FILE_SYSTEM ufs nfs"
-    fi
-    AC_DEFINE(AIX,,[Define for AIX])
-# assume long long exists.
-    longlongsize=${longlongsize:-8} 
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi    
-#
-if test -n "$arch_paragon"; then
-    CC=${CC:-icc}
-    F77=${FC:-if77}
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g"
-    else 
-	if test "$CC" = "icc"; then
-           CFLAGS="$CFLAGS -Knoieee -Mvect -O3"
-	else
-           CFLAGS="$CFLAGS -O"
-        fi
-    fi
-    AR="ar860 cr$AR_LOCAL"
-    MPI_LIB="$MPI_LIB -nx"
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_pfs=1
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="pfs ufs nfs"
-        AC_MSG_RESULT([configuring for file systems pfs, ufs, and nfs])
-    fi
-    AC_DEFINE(PARAGON,,[Define for Intel Paragon])
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-# NO_AIO is if configuring for NFS/UFS. It doesn't affect PFS asynch. I/O.
-# long long does not exist
-    longlongsize=${longlongsize:-0} 
-fi    
-#
-if test -n "$arch_tflop" || test -n "$arch_tflops"; then
-    CC=${CC:-pgcc}
-    F77=${FC:-pgf77}
-    TFLOP_FLAGS="-cougar -D__PUMA"
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g $TFLOP_FLAGS"
-    else
-       if test "$CC" = "pgcc"; then
-           CFLAGS="$CFLAGS -Knoieee -Mvect -O3 $TFLOP_FLAGS"
-       else
-           CFLAGS="$CFLAGS -O $TFLOP_FLAGS"
-       fi
-    fi
-    AR="xar cr$AR_LOCAL"
-        RANLIB="xranlib"
-    MPI_LIB="$MPI_LIB"
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        FILE_SYSTEM="ufs"
-        AC_MSG_RESULT([configuring for file system ufs])
-    fi
-fi
-#
-if test -n "$arch_freebsd" || test -n "$arch_LINUX" || test -n "$arch_LINUX_ALPHA" || test -n "$arch_netbsd" || test -n "$arch_openbsd" ; then
-    CC=${CC:-gcc}
-    if test -n "$arch_freebsd" || test -n "$arch_netbsd" || test -n "$arch_openbsd"; then
-       F77=${FC:-f77}
-       AC_DEFINE(FREEBSD,,[Define for FreeBSD])
-       PAC_HAVE_MOUNT_NFS
-       longlongsize=${longlongsize:-0}
-# printf doesn't work properly and no integer*8 as far as I can tell
-    else 
-       F77=${FC:-g77}
-       AC_DEFINE(LINUX,,[Define for Linux])
-    fi
-    if test $DEBUG = "yes" ; then
-	if test "$CC" = "gcc" ; then
-            CFLAGS="$CFLAGS -g -O -Wall -Wstrict-prototypes -Wmissing-prototypes"
-        else
-	    CFLAGS="$CFLAGS -g"
-        fi
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    if test "$enable_aio" != "yes" ; then
-        AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    else
-        # Try to find the aio routines
-	use_aio=no
-        AC_HEADER_CHECK(aio.h,has_aio_h=yes,has_aio_h=no)
-	add_lib=""
-	AC_SEARCH_LIBS(aio_write,aio,add_lib="-laio")
-	# What function do we want -lrt for?  In recent Linux, aio_write64
-	# is here, as is lio_listio
-	AC_SEARCH_LIBS(aio_write64,rt,add_lib="$add_lib -lrt")
-	AC_SEARCH_LIBS(pthread_create,pthread,[add_lib="$add_lib -lpthread"
-has_pthread=yes],[has_pthread=no])
-        AC_FUNC_CHECK(aio_write,has_aio_write=yes,has_aio_write=no)
-	if test "$has_aio_h" = "yes" -a "$has_aio_write" = "yes" -a \
-	        "$has_pthread" = "yes" ; then
-	    use_aio=yes	
-	fi    
-	# Check for aiocb_t as a shorthand for struct aiocb
-	AC_MSG_CHECKING([for aiocb_t])
-	AC_TRY_COMPILE([#include <aio.h>],
-[aiocb_t a;],has_aiocb_t=yes,has_aiocb_t=no)
-	AC_MSG_RESULT($has_aiocb_t)
-	if test "$has_aiocb_t" = "no" ; then 
-	    AC_DEFINE(NEEDS_AIOCB_T,,[Define for aiocb_t definition needed])
-        fi
-	if test "$use_aio" = "yes" ; then
-	    ROMIO_LIBLIST="$ROMIO_LIBLIST $add_lib"
-	else
-            AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-	fi
-    fi
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-fi    
-#
-if test -n "$arch_SX4" ; then
-    CC=${CC:-mpicc}
-    F77=${FC:-mpif90}
-    if test $DEBUG = "yes" ; then
-        CFLAGS="$CFLAGS -g"
-        FFLAGS="$FFLAGS -g"
-    else
-        USER_FFLAGS="$FFLAGS -Chopt"
-        CFLAGS="$CFLAGS -O"
-        FFLAGS="$FFLAGS -Chopt"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    AC_DEFINE(SX4,,[Define for NEC SX4])
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_sfs=1
-        file_system_nfs=1
-        FILE_SYSTEM="sfs nfs"
-        AC_MSG_RESULT([configuring for file systems sfs and nfs])
-    fi
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi
-#
-if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g +w1"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    RANLIB=":"
-    if test -z "$MPI"; then
-        if test -f "/opt/mpi/include/mpi.h" ; then
-            echo "assuming that you want to use ROMIO with HP MPI"
-            MPI=hp
-        else 
-            echo "assuming that you want to use ROMIO with MPICH"
-            MPI=mpich
-        fi            
-    fi
-    if test $MPI = "mpich" ; then
-        mpi_mpich=1
-        MPI_LIB="$MPI_LIB -lV3"
-        CC=${CC:-cc -Ae}
-        F77=${FC:-f77 +U77}
-    fi
-    if test $MPI = "hp" ; then
-        mpi_hp=1
-        CC=${CC:-mpicc -Ae}
-        F77=${FC:-mpif77 +U77}
-    fi
-    if test $MPI = "lam" && test "$FC" != ""; then
-        FC="$FC +U77"
-    fi
-    FTESTDEFINE="external iargc, getarg"
-    if test -n "$arch_hpux" ; then
-        CFLAGS="$CFLAGS -D_LARGEFILE64_SOURCE"
-        AC_DEFINE(HPUX,,[Define for HPUX])
-        if test $MPI = "hp" ; then
-           F77=${FC:-mpif90 +U77}
-        else
-           F77=${FC:-f90 +U77}
-        fi
-    else
-        AC_DEFINE(SPPUX,,[Define for SPPUX (Convex)])
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        if test -n "$arch_hpux" ; then
-	   AC_MSG_CHECKING([for struct flock64])
-           AC_TRY_COMPILE([#include <fcntl.h>],[
-struct flock64 fl; int i=F_SETLKW64;],flock64_ok="yes",flock64_ok="no")
-           AC_MSG_RESULT($flock64_ok)
-        else
-            flock64_ok="yes"
-        fi
-        if test $flock64_ok = "yes" ; then
-            file_system_hfs=1
-            file_system_nfs=1
-            FILE_SYSTEM="hfs nfs"
-            AC_MSG_RESULT([configuring for file systems hfs and nfs])
-        else
-            file_system_ufs=1
-            file_system_nfs=1
-            FILE_SYSTEM="ufs nfs"
-            AC_MSG_RESULT([no flock64; configuring for file systems ufs and nfs])
-        fi
-    fi
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-    if test "$CC" != "gcc" ; then
-        ROMIO_TCFLAGS="-Ae"
-    fi
-    if test "$F77" != "g77" ; then
-        ROMIO_TFFLAGS="+U77"
-    fi
-fi
-#
-if test -n "$arch_alpha" || test -n "$arch_ALPHA" ; then
-    CC=${CC:-cc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g -std1 -warnprotos -verbose"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    AC_DEFINE(AIO_PRIORITY_DEFAULT,,[Define for AIO priority is default])
-    if test -z "$MPI" ; then
-        MPI=mpich
-        mpi_mpich=1
-    fi
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-    AC_DEFINE(DEC,,[Define for DEC/Compaq/HP Alpha])
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-    ROMIO_LIBLIST="$ROMIO_LIBLIST -laio"
-fi    
-#
-if test -n "$arch_CRAY" ; then
-    CC=${CC:-cc}
-    F77=${FC:-f90}
-    NOF77=1
-    FTESTDEFINE="integer ilen"
-    F77GETARG="call pxfgetarg(i, str, ilen, ierr)"
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-    RANLIB=":"
-    CFLAGS="$CFLAGS -D_UNICOS"
-    AC_DEFINE(CRAY,,[Define if Cray])
-    if test -z "$MPI" || test -n "$mpi_sgi" ; then
-        MPI=cray
-        mpi_cray=1
-        mpi_sgi=""
-# above is to disable configure tests specific to SGI MPI
-        AC_DEFINE(MPISGI,,[Define if SGI MPI])
-        AC_DEFINE(HAVE_MPI_COMBINERS,,[Define if MPI supports datatype combiners])
-        AC_DEFINE(NO_MPI_SGI_type_is_contig,,[Define if no types show contig])
-    fi
-#       MPISGI needed because of error in Cray's and SGI's 
-#       MPI_Type_get_contents (does not increment reference count).
-#       Others needed because MPISGI needed.
-    if test -z "$FILE_SYSTEM" ; then
-        file_system_ufs=1
-        file_system_nfs=1
-        FILE_SYSTEM="ufs nfs"
-        AC_MSG_RESULT([configuring for file systems ufs and nfs])
-    fi
-    MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-    MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi
-#
-if test -n "$arch_sgi" ; then
-    arch_IRIX=1
-    ARCH=IRIX
-fi
-if test -n "$arch_IRIX64" ; then
-    arch_IRIX=1
-fi
-if test -n "$arch_IRIX32" ; then
-    arch_IRIX=1
-fi
-if test -n "$arch_IRIXN32" ; then
-    arch_IRIX=1
-fi
-if test -n "$arch_sgi5" ; then
-    arch_IRIX5=1
-    ARCH=IRIX
-fi
-#
-PAC_GET_SPECIAL_SYSTEM_INFO
-#
-# special case 'sgi5' for use on MESHINE which is much like an SGI running
-# irix 5 with r4400 chips, but does not have 'hinv', so above code doesn't
-# work
-if test -n "$arch_sgi5"; then
-   osversion=5
-   cputype=4400
-   IRIXARCH="$ARCH_$osversion"
-   IRIXARCH="$IRIXARCH_$cputype"
-# now set arch_IRIX to 1
-   arch_IRIX=1
-   echo "IRIX-specific architecture is $IRIXARCH"
-   AC_DEFINE(IRIX,,[Define if IRIX])
-fi
-#
-if test -n "$arch_IRIX"; then
-    CC=${CC:-cc}
-    F77=${FC:-f77}
-    if test $DEBUG = "yes"; then
-        CFLAGS="$CFLAGS -g -fullwarn"
-    else 
-        CFLAGS="$CFLAGS -O"
-    fi
-   if test $osversion = 4 ; then
-	RANLIB="ar ts"
-        if test -n "$mpi_sgi"; then
-            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 4.x])
-        fi
-   elif test $osversion = 5 ; then
-        if test -n "$mpi_sgi"; then
-            AC_MSG_ERROR([SGI\'s MPI does not work with IRIX 5.x])
-        fi
-   elif test $osversion = 6 ; then
-	if test -z "$MPI"; then
-	    if test "$FROM_MPICH2" = "1" ; then
-	        # Building with MPICH2.  Distinguish from MPICH-1
-		MPI=mpich2
-		mpi_mpich2=1
-            elif test -f "/usr/include/mpi.h" ; then
-                AC_MSG_WARN([assuming that you want to use ROMIO with SGI\'s MPI])
-                MPI=sgi
-                mpi_sgi=1
-            else 
-	        AC_MSG_WARN([assuming that you want to use ROMIO with MPICH])
-                MPI=mpich
-                mpi_mpich=1
-            fi            
-	fi
-        RANLIB=":"
-        AC_DEFINE(AIO_SIGNOTIFY_NONE,,[Define if no signotify])
-	if test $cputype -ge 5000 ; then
-            MIPS=4
-        else 
-            MIPS=3
-        fi
-   fi
-   if test -n "$mpi_sgi" && test -z "$MPI_LIB" ; then
-       MPI_LIB="-lmpi"
-   fi
-#  check if pread64 is defined
-   PAC_HAVE_PREAD64
-#
-   if test -z "$FILE_SYSTEM" ; then
-       file_system_nfs=1
-       FILE_SYSTEM="nfs"
-       AC_MSG_CHECKING(for xfs)
-       AC_TRY_COMPILE([
-#include <aio.h>],
-[aiocb64_t *t1;],file_system_xfs=1;FILE_SYSTEM="xfs $FILE_SYSTEM";)
-       if test "$file_system_xfs" = 1 ; then 
-          AC_MSG_RESULT(yes)
-       else
-          AC_MSG_RESULT(no)
-          file_system_ufs=1
-          FILE_SYSTEM="ufs $FILE_SYSTEM"
-       fi
-       AC_MSG_RESULT([configuring for file systems $FILE_SYSTEM])
-   fi
-   AC_DEFINE(IRIX,,[Define if IRIX])
-   MPI_OFFSET_KIND1="      INTEGER MPI_OFFSET_KIND"
-   MPI_OFFSET_KIND2="      PARAMETER (MPI_OFFSET_KIND=8)"
-fi
-
-#
-# If we haven't found an architecture, try for a default
-if test -z "$CC" ; then
-    AC_PROG_CC
-    AC_PROG_F77
-    if test -z "$FILE_SYSTEM" ; then
-        FILE_SYSTEM="ufs"
-    fi
-    AC_DEFINE(NO_AIO,,[Define if AIO should not be used])
-fi
-
-AC_HAVE_FUNCS(memalign)
-
-if test $NOF77 = 0 ; then
-    echo "checking Fortran external names"
-    PAC_GET_FORTNAMES
-    if test -n "$WDEF" ; then
-        CFLAGS="$CFLAGS $WDEF"
-    fi
-    dnl PAC_PROG_F77_NAME_MANGLE
-    dnl (need to set the new name format)
-    rm -f test/mpif.h
-    if test "$MPI_INCLUDE_DIR" != "." && test $FROM_MPICH = 0 && \
-       test $FROM_MPICH2 = 0 ; then
-        if test ! -d test ; then mkdir test ; fi
-        ln -s $MPI_INCLUDE_DIR/mpif.h test
-    fi
-else 
-    F77=":"
-fi
-#
-AC_C_INLINE
-
-# Header files
-AC_CHECK_HEADERS(unistd.h)
-#
-CROSS_SIZEOF_INT=${CROSS_SIZEOF_INT:-0}
-CROSS_SIZEOF_VOID_P=${CROSS_SIZEOF_VOID_P:-0}
-AC_CHECK_SIZEOF(int,$CROSS_SIZEOF_INT)
-AC_CHECK_SIZEOF(void*,$CROSS_SIZEOF_VOID_P)
-AC_CACHE_CHECK([for int large enough for pointers],
-pac_cv_int_hold_pointer,[
-if test "$ac_cv_sizeof_int" = "0" -o \
-	"$ac_cv_sizeof_voidp" = "0" ; then
-    pac_cv_int_hold_pointer=unknown
-elif test "$ac_cv_sizeof_int" -lt "$ac_cv_sizeof_voidp" ; then
-    pac_cv_int_hold_pointer=no
-else
-    pac_cv_int_hold_pointer=yes
-fi
-])
-if test "$pac_cv_int_hold_pointer" != yes ; then
-    AC_DEFINE(INT_LT_POINTER,,[Define if int smaller than pointer])
-fi
-#
-dnl The original ROMIO configure used a set of complex tests here; this
-dnl is a partial reworking using the autoconf2 sizeof macros, and allowing
-dnl for the standardized CROSS_xxx varaibles for cross-compilation environments
-dnl PAC_LONG_LONG_64()
-CROSS_SIZEOF_LONG_LONG=${CROSS_SIZEOF_LONG_LONG:-0}
-AC_CHECK_SIZEOF(long long,$CROSS_SIZEOF_LONG_LONG)
-if test "$ac_sizeof_long_long" != 0 ; then
-    if test "$ac_sizeof_long_long" = "8" ; then
-       AC_DEFINE(HAVE_LONG_LONG_64,,[Define if long long is 64 bits])
-       MPI_OFFSET_TYPE="long long"
-       DEFINE_MPI_OFFSET="typedef long long MPI_Offset;"
-       FORTRAN_MPI_OFFSET="integer*8"
-       LL="\%lld"
-    elif test "$ac_sizeof_long_long" = "$ac_sizeof_int" ; then
-       MPI_OFFSET_TYPE="int"
-       DEFINE_MPI_OFFSET="typedef int MPI_Offset;"
-       FORTRAN_MPI_OFFSET="integer"
-       AC_DEFINE(MPI_OFFSET_IS_INT,,[Define if MPI_Offset is int])
-       LL="\%d"
-       MPI_OFFSET_KIND1="!"
-       MPI_OFFSET_KIND2="!"
-    else
-       echo "defining MPI_Offset as long in C and integer in Fortran" 
-       MPI_OFFSET_TYPE="long"
-       DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
-       FORTRAN_MPI_OFFSET="integer"
-       LL="\%ld"
-       MPI_OFFSET_KIND1="!"
-       MPI_OFFSET_KIND2="!"
-    fi
-else
-    echo "defining MPI_Offset as long in C and integer in Fortran" 
-    MPI_OFFSET_TYPE="long"
-    DEFINE_MPI_OFFSET="typedef long MPI_Offset;"
-    FORTRAN_MPI_OFFSET="integer"
-    LL="\%ld"
-    MPI_OFFSET_KIND1="!"
-    MPI_OFFSET_KIND2="!"
-fi
-
-
-#
-if test -n "$longlongsize"; then
-   if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-       PAC_MPI_LONG_LONG_INT
-   else
-       AC_DEFINE(HAVE_MPI_LONG_LONG_INT,,[Define if supports long long int])
-   fi
-fi
-#
-if test -n "$OFFSET_KIND" -a "A$MPI_OFFSET_KIND1" = "A!" ; then 
-  MPI_OFFSET_KIND1="        INTEGER MPI_OFFSET_KIND"
-  MPI_OFFSET_KIND2="        PARAMETER (MPI_OFFSET_KIND=$OFFSET_KIND)"
-else
- if test "$FORTRAN_MPI_OFFSET" = "integer*8" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 ; then
-   PAC_MPI_OFFSET_KIND
- fi
- #
-  if test "$FORTRAN_MPI_OFFSET" = "integer" && test "A$MPI_OFFSET_KIND2" = "A!" && test $NOF77 = 0 ; then
-   PAC_MPI_OFFSET_KIND_4BYTE
-  fi
-fi
-#
-# check if MPI_Info functions are defined in the MPI implementation
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   PAC_MPI_INFO
-else
-   AC_DEFINE(HAVE_MPI_INFO,,[Define if MPI Info is available])
-   HAVE_MPI_INFO="#define HAVE_MPI_INFO"
-   MPI_FINFO1="!"
-   MPI_FINFO2="!"
-   MPI_FINFO3="!"
-   MPI_FINFO4="!"
-fi   
-#
-if test -n "$mpi_sgi"; then
-   if test -z "$HAVE_MPI_INFO" ; then
-      PAC_CHECK_MPI_SGI_INFO_NULL  # is MPI_INFO_NULL defined in mpi.h?
-   fi
-   PAC_TEST_MPI_SGI_type_is_contig
-   PAC_TEST_MPI_COMBINERS
-   PAC_TEST_MPI_HAVE_OFFSET_KIND
-fi
-#
-# check if darray and subarray constructors are defined in the MPI implementation
-if test $FROM_MPICH = 0 ; then
-   PAC_MPI_DARRAY_SUBARRAY
-else
-   AC_DEFINE(HAVE_MPI_DARRAY_SUBARRAY,,[Define if Darray is available])
-   HAVE_MPI_DARRAY_SUBARRAY="#define HAVE_MPI_DARRAY_SUBARRAY"
-   MPI_FARRAY1="!"
-   MPI_FARRAY2="!"
-   MPI_FARRAY3="!"
-   MPI_FARRAY4="!"
-   MPI_FARRAY5="!"
-   MPI_FARRAY6="!"
-   MPI_FARRAY7="!"
-fi   
-#
-# Check to see if the compiler accepts prototypes
-dnl PAC_CHECK_CC_PROTOTYPES(AC_DEFINE(HAVE_PROTOTYPES))
-#
-#
-# Test for weak symbol support...
-# We can't put # in the message because it causes autoconf to generate
-# incorrect code
-HAVE_WEAK_SYMBOLS=0
-if test -n "$arch_hpux" || test -n "$arch_sppux" ; then
-# multiple secondary definitions not allowed by HP compilers
-# Fortran interface for HP already uses one secondary defn. 
-# therefore, do not use this method for profiling interface.
-# build profiling interface explicitly.
-   TRY_WEAK_SYMBOLS=0
-fi
-if test $TRY_WEAK_SYMBOLS = 1 ; then
-  AC_MSG_CHECKING(for weak symbol support)
-  AC_TRY_LINK([
-#pragma weak PFoo = Foo
-int Foo(a) { return a; }
-],[return PFoo(1);],has_pragma_weak=1)
-  #
-  # Some systems (Linux ia64 and ecc, for example), support weak symbols
-  # only within a single object file!  This tests that case.
-  if test "$has_pragma_weak" = 1 ; then
-    AC_MSG_RESULT([pragma weak])
-    AC_MSG_CHECKING([that weak symbols are visible to other files])
-    rm -f conftest*
-    cat >>conftest1.c <<EOF
-#pragma weak PFoo = Foo
-int Foo(int);
-int Foo(a) { return a; }
-EOF
-    cat >>conftest2.c <<EOF
-int main() {
-return PFoo(0);}
-EOF
-    ac_link2='${CC-cc} -o conftest $CFLAGS $CPPFLAGS $LDFLAGS conftest1.c conftest2.c $LIBS >conftest.out 2>&1'
-    if eval $ac_link2 ; then
-        AC_MSG_RESULT(yes)
-    else
-      echo "$ac_link2" >>config.log
-      echo "Failed program was" >>config.log
-      cat conftest1.c >>config.log
-      cat conftest2.c >>config.log
-      if test -s conftest.out ; then cat conftest.out >> config.log ; fi
-      AC_MSG_RESULT(no)
-      has_pragma_weak=0
-    fi
-    rm -f conftest*
-  fi
-  if test "$has_pragma_weak" = 1 ; then
-    HAVE_WEAK_SYMBOLS=1
-    AC_DEFINE(HAVE_WEAK_SYMBOLS,,[Define if weak symbols available])
-    AC_DEFINE(HAVE_PRAGMA_WEAK,,[Define if pragma weak available])
-  else
-    AC_TRY_LINK([
-#pragma _HP_SECONDARY_DEF Foo PFoo
-int Foo(a) { return a; }
-],[return PFoo(1);],has_pragma_hp_secondary=1)
-    if test "$has_pragma_hp_secondary" = 1 ; then 
-        AC_MSG_RESULT([pragma _HP_SECONDARY_DEF])
-        HAVE_WEAK_SYMBOLS=1
-        AC_DEFINE(HAVE_WEAK_SYMBOLS,,[Define if weak symbols available])
-        AC_DEFINE(HAVE_PRAGMA_HP_SEC_DEF,,[Define for HP weak pragma])
-    else
-        AC_TRY_LINK([
-#pragma _CRI duplicate PFoo as Foo
-int Foo(a) { return a; }
-],[return PFoo(1);],has_pragma_cri_duplicate=1)
-        if test "$has_pragma_cri_duplicate" = 1 ; then
-	    AC_MSG_RESULT([pragma _CRI duplicate x as y])
-	    HAVE_WEAK_SYMBOLS=1
-	    AC_DEFINE(HAVE_WEAK_SYMBOLS,,[Define if weak symbols available])
-	    AC_DEFINE(HAVE_PRAGMA_CRI_DUP,,[Define for CRAY weak dup])
-        else    
-            AC_MSG_RESULT(no)
-        fi
-    fi
-  fi
-fi
-AC_SUBST(HAVE_WEAK_SYMBOLS)
-#
-# if FILE_SYSTEM is not set above, use ufs and nfs as default
-#
-if test -z "$FILE_SYSTEM" ; then
-    file_system_ufs=1
-    file_system_nfs=1
-    FILE_SYSTEM="ufs nfs"
-    AC_MSG_RESULT([configuring for file systems ufs and nfs])
-fi
-#
-if test -n "$file_system_nfs" ; then
-   # Check for problems with locks
-   AC_MSG_CHECKING([whether file locks work with NFS])
-   AC_TRY_RUN([
-#include <fcntl.h>
-#include <errno.h>
-#include <unistd.h>
-
-int main()
-{
-    struct flock lock;
-    int fd, err;
-
-    lock.l_type = F_WRLCK;
-    lock.l_start = 0;
-    lock.l_whence = SEEK_SET;
-    lock.l_len = 100;
-
-    fd = open("conftest.dat", O_RDWR | O_CREAT, 0644);
-
-    err = fcntl(fd, F_SETLKW, &lock);
-
-   /* printf("err = %d, errno = %d\n", err, errno); */
-    close(fd);
-    return err;
-}],nfs_locks_work=yes,nfs_locks_work=no,nfs_locks_work=unknown)
-    AC_MSG_RESULT($nfs_locks_work)
-    if test "$nfs_locks_work" != "yes" ; then
-        AC_MSG_WARN([File locks do not work with NFS.  See the Installation and
-users manual for instructions on fixing this])
-    fi
-fi
-if test -n "$file_system_nfs"; then
-    AC_DEFINE(NFS,,[Define for NFS])
-fi
-if test -n "$file_system_ufs"; then
-    AC_DEFINE(UFS,,[Define for UFS])
-fi
-if test -n "$file_system_hfs"; then
-    AC_DEFINE(HFS,,[Define for HFS])
-fi
-if test -n "$file_system_sfs"; then
-    AC_DEFINE(SFS,,[Define for SFS])
-fi
-if test -n "$file_system_xfs"; then
-    AC_DEFINE(XFS,,[Define for XFS])
-    # Check for memalign value (this was P A C_GET_XFS_MEMALIGN,
-    # switched to autoconf 2)
-    AC_CACHE_CHECK([for memory alignment needed for direct I/O],
-pac_cv_memalignval,[
-/bin/rm -f confmemalignval
-/bin/rm -f /tmp/romio_tmp.bin
-AC_TRY_RUN([#include <stdio.h>
-#include <unistd.h>
-#include <fcntl.h>
-#include <stdio.h>
-main() { 
-  struct dioattr st;
-  int fd = open("/tmp/romio_tmp.bin", O_RDWR | O_CREAT, 0644);
-  FILE *f=fopen("confmemalignval","w");
-  if (fd == -1) exit(1);
-  if (!f) exit(1);
-  fcntl(fd, F_DIOINFO, &st);
-  fprintf( f, "%u\n", st.d_mem);
-  exit(0);
-}],pac_cv_memalignval=`cat confmemalignval`,pac_cv_memalignval="unknown",pac_cv_memalignval="unknown")
-    /bin/rm -f confmemalignval
-    /bin/rm -f /tmp/romio_tmp.bin
-])
-    if test -n "$pac_cv_memalignval" -a "$pac_cv_memalignval" != 0 -a \
-    "$pac_cv_memalignval" != "unknown" ; then
-        CFLAGS="$CFLAGS -DXFS_MEMALIGN=$pac_cv_memalignval"
-    else
-        AC_MSG_RESULT(assuming 128 for memory alignment)
-        CFLAGS="$CFLAGS -DXFS_MEMALIGN=128"
-    fi
-fi
-
-if test -n "$file_system_pvfs"; then
-   # Use ROMIO_PVFS instead of PVFS because FREEBSD defines PVFS.
-    AC_DEFINE(ROMIO_PVFS,,[Define for Romio with PVFS])
-fi
-if test -n "$file_system_pvfs2"; then
-    AC_DEFINE(ROMIO_PVFS2,,[Define for Romio with PVFS2])
-fi
-if test -n "$file_system_pfs"; then
-    AC_DEFINE(PFS,,[Define for PFS])
-fi
-if test -n "$file_system_testfs"; then
-    AC_DEFINE(ROMIO_TESTFS,,[Define for TESTFS])
-fi
-if test -n "$file_system_piofs"; then
-    AC_DEFINE(PIOFS,,[Define for PIOFS])
-    USER_CFLAGS="$USER_CFLAGS -bI:/usr/include/piofs/piofs.exp"
-    ROMIO_LFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
-    USER_FFLAGS="$USER_FFLAGS -bI:/usr/include/piofs/piofs.exp"
-fi
-if test -n "$mpi_mpich"; then
-   if test "$FROM_MPICH2" = 0; then
-      AC_DEFINE(NEEDS_MPI_TEST,,[Define if mpi_test needed])
-      AC_DEFINE(MPICH,,[Define if using MPICH])
-      if test -z "$arch_SX4" ; then
-         MPIOF_H_INCLUDED=1
-      fi
-   fi
-fi
-if test -n "$mpi_sgi"; then
-   AC_DEFINE(MPISGI,,[Define if SGI MPI])
-fi
-if test -n "$mpi_lam"; then
-   AC_DEFINE(MPILAM,,[Define if using LAM/MPI])
-fi
-if test -n "$mpi_hp"; then
-   AC_DEFINE(MPIHP,,[Define if using HP MPI])
-   if test "$NOF77" = 0; then
-      PAC_CHECK_MPIOF_H
-   fi
-fi
-#
-PAC_FUNC_STRERROR
-if test -z "$srcdir" -o "$srcdir" = "." ; then srcdir="$ROMIO_HOME" ; fi
-AC_SUBST(srcdir)
-if test "$FROM_MPICH2" = 0 ; then 
-    if test -z "$LIBNAME"; then
-        LIBNAME="$ROMIO_HOME/lib/$ARCH/libmpio.a"
-    fi
-    #
-    if test ! -d $ROMIO_HOME/lib ; then 
-        mkdir $ROMIO_HOME/lib
-    fi
-    if test ! -d $ROMIO_HOME/lib/$ARCH ; then 
-        mkdir $ROMIO_HOME/lib/$ARCH
-    fi
-else
-    MPILIBNAME=${MPILIBNAME:-mpich}
-    if test -n "$top_build_dir" -a -d "$top_build_dir/lib" ; then
-        LIBNAME=$top_build_dir/lib/lib${MPILIBNAME}.a
-    else
-        LIBNAME="$ROMIO_HOME/lib${MPILIBNAME}.a"
-    fi
-fi
-#
-if test $NOF77 = 1 ; then
-   F77=":"
-else
-   FORTRAN_TEST="fperf fcoll_test fmisc pfcoll_test" 
-fi
-#
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   PAC_TEST_MPI
-   PAC_NEEDS_FINT
-else
-   NEEDS_MPI_FINT=""
-fi
-#
-if test "$MPI_INCLUDE_DIR" = "." ; then
-   ROMIO_INCLUDE="-I../include"
-else 
-   ROMIO_INCLUDE="-I../include -I$MPI_INCLUDE_DIR"
-fi
-#
-TEST_LIBNAME=$LIBNAME
-MPIRUN=mpirun
-#
-# if MPICH, use mpicc in test programs
-#
-if test $FROM_MPICH = 1 ; then
-   MPICH_HOME=`dirname $ROMIO_HOME`
-   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
-   TEST_CC=$MPI_BIN_DIR/mpicc
-   MPI_LIB=""
-   ROMIO_INCLUDE=""
-   USER_CFLAGS=""
-   USER_FFLAGS=""
-   TEST_LIBNAME=""
-   MPIRUN=$MPI_BIN_DIR/mpirun
-   if test -n "$arch_SX4" || test -n "$arch_hpux" ; then
-      TEST_F77=$MPI_BIN_DIR/mpif90
-   else
-      TEST_F77=$MPI_BIN_DIR/mpif77
-   fi
-   CC=$MPI_BIN_DIR/mpicc
-   AC_DEFINE(HAVE_STATUS_SET_BYTES,,[Define if status_set_bytes available])
-fi
-# For now, separate the mpich2 from mpich cases
-if test $FROM_MPICH2 = 1 ; then
-   MPICH_HOME=`dirname $ROMIO_HOME`
-   MPICH_HOME=`dirname $MPICH_HOME`
-   MPICH_HOME=`dirname $MPICH_HOME`
-   if test -z "$MPI_BIN_DIR" ; then MPI_BIN_DIR=$MPICH_HOME/bin ; fi
-   # No special compiler script.
-   # BUT we need the include paths
-   CC="$CC -I${use_top_srcdir}/src/include -I${top_build_dir}/src/include"
-   TEST_CC="$CC"
-   MPI_LIB="$LIBNAME"
-   ROMIO_INCLUDE=""
-   USER_CFLAGS=""
-   USER_FFLAGS=""
-   TEST_LIBNAME=""
-   MPIRUN=$MPI_BIN_DIR/mpiexec
-   AC_DEFINE(HAVE_STATUS_SET_BYTES,,[Define if status_set_bytes available])
-   AC_DEFINE(HAVE_MPI_GREQUEST,,[Define if generalized requests avaliable])
-fi
-#
-#
-# feature tests:  we can't test features if building as part of MPICH because
-# we don't yet have an implementation against which we can test
-#
-if test "$FROM_MPICH2" = 0 -a "$FROM_MPICH" = 0 ; then
-   PAC_TEST_MPIR_STATUS_SET_BYTES
-   PAC_TEST_MPI_GREQUEST
-   AC_DEFINE(PRINT_ERR_MSG,,[Define for printing error messages])
-fi
-#
-if test -z "$TEST_CC" ; then
-   TEST_CC="$CC"
-fi
-if test -z "$TEST_F77" ; then
-   TEST_F77="$F77"
-fi
-#
-CFLAGS="$CFLAGS -DHAVE_ROMIOCONF_H"
-#
-echo "setting CC to $CC"
-echo "setting F77 to $F77"
-echo "setting TEST_CC to $TEST_CC"
-echo "setting TEST_F77 to $TEST_F77"
-echo "setting CFLAGS to $CFLAGS"
-echo "setting USER_CFLAGS to $USER_CFLAGS"
-echo "setting USER_FFLAGS to $USER_FFLAGS"
-#
-VPATH='VPATH = .:${srcdir}'
-AC_SUBST(VPATH)
-AC_SUBST(ARCH)
-AC_SUBST(FILE_SYSTEM)
-AC_SUBST(CC)
-AC_SUBST(CFLAGS)
-AC_SUBST(USER_CFLAGS)
-AC_SUBST(USER_FFLAGS)
-AC_SUBST(MIPS)
-AC_SUBST(BITS)
-AC_SUBST(MPI)
-AC_SUBST(AR)
-AC_SUBST(RANLIB)
-AC_SUBST(MPI_INCLUDE_DIR)
-AC_SUBST(MPI_LIB)
-AC_SUBST(F77)
-AC_SUBST(NOF77)
-AC_SUBST(NOPROFILE)
-AC_SUBST(MAKE)
-AC_SUBST(arch_IRIX)
-AC_SUBST(ROMIO_HOME)
-AC_SUBST(LIBNAME)
-AC_SUBST(TEST_LIBNAME)
-AC_SUBST(LL)
-AC_SUBST(F77GETARG)
-AC_SUBST(F77IARGC)
-AC_SUBST(FTESTDEFINE)
-AC_SUBST(FORTRAN_MPI_OFFSET)
-AC_SUBST(FROM_MPICH)
-AC_SUBST(FROM_MPICH2)
-AC_SUBST(NEEDS_MPI_FINT)
-AC_SUBST(HAVE_MPI_INFO)
-AC_SUBST(BUILD_MPI_INFO)
-AC_SUBST(HAVE_MPI_DARRAY_SUBARRAY)
-AC_SUBST(BUILD_MPI_ARRAY)
-AC_SUBST(DEFINE_MPI_OFFSET)
-AC_SUBST(MPI_OFFSET_TYPE)
-AC_SUBST(MPI_FINFO1)
-AC_SUBST(MPI_FINFO2)
-AC_SUBST(MPI_FINFO3)
-AC_SUBST(MPI_FINFO4)
-AC_SUBST(MPI_FARRAY1)
-AC_SUBST(MPI_FARRAY2)
-AC_SUBST(MPI_FARRAY3)
-AC_SUBST(MPI_FARRAY4)
-AC_SUBST(MPI_FARRAY5)
-AC_SUBST(MPI_FARRAY6)
-AC_SUBST(MPI_FARRAY7)
-AC_SUBST(MPI_OFFSET_KIND1)
-AC_SUBST(MPI_OFFSET_KIND2)
-AC_SUBST(TEST_CC)
-AC_SUBST(TEST_F77)
-AC_SUBST(ROMIO_INCLUDE)
-AC_SUBST(ROMIO_LFLAGS)
-AC_SUBST(ROMIO_LIBLIST)
-AC_SUBST(ROMIO_TCFLAGS)
-AC_SUBST(ROMIO_TCPPFLAGS)
-AC_SUBST(ROMIO_TFFLAGS)
-AC_SUBST(MPIRUN)
-AC_SUBST(FORTRAN_TEST)
-dnl
-dnl Dependency handling
-AC_SUBST(MAKE_DEPEND_C)
-if test ! -d adio ; then mkdir adio ; fi
-if test ! -d adio/include ; then mkdir adio/include ; fi
-if test ! -d mpi2-other ; then mkdir mpi2-other ; fi
-# 
-# Make sure we remove any configuration file incase there is out-of-date data.
-# We remove the version in include in case this is a vpath build
-rm -f adio/include/romioconf.h ${use_top_srcdir}/src/mpi/romio/adio/include/romioconf.h ${use_top_srcdir}/adio/include/romioconf.h
-#
-# Create makefiles for all of the adio devices.  Only the ones that 
-# are active will be called by the top level ROMIO make
-AC_OUTPUT_COMMANDS([chmod 755 util/romioinstall test/runtests])
-AC_OUTPUT(Makefile localdefs mpi-io/Makefile mpi2-other/info/Makefile \
-		   mpi2-other/array/Makefile adio/common/Makefile \
-		   test/Makefile test/misc.c test/large_file.c \
-		   test/runtests util/romioinstall include/mpio.h \
-		   include/mpiof.h \
-		   adio/ad_nfs/Makefile adio/ad_ufs/Makefile \
-		   adio/ad_xfs/Makefile adio/ad_hfs/Makefile \
-		   adio/ad_sfs/Makefile adio/ad_pfs/Makefile \
-		   adio/ad_testfs/Makefile adio/ad_pvfs/Makefile \
-		   adio/ad_pvfs2/Makefile adio/ad_piofs/Makefile \
-                   mpi-io/fortran/Makefile mpi2-other/info/fortran/Makefile \
-                   mpi2-other/array/fortran/Makefile test/fmisc.f \
-                   test/fcoll_test.f test/pfcoll_test.f test/fperf.f )
-#
-rm -f *.o
-if test "$ROMIO_NO_BANNER" != "yes" -a "$FROM_MPICH" = 0 -a \
-         $FROM_MPICH2 = 0 ; then
-cat <<EOF
-
-Please register your copy of ROMIO with us by sending email
-to majordomo@mcs.anl.gov with the message
-subscribe romio-users
-This will enable us to notify you of new releases of ROMIO
-as well as bug fixes.
-
-EOF
-fi
-if test $FROM_MPICH2 = 1 -a "$NOF77" = 0 ; then
-      sed 5d test/fcoll_test.f > test/tmp
-      mv test/tmp test/fcoll_test.f
-      sed 5d test/pfcoll_test.f > test/tmp
-      mv test/tmp test/fcoll_test.f
-      sed 5d test/fperf.f > test/tmp
-      mv test/tmp test/fperf.f
-      sed 5d test/fmisc.f > test/tmp
-      mv test/tmp test/fmisc.f
-fi
-if test $FROM_MPICH = 0 -a $FROM_MPICH2 = 0 ; then
-   AC_MSG_RESULT([Configure done. Now type make])
-fi
-dnl PAC_SUBDIR_CACHE_CLEANUP
-exit 0
Index: romio/adio/ad_hfs/.cvsignore
diff -u romio/adio/ad_hfs/.cvsignore:1.2 romio/adio/ad_hfs/.cvsignore:1.3
--- romio/adio/ad_hfs/.cvsignore:1.2	Fri Aug  1 08:30:17 2003
+++ romio/adio/ad_hfs/.cvsignore	Mon Jan 19 08:49:35 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_nfs/.cvsignore
diff -u romio/adio/ad_nfs/.cvsignore:1.2 romio/adio/ad_nfs/.cvsignore:1.3
--- romio/adio/ad_nfs/.cvsignore:1.2	Fri Aug  1 08:30:17 2003
+++ romio/adio/ad_nfs/.cvsignore	Mon Jan 19 08:49:35 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_ntfs/.cvsignore
diff -u romio/adio/ad_ntfs/.cvsignore:1.2 romio/adio/ad_ntfs/.cvsignore:1.3
--- romio/adio/ad_ntfs/.cvsignore:1.2	Fri Aug  1 08:30:17 2003
+++ romio/adio/ad_ntfs/.cvsignore	Mon Jan 19 08:49:35 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_pfs/.cvsignore
diff -u romio/adio/ad_pfs/.cvsignore:1.2 romio/adio/ad_pfs/.cvsignore:1.3
--- romio/adio/ad_pfs/.cvsignore:1.2	Fri Aug  1 08:30:17 2003
+++ romio/adio/ad_pfs/.cvsignore	Mon Jan 19 08:49:35 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_piofs/.cvsignore
diff -u romio/adio/ad_piofs/.cvsignore:1.2 romio/adio/ad_piofs/.cvsignore:1.3
--- romio/adio/ad_piofs/.cvsignore:1.2	Fri Aug  1 08:30:18 2003
+++ romio/adio/ad_piofs/.cvsignore	Mon Jan 19 08:49:36 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_pvfs/.cvsignore
diff -u romio/adio/ad_pvfs/.cvsignore:1.2 romio/adio/ad_pvfs/.cvsignore:1.3
--- romio/adio/ad_pvfs/.cvsignore:1.2	Fri Aug  1 08:30:18 2003
+++ romio/adio/ad_pvfs/.cvsignore	Mon Jan 19 08:49:36 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_pvfs/ad_pvfs_flush.c
diff -u romio/adio/ad_pvfs/ad_pvfs_flush.c:1.11 romio/adio/ad_pvfs/ad_pvfs_flush.c:1.12
--- romio/adio/ad_pvfs/ad_pvfs_flush.c:1.11	Fri Apr 18 15:15:01 2003
+++ romio/adio/ad_pvfs/ad_pvfs_flush.c	Thu May 20 14:05:17 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs_flush.c,v 1.11 2003/04/18 20:15:01 David Exp $    
+ *   $Id: ad_pvfs_flush.c,v 1.12 2004/05/20 19:05:17 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -10,12 +10,24 @@
 
 void ADIOI_PVFS_Flush(ADIO_File fd, int *error_code)
 {
-    int err;
+    int err, rank, dummy=0, dummy_in=0;
 #ifndef PRINT_ERR_MSG
     static char myname[] = "ADIOI_PVFS_FLUSH";
 #endif
 
-    err = pvfs_fsync(fd->fd_sys);
+    /* a collective routine: because we do not cache data in PVFS1, one process
+     * can initiate the fsync operation and broadcast the result to the others.
+     * One catch: MPI_File_sync has special meaning with respect to file system
+     * consistency.  Ensure no clients have outstanding write operations.
+     */
+
+    MPI_Comm_rank(fd->comm, &rank);
+    MPI_Reduce(&dummy_in, &dummy, 1, MPI_INT, MPI_SUM, 
+		    fd->hints->ranklist[0], fd->comm);
+    if (rank == fd->hints->ranklist[0]) {
+	    err = pvfs_fsync(fd->fd_sys);
+    }
+    MPI_Bcast(&err, 1, MPI_INT, 0, fd->comm);
 
     if (err == -1) {
 #ifdef MPICH2
Index: romio/adio/ad_pvfs/ad_pvfs_resize.c
diff -u romio/adio/ad_pvfs/ad_pvfs_resize.c:1.11 romio/adio/ad_pvfs/ad_pvfs_resize.c:1.12
--- romio/adio/ad_pvfs/ad_pvfs_resize.c:1.11	Fri Apr 18 15:15:01 2003
+++ romio/adio/ad_pvfs/ad_pvfs_resize.c	Thu May 20 14:05:36 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs_resize.c,v 1.11 2003/04/18 20:15:01 David Exp $    
+ *   $Id: ad_pvfs_resize.c,v 1.12 2004/05/20 19:05:36 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -11,11 +11,20 @@
 void ADIOI_PVFS_Resize(ADIO_File fd, ADIO_Offset size, int *error_code)
 {
     int err;
+    int ret, rank;
 #ifndef PRINT_ERR_MSG
     static char myname[] = "ADIOI_PVFS_RESIZE";
 #endif
-    
-    err = pvfs_ftruncate64(fd->fd_sys, size);
+
+    /* because MPI_File_set_size is a collective operation, and PVFS1 clients
+     * do not cache metadata locally, one client can resize and broadcast the
+     * result to the others */
+    MPI_Comm_rank(fd->comm, &rank);
+    if (rank == fd->hints->ranklist[0]) {
+	err = pvfs_ftruncate64(fd->fd_sys, size);
+    }
+    MPI_Bcast(&err, 1, MPI_INT, 0, fd->comm)
+
     if (err == -1) {
 #ifdef MPICH2
 	*error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**io",
Index: romio/adio/ad_pvfs2/.cvsignore
diff -u romio/adio/ad_pvfs2/.cvsignore:1.2 romio/adio/ad_pvfs2/.cvsignore:1.3
--- romio/adio/ad_pvfs2/.cvsignore:1.2	Fri Aug  1 08:30:18 2003
+++ romio/adio/ad_pvfs2/.cvsignore	Mon Jan 19 08:49:36 2004
@@ -1,2 +1,5 @@
 Makefile
 .deps
+*.bb
+*.bbg
+
Index: romio/adio/ad_pvfs2/ad_pvfs2_close.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_close.c:1.2 romio/adio/ad_pvfs2/ad_pvfs2_close.c:1.3
--- romio/adio/ad_pvfs2/ad_pvfs2_close.c:1.2	Fri Jun 27 18:23:16 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_close.c	Thu May 20 14:13:57 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_close.c,v 1.2 2003/06/27 23:23:16 robl Exp $
+ *   $Id: ad_pvfs2_close.c,v 1.3 2004/05/20 19:13:57 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -11,7 +11,10 @@
 void ADIOI_PVFS2_Close(ADIO_File fd, int *error_code)
 {
     ADIOI_Free(fd->fs_ptr);
-    /* pvfs2 doesn't have a 'close' */
+    /* pvfs2 doesn't have a 'close', but MPI-IO semantics dictate that we
+     * ensure all data has been flushed  */
+    /* XXX: reduce and sync? sync on all? */
+
     *error_code = MPI_SUCCESS;
 }
 /* 
Index: romio/adio/ad_pvfs2/ad_pvfs2_common.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_common.c:1.7 romio/adio/ad_pvfs2/ad_pvfs2_common.c:1.9
--- romio/adio/ad_pvfs2/ad_pvfs2_common.c:1.7	Fri Sep  5 15:43:58 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_common.c	Thu Mar 25 16:17:45 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_common.c,v 1.7 2003/09/05 20:43:58 robl Exp $
+ *   $Id: ad_pvfs2_common.c,v 1.9 2004/03/25 22:17:45 robl Exp $
  *
  *   Copyright (C) 2003 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -16,15 +16,12 @@
  * close it down when mpi exits */
 int ADIOI_PVFS2_Initialized = MPI_KEYVAL_INVALID;
 
-PVFS_fs_id * ADIOI_PVFS2_fs_id_list;
-pvfs_mntlist ADIOI_PVFS2_mntlist;
-
 void ADIOI_PVFS2_End(int *error_code)
 {
     int ret;
     ret = PVFS_sys_finalize();
     if (ret < 0 ) {
-	*error_code = MPI_UNDEFINED;
+	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
     } else {
 	*error_code = MPI_SUCCESS;
     }
@@ -40,7 +37,6 @@
 
 void ADIOI_PVFS2_Init(int *error_code )
 {
-	PVFS_sysresp_init resp_init;
 	int ret;
 
 	/* do nothing if we've already fired up the pvfs2 interface */
@@ -49,22 +45,14 @@
 		return;
 	}
 
-	ret = PVFS_util_parse_pvfstab(&ADIOI_PVFS2_mntlist);
-	if (ret < 0) {
-	    /* XXX: better error handling */
-	    fprintf(stderr, "error parsing pvfstab\n");
-	    *error_code = MPI_UNDEFINED;
-	    return;
-	}
-	ret = PVFS_sys_initialize(ADIOI_PVFS2_mntlist, ADIOI_PVFS2_DEBUG_MASK, 
-		&resp_init);
+	ret = PVFS_util_init_defaults();
 	if (ret < 0 ) {
 	    /* XXX: better error handling */
-	    fprintf(stderr, "error initializing pvfs\n");
-	    *error_code = MPI_UNDEFINED;
+	    PVFS_perror("PVFS_util_init_defaults", ret);
+	    ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 	    return;
 	}
-	ADIOI_PVFS2_fs_id_list = resp_init.fsid_list;
+
 	MPI_Keyval_create(MPI_NULL_COPY_FN, ADIOI_PVFS2_End_call,
 		&ADIOI_PVFS2_Initialized, (void *)0); 
 	/* just like romio does, we make a dummy attribute so we 
@@ -87,8 +75,7 @@
 {
     memset(credentials, 0, sizeof(PVFS_credentials));
 
-    credentials->uid = geteuid();
-    credentials->gid = getegid();
+    PVFS_util_gen_credentials(credentials);
 }
 
 /* pvfs_error_convert: given a pvfs error code, make it into the appropriate
Index: romio/adio/ad_pvfs2/ad_pvfs2_common.h
diff -u romio/adio/ad_pvfs2/ad_pvfs2_common.h:1.8 romio/adio/ad_pvfs2/ad_pvfs2_common.h:1.10
--- romio/adio/ad_pvfs2/ad_pvfs2_common.h:1.8	Thu Sep 18 18:13:18 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_common.h	Thu Mar 25 16:22:34 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*-
  * vim: ts=8 sts=4 sw=4 noexpandtab
- *   $Id: ad_pvfs2_common.h,v 1.8 2003/09/18 23:13:18 robl Exp $    
+ *   $Id: ad_pvfs2_common.h,v 1.10 2004/03/25 22:22:34 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -18,14 +18,12 @@
 
 
 struct ADIOI_PVFS2_fs_s {
-    PVFS_pinode_reference pinode_refn;
+    PVFS_object_ref object_ref;
     PVFS_credentials credentials;
 } ADIOI_PVFS2_fs_s;
 
 typedef struct ADIOI_PVFS2_fs_s ADIOI_PVFS2_fs;
 
-extern PVFS_fs_id * ADIOI_PVFS2_fs_id_list;
-extern pvfs_mntlist ADIOI_PVFS2_mntlist;
 
 void ADIOI_PVFS2_Init(int *error_code );
 void ADIOI_PVFS2_makeattribs(PVFS_sys_attr * attribs);
Index: romio/adio/ad_pvfs2/ad_pvfs2_delete.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_delete.c:1.5 romio/adio/ad_pvfs2/ad_pvfs2_delete.c:1.8
--- romio/adio/ad_pvfs2/ad_pvfs2_delete.c:1.5	Fri Sep  5 15:43:58 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_delete.c	Thu May 20 15:31:05 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_delete.c,v 1.5 2003/09/05 20:43:58 robl Exp $    
+ *   $Id: ad_pvfs2_delete.c,v 1.8 2004/05/20 20:31:05 robl Exp $    
  *
  *   Copyright (C) 2003 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -15,7 +15,8 @@
 {
     PVFS_credentials credentials;
     PVFS_sysresp_getparent resp_getparent;
-    int ret, i, mnt_index;
+    int ret;
+    PVFS_fs_id cur_fs;
     char pvfs_path[PVFS_NAME_MAX] = {0};
 
     ADIOI_PVFS2_Init(error_code);
@@ -30,28 +31,17 @@
     ADIOI_PVFS2_makecredentials(&credentials);
 
     /* given the filename, figure out which pvfs filesystem it is on */
-    for (i=0; i<ADIOI_PVFS2_mntlist.ptab_count; i++) {
-	ret = PVFS_util_remove_dir_prefix(filename, 
-		ADIOI_PVFS2_mntlist.ptab_array[i].mnt_dir, 
-		pvfs_path, PVFS_NAME_MAX);
-	if (ret == 0) {
-	    mnt_index = i;
-	    break;
-	}
-    }
-    if (mnt_index == -1) {
-	fprintf(stderr, "Error: could not find filesystem for %s in pvfstab",
-		filename);
+    ret = PVFS_util_resolve(filename, &cur_fs, pvfs_path, PVFS_NAME_MAX);
+    if (ret < 0) {
+	PVFS_perror("PVFS_util_resolve", ret);
 	/* TODO: pick a good error for this */
 	ret = -1;
 	goto resolve_error;
     }
-
-    ret = PVFS_sys_getparent(ADIOI_PVFS2_fs_id_list[mnt_index], pvfs_path,
-	    credentials, &resp_getparent);
+    ret = PVFS_sys_getparent(cur_fs, pvfs_path, &credentials, &resp_getparent);
 
     ret = PVFS_sys_remove(resp_getparent.basename, 
-	    resp_getparent.parent_refn, credentials);
+	    resp_getparent.parent_ref, &credentials);
     if (ret < 0) {
 	/* XXX: better error handling */
 	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
Index: romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c:1.3 romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c:1.5
--- romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c:1.3	Tue Aug  5 17:59:20 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_fcntl.c	Thu May 20 15:31:05 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_fcntl.c,v 1.3 2003/08/05 22:59:20 robl Exp $    
+ *   $Id: ad_pvfs2_fcntl.c,v 1.5 2004/05/20 20:31:05 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -21,8 +21,8 @@
     switch(flag) {
 
     case ADIO_FCNTL_GET_FSIZE:
-	ret = PVFS_sys_getattr(pvfs_fs->pinode_refn, PVFS_ATTR_SYS_SIZE, 
-		pvfs_fs->credentials, &resp_getattr);
+	ret = PVFS_sys_getattr(pvfs_fs->object_ref, PVFS_ATTR_SYS_SIZE, 
+		&(pvfs_fs->credentials), &resp_getattr);
 	if (ret < 0 ) {
 	    ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 	} else {
Index: romio/adio/ad_pvfs2/ad_pvfs2_flush.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_flush.c:1.3 romio/adio/ad_pvfs2/ad_pvfs2_flush.c:1.9
--- romio/adio/ad_pvfs2/ad_pvfs2_flush.c:1.3	Thu Oct 30 12:53:40 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_flush.c	Thu May 20 15:31:05 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_flush.c,v 1.3 2003/10/30 18:53:40 robl Exp $    
+ *   $Id: ad_pvfs2_flush.c,v 1.9 2004/05/20 20:31:05 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -9,13 +9,16 @@
 #include "ad_pvfs2.h"
 #include "ad_pvfs2_common.h"
 
-/* we want to be a bit clever here:  at scale, every client sending a flush
- * will stress the server unnecessarily.  One process should wait for everyone
- * to catch up, do the sync, then broadcast the result.
+/* we want to be a bit clever here:  at scale, if every client sends a
+ * flush request, it will stress the PVFS2 servers with redundant
+ * PVFS_sys_flush requests.  Instead, one process should wait for
+ * everyone to catch up, do the sync, then broadcast the result.  We can
+ * get away with this thanks to PVFS2's stateless design 
  */
-void ADIOI_PVFS2_Flush(ADIO_File fd, int *error_code)
-{
-    int ret, rank, tmprank, dummy1, dummy2;
+
+void ADIOI_PVFS2_Flush(ADIO_File fd, int *error_code) 
+{ 
+    int ret, rank, dummy=0, dummy_in=0; 
     ADIOI_PVFS2_fs *pvfs_fs;
 
     *error_code = MPI_SUCCESS;
@@ -24,14 +27,19 @@
 
     MPI_Comm_rank(fd->comm, &rank);
 
-    /* the cheapest way we know to let one process know everyone is here */
-    MPI_Gather(&dummy1, 1, MPI_INT, &dummy2, 1, MPI_INT, 0, fd->comm);
 
-    if (rank == 0) {
-	ret = PVFS_sys_flush(pvfs_fs->pinode_refn, pvfs_fs->credentials);
+    /* unlike ADIOI_PVFS2_Resize, MPI_File_sync() does not perform any
+     * syncronization */
+    MPI_Reduce(&dummy_in, &dummy, 1, MPI_INT, MPI_SUM, 
+	    fd->hints->ranklist[0], fd->comm);
+
+    /* io_worker computed in ADIO_Open */
+    if (rank == fd->hints->ranklist[0]) {
+	ret = PVFS_sys_flush(pvfs_fs->object_ref, &(pvfs_fs->credentials));
+	MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
+    } else {
 	MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
     }
-    MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
     if (ret < 0)
 	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 }
Index: romio/adio/ad_pvfs2/ad_pvfs2_open.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_open.c:1.11 romio/adio/ad_pvfs2/ad_pvfs2_open.c:1.14
--- romio/adio/ad_pvfs2/ad_pvfs2_open.c:1.11	Sun Nov  2 09:55:18 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_open.c	Thu May 20 15:31:05 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*-
  * vim: ts=8 sts=4 sw=4 noexpandtab
- *   $Id: ad_pvfs2_open.c,v 1.11 2003/11/02 15:55:18 rross Exp $
+ *   $Id: ad_pvfs2_open.c,v 1.14 2004/05/20 20:31:05 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -11,7 +11,7 @@
 
 struct open_status_s {
     int error;
-    PVFS_pinode_reference pinode_refn;
+    PVFS_object_ref object_ref;
 };
 typedef struct open_status_s open_status;
     
@@ -44,33 +44,33 @@
     memset(&resp_create, 0, sizeof(resp_create));
 
     ret = PVFS_sys_lookup(fs_id, pvfs_name,
-	    pvfs2_fs->credentials, &resp_lookup, PVFS2_LOOKUP_LINK_FOLLOW);
+	    &(pvfs2_fs->credentials), &resp_lookup, PVFS2_LOOKUP_LINK_FOLLOW);
     if ( (ret < 0) ) { /* XXX: check what the error was */
 	if (access_mode & MPI_MODE_CREATE)  {
 	    ret = PVFS_sys_getparent(fs_id, pvfs_name,
-		    pvfs2_fs->credentials, &resp_getparent); 
+		    &(pvfs2_fs->credentials), &resp_getparent); 
 	    if (ret < 0) {
 		fprintf(stderr, "pvfs_sys_getparent returns with %d\n", ret);
 		o_status->error = ret;
 		return;
 	    } 
 	    ret = PVFS_sys_create(resp_getparent.basename, 
-		    resp_getparent.parent_refn, attribs, 
-		    pvfs2_fs->credentials, &resp_create); 
+		    resp_getparent.parent_ref, attribs, 
+		    &(pvfs2_fs->credentials), NULL, &resp_create); 
 
 	    if (ret < 0) { /* XXX: should only do this for EEXISTS */
 		ret = PVFS_sys_lookup(fs_id, pvfs_name,
-			pvfs2_fs->credentials, &resp_lookup, 
+			&(pvfs2_fs->credentials), &resp_lookup, 
 			PVFS2_LOOKUP_LINK_FOLLOW);
 		if ( ret < 0 ) {
 		    o_status->error = ret;
 		    return;
 		}
 		o_status->error = ret;
-		o_status->pinode_refn = resp_lookup.pinode_refn;
+		o_status->object_ref = resp_lookup.ref;
 		return;
 	    }
-	    o_status->pinode_refn = resp_create.pinode_refn;
+	    o_status->object_ref = resp_create.ref;
 	} else {
 	    fprintf(stderr, "cannot create file without MPI_MODE_CREATE\n");
 	    o_status->error = ret;
@@ -81,7 +81,7 @@
 	o_status->error = -1; /* XXX: what should it be? */
 	return;
     } else {
-	o_status->pinode_refn = resp_lookup.pinode_refn;
+	o_status->object_ref = resp_lookup.ref;
     }
     o_status->error = ret;
     return;
@@ -95,19 +95,20 @@
  */
 void ADIOI_PVFS2_Open(ADIO_File fd, int *error_code)
 {
-    int rank, ret, i, mnt_index=-1;
+    int rank, ret;
+    PVFS_fs_id cur_fs;
     char pvfs_path[PVFS_NAME_MAX] = {0};
 
     ADIOI_PVFS2_fs *pvfs2_fs;
 
     /* since one process is doing the open, that means one process is also
-     * doing the error checking.  define a struct for both the pinode and the
-     * error code to broadcast to all the processors */
+     * doing the error checking.  define a struct for both the object reference
+     * and the error code to broadcast to all the processors */
 
     open_status o_status;
     MPI_Datatype open_status_type;
     MPI_Datatype types[2] = {MPI_INT, MPI_BYTE};
-    int lens[2] = {1, sizeof(PVFS_pinode_reference)};
+    int lens[2] = {1, sizeof(PVFS_object_ref)};
     MPI_Aint offsets[2];
     
     pvfs2_fs = (ADIOI_PVFS2_fs *)ADIOI_Malloc(sizeof(ADIOI_PVFS2_fs));
@@ -120,7 +121,7 @@
     MPI_Comm_rank(fd->comm, &rank);
 
     MPI_Address(&o_status.error, &offsets[0]);
-    MPI_Address(&o_status.pinode_refn, &offsets[1]);
+    MPI_Address(&o_status.object_ref, &offsets[1]);
 
     MPI_Type_struct(2, lens, offsets, types, &open_status_type);
     MPI_Type_commit(&open_status_type);
@@ -128,7 +129,7 @@
     ADIOI_PVFS2_Init(error_code);
     if (*error_code != MPI_SUCCESS)
     {
-	/* XXX: handle errors */
+	ADIOI_PVFS2_pvfs_error_convert(0, error_code);
 	return;
     }
 
@@ -139,22 +140,16 @@
 
     if (rank == fd->hints->ranklist[0]) {
 	/* given the filename, figure out which pvfs filesystem it is on */
-	for(i=0; i<ADIOI_PVFS2_mntlist.ptab_count; i++) {
-	    ret = PVFS_util_remove_dir_prefix(fd->filename, 
-		    ADIOI_PVFS2_mntlist.ptab_array[i].mnt_dir, 
-		    pvfs_path, PVFS_NAME_MAX);
-	    if (ret == 0) {
-		mnt_index = i;
-		break;
-	    }
-	}
-	if (mnt_index == -1) {
-	    fprintf(stderr, "Error: could not find filesystem for %s in pvfstab", fd->filename);
+	ret = PVFS_util_resolve(fd->filename, &cur_fs, 
+		pvfs_path, PVFS_NAME_MAX);
+	if (ret < 0 ) {
+	    PVFS_perror("PVFS_util_resolve", ret);
 	    /* TODO: pick a good error for this */
 	    o_status.error = -1;
-	} else 
-	    fake_an_open(ADIOI_PVFS2_fs_id_list[mnt_index], pvfs_path,
+	} else  {
+	    fake_an_open(cur_fs, pvfs_path,
 		    fd->access_mode, pvfs2_fs, &o_status);
+	}
     }
 
     /* NOTE: if MPI_MODE_EXCL was set, ADIO_Open will call
@@ -175,7 +170,7 @@
 	return;
     } 
 
-    /* broadcast status and (if successful) valid pinode refn */
+    /* broadcast status and (if successful) valid object reference */
     MPI_Bcast(MPI_BOTTOM, 1, open_status_type, 0, fd->comm);
 
     if (o_status.error != 0 ) { 
@@ -184,7 +179,7 @@
 	return;
     }
 
-    pvfs2_fs->pinode_refn = o_status.pinode_refn;
+    pvfs2_fs->object_ref = o_status.object_ref;
     fd->fs_ptr = pvfs2_fs;
 
     MPI_Type_free(&open_status_type);
Index: romio/adio/ad_pvfs2/ad_pvfs2_read.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_read.c:1.7 romio/adio/ad_pvfs2/ad_pvfs2_read.c:1.9
--- romio/adio/ad_pvfs2/ad_pvfs2_read.c:1.7	Thu Aug  7 18:34:31 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_read.c	Thu May 20 15:31:05 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_read.c,v 1.7 2003/08/07 23:34:31 robl Exp $
+ *   $Id: ad_pvfs2_read.c,v 1.9 2004/05/20 20:31:05 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -39,16 +39,16 @@
     }
 
     if (file_ptr_type == ADIO_EXPLICIT_OFFSET) {
-	ret = PVFS_sys_read(pvfs_fs->pinode_refn, file_req, offset, buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_read(pvfs_fs->object_ref, file_req, offset, buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0 ) {
 	    fprintf(stderr, "pvfs_sys_read returns with %d\n", ret);
 	    goto error_read;
 	}
 	fd->fp_sys_posn = offset + (int)resp_io.total_completed;
     } else { 
-	ret = PVFS_sys_read(pvfs_fs->pinode_refn, file_req, fd->fp_ind, buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_read(pvfs_fs->object_ref, file_req, fd->fp_ind, buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0) {
 	    fprintf(stderr, "pvfs_sys_read returns with %d\n", ret);
 	    goto error_read;
Index: romio/adio/ad_pvfs2/ad_pvfs2_resize.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_resize.c:1.4 romio/adio/ad_pvfs2/ad_pvfs2_resize.c:1.10
--- romio/adio/ad_pvfs2/ad_pvfs2_resize.c:1.4	Thu Sep  4 18:20:09 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_resize.c	Thu May 20 15:31:05 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_pvfs2_resize.c,v 1.4 2003/09/04 23:20:09 robl Exp $
+ *   $Id: ad_pvfs2_resize.c,v 1.10 2004/05/20 20:31:05 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -9,19 +9,36 @@
 #include "ad_pvfs2.h"
 #include "ad_pvfs2_common.h"
 
+/* as with ADIOI_PVFS2_Flush, implement the resize operation in a scalable
+ * manner. one process does the work, then broadcasts the result to everyone
+ * else.  fortunately, this operation is defined to be collective */
 void ADIOI_PVFS2_Resize(ADIO_File fd, ADIO_Offset size, int *error_code)
 {
-    int ret;
+    int ret, rank;
     ADIOI_PVFS2_fs *pvfs_fs;
 
+    *error_code = MPI_SUCCESS;
+
     pvfs_fs = (ADIOI_PVFS2_fs*)fd->fs_ptr;
 
-    ret = PVFS_sys_truncate(pvfs_fs->pinode_refn, size, pvfs_fs->credentials);
-    if (ret < 0 ) {
-	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
-    } else {
-	*error_code = MPI_SUCCESS;
+    MPI_Comm_rank(fd->comm, &rank);
+
+    /* We desginate one node in the communicator to be an 'io_worker' in 
+     * ADIO_Open.  This node can perform operations on files and then 
+     * inform the other nodes of the result */
+
+    /* we know all processes have reached this point because we did an
+     * MPI_Barrier in MPI_File_set_size() */
+
+    if (rank == fd->hints->ranklist[0]) {
+	ret = PVFS_sys_truncate(pvfs_fs->object_ref, 
+		size, &(pvfs_fs->credentials));
+	MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
+    } else  {
+	MPI_Bcast(&ret, 1, MPI_INT, 0, fd->comm);
     }
+    if (ret < 0 ) 
+	ADIOI_PVFS2_pvfs_error_convert(ret, error_code);
 }
 
 /*
Index: romio/adio/ad_pvfs2/ad_pvfs2_write.c
diff -u romio/adio/ad_pvfs2/ad_pvfs2_write.c:1.11 romio/adio/ad_pvfs2/ad_pvfs2_write.c:1.13
--- romio/adio/ad_pvfs2/ad_pvfs2_write.c:1.11	Fri Sep  5 15:47:47 2003
+++ romio/adio/ad_pvfs2/ad_pvfs2_write.c	Thu May 20 15:31:05 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- 
  *   vim: ts=8 sts=4 sw=4 noexpandtab
- *   $Id: ad_pvfs2_write.c,v 1.11 2003/09/05 20:47:47 robl Exp $
+ *   $Id: ad_pvfs2_write.c,v 1.13 2004/05/20 20:31:05 robl Exp $
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -38,16 +38,16 @@
     }
 
     if (file_ptr_type == ADIO_EXPLICIT_OFFSET) {
-	ret = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, offset,  buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_write(pvfs_fs->object_ref, file_req, offset,  buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0 ) {
 	    fprintf(stderr, "pvfs_sys_write returns with %d\n", ret);
 	    goto error_write;
 	}
 	fd->fp_sys_posn = offset + (int) resp_io.total_completed;
     } else {
-	ret = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, fd->fp_ind, buf, 
-		mem_req, pvfs_fs->credentials, &resp_io);
+	ret = PVFS_sys_write(pvfs_fs->object_ref, file_req, fd->fp_ind, buf, 
+		mem_req, &(pvfs_fs->credentials), &resp_io);
 	if (ret < 0) {
 	    fprintf(stderr, "pvfs_sys_write returns with %d\n", ret);
 	    goto error_write;
@@ -205,9 +205,9 @@
 		    err_flag = PVFS_Request_contiguous(file_lengths, 
 			    PVFS_BYTE, &file_req);
 		    if (err_flag < 0) break;
-		    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 
+		    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 
 			    file_offsets, PVFS_BOTTOM, mem_req, 
-			    pvfs_fs->credentials, &resp_io);
+			    &(pvfs_fs->credentials), &resp_io);
 		  
 		    /* in the case of error or the last read list call, 
 		     * leave here */
@@ -385,8 +385,8 @@
 	    /* PVFS_Request_hindexed already expresses the offsets into the
 	     * file, so we should not pass in an offset if we are using
 	     * hindexed for the file type */
-	    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 0, 
-		    mem_offsets, mem_req, pvfs_fs->credentials, &resp_io);
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    mem_offsets, mem_req, &(pvfs_fs->credentials), &resp_io);
 	    if (err_flag < 0)
 		goto error_state;
 
@@ -427,8 +427,8 @@
 	    if (err_flag < 0)
 		goto error_state;
 	    /* as above, use 0 for 'offset' when using hindexed file type*/
-	    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 0, 
-		    mem_offsets, mem_req, pvfs_fs->credentials, &resp_io);
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    mem_offsets, mem_req, &(pvfs_fs->credentials), &resp_io);
 	    if (err_flag < 0)
 		goto error_state;
         }
@@ -781,8 +781,8 @@
 	    if (err_flag < 0)
 		goto error_state;
 	    /* offset will be expressed in memory and file datatypes */
-	    err_flag = PVFS_sys_write(pvfs_fs->pinode_refn, file_req, 0, 
-		    PVFS_BOTTOM, mem_req, pvfs_fs->credentials, &resp_io);
+	    err_flag = PVFS_sys_write(pvfs_fs->object_ref, file_req, 0, 
+		    PVFS_BOTTOM, mem_req, &(pvfs_fs->credentials), &resp_io);
 	    size_wrote += new_buffer_write;
 	    start_k = k;
 	    start_j = j;
Index: romio/adio/ad_sfs/.cvsignore
diff -u romio/adio/ad_sfs/.cvsignore:1.2 romio/adio/ad_sfs/.cvsignore:1.3
--- romio/adio/ad_sfs/.cvsignore:1.2	Fri Aug  1 08:30:18 2003
+++ romio/adio/ad_sfs/.cvsignore	Mon Jan 19 08:49:36 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_testfs/.cvsignore
diff -u romio/adio/ad_testfs/.cvsignore:1.2 romio/adio/ad_testfs/.cvsignore:1.3
--- romio/adio/ad_testfs/.cvsignore:1.2	Fri Aug  1 08:30:19 2003
+++ romio/adio/ad_testfs/.cvsignore	Mon Jan 19 08:49:36 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_ufs/.cvsignore
diff -u romio/adio/ad_ufs/.cvsignore:1.2 romio/adio/ad_ufs/.cvsignore:1.3
--- romio/adio/ad_ufs/.cvsignore:1.2	Fri Aug  1 08:30:19 2003
+++ romio/adio/ad_ufs/.cvsignore	Mon Jan 19 08:49:37 2004
@@ -1,2 +1,4 @@
 Makefile
 .deps
+*.bb
+*.bbg
Index: romio/adio/ad_xfs/.cvsignore
diff -u romio/adio/ad_xfs/.cvsignore:1.3 romio/adio/ad_xfs/.cvsignore:1.4
--- romio/adio/ad_xfs/.cvsignore:1.3	Fri Aug  1 08:30:19 2003
+++ romio/adio/ad_xfs/.cvsignore	Mon Jan 19 08:49:37 2004
@@ -1,4 +1,5 @@
 Makefile
 *.safe
-
 .deps
+*.bb
+*.bbg
Index: romio/adio/common/.cvsignore
diff -u romio/adio/common/.cvsignore:1.3 romio/adio/common/.cvsignore:1.4
--- romio/adio/common/.cvsignore:1.3	Fri Aug  1 08:30:19 2003
+++ romio/adio/common/.cvsignore	Mon Jan 19 08:49:37 2004
@@ -1,5 +1,6 @@
 Makefile
 Debug*
 Release*
-
 .deps
+*.bb
+*.bbg
Index: romio/adio/common/Makefile.in
diff -u romio/adio/common/Makefile.in:1.12 romio/adio/common/Makefile.in:1.15
--- romio/adio/common/Makefile.in:1.12	Tue Oct  7 17:12:29 2003
+++ romio/adio/common/Makefile.in	Fri Feb  6 09:57:24 2004
@@ -19,7 +19,8 @@
       get_fp_posn.o ad_seek.o ad_delete.o ad_flush.o ad_hints.o error.o \
       ad_fstype.o ad_get_sh_fp.o ad_set_sh_fp.o shfp_fname.o byte_offset.o \
       status_setb.o ad_aggregate.o cb_config_list.o \
-      ad_read_str_naive.o gencheck.o ad_set_view.o ad_iopen.o
+      ad_read_str_naive.o gencheck.o ad_set_view.o ad_iopen.o \
+      ad_write_str_naive.o
 
 all: $(LIBNAME)
 	@if [ "@ENABLE_SHLIB@" != "none" ] ; then \
@@ -44,3 +45,9 @@
 
 clean:
 	@rm -f *.o *.lo
+
+tags: TAGS
+SOURCES = ${AD_OBJECTS:.o=.c}
+HEADERS = 
+TAGS:${HEADERS} ${SOURCES}
+	here=`cd ../../../../.. && pwd` ; cd ${srcdir} && etags -o $$here/TAGS --append ${HEADERS} ${SOURCES}
Index: romio/adio/common/ad_open.c
diff -u romio/adio/common/ad_open.c:1.23 romio/adio/common/ad_open.c:1.27
--- romio/adio/common/ad_open.c:1.23	Fri Sep  5 17:35:49 2003
+++ romio/adio/common/ad_open.c	Thu May 20 02:43:36 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_open.c,v 1.23 2003/09/05 22:35:49 gropp Exp $    
+ *   $Id: ad_open.c,v 1.27 2004/05/20 07:43:36 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -29,7 +29,7 @@
     static char myname[] = "ADIO_OPEN";
 #endif
 
-    int rank_ct;
+    int rank_ct, max_error_code;
     int *tmp_ranklist;
     MPI_Comm aggregator_comm = MPI_COMM_NULL; /* just for deferred opens */
 
@@ -126,7 +126,7 @@
 	ADIOI_Error(MPI_FILE_NULL, *error_code, myname);
 #endif
 	fd = ADIO_FILE_NULL;
-	return fd;
+        goto fn_exit;
     }
 
     /* deferred open: 
@@ -153,14 +153,18 @@
 		    MPI_Comm_split(fd->comm, 1, 0, &aggregator_comm);
 		    fd->agg_comm = aggregator_comm;
 		    MPI_Comm_rank(fd->agg_comm, &agg_rank);
-		    if (agg_rank == 0) fd->io_worker = 1;
+		    if (agg_rank == 0) {
+			    fd->io_worker = 1;
+		    }
 	    } else {
 		    MPI_Comm_split(fd->comm, MPI_UNDEFINED, 0, &aggregator_comm);
 		    fd->agg_comm = aggregator_comm;
 	    }
 
     } else {
-	    if (rank == 0) fd->io_worker = 1;
+	    if (rank == 0) {
+		    fd->io_worker = 1;
+	    }
     }
 
     orig_amode_excl = access_mode;
@@ -184,18 +188,11 @@
        else MPI_Bcast(error_code, 1, MPI_INT, 0, fd->comm);
 
        if (*error_code != MPI_SUCCESS) {
-	       /* copied from below */
-	       ADIOI_Free(fd->fns);
-	       MPI_Comm_free(&(fd->comm));
-	       free(fd->filename);
-	       MPI_Info_free(&(fd->info));
-	       ADIOI_Free(fd);
-	       fd = ADIO_FILE_NULL;
-	       return fd;
+           goto fn_exit;
        } 
        else {
-	       /* turn off EXCL for real open */
-	       access_mode = access_mode ^ MPI_MODE_EXCL; 
+           /* turn off EXCL for real open */
+           access_mode = access_mode ^ MPI_MODE_EXCL; 
        }
     }
 
@@ -203,14 +200,14 @@
     if (fd->hints->deferred_open && 
 		    ADIOI_Uses_generic_read(fd) &&
 		    ADIOI_Uses_generic_write(fd) ) {
-	    if (fd->agg_comm == MPI_COMM_NULL) {
-		    /* we might have turned off EXCL for the aggregators.
-		     * restore access_mode that non-aggregators get the right
-		     * value from get_amode */
-		    fd->access_mode = orig_amode_excl;
-		    *error_code = MPI_SUCCESS;
-		    return fd;
-	    }
+        if (fd->agg_comm == MPI_COMM_NULL) {
+            /* we might have turned off EXCL for the aggregators.
+             * restore access_mode that non-aggregators get the right
+             * value from get_amode */
+            fd->access_mode = orig_amode_excl;
+            *error_code = MPI_SUCCESS;
+            goto fn_exit;
+        }
     }
 
 /* For writing with data sieving, a read-modify-write is needed. If 
@@ -240,14 +237,45 @@
      * not an aggregaor and we are doing deferred open, we returned earlier)*/
     fd->is_open = 1;
 
-    /* if error, free and set fd to NULL */
-    if (*error_code != MPI_SUCCESS) {
-	ADIOI_Free(fd->fns);
-	MPI_Comm_free(&(fd->comm));
-	free(fd->filename);
-	MPI_Info_free(&(fd->info));
+ fn_exit:
+    MPI_Allreduce(error_code, &max_error_code, 1, MPI_INT, MPI_MAX, comm);
+    if (max_error_code != MPI_SUCCESS) {
+
+        /* If the file was successfully opened, close it */
+        if (*error_code == MPI_SUCCESS) {
+        
+            /* in the deferred open case, only those who have actually
+               opened the file should close it */
+            if (fd->hints->deferred_open && 
+                ADIOI_Uses_generic_read(fd) &&
+                ADIOI_Uses_generic_write(fd) ) {
+                if (fd->agg_comm != MPI_COMM_NULL) {
+                    (*(fd->fns->ADIOI_xxx_Close))(fd, error_code);
+                }
+            }
+            else {
+                (*(fd->fns->ADIOI_xxx_Close))(fd, error_code);
+            }
+        }
+
+	if (fd->fns) ADIOI_Free(fd->fns);
+	if (fd->filename) free(fd->filename);
+	if (fd->info != MPI_INFO_NULL) MPI_Info_free(&(fd->info));
 	ADIOI_Free(fd);
-	fd = ADIO_FILE_NULL;
+        fd = ADIO_FILE_NULL;
+	if (*error_code == MPI_SUCCESS)
+	{
+#ifdef MPICH2
+	    *error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**oremote_fail", 0);
+#elif defined(PRINT_ERR_MSG)
+	    *error_code = MPI_ERR_UNKNOWN;
+#else
+	    *error_code = MPIR_Err_setmsg(MPI_ERR_IO, MPIR_ADIO_ERROR, myname,
+		"Open Error", "%s", 
+		"Open failed on a remote node");
+	    ADIOI_Error(MPI_FILE_NULL, *error_code, myname);
+#endif
+	}
     }
 
     return fd;
@@ -270,5 +298,3 @@
         }
         return 0;
 }
-
-
Index: romio/adio/common/ad_write_str.c
diff -u romio/adio/common/ad_write_str.c:1.11 romio/adio/common/ad_write_str.c:1.12
--- romio/adio/common/ad_write_str.c:1.11	Sat Jul 26 18:16:57 2003
+++ romio/adio/common/ad_write_str.c	Tue Dec 16 15:51:22 2003
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ad_write_str.c,v 1.11 2003/07/26 23:16:57 David Exp $    
+ *   $Id: ad_write_str.c,v 1.12 2003/12/16 21:51:22 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -101,6 +101,21 @@
     ADIO_Status status1;
     int new_bwr_size, new_fwr_size, max_bufsize;
 
+    if (fd->hints->ds_write == ADIOI_HINT_DISABLE) {
+    	/* if user has disabled data sieving on reads, use naive
+	 * approach instead.
+	 */
+	ADIOI_GEN_WriteStrided_naive(fd, 
+				    buf,
+				    count,
+				    datatype,
+				    file_ptr_type,
+				    offset,
+				    status,
+				    error_code);
+    	return;
+    }
+
     *error_code = MPI_SUCCESS;  /* changed below if error */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
Index: romio/adio/common/ad_write_str_naive.c
diff -u /dev/null romio/adio/common/ad_write_str_naive.c:1.1
--- /dev/null	Thu May 20 15:51:16 2004
+++ romio/adio/common/ad_write_str_naive.c	Tue Dec 16 15:51:23 2003
@@ -0,0 +1,375 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/* 
+ *   $Id: ad_write_str_naive.c,v 1.1 2003/12/16 21:51:23 robl Exp $
+ *
+ *   Copyright (C) 2001 University of Chicago. 
+ *   See COPYRIGHT notice in top-level directory.
+ */
+
+#include "adio.h"
+#include "adio_extern.h"
+
+void ADIOI_GEN_WriteStrided_naive(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype buftype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code)
+{
+    /* offset is in units of etype relative to the filetype. */
+
+    ADIOI_Flatlist_node *flat_buf, *flat_file;
+    /* bwr == buffer write; fwr == file write */
+    int bwr_size, fwr_size=0, b_index;
+    int bufsize, size, sum, n_etypes_in_filetype, size_in_filetype;
+    int n_filetypes, etype_in_filetype;
+    ADIO_Offset abs_off_in_filetype=0;
+    int filetype_size, etype_size, buftype_size, req_len;
+    MPI_Aint filetype_extent, buftype_extent; 
+    int buf_count, buftype_is_contig, filetype_is_contig;
+    ADIO_Offset userbuf_off;
+    ADIO_Offset off, req_off, disp, end_offset=0, start_off;
+    ADIO_Status status1;
+
+    *error_code = MPI_SUCCESS;  /* changed below if error */
+
+    ADIOI_Datatype_iscontig(buftype, &buftype_is_contig);
+    ADIOI_Datatype_iscontig(fd->filetype, &filetype_is_contig);
+
+    MPI_Type_size(fd->filetype, &filetype_size);
+    if ( ! filetype_size ) {
+	*error_code = MPI_SUCCESS; 
+	return;
+    }
+
+    MPI_Type_extent(fd->filetype, &filetype_extent);
+    MPI_Type_size(buftype, &buftype_size);
+    MPI_Type_extent(buftype, &buftype_extent);
+    etype_size = fd->etype_size;
+
+    bufsize = buftype_size * count;
+
+    /* contiguous in buftype and filetype is handled elsewhere */
+
+    if (!buftype_is_contig && filetype_is_contig) {
+    	int b_count;
+	/* noncontiguous in memory, contiguous in file. */
+
+	ADIOI_Flatten_datatype(buftype);
+	flat_buf = ADIOI_Flatlist;
+	while (flat_buf->type != buftype) flat_buf = flat_buf->next;
+
+        off = (file_ptr_type == ADIO_INDIVIDUAL) ? fd->fp_ind : 
+              fd->disp + etype_size * offset;
+
+	start_off = off;
+	end_offset = off + bufsize - 1;
+
+	/* if atomicity is true, lock (exclusive) the region to be accessed */
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_WRITE_LOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+	/* for each region in the buffer, grab the data and put it in
+	 * place
+	 */
+        for (b_count=0; b_count < count; b_count++) {
+            for (b_index=0; b_index < flat_buf->count; b_index++) {
+                userbuf_off = b_count*buftype_extent + 
+		              flat_buf->indices[b_index];
+		req_off = off;
+		req_len = flat_buf->blocklens[b_index];
+
+		ADIO_WriteContig(fd, 
+				(char *) buf + userbuf_off,
+				req_len, 
+				MPI_BYTE, 
+		    		ADIO_EXPLICIT_OFFSET,
+				req_off,
+				&status1,
+				error_code);
+		if (*error_code != MPI_SUCCESS) return;
+
+		/* off is (potentially) used to save the final offset later */
+                off += flat_buf->blocklens[b_index];
+            }
+	}
+
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_UNLOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+        if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind = off;
+
+    }
+
+    else {  /* noncontiguous in file */
+    	int f_index, st_fwr_size, st_index = 0, st_n_filetypes;
+	int flag;
+
+        /* First we're going to calculate a set of values for use in all
+	 * the noncontiguous in file cases:
+	 * start_off - starting byte position of data in file
+	 * end_offset - last byte offset to be acessed in the file
+	 * st_n_filetypes - how far into the file we start in terms of
+	 *                  whole filetypes
+	 * st_index - index of block in first filetype that we will be
+	 *            starting in (?)
+	 * st_fwr_size - size of the data in the first filetype block
+	 *               that we will write (accounts for being part-way
+	 *               into writing this block of the filetype
+	 *
+	 */
+
+	/* filetype already flattened in ADIO_Open */
+	flat_file = ADIOI_Flatlist;
+	while (flat_file->type != fd->filetype) flat_file = flat_file->next;
+	disp = fd->disp;
+
+	if (file_ptr_type == ADIO_INDIVIDUAL) {
+	    start_off = fd->fp_ind; /* in bytes */
+	    n_filetypes = -1;
+	    flag = 0;
+	    while (!flag) {
+                n_filetypes++;
+		for (f_index=0; f_index < flat_file->count; f_index++) {
+		    if (disp + flat_file->indices[f_index] + 
+                       (ADIO_Offset) n_filetypes*filetype_extent + 
+		       flat_file->blocklens[f_index] >= start_off) 
+		    {
+		    	/* this block contains our starting position */
+
+			st_index = f_index;
+			fwr_size = (int) (disp + flat_file->indices[f_index] + 
+		 	           (ADIO_Offset) n_filetypes*filetype_extent + 
+				   flat_file->blocklens[f_index] - start_off);
+			flag = 1;
+			break;
+		    }
+		}
+	    }
+	}
+	else {
+	    n_etypes_in_filetype = filetype_size/etype_size;
+	    n_filetypes = (int) (offset / n_etypes_in_filetype);
+	    etype_in_filetype = (int) (offset % n_etypes_in_filetype);
+	    size_in_filetype = etype_in_filetype * etype_size;
+ 
+	    sum = 0;
+	    for (f_index=0; f_index < flat_file->count; f_index++) {
+		sum += flat_file->blocklens[f_index];
+		if (sum > size_in_filetype) {
+		    st_index = f_index;
+		    fwr_size = sum - size_in_filetype;
+		    abs_off_in_filetype = flat_file->indices[f_index] +
+			                  size_in_filetype - 
+			                  (sum - flat_file->blocklens[f_index]);
+		    break;
+		}
+	    }
+
+	    /* abs. offset in bytes in the file */
+	    start_off = disp + (ADIO_Offset) n_filetypes*filetype_extent + 
+	    	        abs_off_in_filetype;
+	}
+
+	st_fwr_size = fwr_size;
+	st_n_filetypes = n_filetypes;
+
+	/* start_off, st_n_filetypes, st_index, and st_fwr_size are 
+	 * all calculated at this point
+	 */
+
+        /* Calculate end_offset, the last byte-offset that will be accessed.
+         * e.g., if start_off=0 and 100 bytes to be written, end_offset=99
+	 */
+	userbuf_off = 0;
+	f_index = st_index;
+	off = start_off;
+	fwr_size = ADIOI_MIN(st_fwr_size, bufsize);
+	while (userbuf_off < bufsize) {
+	    userbuf_off += fwr_size;
+	    end_offset = off + fwr_size - 1;
+
+	    if (f_index < (flat_file->count - 1)) f_index++;
+	    else {
+		f_index = 0;
+		n_filetypes++;
+	    }
+
+	    off = disp + flat_file->indices[f_index] + 
+	          (ADIO_Offset) n_filetypes*filetype_extent;
+	    fwr_size = ADIOI_MIN(flat_file->blocklens[f_index], 
+	                         bufsize-(int)userbuf_off);
+	}
+
+	/* End of calculations.  At this point the following values have
+	 * been calculated and are ready for use:
+	 * - start_off
+	 * - end_offset
+	 * - st_n_filetypes
+	 * - st_index
+	 * - st_fwr_size
+	 */
+
+	/* if atomicity is true, lock (exclusive) the region to be accessed */
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_WRITE_LOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+	if (buftype_is_contig && !filetype_is_contig) {
+	    /* contiguous in memory, noncontiguous in file. should be the
+	     * most common case.
+	     */
+
+	    userbuf_off = 0;
+	    f_index = st_index;
+	    off = start_off;
+	    n_filetypes = st_n_filetypes;
+	    fwr_size = ADIOI_MIN(st_fwr_size, bufsize);
+
+	    /* while there is still space in the buffer, write more data */
+	    while (userbuf_off < bufsize) {
+                if (fwr_size) { 
+                    /* TYPE_UB and TYPE_LB can result in 
+                       fwr_size = 0. save system call in such cases */ 
+		    req_off = off;
+		    req_len = fwr_size;
+
+		    ADIO_WriteContig(fd, 
+				    (char *) buf + userbuf_off,
+				    req_len, 
+				    MPI_BYTE, 
+				    ADIO_EXPLICIT_OFFSET,
+				    req_off,
+				    &status1,
+				    error_code);
+		    if (*error_code != MPI_SUCCESS) return;
+		}
+		userbuf_off += fwr_size;
+
+                if (off + fwr_size < disp + flat_file->indices[f_index] +
+                   flat_file->blocklens[f_index] + 
+		   (ADIO_Offset) n_filetypes*filetype_extent)
+		{
+		    /* important that this value be correct, as it is
+		     * used to set the offset in the fd near the end of
+		     * this function.
+		     */
+                    off += fwr_size;
+		}
+                /* did not reach end of contiguous block in filetype.
+                 * no more I/O needed. off is incremented by fwr_size.
+		 */
+                else {
+		    if (f_index < (flat_file->count - 1)) f_index++;
+		    else {
+			f_index = 0;
+			n_filetypes++;
+		    }
+		    off = disp + flat_file->indices[f_index] + 
+                          (ADIO_Offset) n_filetypes*filetype_extent;
+		    fwr_size = ADIOI_MIN(flat_file->blocklens[f_index], 
+		                         bufsize-(int)userbuf_off);
+		}
+	    }
+	}
+	else {
+	    int i, tmp_bufsize = 0;
+	    /* noncontiguous in memory as well as in file */
+
+	    ADIOI_Flatten_datatype(buftype);
+	    flat_buf = ADIOI_Flatlist;
+	    while (flat_buf->type != buftype) flat_buf = flat_buf->next;
+
+	    b_index = buf_count = 0;
+	    i = (int) (flat_buf->indices[0]);
+	    f_index = st_index;
+	    off = start_off;
+	    n_filetypes = st_n_filetypes;
+	    fwr_size = st_fwr_size;
+	    bwr_size = flat_buf->blocklens[0];
+
+	    /* while we haven't read size * count bytes, keep going */
+	    while (tmp_bufsize < bufsize) {
+    		int new_bwr_size = bwr_size, new_fwr_size = fwr_size;
+
+		size = ADIOI_MIN(fwr_size, bwr_size);
+		if (size) {
+		    req_off = off;
+		    req_len = size;
+		    userbuf_off = i;
+
+		    ADIO_WriteContig(fd, 
+				    (char *) buf + userbuf_off,
+				    req_len, 
+				    MPI_BYTE, 
+				    ADIO_EXPLICIT_OFFSET,
+				    req_off,
+				    &status1,
+				    error_code);
+		    if (*error_code != MPI_SUCCESS) return;
+		}
+
+		if (size == fwr_size) {
+		    /* reached end of contiguous block in file */
+		    if (f_index < (flat_file->count - 1)) f_index++;
+		    else {
+			f_index = 0;
+			n_filetypes++;
+		    }
+
+		    off = disp + flat_file->indices[f_index] + 
+                          (ADIO_Offset) n_filetypes*filetype_extent;
+
+		    new_fwr_size = flat_file->blocklens[f_index];
+		    if (size != bwr_size) {
+			i += size;
+			new_bwr_size -= size;
+		    }
+		}
+
+		if (size == bwr_size) {
+		    /* reached end of contiguous block in memory */
+
+		    b_index = (b_index + 1)%flat_buf->count;
+		    buf_count++;
+		    i = (int) (buftype_extent*(buf_count/flat_buf->count) +
+			flat_buf->indices[b_index]);
+		    new_bwr_size = flat_buf->blocklens[b_index];
+		    if (size != fwr_size) {
+			off += size;
+			new_fwr_size -= size;
+		    }
+		}
+		tmp_bufsize += size;
+		fwr_size = new_fwr_size;
+                bwr_size = new_bwr_size;
+	    }
+	}
+
+	/* unlock the file region if we locked it */
+        if ((fd->atomicity) && (fd->file_system != ADIO_PIOFS) && 
+	   (fd->file_system != ADIO_PVFS))
+	{
+            ADIOI_UNLOCK(fd, start_off, SEEK_SET, end_offset-start_off+1);
+	}
+
+	if (file_ptr_type == ADIO_INDIVIDUAL) fd->fp_ind = off;
+    } /* end of (else noncontiguous in file) */
+
+    fd->fp_sys_posn = -1;   /* mark it as invalid. */
+
+#ifdef HAVE_STATUS_SET_BYTES
+    MPIR_Status_set_bytes(status, buftype, bufsize);
+    /* This is a temporary way of filling in status. The right way is to 
+     * keep track of how much data was actually written and placed in buf 
+     */
+#endif
+
+    if (!buftype_is_contig) ADIOI_Delete_flattened(buftype);
+}
Index: romio/adio/common/flatten.c
diff -u romio/adio/common/flatten.c:1.12 romio/adio/common/flatten.c:1.14
--- romio/adio/common/flatten.c:1.12	Thu Sep  4 16:35:29 2003
+++ romio/adio/common/flatten.c	Thu Feb 19 10:24:02 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: flatten.c,v 1.12 2003/09/04 21:35:29 rross Exp $    
+ *   $Id: flatten.c,v 1.14 2004/02/19 16:24:02 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -12,14 +12,6 @@
 #include "mpisgi2.h"
 #endif
 
-#if 0
-#define HAVE_MPIR_TYPE_FLATTEN 1
-#define HAVE_MPIR_TYPE_GET_CONTIG_BLOCKS 1
-#endif
-
-#undef HAVE_MPI_COMBINER_DUP
-#undef HAVE_MPI_COMBINER_SUBARRAY
-
 void ADIOI_Optimize_flattened(ADIOI_Flatlist_node *flat_type);
 void ADIOI_Flatten_subarray(int ndims,
 			    int *array_of_sizes,
@@ -30,12 +22,46 @@
 			    ADIOI_Flatlist_node *flat,
 			    ADIO_Offset start_offset,
 			    int *inout_index_p);
+void ADIOI_Flatten_darray(int size,
+			  int rank,
+			  int ndims,
+			  int array_of_gsizes[],
+			  int array_of_distribs[],
+			  int array_of_dargs[],
+			  int array_of_psizes[],
+			  int order,
+			  MPI_Datatype oldtype,
+			  ADIOI_Flatlist_node *flat,
+			  ADIO_Offset start_offset,
+			  int *inout_index_p);
 void ADIOI_Flatten_copy_type(ADIOI_Flatlist_node *flat,
 			     int old_type_start,
 			     int old_type_end,
 			     int new_type_start,
 			     ADIO_Offset offset_adjustment);
 
+/* darray helper functions */
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+static int index_of_type(int type_nr,
+			 int dim_size,
+			 int dim_rank,
+			 int dim_ranks,
+			 int k);
+static int get_cyclic_k(int dim_size,
+			int dim_ranks,
+			int dist,
+			int d_arg);
+static void get_darray_position(int rank,
+				int ranks,
+				int ndims,
+				int array_of_psizes[],
+				int r[]);
+static int local_types_in_dim(int dim_size,
+			      int dim_rank,
+			      int dim_ranks,
+			      int k);
+#endif
+
 /* flatten datatype and add it to Flatlist */
 void ADIOI_Flatten_datatype(MPI_Datatype datatype)
 {
@@ -104,7 +130,7 @@
 	FPRINTF(stderr, "\n\n");
 	FPRINTF(stderr, "indices: ");
 	for (i=0; i<flat->count; i++) 
-	    FPRINTF(stderr, "%ld ", flat->indices[i]);
+	    FPRINTF(stderr, "%ld ", (long) flat->indices[i]);
 	FPRINTF(stderr, "\n\n");
     }
 #endif
@@ -133,7 +159,7 @@
     MPI_Type_get_contents(datatype, nints, nadds, ntypes, ints, adds, types);
 
     switch (combiner) {
-#ifdef HAVE_MPI_COMBINER_DUP
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DUP
     case MPI_COMBINER_DUP:
         MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
 			      &old_ntypes, &old_combiner); 
@@ -142,7 +168,7 @@
             ADIOI_Flatten(types[0], flat, st_offset, curr_index);
         break;
 #endif
-#ifdef HAVE_MPI_COMBINER_SUBARRAY
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_SUBARRAY
     case MPI_COMBINER_SUBARRAY:
 	{
 	    int dims = ints[0];
@@ -159,6 +185,25 @@
 	}
 	break;
 #endif
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+    case MPI_COMBINER_DARRAY:
+	{
+	    int dims = ints[2];
+	    ADIOI_Flatten_darray(ints[0],         /* size */
+				 ints[1],         /* rank */
+				 dims,
+				 &ints[3],        /* gsizes */
+				 &ints[dims+3],   /* distribs */
+				 &ints[2*dims+3], /* dargs */
+				 &ints[3*dims+3], /* psizes */
+				 ints[4*dims+3],  /* order */
+				 types[0],
+				 flat,
+				 st_offset,
+				 curr_index);
+	}
+	break;
+#endif
     case MPI_COMBINER_CONTIGUOUS:
 	top_count = ints[0];
         MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
@@ -485,11 +530,8 @@
 
 }
 
-
 /********************************************************/
 
-
-
 /* ADIOI_Count_contiguous_blocks
  *
  * Returns number of contiguous blocks in type, and also saves this value in
@@ -520,7 +562,7 @@
     MPI_Type_get_contents(datatype, nints, nadds, ntypes, ints, adds, types);
 
     switch (combiner) {
-#ifdef HAVE_MPI_COMBINER_DUP
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DUP
     case MPI_COMBINER_DUP:
         MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
                               &old_ntypes, &old_combiner); 
@@ -530,7 +572,7 @@
 	else count = 1;
         break;
 #endif
-#ifdef HAVE_MPI_COMBINER_SUBARRAY
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_SUBARRAY
     case MPI_COMBINER_SUBARRAY:
 	/* first get an upper bound (since we're not optimizing) on the
 	 * number of blocks in the child type.
@@ -556,7 +598,44 @@
 	    n *= ints[ints[0]+1+i];
 	}
 	count *= n;
-	break;	    
+	break;
+#endif
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+    case MPI_COMBINER_DARRAY:
+	{
+	    int dims, k, *ranks;
+
+	    MPI_Type_get_envelope(types[0], &old_nints, &old_nadds,
+				  &old_ntypes, &old_combiner);
+	    ADIOI_Datatype_iscontig(types[0], &old_is_contig);
+	    if ((old_combiner != MPI_COMBINER_NAMED) && (!old_is_contig))
+		count = ADIOI_Count_contiguous_blocks(types[0], curr_index);
+	    else count = 1;
+	    
+	    n = 1;
+	    dims = ints[2];
+	    ranks = ADIOI_Malloc(sizeof(int) * dims);
+	    get_darray_position(ints[1],         /* rank */
+				ints[0],         /* size */
+				dims,
+				&ints[3*dims+3], /* psizes */
+				ranks);
+
+	    for (i=0; i < dims; i++) {
+		k = get_cyclic_k(ints[3+i],         /* gsize */
+				 ints[3*dims+3+i],  /* psize */
+				 ints[dims+3+i],    /* distrib */
+				 ints[2*dims+3+i]); /* darg */
+
+		n *= local_types_in_dim(ints[3+i],        /* gsize */
+					ranks[i],         /* dim rank */
+					ints[3*dims+3+i], /* psize */
+					k);
+	    }
+	    ADIOI_Free(ranks);
+	    count *= n;
+	}
+	break;
 #endif
     case MPI_COMBINER_CONTIGUOUS:
         top_count = ints[0];
@@ -772,7 +851,7 @@
 
 /****************************************************************/
 
-#ifdef HAVE_MPI_COMBINER_SUBARRAY
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_SUBARRAY
 /* ADIOI_Flatten_subarray()
  *
  * ndims - number of dimensions in the array
@@ -797,10 +876,11 @@
 			    ADIO_Offset start_offset,
 			    int *inout_index_p)
 {
-    int i, j, oldtype_extent, total_types, *dim_sz, flatten_start_offset,
+    int i, j, total_types, *dim_sz, flatten_start_offset,
 	flatten_end_offset;
     int old_nints, old_nadds, old_ntypes, old_combiner;
     ADIO_Offset subarray_start_offset, type_offset, *dim_skipbytes;
+    MPI_Aint oldtype_extent;
 
     MPI_Type_extent(oldtype, &oldtype_extent);
 
@@ -960,3 +1040,319 @@
 	out_index++;
     }
 }
+
+/****************************************************************/
+
+#ifdef MPIIMPL_HAVE_MPI_COMBINER_DARRAY
+/* ADIOI_Flatten_darray()
+ *
+ * size - number of processes across which darray is defined
+ * rank - our rank in the group of processes
+ * ndims - number of dimensions of darray type
+ * gsizes - dimensions of the array in types (order varies)
+ * distribs - type of dist. for each dimension (order varies)
+ * dargs - argument to dist. for each dimension (order varies)
+ * psizes - number of processes across which each dimension
+ *          is split (always C order)
+ * order - order of parameters (c or fortran)
+ * oldtype - type on which this darray is built
+ * flat - ...
+ * start_offset - offset of this type to begin with
+ * inout_index_p - count of indices already used on input, updated
+ *                 for output
+ *
+ * The general approach is to convert everything into cyclic-k and process
+ * it from there.
+ */
+void ADIOI_Flatten_darray(int size,
+			  int rank,
+			  int ndims,
+			  int array_of_gsizes[],
+			  int array_of_distribs[],
+			  int array_of_dargs[],
+			  int array_of_psizes[],
+			  int order,
+			  MPI_Datatype oldtype,
+			  ADIOI_Flatlist_node *flat,
+			  ADIO_Offset start_offset,
+			  int *inout_index_p)
+{
+    int i, j, total_types, flatten_start_offset,
+	flatten_end_offset, oldtype_nints, oldtype_nadds, oldtype_ntypes,
+	oldtype_combiner, *dim_ranks, *dim_ks, *dim_localtypes;
+    ADIO_Offset darray_start_offset, first_darray_offset;
+    MPI_Aint oldtype_extent, *dim_skipbytes;
+
+    MPI_Type_extent(oldtype, &oldtype_extent);
+
+    dim_localtypes = ADIOI_Malloc(sizeof(int) * ndims);
+    dim_skipbytes = ADIOI_Malloc(sizeof(MPI_Aint) * ndims);
+    dim_ranks = (int *) ADIOI_Malloc(sizeof(int) * ndims);
+    dim_ks = (int *) ADIOI_Malloc(sizeof(int) * ndims);
+
+    /* fill in dim_ranks, C order (just like psizes) */
+    get_darray_position(rank, size, ndims, array_of_psizes, dim_ranks);
+
+    /* calculate all k values; store in same order as arrays */
+    for (i=0; i < ndims; i++) {
+	dim_ks[i] = get_cyclic_k(array_of_gsizes[i],
+				 array_of_psizes[i],
+				 array_of_distribs[i],
+				 array_of_dargs[i]);
+    }
+
+    /* calculate total number of oldtypes in this type */
+    total_types = 1;
+    for (i=0; i < ndims; i++) {
+	total_types *= local_types_in_dim(array_of_gsizes[i],
+					  dim_ranks[i],
+					  array_of_psizes[i],
+					  dim_ks[i]);
+    }
+
+    /* fill in temporary values; these are just cached so we aren't
+     * calculating them for every type instance.
+     *
+     * dim_localtypes holds the # of types this process has in the given
+     * dimension.
+     *
+     * dim_skipbytes (in this function) is going to hold the distance
+     * to skip to move from one type to the next in that dimension, in
+     * bytes, in terms of the darray as a whole.  sort of like the stride
+     * for a vector.
+     * 
+     * we keep this stuff in row-major (C) order -- least-frequently changing
+     * first.
+     */
+    for (i=0; i < ndims; i++) {
+	int idx = (order == MPI_ORDER_C) ? i : ndims-1-i;
+
+	dim_localtypes[i] = local_types_in_dim(array_of_gsizes[idx],
+					       dim_ranks[idx],
+					       array_of_psizes[idx],
+					       dim_ks[idx]);
+    }
+
+    dim_skipbytes[ndims-1] = oldtype_extent;
+    for (i=ndims-2; i >= 0; i--) {
+	int idx = (order == MPI_ORDER_C) ? i+1 : ndims-2-i;
+
+	dim_skipbytes[i] = array_of_gsizes[idx] * dim_skipbytes[i+1];
+    }
+
+#if 0
+    for (i=0; i < ndims; i++) {
+	MPIU_dbg_printf("dim_skipbytes[%d] = %d, dim_localtypes[%d] = %d\n",
+			i, (int) dim_skipbytes[i], i, dim_localtypes[i]);
+    }
+#endif
+
+
+    /* determine starting offset */
+    darray_start_offset = start_offset;
+    first_darray_offset = 0;
+    for (i=0; i < ndims; i++) {
+	ADIO_Offset this_dim_off;
+	int idx = (order == MPI_ORDER_C) ? i : ndims-1-i;
+
+	this_dim_off = index_of_type(0,
+				     array_of_gsizes[idx],
+				     dim_ranks[i],
+				     array_of_psizes[i],
+				     dim_ks[idx]);
+
+	this_dim_off *= (ADIO_Offset) dim_skipbytes[i];
+	darray_start_offset += this_dim_off;
+	first_darray_offset += this_dim_off;
+    }
+    
+    /* flatten one of the type to get the offsets that we need;
+     * we need an accurate starting offset to do this in-place.
+     *
+     * we save the starting offset so we can adjust when copying
+     * later on.
+     */
+    flatten_start_offset = *inout_index_p;
+    MPI_Type_get_envelope(oldtype,
+			  &oldtype_nints,
+			  &oldtype_nadds,
+			  &oldtype_ntypes,
+			  &oldtype_combiner);
+    if (oldtype_combiner != MPI_COMBINER_NAMED) {
+	ADIOI_Flatten(oldtype, flat, darray_start_offset, inout_index_p);
+    }
+    else {
+	int oldtype_size;
+
+	MPI_Type_size(oldtype, &oldtype_size);
+
+	flat->indices[flatten_start_offset]   = darray_start_offset;
+	flat->blocklens[flatten_start_offset] = oldtype_size;
+	(*inout_index_p)++;
+    }
+    flatten_end_offset = *inout_index_p;
+
+    /* now run through all the types, calculating the effective
+     * offset and then making a copy of the flattened regions for the
+     * type (and adjusting the offsets of them appropriately)
+     */
+    for (i=0; i < total_types; i++) {
+	int block_nr = i;
+	ADIO_Offset type_offset = 0;
+
+	for (j=ndims-1; j >= 0; j--) {
+	    ADIO_Offset dim_off;
+	    int idx = (order == MPI_ORDER_C) ? j : ndims-1-j;
+	    int dim_index = block_nr % dim_localtypes[j];
+
+	    dim_off = index_of_type(dim_index,
+				    array_of_gsizes[idx],
+				    dim_ranks[j],
+				    array_of_psizes[j],
+				    dim_ks[idx]);
+
+
+	    if (dim_off) type_offset += (ADIO_Offset) dim_off *
+			     (ADIO_Offset) dim_skipbytes[j];
+#if 0
+	    {
+		char s1[] = " ", s2[] = "  ", s3[] = "   ";
+		MPIU_dbg_printf("%sindex of type %d (pass %d,%d) is %d; new offset = %d\n",
+				(j == 0) ? s1 : ((j == 1) ? s2 : s3),
+				dim_index, i, j, (int) dim_off, (int) type_offset);
+	    }
+#endif
+	    block_nr /= dim_localtypes[j];
+	}
+
+	/* perform copy; noting in this case that the type offsets that
+	 * we are calculating here are relative to the beginning of the
+	 * darray as a whole, not relative to the first of our elements.
+	 *
+	 * because of that we have to subtract off the first_darray_offset
+	 * in order to get the right offset adjustment.
+	 */
+	ADIOI_Flatten_copy_type(flat,
+				flatten_start_offset,
+				flatten_end_offset,
+				flatten_start_offset + i * (flatten_end_offset - flatten_start_offset),
+				type_offset - first_darray_offset);
+    }
+    
+    /* free temp space */
+    ADIOI_Free(dim_skipbytes);
+    ADIOI_Free(dim_localtypes);
+    ADIOI_Free(dim_ranks);
+    ADIOI_Free(dim_ks);
+
+    *inout_index_p = flatten_start_offset + total_types *
+	(flatten_end_offset - flatten_start_offset);
+}
+
+/* darray processing helper functions */
+static int index_of_type(int type_nr,
+			 int dim_size,
+			 int dim_rank,
+			 int dim_ranks,
+			 int k)
+{
+    int cycle, leftover, index;
+
+    /* handle MPI_DISTRIBUTE_NONE case */
+    if (k == 0) return type_nr;
+
+    cycle = type_nr / k;
+    leftover = type_nr % k;
+
+    index = (dim_rank * k) + (dim_ranks * k * cycle) + leftover;
+
+    return index;
+}
+
+static int get_cyclic_k(int dim_size,
+			int dim_ranks,
+			int dist,
+			int d_arg)
+{
+    int k;
+
+    /* calculate correct "k" if DFLT_DARG passed in */
+    if (dist == MPI_DISTRIBUTE_NONE) return 0; /* indicates NONE */
+    else if (d_arg == MPI_DISTRIBUTE_DFLT_DARG) {
+	if (dist == MPI_DISTRIBUTE_BLOCK) {
+	    k = (dim_size + dim_ranks - 1) / dim_ranks;
+	}
+	else {
+	    k = 1;
+	}
+    }
+    else {
+	k = d_arg;
+    }
+
+    return k;
+}
+
+static int local_types_in_dim(int dim_size,
+			      int dim_rank,
+			      int dim_ranks,
+			      int k)
+{
+    int count, n_blocks, n_types, leftover;
+
+    if (k == 0) {
+	/* indicates MPI_DISTRIBUTE_NONE */
+	return dim_size;
+    }
+
+    /* blocks are regions of (up to k) types; this count
+     * includes partials
+     */
+    n_blocks = (dim_size + k - 1) / k;
+
+    /* count gets us a total # of blocks that the particular
+     * rank gets, including possibly a partial block
+     */
+    count = n_blocks / dim_ranks;
+    leftover = n_blocks - (count * dim_ranks);
+    if (dim_rank < leftover) count++;
+
+    n_types = count * k;
+
+    /* subtract off the types that are missing from the final
+     * partial block, if there is a partial and this rank is
+     * the one that has it.
+     */
+    if ((dim_rank == leftover - 1) && (dim_size % k != 0)) {
+	n_types -= k - (dim_size - ((dim_size / k) * k));
+    }
+
+    return n_types;
+}
+
+/* get_darray_position(rank, ranks, ndims, array_of_psizes, r[])
+ *
+ * Calculates the position of this process in the darray
+ * given the rank of the process passed to the darray create
+ * and the total number of processes also passed to the darray
+ * create.
+ *
+ * Assumes that the array (r[]) has already been allocated.
+ */
+static void get_darray_position(int rank,
+				int ranks,
+				int ndims,
+				int array_of_psizes[],
+				int r[])
+{
+    int i;
+    int t_rank = rank;
+    int t_size = ranks;
+
+    for (i = 0; i < ndims; i++) {
+	t_size = t_size / array_of_psizes[i];
+	r[i] = t_rank / t_size;
+	t_rank = t_rank % t_size;
+    }
+} 
+#endif
Index: romio/adio/include/adio.h
diff -u romio/adio/include/adio.h:1.30 romio/adio/include/adio.h:1.33
--- romio/adio/include/adio.h:1.30	Mon Sep  8 08:35:43 2003
+++ romio/adio/include/adio.h	Tue Mar 16 16:53:55 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: adio.h,v 1.30 2003/09/08 13:35:43 gropp Exp $    
+ *   $Id: adio.h,v 1.33 2004/03/16 22:53:55 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -180,8 +180,8 @@
     ADIOI_Fns *fns;          /* struct of I/O functions to use */
     MPI_Comm comm;           /* communicator indicating who called open */
     MPI_Comm agg_comm;      /* deferred open: aggregators who called open */
-    int io_worker;	    /* if one proc should do io, should it be me? */
-    int is_open;		/* deferred open: 0: not open yet 1: is open */
+    int io_worker;	    /* bool: if one proc should do io, is it me? */
+    int is_open;	    /* deferred open: 0: not open yet 1: is open */
     char *filename;          
     int file_system;         /* type of file system */
     int access_mode;         /* Access mode (sequential, append, etc.) */
Index: romio/adio/include/adioi.h
diff -u romio/adio/include/adioi.h:1.21 romio/adio/include/adioi.h:1.22
--- romio/adio/include/adioi.h:1.21	Thu Dec  4 16:20:06 2003
+++ romio/adio/include/adioi.h	Wed Dec 17 10:49:52 2003
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: adioi.h,v 1.21 2003/12/04 22:20:06 robl Exp $    
+ *   $Id: adioi.h,v 1.22 2003/12/17 16:49:52 robl Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -304,6 +304,10 @@
                        MPI_Datatype datatype, int file_ptr_type,
                        ADIO_Offset offset, ADIO_Status *status, int
                        *error_code);
+void ADIOI_GEN_WriteStrided_naive(ADIO_File fd, void *buf, int count,
+                       MPI_Datatype datatype, int file_ptr_type,
+                       ADIO_Offset offset, ADIO_Status *status, int
+                       *error_code);
 void ADIOI_GEN_ReadStridedColl(ADIO_File fd, void *buf, int count,
                        MPI_Datatype datatype, int file_ptr_type,
                        ADIO_Offset offset, ADIO_Status *status, int
Index: romio/adio/include/mpipr.h
diff -u romio/adio/include/mpipr.h:1.8 romio/adio/include/mpipr.h:1.9
--- romio/adio/include/mpipr.h:1.8	Mon Sep  8 08:36:43 2003
+++ romio/adio/include/mpipr.h	Thu Jan  8 16:41:54 2004
@@ -1,5 +1,5 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
-/*  $Id: mpipr.h,v 1.8 2003/09/08 13:36:43 gropp Exp $
+/*  $Id: mpipr.h,v 1.9 2004/01/08 22:41:54 gropp Exp $
  *
  *  (C) 2001 by Argonne National Laboratory.
  *      See COPYRIGHT in top-level directory.
@@ -149,6 +149,7 @@
 #define MPI_Group_union PMPI_Group_union
 #undef MPI_Ibsend
 #define MPI_Ibsend PMPI_Ibsend
+#if 0
 #undef MPI_Info_create
 #define MPI_Info_create PMPI_Info_create
 #undef MPI_Info_delete
@@ -167,6 +168,7 @@
 #define MPI_Info_get_valuelen PMPI_Info_get_valuelen
 #undef MPI_Info_set
 #define MPI_Info_set PMPI_Info_set
+#endif /* only conditionally set the info */
 #undef MPI_Init
 #define MPI_Init PMPI_Init
 #undef MPI_Initialized
Index: romio/include/mpio.h.in
diff -u romio/include/mpio.h.in:1.20 romio/include/mpio.h.in:1.24
--- romio/include/mpio.h.in:1.20	Thu Nov  6 18:14:54 2003
+++ romio/include/mpio.h.in	Sun Feb 29 12:31:14 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: mpio.h.in,v 1.20 2003/11/07 00:14:54 robl Exp $    
+ *   $Id: mpio.h.in,v 1.24 2004/02/29 18:31:14 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -17,7 +17,7 @@
 extern "C" {
 #endif
 
-#define ROMIO_VERSION 124 /* version 1.2.4 */
+#define ROMIO_VERSION 126 /* version 1.2.6 */
 
 /* define MPI-IO datatypes and constants */
 
@@ -30,6 +30,12 @@
 typedef struct ADIOI_RequestD *MPIO_Request;  
 #else
 #define MPIO_Request MPI_Request
+#define MPIO_USES_MPI_REQUEST
+/* Also rename the MPIO routines to get the MPI versions */
+#define MPIO_Wait MPI_Wait
+#define MPIO_Test MPI_Test
+#define PMPIO_Wait PMPI_Wait
+#define PMPIO_Test PMPI_Test
 #endif
 #define MPIO_REQUEST_DEFINED
 
@@ -66,7 +72,12 @@
 
 #define MPI_DISPLACEMENT_CURRENT   -54278278
 
+/* #ifndef MPICH2 */
+/* FIXME: Make sure that we get a consistent definition of MPI_FILE_NULL
+	in MPICH2 */
+/* MPICH2 defines null object handles differently */
 #define MPI_FILE_NULL           ((MPI_File) 0)
+/* #endif */
 #define MPIO_REQUEST_NULL       ((MPIO_Request) 0)
 
 #define MPI_SEEK_SET            600
@@ -204,8 +215,11 @@
 int MPI_File_sync(MPI_File fh);
 
 /* Section 4.13.3 */
+#ifndef MPICH2
+/* MPICH2 provides these definitions */
 int MPI_File_set_errhandler( MPI_File, MPI_Errhandler );
 int MPI_File_get_errhandler( MPI_File, MPI_Errhandler * );
+#endif
 /* End Prototypes */
 
 #ifndef HAVE_MPI_DARRAY_SUBARRAY
@@ -399,8 +413,11 @@
 int PMPI_File_sync(MPI_File fh);
 
 /* Section 4.13.3 */
+#ifndef MPICH2
+/* MPICH2 provides these definitions */
 int PMPI_File_set_errhandler( MPI_File, MPI_Errhandler );
 int PMPI_File_get_errhandler( MPI_File, MPI_Errhandler * );
+#endif
 
 #ifndef HAVE_MPI_DARRAY_SUBARRAY
 /* Section 4.14.4 */
Index: romio/mpi-io/.cvsignore
diff -u romio/mpi-io/.cvsignore:1.2 romio/mpi-io/.cvsignore:1.3
--- romio/mpi-io/.cvsignore:1.2	Fri Aug  1 08:30:20 2003
+++ romio/mpi-io/.cvsignore	Mon Jan 19 08:49:37 2004
@@ -1,2 +1,5 @@
 Makefile
 .deps
+*.o
+*.bb
+*.bbg
Index: romio/mpi-io/Makefile.in
diff -u romio/mpi-io/Makefile.in:1.19 romio/mpi-io/Makefile.in:1.21
--- romio/mpi-io/Makefile.in:1.19	Mon Dec  1 15:52:58 2003
+++ romio/mpi-io/Makefile.in	Tue Jan 27 17:27:39 2004
@@ -34,10 +34,7 @@
 
 # EXTRA objects are ones that need to be included for all but MPICH2
 MPIO_OBJECTS = close.o read.o open.o write.o set_view.o \
-      iread.o iwrite.o iotest.o iowait.o \
-	iowaitall.o iowaitany.o \
-	iotestall.o iotestany.o \
-	iowaitsome.o iotestsome.o \
+      iread.o iwrite.o \
       seek.o get_posn.o \
       delete.o read_all.o read_at.o \
       read_atall.o iread_at.o iwrite_at.o write_all.o get_bytoff.o \
@@ -50,17 +47,18 @@
       get_posn_sh.o iread_sh.o read_sh.o write_sh.o \
       iwrite_sh.o seek_sh.o read_ord.o read_orde.o write_ordb.o \
       read_ordb.o write_ord.o write_orde.o mpiu_greq.o mpich2_fileutil.o
+# MPIO_REQOBJECTS are the routines that provide the MPIO_Wait etc.
+# routines (iotest.o, iowait.o iowaitall.o iowaitany.o iotestall.o
+# iotestany.o iowaitsome.o and iotestsome.o)
+MPIO_REQOBJECTS = @MPIO_REQOBJECTS@
 
 # Either get_errh.o set_errh.o or empty 
-MPIO_EXTRA_OBJECTS = @MPIO_EXTRA_OBJECTS@
+MPIO_EXTRA_OBJECTS = @MPIO_EXTRA_OBJECTS@ @MPIO_REQOBJECTS@
 
 # mpich2_fileutil.p is not included because it does not include any
 # name-shifted functions
 MPIO_TMP_POBJECTS = close.p read.p open.p write.p get_extent.p \
-      iread.p iwrite.p iotest.p iowait.p \
-	iowaitall.p iowaitany.p \
-	iotestall.p iotestany.p \
-	iowaitsome.p iotestsome.p \
+      iread.p iwrite.p \
       seek.p \
       delete.p read_all.p read_at.p \
       read_atall.p iread_at.p iwrite_at.p get_posn.p \
@@ -75,17 +73,14 @@
       read_ordb.p write_ord.p write_orde.p 
 
 # Either get_errh.p set_errh.p or empty 
-MPIO_EXTRA_TMP_POBJECTS = @MPIO_EXTRA_TMP_POBJECTS@
+MPIO_EXTRA_TMP_POBJECTS = @MPIO_EXTRA_TMP_POBJECTS@ @MPIO_REQ_TMP_POBJECTS@
 
 # _mpich2_fileutil.o is not included because it does not include any 
 # name-shifted functions
 MPIO_REAL_POBJECTS = _close.o _read.o _open.o _get_extent.o \
       _write.o _set_view.o _seek.o _read_at.o _prealloc.o \
-      _iread.o _iwrite.o _iotest.o _iowait.o \
-	_iowaitall.o _iowaitany.o \
-	_iotestall.o _iotestany.o \
-	_iowaitsome.o _iotestsome.o \
-	_get_posn.o \
+      _iread.o _iwrite.o \
+      _get_posn.o \
       _delete.o _read_all.o _get_bytoff.o \
       _read_atall.o _iread_at.o _iwrite_at.o _get_group.o _get_amode.o \
       _write_all.o _write_at.o _write_atall.o _get_view.o \
@@ -99,7 +94,7 @@
       _read_ordb.o _write_ord.o _write_orde.o 
 
 # Either _get_errh.o _set_errh.o or empty 
-MPIO_EXTRA_REAL_POBJECTS = @MPIO_EXTRA_REAL_POBJECTS@
+MPIO_EXTRA_REAL_POBJECTS = @MPIO_EXTRA_REAL_POBJECTS@ @MPIO_REQ_REAL_POBJECTS@
 
 all: $(LIBNAME)
 	@if [ "@ENABLE_SHLIB@" != "none" ] ; then \
@@ -153,3 +148,9 @@
 mandoc: ${mpi_sources:.c=.man}
 latexdoc: ${mpi_sources:.c=.latex}
 htmldoc: ${mpi_sources:.c=.html}
+
+tags: TAGS
+SOURCES = ${mpi_sources}
+HEADERS = 
+TAGS:${HEADERS} ${SOURCES}
+	here=`cd ../../../.. && pwd` ; cd ${srcdir} && etags -o $$here/TAGS --append ${HEADERS} ${SOURCES}
Index: romio/mpi-io/close.c
diff -u romio/mpi-io/close.c:1.11 romio/mpi-io/close.c:1.12
--- romio/mpi-io/close.c:1.11	Tue Jul  1 14:12:39 2003
+++ romio/mpi-io/close.c	Tue Apr  6 13:46:31 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: close.c,v 1.11 2003/07/01 19:12:39 robl Exp $    
+ *   $Id: close.c,v 1.12 2004/04/06 18:46:31 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -55,6 +55,10 @@
 
     if (((*fh)->file_system != ADIO_PIOFS) && ((*fh)->file_system != ADIO_PVFS) && ((*fh)->file_system != ADIO_PVFS2)) {
 	ADIOI_Free((*fh)->shared_fp_fname);
+        /* need a barrier because the file containing the shared file
+        pointer is opened with COMM_SELF. We don't want it to be
+	deleted while others are still accessing it. */ 
+        MPI_Barrier((*fh)->comm);
 	if ((*fh)->shared_fp_fd != ADIO_FILE_NULL)
 	    ADIO_Close((*fh)->shared_fp_fd, &error_code);
     }
Index: romio/mpi-io/delete.c
diff -u romio/mpi-io/delete.c:1.18 romio/mpi-io/delete.c:1.19
--- romio/mpi-io/delete.c:1.18	Mon Sep 15 08:33:30 2003
+++ romio/mpi-io/delete.c	Thu Feb 12 00:08:22 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: delete.c,v 1.18 2003/09/15 13:33:30 gropp Exp $    
+ *   $Id: delete.c,v 1.19 2004/02/12 06:08:22 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -56,7 +56,9 @@
    /* check if MPI itself has been initialized. If not, flag an error.
    Can't initialize it here, because don't know argc, argv */
         MPI_Initialized(&flag);
-        if (!flag) {
+	/* --BEGIN ERROR HANDLING-- */
+        if (!flag)
+	{
 #ifdef MPICH2
 	    error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**initialized", 0);
@@ -65,7 +67,8 @@
             FPRINTF(stderr, "Error: MPI_Init() must be called before using MPI-IO\n");
             MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
-        }
+	}
+	/* --END ERROR HANDLING-- */
 
         MPI_Keyval_create(MPI_NULL_COPY_FN, ADIOI_End_call, &ADIO_Init_keyval,
                           (void *) 0);  
@@ -86,7 +89,9 @@
     /* resolve file system type from file name; this is a collective call */
     ADIO_ResolveFileType(MPI_COMM_SELF, filename, &file_system, &fsops, 
 			 &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 	/* ADIO_ResolveFileType() will print as informative a message as it
 	 * possibly can or call MPIR_Err_setmsg.  We just need to propagate 
 	 * the error up.  In the PRINT_ERR_MSG case MPI_Abort has already
@@ -100,6 +105,7 @@
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* skip prefix on filename if there is one */
     tmp = strchr(filename, ':');
Index: romio/mpi-io/get_posn_sh.c
diff -u romio/mpi-io/get_posn_sh.c:1.17 romio/mpi-io/get_posn_sh.c:1.18
--- romio/mpi-io/get_posn_sh.c:1.17	Tue Jul  1 14:12:39 2003
+++ romio/mpi-io/get_posn_sh.c	Thu Feb 12 00:08:24 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: get_posn_sh.c,v 1.17 2003/07/01 19:12:39 robl Exp $    
+ *   $Id: get_posn_sh.c,v 1.18 2004/02/12 06:08:24 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -52,7 +52,9 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**ioamodeseq", 0);
@@ -67,7 +69,8 @@
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -80,6 +83,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_get_position_shared", &error_code);
 
Index: romio/mpi-io/get_view.c
diff -u romio/mpi-io/get_view.c:1.15 romio/mpi-io/get_view.c:1.16
--- romio/mpi-io/get_view.c:1.15	Fri Apr 18 15:15:08 2003
+++ romio/mpi-io/get_view.c	Thu Feb 12 00:08:26 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: get_view.c,v 1.15 2003/04/18 20:15:08 David Exp $    
+ *   $Id: get_view.c,v 1.16 2004/02/12 06:08:26 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -60,7 +60,9 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (datarep <= (char *) 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (datarep <= (char *) 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iodatarepnomem", 0);
@@ -74,6 +76,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     *disp = fh->disp;
     strcpy(datarep, "native");
Index: romio/mpi-io/ioreq_f2c.c
diff -u romio/mpi-io/ioreq_f2c.c:1.10 romio/mpi-io/ioreq_f2c.c:1.11
--- romio/mpi-io/ioreq_f2c.c:1.10	Mon Feb 24 17:52:08 2003
+++ romio/mpi-io/ioreq_f2c.c	Thu Feb 12 00:08:27 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: ioreq_f2c.c,v 1.10 2003/02/24 23:52:08 robl Exp $    
+ *   $Id: ioreq_f2c.c,v 1.11 2004/02/12 06:08:27 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -44,11 +44,13 @@
 #ifndef INT_LT_POINTER
     return (MPIO_Request) request;
 #else
+    /* --BEGIN ERROR HANDLING-- */
     if (!request) return MPIO_REQUEST_NULL;
     if ((request < 0) || (request > ADIOI_Reqtable_ptr)) {
 	FPRINTF(stderr, "MPIO_Request_f2c: Invalid request\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
+    /* --END ERROR HANDLING-- */
     return ADIOI_Reqtable[request];
 #endif
 }
Index: romio/mpi-io/iread_sh.c
diff -u romio/mpi-io/iread_sh.c:1.20 romio/mpi-io/iread_sh.c:1.21
--- romio/mpi-io/iread_sh.c:1.20	Tue Jul  1 14:12:40 2003
+++ romio/mpi-io/iread_sh.c	Thu Feb 12 00:08:29 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: iread_sh.c,v 1.20 2003/07/01 19:12:40 robl Exp $    
+ *   $Id: iread_sh.c,v 1.21 2004/02/12 06:08:29 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -76,8 +76,10 @@
     ADIO_Status status;
     ADIO_Offset off, shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_iread_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -85,7 +87,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -99,7 +102,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
@@ -113,10 +117,13 @@
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
@@ -131,7 +138,8 @@
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**iosharedunsupported", 0);
@@ -145,6 +153,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
@@ -153,20 +162,27 @@
 
     incr = (count*datatype_size)/fh->etype_size;
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 	FPRINTF(stderr, "MPI_File_iread_shared: Error! Could not access shared file pointer.\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
+    /* --END ERROR HANDLING-- */
 
     /* contiguous or strided? */
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
     /* convert count and shared_fp to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * shared_fp;
         if (!(fh->atomicity))
+	{
 	    ADIO_IreadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
-			off, request, &error_code); 
-        else {
+			off, request, &error_code);
+	}
+        else
+	{
             /* to maintain strict atomicity semantics with other concurrent
               operations, lock (exclusive) and call blocking routine */
 
@@ -178,21 +194,28 @@
 	    (*request)->handle = 0;
 
             if (fh->file_system != ADIO_NFS)
+	    {
                 ADIOI_WRITE_LOCK(fh, off, SEEK_SET, bufsize);
+	    }
 
             ADIO_ReadContig(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET, off, 
                     &status, &error_code);  
 
             if (fh->file_system != ADIO_NFS)
+	    {
                 ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
+	    }
 
             fh->async_count++;
             /* status info. must be linked to the request structure, so that it
                can be accessed later from a wait */
         }
     }
-    else ADIO_IreadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
-			   shared_fp, request, &error_code); 
+    else
+    {
+	ADIO_IreadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
+			   shared_fp, request, &error_code);
+    }
 
     return error_code;
 }
Index: romio/mpi-io/mpich2_fileutil.c
diff -u romio/mpi-io/mpich2_fileutil.c:1.12 romio/mpi-io/mpich2_fileutil.c:1.13
--- romio/mpi-io/mpich2_fileutil.c:1.12	Mon Nov  3 07:49:38 2003
+++ romio/mpi-io/mpich2_fileutil.c	Wed Feb  4 15:59:24 2004
@@ -116,7 +116,7 @@
     else if (file_ptr->cookie != ADIOI_FILE_COOKIE) {
 	return MPI_ERR_FILE;
     }
-    /* -- END ERROR HANDLING-- */
+    /* --END ERROR HANDLING-- */
     else {
 	if (file_ptr->err_handler == MPI_ERRORS_RETURN) 
 	    *e = 0;
Index: romio/mpi-io/open.c
diff -u romio/mpi-io/open.c:1.32 romio/mpi-io/open.c:1.34
--- romio/mpi-io/open.c:1.32	Mon Sep 22 16:23:23 2003
+++ romio/mpi-io/open.c	Wed May 19 18:55:09 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: open.c,v 1.32 2003/09/22 21:23:23 gropp Exp $    
+ *   $Id: open.c,v 1.34 2004/05/19 23:55:09 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -57,7 +57,9 @@
     HPMP_IO_OPEN_START(fl_xmpi, comm);
 #endif /* MPI_hpux */
 
-    if (comm == MPI_COMM_NULL) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (comm == MPI_COMM_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_COMM, "**comm", 0);
 	return MPIR_Err_return_file(MPI_FILE_NULL, myname, error_code);
@@ -70,9 +72,12 @@
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Comm_test_inter(comm, &flag);
-    if (flag) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (flag)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_COMM, 
 	    "**commnotintra", 0);
@@ -88,7 +93,8 @@
     }
 
     if ( ((amode&MPI_MODE_RDONLY)?1:0) + ((amode&MPI_MODE_RDWR)?1:0) +
-	 ((amode&MPI_MODE_WRONLY)?1:0) != 1 ) {
+	 ((amode&MPI_MODE_WRONLY)?1:0) != 1 )
+    {
 #ifdef MPICH2
 	     error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_AMODE, 
 		 "**fileamodeone", 0);
@@ -104,7 +110,8 @@
     }
 
     if ((amode & MPI_MODE_RDONLY) && 
-            ((amode & MPI_MODE_CREATE) || (amode & MPI_MODE_EXCL))) {
+            ((amode & MPI_MODE_CREATE) || (amode & MPI_MODE_EXCL)))
+    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_AMODE, 
 		    "**fileamoderead", 0);
@@ -119,7 +126,8 @@
 #endif
     }
 
-    if ((amode & MPI_MODE_RDWR) && (amode & MPI_MODE_SEQUENTIAL)) {
+    if ((amode & MPI_MODE_RDWR) && (amode & MPI_MODE_SEQUENTIAL))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_AMODE, 
 	    "**fileamodeseq", 0);
@@ -133,6 +141,7 @@
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 /* check if amode is the same on all processes */
     MPI_Comm_dup(comm, &dupcomm);
@@ -148,7 +157,8 @@
 */
 
 /* check if ADIO has been initialized. If not, initialize it */
-    if (ADIO_Init_keyval == MPI_KEYVAL_INVALID) {
+    if (ADIO_Init_keyval == MPI_KEYVAL_INVALID)
+    {
 
 /* check if MPI itself has been initialized. If not, flag an error.
    Can't initialize it here, because don't know argc, argv */
@@ -180,7 +190,9 @@
 
     /* resolve file system type from file name; this is a collective call */
     ADIO_ResolveFileType(dupcomm, filename, &file_system, &fsops, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 	/* ADIO_ResolveFileType() will print as informative a message as it
 	 * possibly can or call MPIR_Err_setmsg.  We just need to propagate 
 	 * the error up.  In the PRINT_ERR_MSG case MPI_Abort has already
@@ -202,7 +214,8 @@
      *  these tests here. -- Rob, 06/06/2001
      */
     if (((file_system == ADIO_PIOFS) || (file_system == ADIO_PVFS) || (file_system == ADIO_PVFS2)) && 
-        (amode & MPI_MODE_SEQUENTIAL)) {
+        (amode & MPI_MODE_SEQUENTIAL))
+    {
 #ifdef MPICH2
 	    error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 		"**iosequnsupported", 0);
@@ -216,6 +229,7 @@
 	return ADIOI_Error(MPI_FILE_NULL, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* strip off prefix if there is one */
     tmp = strchr(filename, ':');
@@ -231,6 +245,9 @@
     *fh = ADIO_Open(comm, dupcomm, filename, file_system, amode, 0, MPI_BYTE,
                     MPI_BYTE, M_ASYNC, info, ADIO_PERM_NULL, &error_code);
 
+    if (error_code != MPI_SUCCESS)
+        MPI_Comm_free(&dupcomm);
+
     /* determine name of file that will hold the shared file pointer */
     /* can't support shared file pointers on a file system that doesn't
        support file locking, e.g., PIOFS, PVFS, PVFS2 */
Index: romio/mpi-io/read_alle.c
diff -u romio/mpi-io/read_alle.c:1.15 romio/mpi-io/read_alle.c:1.16
--- romio/mpi-io/read_alle.c:1.15	Mon Sep  8 08:35:04 2003
+++ romio/mpi-io/read_alle.c	Thu Feb 12 00:08:42 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_alle.c,v 1.15 2003/09/08 13:35:04 gropp Exp $    
+ *   $Id: read_alle.c,v 1.16 2004/02/12 06:08:42 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -43,8 +43,10 @@
     static char myname[] = "MPI_FILE_IREAD";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_all_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -52,7 +54,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
@@ -66,6 +69,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     if (status != MPI_STATUS_IGNORE)
Index: romio/mpi-io/read_at.c
diff -u romio/mpi-io/read_at.c:1.20 romio/mpi-io/read_at.c:1.21
--- romio/mpi-io/read_at.c:1.20	Mon Sep  8 08:33:43 2003
+++ romio/mpi-io/read_at.c	Thu Feb 12 00:08:44 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_at.c,v 1.20 2003/09/08 13:33:43 gropp Exp $    
+ *   $Id: read_at.c,v 1.21 2004/02/12 06:08:44 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -57,8 +57,10 @@
     HPMP_IO_START(fl_xmpi, BLKMPIFILEREADAT, TRDTBLOCK, fh, datatype, count);
 #endif /* MPI_hpux */
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_at: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -66,7 +68,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (offset < 0) {
+    if (offset < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadoffset", 0);
@@ -81,7 +84,8 @@
 #endif
     }
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
@@ -96,7 +100,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
@@ -110,9 +115,11 @@
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
-    if (count*datatype_size == 0) {
+    if (count*datatype_size == 0)
+    {
 #ifdef MPI_hpux
 	HPMP_IO_END(fl_xmpi, fh, datatype, count);
 #endif /* MPI_hpux */
@@ -122,7 +129,9 @@
 	return MPI_SUCCESS;
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
@@ -137,7 +146,8 @@
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_WRONLY) {
+    if (fh->access_mode & MPI_MODE_WRONLY)
+    {
 #ifdef MPICH2
 	error_code=  MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ACCESS, 
 	    "**ioneedrd", 0);
@@ -152,7 +162,8 @@
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**ioamodeseq", 0);
@@ -166,6 +177,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
@@ -174,7 +186,8 @@
 
     /* contiguous or strided? */
 
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
     /* convert count and offset to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * offset;
@@ -196,9 +209,12 @@
 	    	(fh->file_system != ADIO_PVFS2))
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
-    else ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
-			  offset, status, &error_code); 
-    /* For strided and atomic mode, locking is done in ADIO_ReadStrided */
+    else
+    {
+	ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
+			  offset, status, &error_code);
+	/* For strided and atomic mode, locking is done in ADIO_ReadStrided */
+    }
 
 
 #ifdef MPI_hpux
Index: romio/mpi-io/read_ordb.c
diff -u romio/mpi-io/read_ordb.c:1.20 romio/mpi-io/read_ordb.c:1.21
--- romio/mpi-io/read_ordb.c:1.20	Thu Sep 25 08:25:11 2003
+++ romio/mpi-io/read_ordb.c	Thu Feb 12 00:08:49 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_ordb.c,v 1.20 2003/09/25 13:25:11 gropp Exp $    
+ *   $Id: read_ordb.c,v 1.21 2004/02/12 06:08:49 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -47,8 +47,10 @@
 #endif
     ADIO_Offset shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_ordered_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -56,7 +58,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
@@ -71,7 +74,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
@@ -86,7 +90,8 @@
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcoll", 0);
@@ -100,11 +105,14 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
@@ -120,7 +128,8 @@
     }
 
     if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || 
-		    (fh->file_system == ADIO_PVFS2)) {
+		    (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -133,6 +142,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_read_ordered_begin", &error_code);
 
@@ -147,7 +157,9 @@
     if (dest >= nprocs) dest = MPI_PROC_NULL;
     MPI_Recv( NULL, 0, MPI_BYTE, source, 0, fh->comm, MPI_STATUS_IGNORE );
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
@@ -157,6 +169,7 @@
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
     MPI_Send( NULL, 0, MPI_BYTE, dest, 0, fh->comm );
 
     ADIO_ReadStridedColl(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
Index: romio/mpi-io/read_orde.c
diff -u romio/mpi-io/read_orde.c:1.15 romio/mpi-io/read_orde.c:1.16
--- romio/mpi-io/read_orde.c:1.15	Mon Sep  8 08:35:04 2003
+++ romio/mpi-io/read_orde.c	Thu Feb 12 00:08:51 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_orde.c,v 1.15 2003/09/08 13:35:04 gropp Exp $    
+ *   $Id: read_orde.c,v 1.16 2004/02/12 06:08:51 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -52,7 +52,9 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
@@ -66,6 +68,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     if (status != MPI_STATUS_IGNORE)
Index: romio/mpi-io/read_sh.c
diff -u romio/mpi-io/read_sh.c:1.19 romio/mpi-io/read_sh.c:1.20
--- romio/mpi-io/read_sh.c:1.19	Mon Sep 15 08:33:31 2003
+++ romio/mpi-io/read_sh.c	Thu Feb 12 00:08:53 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: read_sh.c,v 1.19 2003/09/15 13:33:31 gropp Exp $    
+ *   $Id: read_sh.c,v 1.20 2004/02/12 06:08:53 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -50,8 +50,10 @@
     int datatype_size, incr;
     ADIO_Offset off, shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_read_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -59,7 +61,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
@@ -74,7 +77,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
@@ -88,16 +92,20 @@
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
-    if (count*datatype_size == 0) {
+    if (count*datatype_size == 0)
+    {
 #ifdef HAVE_STATUS_SET_BYTES
 	MPIR_Status_set_bytes(status, datatype, 0);
 #endif
 	return MPI_SUCCESS;
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
@@ -112,7 +120,8 @@
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) || (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -125,6 +134,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
@@ -133,7 +143,9 @@
 
     incr = (count*datatype_size)/fh->etype_size;
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
@@ -143,9 +155,11 @@
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* contiguous or strided? */
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
 	/* convert count and shared_fp to bytes */
         bufsize = datatype_size * count;
         off = fh->disp + fh->etype_size * shared_fp;
@@ -163,9 +177,12 @@
         if ((fh->atomicity) && (fh->file_system != ADIO_NFS))
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
-    else ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
-                          shared_fp, status, &error_code); 
-    /* For strided and atomic mode, locking is done in ADIO_ReadStrided */
+    else
+    {
+	ADIO_ReadStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
+                          shared_fp, status, &error_code);
+	/* For strided and atomic mode, locking is done in ADIO_ReadStrided */
+    }
 
     return error_code;
 }
Index: romio/mpi-io/seek_sh.c
diff -u romio/mpi-io/seek_sh.c:1.18 romio/mpi-io/seek_sh.c:1.19
--- romio/mpi-io/seek_sh.c:1.18	Mon Sep 15 08:33:31 2003
+++ romio/mpi-io/seek_sh.c	Thu Feb 12 00:09:02 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: seek_sh.c,v 1.18 2003/09/15 13:33:31 gropp Exp $    
+ *   $Id: seek_sh.c,v 1.19 2004/02/12 06:09:02 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -42,8 +42,10 @@
 #endif
     MPI_Offset curr_offset, eof_offset, tmp_offset;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_seek_shared: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -51,7 +53,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**ioamodeseq", 0);
@@ -66,7 +69,8 @@
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**iosharedunsupported", 0);
@@ -80,10 +84,13 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     tmp_offset = offset;
     MPI_Bcast(&tmp_offset, 1, ADIO_OFFSET, 0, fh->comm);
-    if (tmp_offset != offset) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (tmp_offset != offset)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**notsame", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -96,10 +103,13 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     tmp_whence = whence;
     MPI_Bcast(&tmp_whence, 1, MPI_INT, 0, fh->comm);
-    if (tmp_whence != whence) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (tmp_whence != whence)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadwhence", 0);
@@ -113,15 +123,20 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_seek_shared", &error_code);
 
     MPI_Comm_rank(fh->comm, &myrank);
 
-    if (!myrank) {
-	switch(whence) {
+    if (!myrank)
+    {
+	switch(whence)
+	{
 	case MPI_SEEK_SET:
-	    if (offset < 0) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (offset < 0)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		    "**iobadoffset", 0);
@@ -130,27 +145,33 @@
 		FPRINTF(stderr, "MPI_File_seek_shared: Invalid offset argument\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
-	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG,
+		error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG,
 				     myname, (char *) 0, (char *) 0);
-	return ADIOI_Error(fh, error_code, myname);	    
+		return ADIOI_Error(fh, error_code, myname);	    
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    break;
 	case MPI_SEEK_CUR:
 	    /* get current location of shared file pointer */
 	    ADIO_Get_shared_fp(fh, 0, &curr_offset, &error_code);
-	    if (error_code != MPI_SUCCESS) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (error_code != MPI_SUCCESS)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
-	    "**iosharedfailed", 0);
+		    "**iosharedfailed", 0);
 		return MPIR_Err_return_file(fh, myname, error_code);
 #else
 		FPRINTF(stderr, "MPI_File_seek_shared: Error! Could not access shared file pointer.\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    offset += curr_offset;
-	    if (offset < 0) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (offset < 0)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		    "**ionegoffset", 0);
@@ -159,17 +180,20 @@
 		FPRINTF(stderr, "MPI_File_seek_shared: offset points to a negative location in the file\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
-	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG_NEG,
+		error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG_NEG,
 				     myname, (char *) 0, (char *) 0);
-	return ADIOI_Error(fh, error_code, myname);	    
+		return ADIOI_Error(fh, error_code, myname);	    
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    break;
 	case MPI_SEEK_END:
 	    /* find offset corr. to end of file */
 	    ADIOI_Get_eof_offset(fh, &eof_offset);
 	    offset += eof_offset;
-	    if (offset < 0) {
+	    /* --BEGIN ERROR HANDLING-- */
+	    if (offset < 0)
+	    {
 #ifdef MPICH2
 		error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		    "**ionegoffset", 0);
@@ -178,13 +202,15 @@
 		FPRINTF(stderr, "MPI_File_seek_shared: offset points to a negative location in the file\n");
 		MPI_Abort(MPI_COMM_WORLD, 1);
 #else /* MPICH-1 */
-	error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG_NEG,
+		error_code = MPIR_Err_setmsg(MPI_ERR_ARG, MPIR_ERR_OFFSET_ARG_NEG,
 				     myname, (char *) 0, (char *) 0);
-	return ADIOI_Error(fh, error_code, myname);	    
+		return ADIOI_Error(fh, error_code, myname);	    
 #endif
 	    }
+	    /* --END ERROR HANDLING-- */
 	    break;
 	default:
+	    /* --BEGIN ERROR HANDLING-- */
 #ifdef MPICH2
 	    error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 		"**iobadwhence", 0);
@@ -197,6 +223,7 @@
 				     myname, (char *) 0, (char *) 0);
 	    return ADIOI_Error(fh, error_code, myname);
 #endif
+	    /* --END ERROR HANDLING-- */
 	}
 
 	ADIO_Set_shared_fp(fh, offset, &error_code);
Index: romio/mpi-io/set_errh.c
diff -u romio/mpi-io/set_errh.c:1.11 romio/mpi-io/set_errh.c:1.12
--- romio/mpi-io/set_errh.c:1.11	Fri Apr 18 15:15:12 2003
+++ romio/mpi-io/set_errh.c	Tue Dec 16 11:32:34 2003
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: set_errh.c,v 1.11 2003/04/18 20:15:12 David Exp $    
+ *   $Id: set_errh.c,v 1.12 2003/12/16 17:32:34 thakur Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -41,7 +41,7 @@
     static char myname[] = "MPI_FILE_SET_ERRHANDLER";
 #endif
 
-    if ((errhandler != MPI_ERRORS_RETURN) || (errhandler != MPI_ERRORS_ARE_FATAL)) {
+    if ((errhandler != MPI_ERRORS_RETURN) && (errhandler != MPI_ERRORS_ARE_FATAL)) {
 	FPRINTF(stderr, "Only MPI_ERRORS_RETURN and MPI_ERRORS_ARE_FATAL are currently supported for MPI_File_set_errhandler\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
Index: romio/mpi-io/wr_atallb.c
diff -u romio/mpi-io/wr_atallb.c:1.16 romio/mpi-io/wr_atallb.c:1.17
--- romio/mpi-io/wr_atallb.c:1.16	Fri Sep  5 17:33:57 2003
+++ romio/mpi-io/wr_atallb.c	Thu Feb 12 00:09:09 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: wr_atallb.c,v 1.16 2003/09/05 22:33:57 gropp Exp $    
+ *   $Id: wr_atallb.c,v 1.17 2004/02/12 06:09:09 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -44,8 +44,10 @@
     static char myname[] = "MPI_FILE_WRITE_AT_ALL_BEGIN";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_at_all_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -53,7 +55,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (offset < 0) {
+    if (offset < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**iobadoffset", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -67,7 +70,8 @@
 #endif
     }
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, "**iobadcount", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -81,7 +85,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
@@ -96,7 +101,8 @@
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**ioamodeseq", 0);
@@ -111,7 +117,8 @@
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcoll", 0);
@@ -125,11 +132,14 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
@@ -143,6 +153,7 @@
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_datatype = datatype;
     ADIO_WriteStridedColl(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
Index: romio/mpi-io/wr_atalle.c
diff -u romio/mpi-io/wr_atalle.c:1.16 romio/mpi-io/wr_atalle.c:1.17
--- romio/mpi-io/wr_atalle.c:1.16	Mon Sep  8 08:35:05 2003
+++ romio/mpi-io/wr_atalle.c	Thu Feb 12 00:09:10 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: wr_atalle.c,v 1.16 2003/09/08 13:35:05 gropp Exp $    
+ *   $Id: wr_atalle.c,v 1.17 2004/02/12 06:09:10 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -43,8 +43,10 @@
     static char myname[] = "MPI_FILE_WRITE_AT_ALL_END";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_at_all_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -52,7 +54,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
@@ -66,6 +69,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     /* FIXME - we should really ensure that the split_datatype remains
Index: romio/mpi-io/write_allb.c
diff -u romio/mpi-io/write_allb.c:1.15 romio/mpi-io/write_allb.c:1.16
--- romio/mpi-io/write_allb.c:1.15	Fri Sep  5 17:34:31 2003
+++ romio/mpi-io/write_allb.c	Thu Feb 12 00:09:12 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_allb.c,v 1.15 2003/09/05 22:34:31 gropp Exp $    
+ *   $Id: write_allb.c,v 1.16 2004/02/12 06:09:12 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -43,8 +43,10 @@
     static char myname[] = "MPI_FILE_WRITE_ALL_BEGIN";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_all_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -52,7 +54,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
@@ -67,7 +70,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
@@ -82,7 +86,8 @@
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, 
 	    "**ioamodeseq", 0);
@@ -97,7 +102,8 @@
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, "**iosplitcoll", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -110,11 +116,14 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO,
 	    "**ioetype", 0);
@@ -128,6 +137,7 @@
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* See FIXME in write_alle.c */
     fh->split_datatype = datatype;
Index: romio/mpi-io/write_alle.c
diff -u romio/mpi-io/write_alle.c:1.15 romio/mpi-io/write_alle.c:1.18
--- romio/mpi-io/write_alle.c:1.15	Fri Sep  5 17:34:32 2003
+++ romio/mpi-io/write_alle.c	Wed Mar 17 14:31:27 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_alle.c,v 1.15 2003/09/05 22:34:32 gropp Exp $    
+ *   $Id: write_alle.c,v 1.18 2004/03/17 20:31:27 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -43,6 +43,7 @@
     static char myname[] = "MPI_FILE_WRITE_ALL_END";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
     if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
 	FPRINTF(stderr, "MPI_File_write_all_end: Invalid file handle\n");
@@ -52,7 +53,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO,
 	    "**iosplitcollnone", 0);
@@ -66,11 +68,13 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     /* FIXME - we should really ensure that the split_datatype remains
        valid by incrementing the ref count in the write_allb.c routine
        and decrement it here after setting the bytes */
+    if (status != MPI_STATUS_IGNORE)
        *status = fh->split_status;
 #endif
     fh->split_coll_count = 0;
Index: romio/mpi-io/write_at.c
diff -u romio/mpi-io/write_at.c:1.20 romio/mpi-io/write_at.c:1.21
--- romio/mpi-io/write_at.c:1.20	Mon Sep  8 16:29:22 2003
+++ romio/mpi-io/write_at.c	Thu Feb 12 00:09:15 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_at.c,v 1.20 2003/09/08 21:29:22 gropp Exp $    
+ *   $Id: write_at.c,v 1.21 2004/02/12 06:09:15 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -58,8 +58,10 @@
     HPMP_IO_START(fl_xmpi, BLKMPIFILEWRITEAT, TRDTBLOCK, fh, datatype, count);
 #endif /* MPI_hpux */
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_at: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -67,7 +69,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (offset < 0) {
+    if (offset < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadoffset", 0);
@@ -82,7 +85,8 @@
 #endif
     }
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadcount", 0);
@@ -97,7 +101,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE,
 	    "**dtypenull", 0);
@@ -111,9 +116,11 @@
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
-    if (count*datatype_size == 0) {
+    if (count*datatype_size == 0)
+    {
 #ifdef MPI_hpux
 	HPMP_IO_END(fl_xmpi, fh, datatype, count);
 #endif /* MPI_hpux */
@@ -124,7 +131,9 @@
 	return MPI_SUCCESS;
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO,
 	    "**ioetype", 0);
@@ -139,7 +148,8 @@
 #endif
     }
 
-    if (fh->access_mode & MPI_MODE_SEQUENTIAL) {
+    if (fh->access_mode & MPI_MODE_SEQUENTIAL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**ioamodeseq", 0);
@@ -153,7 +163,9 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
-    if (fh->access_mode & MPI_MODE_RDONLY) {
+
+    if (fh->access_mode & MPI_MODE_RDONLY)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_READ_ONLY,
 	    "**filerdonly", "**filerdonly %s", fh->filename );
@@ -167,7 +179,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
-
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
@@ -176,7 +188,8 @@
 
     /* contiguous or strided? */
 
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
     /* convert bufocunt and offset to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * offset;
@@ -199,9 +212,11 @@
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
     else
+    {
 	ADIO_WriteStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
-			 offset, status, &error_code); 
-    /* For strided and atomic mode, locking is done in ADIO_WriteStrided */
+			 offset, status, &error_code);
+	/* For strided and atomic mode, locking is done in ADIO_WriteStrided */
+    }
 
 #ifdef MPI_hpux
     HPMP_IO_END(fl_xmpi, fh, datatype, count);
Index: romio/mpi-io/write_ordb.c
diff -u romio/mpi-io/write_ordb.c:1.20 romio/mpi-io/write_ordb.c:1.21
--- romio/mpi-io/write_ordb.c:1.20	Thu Sep 25 08:25:11 2003
+++ romio/mpi-io/write_ordb.c	Thu Feb 12 00:09:17 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_ordb.c,v 1.20 2003/09/25 13:25:11 gropp Exp $    
+ *   $Id: write_ordb.c,v 1.21 2004/02/12 06:09:17 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -47,8 +47,10 @@
 #endif
     ADIO_Offset shared_fp;
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_ordered_begin: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -56,7 +58,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG,
 	    "**iobadcount", 0);
@@ -71,7 +74,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE,
 	    "**dtypenull", 0);
@@ -86,7 +90,8 @@
 #endif
     }
 
-    if (fh->split_coll_count) {
+    if (fh->split_coll_count)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcoll", 0);
@@ -100,11 +105,14 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     fh->split_coll_count = 1;
 
     MPI_Type_size(datatype, &datatype_size);
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
@@ -120,7 +128,8 @@
     }
 
     if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS) ||
-		    (fh->file_system == ADIO_PVFS2)) {
+		    (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION,
 	    "**iosharedunsupported", 0);
@@ -136,6 +145,7 @@
     }
 
     ADIOI_TEST_DEFERRED(fh, "MPI_File_write_ordered_begin", &error_code);
+    /* --END ERROR HANDLING-- */
 
     MPI_Comm_size(fh->comm, &nprocs);
     MPI_Comm_rank(fh->comm, &myrank);
@@ -148,7 +158,9 @@
     if (dest >= nprocs) dest = MPI_PROC_NULL;
     MPI_Recv( NULL, 0, MPI_BYTE, source, 0, fh->comm, MPI_STATUS_IGNORE );
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
@@ -158,6 +170,7 @@
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
     MPI_Send( NULL, 0, MPI_BYTE, dest, 0, fh->comm );
 
     ADIO_WriteStridedColl(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
Index: romio/mpi-io/write_orde.c
diff -u romio/mpi-io/write_orde.c:1.15 romio/mpi-io/write_orde.c:1.16
--- romio/mpi-io/write_orde.c:1.15	Mon Sep  8 08:35:05 2003
+++ romio/mpi-io/write_orde.c	Thu Feb 12 00:09:19 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_orde.c,v 1.15 2003/09/08 13:35:05 gropp Exp $    
+ *   $Id: write_orde.c,v 1.16 2004/02/12 06:09:19 David Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -43,8 +43,10 @@
     static char myname[] = "MPI_FILE_WRITE_ORDERED_END";
 #endif
 
+    /* --BEGIN ERROR HANDLING-- */
 #ifdef PRINT_ERR_MSG
-    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE)) {
+    if ((fh <= (MPI_File) 0) || (fh->cookie != ADIOI_FILE_COOKIE))
+    {
 	FPRINTF(stderr, "MPI_File_write_ordered_end: Invalid file handle\n");
 	MPI_Abort(MPI_COMM_WORLD, 1);
     }
@@ -52,7 +54,8 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (!(fh->split_coll_count)) {
+    if (!(fh->split_coll_count))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**iosplitcollnone", 0);
@@ -66,6 +69,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
 #ifdef HAVE_STATUS_SET_BYTES
     if (status != MPI_STATUS_IGNORE)
Index: romio/mpi-io/write_sh.c
diff -u romio/mpi-io/write_sh.c:1.19 romio/mpi-io/write_sh.c:1.21
--- romio/mpi-io/write_sh.c:1.19	Mon Sep 15 08:33:36 2003
+++ romio/mpi-io/write_sh.c	Fri Feb 20 13:47:59 2004
@@ -1,6 +1,6 @@
 /* -*- Mode: C; c-basic-offset:4 ; -*- */
 /* 
- *   $Id: write_sh.c,v 1.19 2003/09/15 13:33:36 gropp Exp $    
+ *   $Id: write_sh.c,v 1.21 2004/02/20 19:47:59 gropp Exp $    
  *
  *   Copyright (C) 1997 University of Chicago. 
  *   See COPYRIGHT notice in top-level directory.
@@ -59,7 +59,9 @@
     ADIOI_TEST_FILE_HANDLE(fh, myname);
 #endif
 
-    if (count < 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (count < 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_ARG, 
 	    "**iobadcount", 0);
@@ -74,7 +76,8 @@
 #endif
     }
 
-    if (datatype == MPI_DATATYPE_NULL) {
+    if (datatype == MPI_DATATYPE_NULL)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_TYPE, 
 	    "**dtypenull", 0);
@@ -88,6 +91,7 @@
 	return ADIOI_Error(fh, error_code, myname);	    
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     MPI_Type_size(datatype, &datatype_size);
     if (count*datatype_size == 0) {
@@ -97,7 +101,9 @@
 	return MPI_SUCCESS; 
     }
 
-    if ((count*datatype_size) % fh->etype_size != 0) {
+    /* --BEGIN ERROR HANDLING-- */
+    if ((count*datatype_size) % fh->etype_size != 0)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_IO, 
 	    "**ioetype", 0);
@@ -112,7 +118,8 @@
 #endif
     }
 
-    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2)) {
+    if ((fh->file_system == ADIO_PIOFS) || (fh->file_system == ADIO_PVFS)|| (fh->file_system == ADIO_PVFS2))
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_RECOVERABLE, myname, __LINE__, MPI_ERR_UNSUPPORTED_OPERATION, "**iosharedunsupported", 0);
 	return MPIR_Err_return_file(fh, myname, error_code);
@@ -125,6 +132,7 @@
 	return ADIOI_Error(fh, error_code, myname);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     ADIOI_Datatype_iscontig(datatype, &buftype_is_contig);
     ADIOI_Datatype_iscontig(fh->filetype, &filetype_is_contig);
@@ -133,7 +141,9 @@
 
     incr = (count*datatype_size)/fh->etype_size;
     ADIO_Get_shared_fp(fh, incr, &shared_fp, &error_code);
-    if (error_code != MPI_SUCCESS) {
+    /* --BEGIN ERROR HANDLING-- */
+    if (error_code != MPI_SUCCESS)
+    {
 #ifdef MPICH2
 	error_code = MPIR_Err_create_code(MPI_SUCCESS, MPIR_ERR_FATAL, myname, __LINE__, MPI_ERR_INTERN, 
 					  "**iosharedfailed", 0);
@@ -143,9 +153,11 @@
 	MPI_Abort(MPI_COMM_WORLD, 1);
 #endif
     }
+    /* --END ERROR HANDLING-- */
 
     /* contiguous or strided? */
-    if (buftype_is_contig && filetype_is_contig) {
+    if (buftype_is_contig && filetype_is_contig)
+    {
         /* convert bufocunt and shared_fp to bytes */
 	bufsize = datatype_size * count;
 	off = fh->disp + fh->etype_size * shared_fp;
@@ -164,9 +176,11 @@
             ADIOI_UNLOCK(fh, off, SEEK_SET, bufsize);
     }
     else
+    {
 	ADIO_WriteStrided(fh, buf, count, datatype, ADIO_EXPLICIT_OFFSET,
-			 shared_fp, status, &error_code); 
-    /* For strided and atomic mode, locking is done in ADIO_WriteStrided */
+			 shared_fp, status, &error_code);
+	/* For strided and atomic mode, locking is done in ADIO_WriteStrided */
+    }
 
     return error_code;
 }
Index: romio/test/async.c
diff -u romio/test/async.c:1.6 romio/test/async.c:1.7
--- romio/test/async.c:1.6	Sun Feb 23 10:17:22 2003
+++ romio/test/async.c	Tue Jan 27 17:23:37 2004
@@ -66,7 +66,11 @@
                   MPI_INFO_NULL, &fh);
     MPI_File_set_view(fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL);
     MPI_File_iwrite(fh, buf, nints, MPI_INT, &request);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait( &request, &status );
+#else    
     MPIO_Wait(&request, &status);
+#endif
     MPI_File_close(&fh);
 
     /* reopen the file and read the data back */
@@ -76,7 +80,12 @@
                   MPI_INFO_NULL, &fh);
     MPI_File_set_view(fh, 0, MPI_INT, MPI_INT, "native", MPI_INFO_NULL);
     MPI_File_iread(fh, buf, nints, MPI_INT, &request);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait( &request, &status );
+#else
     MPIO_Wait(&request, &status);
+#endif
+
     MPI_File_close(&fh);
 
     /* check if the data read is correct */
Index: romio/test/i_noncontig.c
diff -u romio/test/i_noncontig.c:1.6 romio/test/i_noncontig.c:1.7
--- romio/test/i_noncontig.c:1.6	Sun Feb 23 10:31:15 2003
+++ romio/test/i_noncontig.c	Thu Jan 29 10:30:22 2004
@@ -91,14 +91,22 @@
 
     for (i=0; i<SIZE; i++) buf[i] = i + mynod*SIZE;
     MPI_File_iwrite(fh, buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     MPI_Barrier(MPI_COMM_WORLD);
 
     for (i=0; i<SIZE; i++) buf[i] = -1;
 
     MPI_File_iread_at(fh, 0, buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     for (i=0; i<SIZE; i++) {
 	if (!mynod) {
@@ -144,14 +152,22 @@
 
     for (i=0; i<SIZE; i++) buf[i] = i + mynod*SIZE;
     MPI_File_iwrite_at(fh, mynod*(SIZE/2)*sizeof(int), buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     MPI_Barrier(MPI_COMM_WORLD);
 
     for (i=0; i<SIZE; i++) buf[i] = -1;
 
     MPI_File_iread_at(fh, mynod*(SIZE/2)*sizeof(int), buf, 1, newtype, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     for (i=0; i<SIZE; i++) {
 	if (!mynod) {
@@ -199,14 +215,22 @@
 
     for (i=0; i<SIZE; i++) buf[i] = i + mynod*SIZE;
     MPI_File_iwrite(fh, buf, SIZE, MPI_INT, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     MPI_Barrier(MPI_COMM_WORLD);
 
     for (i=0; i<SIZE; i++) buf[i] = -1;
 
     MPI_File_iread_at(fh, 0, buf, SIZE, MPI_INT, &req);
+#ifdef MPIO_USES_MPI_REQUEST
+    MPI_Wait(&req, &status);
+#else
     MPIO_Wait(&req, &status);
+#endif
 
     for (i=0; i<SIZE; i++) {
 	if (!mynod) {
Index: romio/test/runtests.in
diff -u romio/test/runtests.in:1.10 romio/test/runtests.in:1.11
--- romio/test/runtests.in:1.10	Thu Dec 19 16:31:35 2002
+++ romio/test/runtests.in	Thu Jan  8 16:39:12 2004
@@ -1,6 +1,6 @@
 #! /bin/sh
 mpirun="@MPIRUN@"
-STOPFILE=$HOME/.stopmpichtests
+STOPFILE=${MPITEST_STOPTEST:-"$HOME/.stopmpichtests"}
 #
 # If the programs are not available, run make.
 runtests=1
Index: romio/util/nfslock.c
diff -u /dev/null romio/util/nfslock.c:1.2
--- /dev/null	Thu May 20 15:51:19 2004
+++ romio/util/nfslock.c	Tue Jan 20 10:23:54 2004
@@ -0,0 +1,69 @@
+/* -*- Mode: C; c-basic-offset:4 ; -*- */
+/*  
+ *  (C) 2004 by Argonne National Laboratory.
+ *      See COPYRIGHT in top-level directory.
+ */
+#include <stdio.h>
+#include <fcntl.h>
+#include <errno.h>
+#include <unistd.h>
+
+/*
+ * This routine tests to see if fcntl returns success when asked to 
+ * establish a file lock.  This test is intended for use on file systems
+ * such as NFS that may not implement file locks.  ROMIO makes use
+ * of file locks to implement certain operations, and may not work
+ * properly if file locks are not available.  
+ *
+ * This is a simple test and has at least two limitations:
+ * 
+ * 1. Some implementations of NFS are known to return success for 
+ * setting a file lock when in fact no lock has been set.  This
+ * test will not detect such erroneous implementations of NFS
+ *
+ * 2. Some implementations will hang (enter and wait indefinitately)
+ * within the fcntl call.  This program will also hang in that case.
+ * Under normal conditions, this program should only take a few seconds to 
+ * run.
+ *
+ * This program prints a message showing the success or failure of
+ * setting the file lock and sets the return status to 0 on success and
+ * non-zero on failure.  If there is a failure, the system routine
+ * perror is also called to explain the reason.
+ */
+int main( int argc, char *argv[] )
+{
+    struct flock lock;
+    int fd, err;
+    char *filename;
+
+    /* Set the filename.  Either arg[1] or conftest.dat */
+    if (argc > 1 && argv[1]) {
+      filename = argv[1];
+    }
+    else {
+      filename = "conftest.dat";
+    }
+
+       
+    lock.l_type   = F_WRLCK;
+    lock.l_start  = 0;
+    lock.l_whence = SEEK_SET;
+    lock.l_len    = 100;
+
+    fd = open(filename, O_RDWR | O_CREAT, 0644);
+
+    err = fcntl(fd, F_SETLKW, &lock);
+
+    if (err) {
+      printf( "Failed to set a file lock on %s\n", filename );
+      perror( "Reason " );
+    }
+    else {
+      printf( "fcntl claims success in setting a file lock on %s\n", filename );
+    }
+   /* printf("err = %d, errno = %d\n", err, errno); */
+    close(fd);
+    unlink( filename );
+    return err;
+}
